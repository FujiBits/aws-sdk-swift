// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// User does not have sufficient access to perform this action.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.BatchError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvsClientTypes.BatchError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchError(arn: \(Swift.String(describing: arn)), code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension IvsClientTypes {
    /// Error related to a specific channel, specified by its ARN.
    public struct BatchError: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Error code.
        public var code: Swift.String?
        /// Error message, determined by the application.
        public var message: Swift.String?

        public init (
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }

}

public struct BatchGetChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetChannelOutputError>
}

extension BatchGetChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetChannelInput(arns: \(Swift.String(describing: arns)))"}
}

extension BatchGetChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for channelarnlist0 in arns {
                try arnsContainer.encode(channelarnlist0)
            }
        }
    }
}

public struct BatchGetChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetChannelOutputError>
}

public struct BatchGetChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetChannelOutputError>
}

public struct BatchGetChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchGetChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/BatchGetChannel"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchGetChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetChannelOutputError>
}

public struct BatchGetChannelInput: Swift.Equatable {
    /// Array of ARNs, one per channel.
    /// This member is required.
    public var arns: [Swift.String]?

    public init (
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetChannelInputBody: Swift.Equatable {
    public let arns: [Swift.String]?
}

extension BatchGetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetChannelOutputResponse(channels: \(Swift.String(describing: channels)), errors: \(Swift.String(describing: errors)))"}
}

extension BatchGetChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.errors = output.errors
        } else {
            self.channels = nil
            self.errors = nil
        }
    }
}

public struct BatchGetChannelOutputResponse: Swift.Equatable {
    public var channels: [IvsClientTypes.Channel]?
    /// Each error object is related to a specific ARN in the request.
    public var errors: [IvsClientTypes.BatchError]?

    public init (
        channels: [IvsClientTypes.Channel]? = nil,
        errors: [IvsClientTypes.BatchError]? = nil
    )
    {
        self.channels = channels
        self.errors = errors
    }
}

struct BatchGetChannelOutputResponseBody: Swift.Equatable {
    public let channels: [IvsClientTypes.Channel]?
    public let errors: [IvsClientTypes.BatchError]?
}

extension BatchGetChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([IvsClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[IvsClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [IvsClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchGetStreamKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetStreamKeyOutputError>
}

extension BatchGetStreamKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetStreamKeyInput(arns: \(Swift.String(describing: arns)))"}
}

extension BatchGetStreamKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for streamkeyarnlist0 in arns {
                try arnsContainer.encode(streamkeyarnlist0)
            }
        }
    }
}

public struct BatchGetStreamKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetStreamKeyOutputError>
}

public struct BatchGetStreamKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetStreamKeyOutputError>
}

public struct BatchGetStreamKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetStreamKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchGetStreamKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/BatchGetStreamKey"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchGetStreamKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetStreamKeyOutputError>
}

public struct BatchGetStreamKeyInput: Swift.Equatable {
    /// Array of ARNs, one per channel.
    /// This member is required.
    public var arns: [Swift.String]?

    public init (
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetStreamKeyInputBody: Swift.Equatable {
    public let arns: [Swift.String]?
}

extension BatchGetStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetStreamKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetStreamKeyOutputResponse(errors: \(Swift.String(describing: errors)), streamKeys: \(Swift.String(describing: streamKeys)))"}
}

extension BatchGetStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.streamKeys = output.streamKeys
        } else {
            self.errors = nil
            self.streamKeys = nil
        }
    }
}

public struct BatchGetStreamKeyOutputResponse: Swift.Equatable {
    public var errors: [IvsClientTypes.BatchError]?
    public var streamKeys: [IvsClientTypes.StreamKey]?

    public init (
        errors: [IvsClientTypes.BatchError]? = nil,
        streamKeys: [IvsClientTypes.StreamKey]? = nil
    )
    {
        self.errors = errors
        self.streamKeys = streamKeys
    }
}

struct BatchGetStreamKeyOutputResponseBody: Swift.Equatable {
    public let streamKeys: [IvsClientTypes.StreamKey]?
    public let errors: [IvsClientTypes.BatchError]?
}

extension BatchGetStreamKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case streamKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamKey?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[IvsClientTypes.StreamKey]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [IvsClientTypes.StreamKey]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IvsClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case ingestEndpoint
        case latencyMode
        case name
        case playbackUrl
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let ingestEndpoint = ingestEndpoint {
            try encodeContainer.encode(ingestEndpoint, forKey: .ingestEndpoint)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let playbackUrl = playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let ingestEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestEndpoint)
        ingestEndpoint = ingestEndpointDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let authorizedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(arn: \(Swift.String(describing: arn)), authorized: \(Swift.String(describing: authorized)), ingestEndpoint: \(Swift.String(describing: ingestEndpoint)), latencyMode: \(Swift.String(describing: latencyMode)), name: \(Swift.String(describing: name)), playbackUrl: \(Swift.String(describing: playbackUrl)), recordingConfigurationArn: \(Swift.String(describing: recordingConfigurationArn)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension IvsClientTypes {
    /// Object specifying a channel.
    public struct Channel: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default:
        ///         false.
        public var authorized: Swift.Bool
        /// Channel ingest endpoint, part of the definition of an ingest server, used when you set up
        ///       streaming software.
        public var ingestEndpoint: Swift.String?
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to
        ///       Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW. (Note: In the Amazon IVS console, LOW and
        ///       NORMAL correspond to Ultra-low and Standard, respectively.)
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Channel playback URL.
        public var playbackUrl: Swift.String?
        /// Recording-configuration ARN. A value other than an empty string indicates that recording
        ///       is enabled. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you
        ///         exceed the allowable resolution or bitrate, the stream probably will disconnect
        ///         immediately. Default: STANDARD. Valid values:
        ///
        ///
        ///
        ///                   STANDARD: Multiple qualities are generated from the original input, to
        ///           automatically give viewers the best experience for their devices and network conditions.
        ///           Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.
        ///
        ///
        ///
        ///                   BASIC: Amazon IVS delivers the original input to viewers. The viewer’s
        ///           video-quality choice is limited to the original input. Vertical resolution can be up to
        ///           480 and bitrate can be up to 1.5 Mbps.
        ///
        ///
        public var type: IvsClientTypes.ChannelType?

        public init (
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            ingestEndpoint: Swift.String? = nil,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: IvsClientTypes.ChannelType? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.ingestEndpoint = ingestEndpoint
            self.latencyMode = latencyMode
            self.name = name
            self.playbackUrl = playbackUrl
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
            self.type = type
        }
    }

}

extension IvsClientTypes {
    public enum ChannelLatencyMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lowlatency
        case normallatency
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelLatencyMode] {
            return [
                .lowlatency,
                .normallatency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lowlatency: return "LOW"
            case .normallatency: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelLatencyMode(rawValue: rawValue) ?? ChannelLatencyMode.sdkUnknown(rawValue)
        }
    }
}

extension ChannelNotBroadcasting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelNotBroadcasting(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension ChannelNotBroadcasting {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ChannelNotBroadcastingBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ChannelNotBroadcasting: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The stream is offline for the given channel ARN.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ChannelNotBroadcastingBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension ChannelNotBroadcastingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.ChannelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let authorizedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(arn: \(Swift.String(describing: arn)), authorized: \(Swift.String(describing: authorized)), latencyMode: \(Swift.String(describing: latencyMode)), name: \(Swift.String(describing: name)), recordingConfigurationArn: \(Swift.String(describing: recordingConfigurationArn)), tags: \(Swift.String(describing: tags)))"}
}

extension IvsClientTypes {
    /// Summary information about a channel.
    public struct ChannelSummary: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use
        ///       LOW for near-real-time interaction with viewers. Default: LOW. (Note: In the Amazon IVS
        ///       console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Recording-configuration ARN. A value other than an empty string indicates that recording
        ///       is enabled. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.latencyMode = latencyMode
            self.name = name
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
        }
    }

}

extension IvsClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basicchanneltype
        case standardchanneltype
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .basicchanneltype,
                .standardchanneltype,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basicchanneltype: return "BASIC"
            case .standardchanneltype: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Updating or deleting a resource can cause an inconsistent state.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct CreateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(authorized: \(Swift.String(describing: authorized)), latencyMode: \(Swift.String(describing: latencyMode)), name: \(Swift.String(describing: name)), recordingConfigurationArn: \(Swift.String(describing: recordingConfigurationArn)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/CreateChannel"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Swift.Equatable {
    /// Whether the channel is private (enabled for playback authorization). Default:
    ///         false.
    public var authorized: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to
    ///       Full HD. Use LOW for near-real-time interaction with viewers. (Note: In the
    ///       Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
    ///       Default: LOW.
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Recording-configuration ARN. Default: "" (empty string, recording is disabled).
    public var recordingConfigurationArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?
    /// Channel type, which determines the allowable resolution and bitrate. If you
    ///         exceed the allowable resolution or bitrate, the stream probably will disconnect
    ///         immediately. Default: STANDARD. Valid values:
    ///
    ///
    ///
    ///                   STANDARD: Multiple qualities are generated from the original input, to
    ///           automatically give viewers the best experience for their devices and network conditions.
    ///           Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.
    ///
    ///
    ///
    ///                   BASIC: Amazon IVS delivers the original input to viewers. The viewer’s
    ///           video-quality choice is limited to the original input. Vertical resolution can be up to
    ///           480 and bitrate can be up to 1.5 Mbps.
    ///
    ///
    public var type: IvsClientTypes.ChannelType?

    public init (
        authorized: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
        self.type = type
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let latencyMode: IvsClientTypes.ChannelLatencyMode?
    public let type: IvsClientTypes.ChannelType?
    public let authorized: Swift.Bool
    public let recordingConfigurationArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelOutputResponse(channel: \(Swift.String(describing: channel)), streamKey: \(Swift.String(describing: streamKey)))"}
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
            self.streamKey = output.streamKey
        } else {
            self.channel = nil
            self.streamKey = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// Object specifying a channel.
    public var channel: IvsClientTypes.Channel?
    /// Object specifying a stream key.
    public var streamKey: IvsClientTypes.StreamKey?

    public init (
        channel: IvsClientTypes.Channel? = nil,
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.channel = channel
        self.streamKey = streamKey
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    public let channel: IvsClientTypes.Channel?
    public let streamKey: IvsClientTypes.StreamKey?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case streamKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

public struct CreateRecordingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecordingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecordingConfigurationOutputError>
}

extension CreateRecordingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecordingConfigurationInput(destinationConfiguration: \(Swift.String(describing: destinationConfiguration)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRecordingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRecordingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecordingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecordingConfigurationOutputError>
}

public struct CreateRecordingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecordingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecordingConfigurationOutputError>
}

public struct CreateRecordingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecordingConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateRecordingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/CreateRecordingConfiguration"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRecordingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecordingConfigurationOutputError>
}

public struct CreateRecordingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where recorded video will be
    ///       stored.
    /// This member is required.
    public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    /// An arbitrary string (a nickname) that helps the customer identify that resource. The value
    ///       does not need to be unique.
    public var name: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?

    public init (
        destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.tags = tags
    }
}

struct CreateRecordingConfigurationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecordingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecordingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecordingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case pendingVerification(PendingVerification)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecordingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecordingConfigurationOutputResponse(recordingConfiguration: \(Swift.String(describing: recordingConfiguration)))"}
}

extension CreateRecordingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRecordingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct CreateRecordingConfigurationOutputResponse: Swift.Equatable {
    /// An object representing a configuration to record a channel stream.
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init (
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct CreateRecordingConfigurationOutputResponseBody: Swift.Equatable {
    public let recordingConfiguration: IvsClientTypes.RecordingConfiguration?
}

extension CreateRecordingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

public struct CreateStreamKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamKeyOutputError>
}

extension CreateStreamKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamKeyInput(channelArn: \(Swift.String(describing: channelArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateStreamKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamKeyOutputError>
}

public struct CreateStreamKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamKeyOutputError>
}

public struct CreateStreamKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStreamKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/CreateStreamKey"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamKeyOutputError>
}

public struct CreateStreamKeyInput: Swift.Equatable {
    /// ARN of the channel for which to create the stream key.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value).
    public var tags: [Swift.String:Swift.String]?

    public init (
        channelArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelArn = channelArn
        self.tags = tags
    }
}

struct CreateStreamKeyInputBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamKeyOutputResponse(streamKey: \(Swift.String(describing: streamKey)))"}
}

extension CreateStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct CreateStreamKeyOutputResponse: Swift.Equatable {
    /// Stream key used to authenticate an RTMPS stream for ingestion.
    public var streamKey: IvsClientTypes.StreamKey?

    public init (
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct CreateStreamKeyOutputResponseBody: Swift.Equatable {
    public let streamKey: IvsClientTypes.StreamKey?
}

extension CreateStreamKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

public struct DeleteChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

extension DeleteChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/DeleteChannel"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Swift.Equatable {
    /// ARN of the channel to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Swift.Equatable {
}

extension DeleteChannelOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePlaybackKeyPairInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackKeyPairOutputError>
}

extension DeletePlaybackKeyPairInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlaybackKeyPairInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeletePlaybackKeyPairInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeletePlaybackKeyPairInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackKeyPairOutputError>
}

public struct DeletePlaybackKeyPairInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackKeyPairOutputError>
}

public struct DeletePlaybackKeyPairInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePlaybackKeyPairInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePlaybackKeyPairInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/DeletePlaybackKeyPair"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePlaybackKeyPairInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePlaybackKeyPairOutputError>
}

public struct DeletePlaybackKeyPairInput: Swift.Equatable {
    /// ARN of the key pair to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePlaybackKeyPairInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeletePlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePlaybackKeyPairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaybackKeyPairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlaybackKeyPairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaybackKeyPairOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePlaybackKeyPairOutputResponse()"}
}

extension DeletePlaybackKeyPairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaybackKeyPairOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePlaybackKeyPairOutputResponseBody: Swift.Equatable {
}

extension DeletePlaybackKeyPairOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRecordingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordingConfigurationOutputError>
}

extension DeleteRecordingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecordingConfigurationInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteRecordingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteRecordingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordingConfigurationOutputError>
}

public struct DeleteRecordingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordingConfigurationOutputError>
}

public struct DeleteRecordingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordingConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRecordingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/DeleteRecordingConfiguration"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRecordingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordingConfigurationOutputError>
}

public struct DeleteRecordingConfigurationInput: Swift.Equatable {
    /// ARN of the recording configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRecordingConfigurationInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRecordingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecordingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecordingConfigurationOutputResponse()"}
}

extension DeleteRecordingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordingConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRecordingConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteRecordingConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteStreamKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamKeyOutputError>
}

extension DeleteStreamKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamKeyInput(arn: \(Swift.String(describing: arn)))"}
}

extension DeleteStreamKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteStreamKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamKeyOutputError>
}

public struct DeleteStreamKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamKeyOutputError>
}

public struct DeleteStreamKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStreamKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/DeleteStreamKey"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStreamKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamKeyOutputError>
}

public struct DeleteStreamKeyInput: Swift.Equatable {
    /// ARN of the stream key to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStreamKeyInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension DeleteStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamKeyOutputResponse()"}
}

extension DeleteStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamKeyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStreamKeyOutputResponseBody: Swift.Equatable {
}

extension DeleteStreamKeyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IvsClientTypes.DestinationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(IvsClientTypes.S3DestinationConfiguration.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension IvsClientTypes.DestinationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DestinationConfiguration(s3: \(Swift.String(describing: s3)))"}
}

extension IvsClientTypes {
    /// A complex type that describes a location where recorded videos will be stored. Each member
    ///       represents a type of destination configuration. For recording, you define one and only one
    ///       type of destination configuration.
    public struct DestinationConfiguration: Swift.Equatable {
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IvsClientTypes.S3DestinationConfiguration?

        public init (
            s3: IvsClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.s3 = s3
        }
    }

}

public struct GetChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelOutputError>
}

extension GetChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelOutputError>
}

public struct GetChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelOutputError>
}

public struct GetChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/GetChannel"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChannelOutputError>
}

public struct GetChannelInput: Swift.Equatable {
    /// ARN of the channel for which the configuration is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetChannelInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChannelOutputResponse(channel: \(Swift.String(describing: channel)))"}
}

extension GetChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct GetChannelOutputResponse: Swift.Equatable {
    /// Object specifying a channel.
    public var channel: IvsClientTypes.Channel?

    public init (
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct GetChannelOutputResponseBody: Swift.Equatable {
    public let channel: IvsClientTypes.Channel?
}

extension GetChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

public struct GetPlaybackKeyPairInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackKeyPairOutputError>
}

extension GetPlaybackKeyPairInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaybackKeyPairInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetPlaybackKeyPairInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetPlaybackKeyPairInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackKeyPairOutputError>
}

public struct GetPlaybackKeyPairInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackKeyPairOutputError>
}

public struct GetPlaybackKeyPairInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPlaybackKeyPairInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetPlaybackKeyPairInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/GetPlaybackKeyPair"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPlaybackKeyPairInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPlaybackKeyPairOutputError>
}

public struct GetPlaybackKeyPairInput: Swift.Equatable {
    /// ARN of the key pair to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetPlaybackKeyPairInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetPlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetPlaybackKeyPairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaybackKeyPairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlaybackKeyPairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaybackKeyPairOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPlaybackKeyPairOutputResponse(keyPair: \(Swift.String(describing: keyPair)))"}
}

extension GetPlaybackKeyPairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPlaybackKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct GetPlaybackKeyPairOutputResponse: Swift.Equatable {
    /// A key pair used to sign and validate a playback authorization token.
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init (
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct GetPlaybackKeyPairOutputResponseBody: Swift.Equatable {
    public let keyPair: IvsClientTypes.PlaybackKeyPair?
}

extension GetPlaybackKeyPairOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPair
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(IvsClientTypes.PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

public struct GetRecordingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordingConfigurationOutputError>
}

extension GetRecordingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordingConfigurationInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetRecordingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetRecordingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordingConfigurationOutputError>
}

public struct GetRecordingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordingConfigurationOutputError>
}

public struct GetRecordingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordingConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetRecordingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/GetRecordingConfiguration"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRecordingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordingConfigurationOutputError>
}

public struct GetRecordingConfigurationInput: Swift.Equatable {
    /// ARN of the recording configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRecordingConfigurationInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRecordingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordingConfigurationOutputResponse(recordingConfiguration: \(Swift.String(describing: recordingConfiguration)))"}
}

extension GetRecordingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct GetRecordingConfigurationOutputResponse: Swift.Equatable {
    /// An object representing a configuration to record a channel stream.
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init (
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct GetRecordingConfigurationOutputResponseBody: Swift.Equatable {
    public let recordingConfiguration: IvsClientTypes.RecordingConfiguration?
}

extension GetRecordingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

public struct GetStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamOutputError>
}

extension GetStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamInput(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension GetStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

public struct GetStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamOutputError>
}

public struct GetStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamOutputError>
}

public struct GetStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/GetStream"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamOutputError>
}

public struct GetStreamInput: Swift.Equatable {
    /// Channel ARN for stream to be accessed.
    /// This member is required.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct GetStreamInputBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension GetStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

public struct GetStreamKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamKeyOutputError>
}

extension GetStreamKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamKeyInput(arn: \(Swift.String(describing: arn)))"}
}

extension GetStreamKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetStreamKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamKeyOutputError>
}

public struct GetStreamKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamKeyOutputError>
}

public struct GetStreamKeyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamKeyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStreamKeyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/GetStreamKey"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamKeyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamKeyOutputError>
}

public struct GetStreamKeyInput: Swift.Equatable {
    /// ARN for the stream key to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStreamKeyInputBody: Swift.Equatable {
    public let arn: Swift.String?
}

extension GetStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamKeyOutputResponse(streamKey: \(Swift.String(describing: streamKey)))"}
}

extension GetStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct GetStreamKeyOutputResponse: Swift.Equatable {
    /// Object specifying a stream key.
    public var streamKey: IvsClientTypes.StreamKey?

    public init (
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct GetStreamKeyOutputResponseBody: Swift.Equatable {
    public let streamKey: IvsClientTypes.StreamKey?
}

extension GetStreamKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

extension GetStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamOutputResponse(stream: \(Swift.String(describing: stream)))"}
}

extension GetStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamOutputResponse: Swift.Equatable {
    /// Specifies a live video stream that has been ingested and distributed.
    public var stream: IvsClientTypes.Stream?

    public init (
        stream: IvsClientTypes.Stream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamOutputResponseBody: Swift.Equatable {
    public let stream: IvsClientTypes.Stream?
}

extension GetStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Stream.self, forKey: .stream)
        stream = streamDecoded
    }
}

public struct ImportPlaybackKeyPairInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportPlaybackKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportPlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportPlaybackKeyPairOutputError>
}

extension ImportPlaybackKeyPairInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportPlaybackKeyPairInput(name: \(Swift.String(describing: name)), publicKeyMaterial: \(Swift.String(describing: publicKeyMaterial)), tags: \(Swift.String(describing: tags)))"}
}

extension ImportPlaybackKeyPairInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publicKeyMaterial = publicKeyMaterial {
            try encodeContainer.encode(publicKeyMaterial, forKey: .publicKeyMaterial)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ImportPlaybackKeyPairInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportPlaybackKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportPlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportPlaybackKeyPairOutputError>
}

public struct ImportPlaybackKeyPairInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportPlaybackKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportPlaybackKeyPairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportPlaybackKeyPairOutputError>
}

public struct ImportPlaybackKeyPairInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportPlaybackKeyPairInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ImportPlaybackKeyPairInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/ImportPlaybackKeyPair"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportPlaybackKeyPairInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportPlaybackKeyPairOutputError>
}

public struct ImportPlaybackKeyPairInput: Swift.Equatable {
    /// An arbitrary string (a nickname) assigned to a playback key pair that helps the customer
    ///       identify that resource. The value does not need to be unique.
    public var name: Swift.String?
    /// The public portion of a customer-generated key pair.
    /// This member is required.
    public var publicKeyMaterial: Swift.String?
    /// Any tags provided with the request are added to the playback key pair tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        name: Swift.String? = nil,
        publicKeyMaterial: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.publicKeyMaterial = publicKeyMaterial
        self.tags = tags
    }
}

struct ImportPlaybackKeyPairInputBody: Swift.Equatable {
    public let publicKeyMaterial: Swift.String?
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension ImportPlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyMaterialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyMaterial)
        publicKeyMaterial = publicKeyMaterialDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportPlaybackKeyPairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportPlaybackKeyPairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportPlaybackKeyPairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportPlaybackKeyPairOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportPlaybackKeyPairOutputResponse(keyPair: \(Swift.String(describing: keyPair)))"}
}

extension ImportPlaybackKeyPairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportPlaybackKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct ImportPlaybackKeyPairOutputResponse: Swift.Equatable {
    /// A key pair used to sign and validate a playback authorization token.
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init (
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct ImportPlaybackKeyPairOutputResponseBody: Swift.Equatable {
    public let keyPair: IvsClientTypes.PlaybackKeyPair?
}

extension ImportPlaybackKeyPairOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPair
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(IvsClientTypes.PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Unexpected error during processing of request.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct ListChannelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(filterByName: \(Swift.String(describing: filterByName)), filterByRecordingConfigurationArn: \(Swift.String(describing: filterByRecordingConfigurationArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByName = filterByName {
            try encodeContainer.encode(filterByName, forKey: .filterByName)
        }
        if let filterByRecordingConfigurationArn = filterByRecordingConfigurationArn {
            try encodeContainer.encode(filterByRecordingConfigurationArn, forKey: .filterByRecordingConfigurationArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChannelsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListChannelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/ListChannels"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChannelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Swift.Equatable {
    /// Filters the channel list to match the specified name.
    public var filterByName: Swift.String?
    /// Filters the channel list to match the specified recording-configuration ARN.
    public var filterByRecordingConfigurationArn: Swift.String?
    /// Maximum number of channels to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first channel to retrieve. This is used for pagination; see the nextToken
    ///       response field.
    public var nextToken: Swift.String?

    public init (
        filterByName: Swift.String? = nil,
        filterByRecordingConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByName = filterByName
        self.filterByRecordingConfigurationArn = filterByRecordingConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
    public let filterByName: Swift.String?
    public let filterByRecordingConfigurationArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByName)
        filterByName = filterByNameDecoded
        let filterByRecordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByRecordingConfigurationArn)
        filterByRecordingConfigurationArn = filterByRecordingConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// List of the matching channels.
    /// This member is required.
    public var channels: [IvsClientTypes.ChannelSummary]?
    /// If there are more channels than maxResults, use nextToken in the
    ///       request to get the next set.
    public var nextToken: Swift.String?

    public init (
        channels: [IvsClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    public let channels: [IvsClientTypes.ChannelSummary]?
    public let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([IvsClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[IvsClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [IvsClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPlaybackKeyPairsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackKeyPairsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaybackKeyPairsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaybackKeyPairsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackKeyPairsOutputError>
}

extension ListPlaybackKeyPairsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaybackKeyPairsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlaybackKeyPairsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPlaybackKeyPairsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackKeyPairsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaybackKeyPairsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaybackKeyPairsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackKeyPairsOutputError>
}

public struct ListPlaybackKeyPairsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackKeyPairsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPlaybackKeyPairsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPlaybackKeyPairsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackKeyPairsOutputError>
}

public struct ListPlaybackKeyPairsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPlaybackKeyPairsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPlaybackKeyPairsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/ListPlaybackKeyPairs"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPlaybackKeyPairsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPlaybackKeyPairsOutputError>
}

public struct ListPlaybackKeyPairsInput: Swift.Equatable {
    /// The first key pair to retrieve. This is used for pagination; see the
    ///         nextToken response field. Default: 50.
    public var maxResults: Swift.Int
    /// Maximum number of key pairs to return.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListPlaybackKeyPairsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPlaybackKeyPairsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaybackKeyPairsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlaybackKeyPairsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaybackKeyPairsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPlaybackKeyPairsOutputResponse(keyPairs: \(Swift.String(describing: keyPairs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPlaybackKeyPairsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPlaybackKeyPairsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyPairs = output.keyPairs
            self.nextToken = output.nextToken
        } else {
            self.keyPairs = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackKeyPairsOutputResponse: Swift.Equatable {
    /// List of key pairs.
    /// This member is required.
    public var keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    /// If there are more key pairs than maxResults, use nextToken in
    ///       the request to get the next set.
    public var nextToken: Swift.String?

    public init (
        keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyPairs = keyPairs
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsOutputResponseBody: Swift.Equatable {
    public let keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    public let nextToken: Swift.String?
}

extension ListPlaybackKeyPairsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPairs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairsContainer = try containerValues.decodeIfPresent([IvsClientTypes.PlaybackKeyPairSummary?].self, forKey: .keyPairs)
        var keyPairsDecoded0:[IvsClientTypes.PlaybackKeyPairSummary]? = nil
        if let keyPairsContainer = keyPairsContainer {
            keyPairsDecoded0 = [IvsClientTypes.PlaybackKeyPairSummary]()
            for structure0 in keyPairsContainer {
                if let structure0 = structure0 {
                    keyPairsDecoded0?.append(structure0)
                }
            }
        }
        keyPairs = keyPairsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRecordingConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordingConfigurationsOutputError>
}

extension ListRecordingConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordingConfigurationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRecordingConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRecordingConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordingConfigurationsOutputError>
}

public struct ListRecordingConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordingConfigurationsOutputError>
}

public struct ListRecordingConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordingConfigurationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRecordingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/ListRecordingConfigurations"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecordingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordingConfigurationsOutputError>
}

public struct ListRecordingConfigurationsInput: Swift.Equatable {
    /// Maximum number of recording configurations to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first recording configuration to retrieve. This is used for pagination; see the
    ///         nextToken response field.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecordingConfigurationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListRecordingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRecordingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecordingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordingConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordingConfigurationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recordingConfigurations: \(Swift.String(describing: recordingConfigurations)))"}
}

extension ListRecordingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecordingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recordingConfigurations = output.recordingConfigurations
        } else {
            self.nextToken = nil
            self.recordingConfigurations = nil
        }
    }
}

public struct ListRecordingConfigurationsOutputResponse: Swift.Equatable {
    /// If there are more recording configurations than maxResults, use
    ///         nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching recording configurations.
    /// This member is required.
    public var recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recordingConfigurations = recordingConfigurations
    }
}

struct ListRecordingConfigurationsOutputResponseBody: Swift.Equatable {
    public let recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?
    public let nextToken: Swift.String?
}

extension ListRecordingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recordingConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationsContainer = try containerValues.decodeIfPresent([IvsClientTypes.RecordingConfigurationSummary?].self, forKey: .recordingConfigurations)
        var recordingConfigurationsDecoded0:[IvsClientTypes.RecordingConfigurationSummary]? = nil
        if let recordingConfigurationsContainer = recordingConfigurationsContainer {
            recordingConfigurationsDecoded0 = [IvsClientTypes.RecordingConfigurationSummary]()
            for structure0 in recordingConfigurationsContainer {
                if let structure0 = structure0 {
                    recordingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        recordingConfigurations = recordingConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamKeysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamKeysOutputError>
}

extension ListStreamKeysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamKeysInput(channelArn: \(Swift.String(describing: channelArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListStreamKeysInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListStreamKeysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamKeysOutputError>
}

public struct ListStreamKeysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamKeysOutputError>
}

public struct ListStreamKeysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamKeysInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStreamKeysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/ListStreamKeys"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStreamKeysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamKeysOutputError>
}

public struct ListStreamKeysInput: Swift.Equatable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streamKeys to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first stream key to retrieve. This is used for pagination; see the
    ///         nextToken response field.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamKeysInputBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListStreamKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStreamKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamKeysOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamKeysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamKeysOutputResponse(nextToken: \(Swift.String(describing: nextToken)), streamKeys: \(Swift.String(describing: streamKeys)))"}
}

extension ListStreamKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamKeys = output.streamKeys
        } else {
            self.nextToken = nil
            self.streamKeys = nil
        }
    }
}

public struct ListStreamKeysOutputResponse: Swift.Equatable {
    /// If there are more stream keys than maxResults, use nextToken in
    ///       the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream keys.
    /// This member is required.
    public var streamKeys: [IvsClientTypes.StreamKeySummary]?

    public init (
        nextToken: Swift.String? = nil,
        streamKeys: [IvsClientTypes.StreamKeySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamKeys = streamKeys
    }
}

struct ListStreamKeysOutputResponseBody: Swift.Equatable {
    public let streamKeys: [IvsClientTypes.StreamKeySummary]?
    public let nextToken: Swift.String?
}

extension ListStreamKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamKeySummary?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[IvsClientTypes.StreamKeySummary]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [IvsClientTypes.StreamKeySummary]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

extension ListStreamsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListStreamsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListStreamsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStreamsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/ListStreams"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStreamsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamsOutputError>
}

public struct ListStreamsInput: Swift.Equatable {
    /// Maximum number of streams to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first stream to retrieve. This is used for pagination; see the nextToken
    ///       response field.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), streams: \(Swift.String(describing: streams)))"}
}

extension ListStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListStreamsOutputResponse: Swift.Equatable {
    /// If there are more streams than maxResults, use nextToken in the
    ///       request to get the next set.
    public var nextToken: Swift.String?
    /// List of streams.
    /// This member is required.
    public var streams: [IvsClientTypes.StreamSummary]?

    public init (
        nextToken: Swift.String? = nil,
        streams: [IvsClientTypes.StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListStreamsOutputResponseBody: Swift.Equatable {
    public let streams: [IvsClientTypes.StreamSummary]?
    public let nextToken: Swift.String?
}

extension ListStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamSummary?].self, forKey: .streams)
        var streamsDecoded0:[IvsClientTypes.StreamSummary]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [IvsClientTypes.StreamSummary]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Maximum number of tags to return. Default: 50.
    public var maxResults: Swift.Int
    /// The first tag to retrieve. This is used for pagination; see the nextToken
    ///       response field.
    public var nextToken: Swift.String?
    /// The ARN of the resource to be retrieved.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// If there are more tags than maxResults, use nextToken in the
    ///       request to get the next set.
    public var nextToken: Swift.String?
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PendingVerification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingVerification(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension PendingVerification {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct PendingVerification: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///  Your account is pending verification.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct PendingVerificationBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.PlaybackKeyPair: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case fingerprint
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.PlaybackKeyPair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaybackKeyPair(arn: \(Swift.String(describing: arn)), fingerprint: \(Swift.String(describing: fingerprint)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension IvsClientTypes {
    /// A key pair used to sign and validate a playback authorization token.
    public struct PlaybackKeyPair: Swift.Equatable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Key-pair identifier.
        public var fingerprint: Swift.String?
        /// An arbitrary string (a nickname) assigned to a playback key pair that helps the customer
        ///       identify that resource. The value does not need to be unique.
        public var name: Swift.String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.tags = tags
        }
    }

}

extension IvsClientTypes.PlaybackKeyPairSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.PlaybackKeyPairSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaybackKeyPairSummary(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension IvsClientTypes {
    /// Summary information about a playback key pair.
    public struct PlaybackKeyPairSummary: Swift.Equatable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// An arbitrary string (a nickname) assigned to a playback key pair that helps the customer
        ///       identify that resource. The value does not need to be unique.
        public var name: Swift.String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

public struct PutMetadataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMetadataOutputError>
}

extension PutMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMetadataInput(channelArn: \(Swift.String(describing: channelArn)), metadata: \(Swift.String(describing: metadata)))"}
}

extension PutMetadataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

public struct PutMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMetadataOutputError>
}

public struct PutMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMetadataOutputError>
}

public struct PutMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMetadataInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/PutMetadata"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMetadataOutputError>
}

public struct PutMetadataInput: Swift.Equatable {
    /// ARN of the channel into which metadata is inserted. This channel must have an active
    ///       stream.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Metadata to insert into the stream. Maximum: 1 KB per request.
    /// This member is required.
    public var metadata: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.metadata = metadata
    }
}

struct PutMetadataInputBody: Swift.Equatable {
    public let channelArn: Swift.String?
    public let metadata: Swift.String?
}

extension PutMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case metadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension PutMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMetadataOutputResponse()"}
}

extension PutMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMetadataOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutMetadataOutputResponseBody: Swift.Equatable {
}

extension PutMetadataOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IvsClientTypes.RecordingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationConfiguration
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.RecordingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordingConfiguration(arn: \(Swift.String(describing: arn)), destinationConfiguration: \(Swift.String(describing: destinationConfiguration)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension IvsClientTypes {
    /// An object representing a configuration to record a channel stream.
    public struct RecordingConfiguration: Swift.Equatable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// An arbitrary string (a nickname) assigned to a recording configuration that helps the
        ///       customer identify that resource. The value does not need to be unique.
        public var name: Swift.String?
        /// Indicates the current state of the recording configuration. When the state is
        ///         ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension IvsClientTypes {
    public enum RecordingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createfailed
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationState] {
            return [
                .active,
                .createfailed,
                .creating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createfailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingConfigurationState(rawValue: rawValue) ?? RecordingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.RecordingConfigurationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationConfiguration
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.RecordingConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordingConfigurationSummary(arn: \(Swift.String(describing: arn)), destinationConfiguration: \(Swift.String(describing: destinationConfiguration)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension IvsClientTypes {
    /// Summary information about a RecordingConfiguration.
    public struct RecordingConfigurationSummary: Swift.Equatable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// An arbitrary string (a nickname) assigned to a recording configuration that helps the
        ///       customer identify that resource. The value does not need to be unique.
        public var name: Swift.String?
        /// Indicates the current state of the recording configuration. When the state is
        ///       ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Request references a resource which does not exist.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.S3DestinationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension IvsClientTypes.S3DestinationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3DestinationConfiguration(bucketName: \(Swift.String(describing: bucketName)))"}
}

extension IvsClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// Location (S3 bucket name) where recorded videos will be stored.
        /// This member is required.
        public var bucketName: Swift.String?

        public init (
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Request would cause a service quota to be exceeded.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct StopStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamOutputError>
}

extension StopStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopStreamInput(channelArn: \(Swift.String(describing: channelArn)))"}
}

extension StopStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

public struct StopStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamOutputError>
}

public struct StopStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamOutputError>
}

public struct StopStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopStreamInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/StopStream"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopStreamOutputError>
}

public struct StopStreamInput: Swift.Equatable {
    /// ARN of the channel for which the stream is to be stopped.
    /// This member is required.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct StopStreamInputBody: Swift.Equatable {
    public let channelArn: Swift.String?
}

extension StopStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension StopStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamUnavailable" : self = .streamUnavailable(try StreamUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case streamUnavailable(StreamUnavailable)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopStreamOutputResponse()"}
}

extension StopStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopStreamOutputResponseBody: Swift.Equatable {
}

extension StopStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IvsClientTypes.Stream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case health
        case playbackUrl
        case startTime
        case state
        case viewerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let playbackUrl = playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .viewerCount)
        viewerCount = viewerCountDecoded
    }
}

extension IvsClientTypes.Stream: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Stream(channelArn: \(Swift.String(describing: channelArn)), health: \(Swift.String(describing: health)), playbackUrl: \(Swift.String(describing: playbackUrl)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), viewerCount: \(Swift.String(describing: viewerCount)))"}
}

extension IvsClientTypes {
    /// Specifies a live video stream that has been ingested and distributed.
    public struct Stream: Swift.Equatable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The stream’s health.
        public var health: IvsClientTypes.StreamHealth?
        /// URL of the master playlist, required by the video player to play the HLS stream.
        public var playbackUrl: Swift.String?
        /// ISO-8601 formatted timestamp of the stream’s start.
        public var startTime: ClientRuntime.Date?
        /// The stream’s state.
        public var state: IvsClientTypes.StreamState?
        /// Number of current viewers of the stream. A value of -1 indicates that the request timed
        ///       out; in this case, retry.
        public var viewerCount: Swift.Int

        public init (
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            playbackUrl: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.playbackUrl = playbackUrl
            self.startTime = startTime
            self.state = state
            self.viewerCount = viewerCount
        }
    }

}

extension IvsClientTypes {
    public enum StreamHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case starving
        case streamhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamHealth] {
            return [
                .starving,
                .streamhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .starving: return "STARVING"
            case .streamhealthy: return "HEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamHealth(rawValue: rawValue) ?? StreamHealth.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.StreamKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case channelArn
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.StreamKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamKey(arn: \(Swift.String(describing: arn)), channelArn: \(Swift.String(describing: channelArn)), tags: \(Swift.String(describing: tags)), value: \(Swift.String(describing: value)))"}
}

extension IvsClientTypes {
    /// Object specifying a stream key.
    public struct StreamKey: Swift.Equatable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?
        /// Stream-key value.
        public var value: Swift.String?

        public init (
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
            self.value = value
        }
    }

}

extension IvsClientTypes.StreamKeySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case channelArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.StreamKeySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamKeySummary(arn: \(Swift.String(describing: arn)), channelArn: \(Swift.String(describing: channelArn)), tags: \(Swift.String(describing: tags)))"}
}

extension IvsClientTypes {
    /// Summary information about a stream key.
    public struct StreamKeySummary: Swift.Equatable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Array of 1-50 maps, each of the form string:string (key:value).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
        }
    }

}

extension IvsClientTypes {
    public enum StreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case streamlive
        case streamoffline
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamState] {
            return [
                .streamlive,
                .streamoffline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .streamlive: return "LIVE"
            case .streamoffline: return "OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamState(rawValue: rawValue) ?? StreamState.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.StreamSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case health
        case startTime
        case state
        case viewerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .viewerCount)
        viewerCount = viewerCountDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IvsClientTypes.StreamSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamSummary(channelArn: \(Swift.String(describing: channelArn)), health: \(Swift.String(describing: health)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), viewerCount: \(Swift.String(describing: viewerCount)))"}
}

extension IvsClientTypes {
    /// Summary information about a stream.
    public struct StreamSummary: Swift.Equatable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The stream’s health.
        public var health: IvsClientTypes.StreamHealth?
        /// ISO-8601 formatted timestamp of the stream’s start.
        public var startTime: ClientRuntime.Date?
        /// The stream’s state.
        public var state: IvsClientTypes.StreamState?
        /// Number of current viewers of the stream. A value of -1 indicates that the request timed
        ///       out; in this case, retry.
        public var viewerCount: Swift.Int

        public init (
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.startTime = startTime
            self.state = state
            self.viewerCount = viewerCount
        }
    }

}

extension StreamUnavailable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamUnavailable(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension StreamUnavailable {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StreamUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct StreamUnavailable: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The stream is temporarily unavailable.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct StreamUnavailableBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension StreamUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be added or updated.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Request was denied due to request throttling.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(arn: \(Swift.String(describing: arn)), authorized: \(Swift.String(describing: authorized)), latencyMode: \(Swift.String(describing: latencyMode)), name: \(Swift.String(describing: name)), recordingConfigurationArn: \(Swift.String(describing: recordingConfigurationArn)), type: \(Swift.String(describing: type)))"}
}

extension UpdateChannelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChannelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateChannelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/UpdateChannel"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChannelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Swift.Equatable {
    /// ARN of the channel to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Whether the channel is private (enabled for playback authorization).
    public var authorized: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use
    ///       LOW for near-real-time interaction with viewers. (Note: In the Amazon IVS console,
    ///         LOW and NORMAL correspond to Ultra-low and Standard,
    ///       respectively.)
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Recording-configuration ARN. If this is set to an empty string, recording is disabled. A
    ///       value other than an empty string indicates that recording is enabled
    public var recordingConfigurationArn: Swift.String?
    /// Channel type, which determines the allowable resolution and bitrate. If you
    ///         exceed the allowable resolution or bitrate, the stream probably will disconnect
    ///         immediately. Valid values:
    ///
    ///
    ///
    ///                   STANDARD: Multiple qualities are generated from the original input, to
    ///           automatically give viewers the best experience for their devices and network conditions.
    ///           Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.
    ///
    ///
    ///
    ///                   BASIC: Amazon IVS delivers the original input to viewers. The viewer’s
    ///           video-quality choice is limited to the original input. Vertical resolution can be up to
    ///           480 and bitrate can be up to 1.5 Mbps.
    ///
    ///
    public var type: IvsClientTypes.ChannelType?

    public init (
        arn: Swift.String? = nil,
        authorized: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.type = type
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    public let arn: Swift.String?
    public let name: Swift.String?
    public let latencyMode: IvsClientTypes.ChannelLatencyMode?
    public let type: IvsClientTypes.ChannelType?
    public let authorized: Swift.Bool
    public let recordingConfigurationArn: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelOutputResponse(channel: \(Swift.String(describing: channel)))"}
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// Object specifying a channel.
    public var channel: IvsClientTypes.Channel?

    public init (
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    public let channel: IvsClientTypes.Channel?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(exceptionMessage: \(Swift.String(describing: exceptionMessage)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The input fails to satisfy the constraints specified by an AWS service.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let exceptionMessage: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}
