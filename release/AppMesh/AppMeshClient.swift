// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class AppMeshClient {
    let client: ClientRuntime.SdkHttpClient
    let config: AWSClientRuntime.AWSClientConfiguration
    let serviceName = "App Mesh"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: AWSClientRuntime.AWSClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String? = nil) throws {
        let config = try AppMeshClientConfiguration(region: region)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class AppMeshClientConfiguration: AWSClientRuntime.AWSClientConfiguration {

        public var clientLogMode: ClientRuntime.ClientLogMode
        public var decoder: ClientRuntime.ResponseDecoder?
        public var encoder: ClientRuntime.RequestEncoder?
        public var httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public var httpClientEngine: ClientRuntime.HttpClientEngine
        public var idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public var logger: ClientRuntime.LogAgent
        public var retryer: ClientRuntime.SDKRetryer

        public var credentialsProvider: AWSClientRuntime.CredentialsProvider
        public var endpointResolver: AWSClientRuntime.EndpointResolver
        public var region: Swift.String?
        public var regionResolver: AWSClientRuntime.RegionResolver
        public var signingRegion: Swift.String?

        public init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil,
            runtimeConfig: ClientRuntime.SDKRuntimeConfiguration
        ) throws {
            self.regionResolver = regionResolver ?? DefaultRegionResolver()
            let defaultRegion = self.regionResolver.resolveRegion()
            self.region = region ?? defaultRegion
            self.signingRegion = signingRegion ?? defaultRegion
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromCustom(credProvider)
            } else {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retryer = runtimeConfig.retryer
        }

        public convenience init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil
        ) throws {
            let defaultRuntimeConfig = try ClientRuntime.DefaultSDKRuntimeConfiguration("AppMeshClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, regionResolver: regionResolver, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct AppMeshClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "AppMeshClient"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension AppMeshClient: AppMeshClientProtocol {
    /// Creates a gateway route.
    ///          A gateway route is attached to a virtual gateway and routes traffic to an existing
    ///          virtual service. If a route matches a request, it can distribute traffic to a target
    ///          virtual service.
    ///          For more information about gateway routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/gateway-routes.html">Gateway routes.
    public func createGatewayRoute(input: CreateGatewayRouteInput, completion: @escaping (ClientRuntime.SdkResult<CreateGatewayRouteOutputResponse, CreateGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateGatewayRouteInput, CreateGatewayRouteOutputResponse, CreateGatewayRouteOutputError>(id: "createGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateGatewayRouteOutputResponse>, ClientRuntime.SdkError<CreateGatewayRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateGatewayRouteInput, CreateGatewayRouteOutputResponse, CreateGatewayRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateGatewayRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a service mesh.
    ///           A service mesh is a logical boundary for network traffic between services that are
    ///          represented by resources within the mesh. After you create your service mesh, you can
    ///          create virtual services, virtual nodes, virtual routers, and routes to distribute traffic
    ///          between the applications in your mesh.
    ///          For more information about service meshes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/meshes.html">Service meshes.
    public func createMesh(input: CreateMeshInput, completion: @escaping (ClientRuntime.SdkResult<CreateMeshOutputResponse, CreateMeshOutputError>) -> Void)
    {
        let urlPath = "/v20190125/meshes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMeshInput, CreateMeshOutputResponse, CreateMeshOutputError>(id: "createMesh")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateMeshOutputResponse>, ClientRuntime.SdkError<CreateMeshOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateMeshInput, CreateMeshOutputResponse, CreateMeshOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMeshInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a route that is associated with a virtual router.
    ///           You can route several different protocols and define a retry policy for a route.
    ///          Traffic can be routed to one or more virtual nodes.
    ///          For more information about routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/routes.html">Routes.
    public func createRoute(input: CreateRouteInput, completion: @escaping (ClientRuntime.SdkResult<CreateRouteOutputResponse, CreateRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRouteInput, CreateRouteOutputResponse, CreateRouteOutputError>(id: "createRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateRouteOutputResponse>, ClientRuntime.SdkError<CreateRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateRouteInput, CreateRouteOutputResponse, CreateRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a virtual gateway.
    ///          A virtual gateway allows resources outside your mesh to communicate to resources that
    ///          are inside your mesh. The virtual gateway represents an Envoy proxy running in an Amazon ECS
    ///          task, in a Kubernetes service, or on an Amazon EC2 instance. Unlike a virtual node, which
    ///          represents an Envoy running with an application, a virtual gateway represents Envoy
    ///          deployed by itself.
    ///          For more information about virtual gateways, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html">Virtual gateways.
    public func createVirtualGateway(input: CreateVirtualGatewayInput, completion: @escaping (ClientRuntime.SdkResult<CreateVirtualGatewayOutputResponse, CreateVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualGatewayInput, CreateVirtualGatewayOutputResponse, CreateVirtualGatewayOutputError>(id: "createVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualGatewayOutputResponse>, ClientRuntime.SdkError<CreateVirtualGatewayOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVirtualGatewayInput, CreateVirtualGatewayOutputResponse, CreateVirtualGatewayOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a virtual node within a service mesh.
    ///           A virtual node acts as a logical pointer to a particular task group, such as an Amazon ECS
    ///          service or a Kubernetes deployment. When you create a virtual node, you can specify the
    ///          service discovery information for your task group, and whether the proxy running in a task
    ///          group will communicate with other proxies using Transport Layer Security (TLS).
    ///          You define a listener for any inbound traffic that your virtual node
    ///          expects. Any virtual service that your virtual node expects to communicate to is specified
    ///          as a backend.
    ///          The response metadata for your new virtual node contains the arn that is
    ///          associated with the virtual node. Set this value to the full ARN; for example,
    ///             arn:aws:appmesh:us-west-2:123456789012:myMesh/default/virtualNode/myApp)
    ///          as the APPMESH_RESOURCE_ARN environment variable for your task group's Envoy
    ///          proxy container in your task definition or pod spec. This is then mapped to the
    ///             node.id and node.cluster Envoy parameters.
    ///
    ///             By default, App Mesh uses the name of the resource you specified in
    ///                APPMESH_RESOURCE_ARN when Envoy is referring to itself in metrics and
    ///             traces. You can override this behavior by setting the
    ///                APPMESH_RESOURCE_CLUSTER environment variable with your own name.
    ///
    ///          For more information about virtual nodes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_nodes.html">Virtual nodes. You must be using 1.15.0 or later of the Envoy image when
    ///          setting these variables. For more information aboutApp Mesh Envoy variables, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/envoy.html">Envoy image in
    ///          the AWS App Mesh User Guide.
    public func createVirtualNode(input: CreateVirtualNodeInput, completion: @escaping (ClientRuntime.SdkResult<CreateVirtualNodeOutputResponse, CreateVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualNodeInput, CreateVirtualNodeOutputResponse, CreateVirtualNodeOutputError>(id: "createVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualNodeOutputResponse>, ClientRuntime.SdkError<CreateVirtualNodeOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVirtualNodeInput, CreateVirtualNodeOutputResponse, CreateVirtualNodeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualNodeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a virtual router within a service mesh.
    ///          Specify a listener for any inbound traffic that your virtual router
    ///          receives. Create a virtual router for each protocol and port that you need to route.
    ///          Virtual routers handle traffic for one or more virtual services within your mesh. After you
    ///          create your virtual router, create and associate routes for your virtual router that direct
    ///          incoming requests to different virtual nodes.
    ///          For more information about virtual routers, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_routers.html">Virtual routers.
    public func createVirtualRouter(input: CreateVirtualRouterInput, completion: @escaping (ClientRuntime.SdkResult<CreateVirtualRouterOutputResponse, CreateVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualRouterInput, CreateVirtualRouterOutputResponse, CreateVirtualRouterOutputError>(id: "createVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualRouterOutputResponse>, ClientRuntime.SdkError<CreateVirtualRouterOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVirtualRouterInput, CreateVirtualRouterOutputResponse, CreateVirtualRouterOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualRouterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a virtual service within a service mesh.
    ///          A virtual service is an abstraction of a real service that is provided by a virtual node
    ///          directly or indirectly by means of a virtual router. Dependent services call your virtual
    ///          service by its virtualServiceName, and those requests are routed to the
    ///          virtual node or virtual router that is specified as the provider for the virtual
    ///          service.
    ///          For more information about virtual services, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_services.html">Virtual services.
    public func createVirtualService(input: CreateVirtualServiceInput, completion: @escaping (ClientRuntime.SdkResult<CreateVirtualServiceOutputResponse, CreateVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualServiceInput, CreateVirtualServiceOutputResponse, CreateVirtualServiceOutputError>(id: "createVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateVirtualServiceOutputResponse>, ClientRuntime.SdkError<CreateVirtualServiceOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVirtualServiceInput, CreateVirtualServiceOutputResponse, CreateVirtualServiceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing gateway route.
    public func deleteGatewayRoute(input: DeleteGatewayRouteInput, completion: @escaping (ClientRuntime.SdkResult<DeleteGatewayRouteOutputResponse, DeleteGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        guard let gatewayRouteName = input.gatewayRouteName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component gatewayRouteName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes/\(gatewayRouteName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteGatewayRouteInput, DeleteGatewayRouteOutputResponse, DeleteGatewayRouteOutputError>(id: "deleteGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteGatewayRouteInput, DeleteGatewayRouteOutputResponse, DeleteGatewayRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing service mesh.
    ///          You must delete all resources (virtual services, routes, virtual routers, and virtual
    ///          nodes) in the service mesh before you can delete the mesh itself.
    public func deleteMesh(input: DeleteMeshInput, completion: @escaping (ClientRuntime.SdkResult<DeleteMeshOutputResponse, DeleteMeshOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMeshInput, DeleteMeshOutputResponse, DeleteMeshOutputError>(id: "deleteMesh")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteMeshInput, DeleteMeshOutputResponse, DeleteMeshOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing route.
    public func deleteRoute(input: DeleteRouteInput, completion: @escaping (ClientRuntime.SdkResult<DeleteRouteOutputResponse, DeleteRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        guard let routeName = input.routeName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component routeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes/\(routeName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRouteInput, DeleteRouteOutputResponse, DeleteRouteOutputError>(id: "deleteRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteRouteInput, DeleteRouteOutputResponse, DeleteRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing virtual gateway. You cannot delete a virtual gateway if any gateway
    ///          routes are associated to it.
    public func deleteVirtualGateway(input: DeleteVirtualGatewayInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVirtualGatewayOutputResponse, DeleteVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways/\(virtualGatewayName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualGatewayInput, DeleteVirtualGatewayOutputResponse, DeleteVirtualGatewayOutputError>(id: "deleteVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVirtualGatewayInput, DeleteVirtualGatewayOutputResponse, DeleteVirtualGatewayOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing virtual node.
    ///          You must delete any virtual services that list a virtual node as a service provider
    ///          before you can delete the virtual node itself.
    public func deleteVirtualNode(input: DeleteVirtualNodeInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVirtualNodeOutputResponse, DeleteVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualNodeName = input.virtualNodeName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualNodeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes/\(virtualNodeName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualNodeInput, DeleteVirtualNodeOutputResponse, DeleteVirtualNodeOutputError>(id: "deleteVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVirtualNodeInput, DeleteVirtualNodeOutputResponse, DeleteVirtualNodeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing virtual router.
    ///          You must delete any routes associated with the virtual router before you can delete the
    ///          router itself.
    public func deleteVirtualRouter(input: DeleteVirtualRouterInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVirtualRouterOutputResponse, DeleteVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters/\(virtualRouterName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualRouterInput, DeleteVirtualRouterOutputResponse, DeleteVirtualRouterOutputError>(id: "deleteVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVirtualRouterInput, DeleteVirtualRouterOutputResponse, DeleteVirtualRouterOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing virtual service.
    public func deleteVirtualService(input: DeleteVirtualServiceInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVirtualServiceOutputResponse, DeleteVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualServiceName = input.virtualServiceName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualServiceName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices/\(virtualServiceName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualServiceInput, DeleteVirtualServiceOutputResponse, DeleteVirtualServiceOutputError>(id: "deleteVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVirtualServiceInput, DeleteVirtualServiceOutputResponse, DeleteVirtualServiceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing gateway route.
    public func describeGatewayRoute(input: DescribeGatewayRouteInput, completion: @escaping (ClientRuntime.SdkResult<DescribeGatewayRouteOutputResponse, DescribeGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        guard let gatewayRouteName = input.gatewayRouteName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component gatewayRouteName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes/\(gatewayRouteName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeGatewayRouteInput, DescribeGatewayRouteOutputResponse, DescribeGatewayRouteOutputError>(id: "describeGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeGatewayRouteInput, DescribeGatewayRouteOutputResponse, DescribeGatewayRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing service mesh.
    public func describeMesh(input: DescribeMeshInput, completion: @escaping (ClientRuntime.SdkResult<DescribeMeshOutputResponse, DescribeMeshOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMeshInput, DescribeMeshOutputResponse, DescribeMeshOutputError>(id: "describeMesh")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeMeshInput, DescribeMeshOutputResponse, DescribeMeshOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing route.
    public func describeRoute(input: DescribeRouteInput, completion: @escaping (ClientRuntime.SdkResult<DescribeRouteOutputResponse, DescribeRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        guard let routeName = input.routeName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component routeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes/\(routeName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRouteInput, DescribeRouteOutputResponse, DescribeRouteOutputError>(id: "describeRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeRouteInput, DescribeRouteOutputResponse, DescribeRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing virtual gateway.
    public func describeVirtualGateway(input: DescribeVirtualGatewayInput, completion: @escaping (ClientRuntime.SdkResult<DescribeVirtualGatewayOutputResponse, DescribeVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways/\(virtualGatewayName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualGatewayInput, DescribeVirtualGatewayOutputResponse, DescribeVirtualGatewayOutputError>(id: "describeVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeVirtualGatewayInput, DescribeVirtualGatewayOutputResponse, DescribeVirtualGatewayOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing virtual node.
    public func describeVirtualNode(input: DescribeVirtualNodeInput, completion: @escaping (ClientRuntime.SdkResult<DescribeVirtualNodeOutputResponse, DescribeVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualNodeName = input.virtualNodeName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualNodeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes/\(virtualNodeName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualNodeInput, DescribeVirtualNodeOutputResponse, DescribeVirtualNodeOutputError>(id: "describeVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeVirtualNodeInput, DescribeVirtualNodeOutputResponse, DescribeVirtualNodeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing virtual router.
    public func describeVirtualRouter(input: DescribeVirtualRouterInput, completion: @escaping (ClientRuntime.SdkResult<DescribeVirtualRouterOutputResponse, DescribeVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters/\(virtualRouterName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualRouterInput, DescribeVirtualRouterOutputResponse, DescribeVirtualRouterOutputError>(id: "describeVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeVirtualRouterInput, DescribeVirtualRouterOutputResponse, DescribeVirtualRouterOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing virtual service.
    public func describeVirtualService(input: DescribeVirtualServiceInput, completion: @escaping (ClientRuntime.SdkResult<DescribeVirtualServiceOutputResponse, DescribeVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualServiceName = input.virtualServiceName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualServiceName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices/\(virtualServiceName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualServiceInput, DescribeVirtualServiceOutputResponse, DescribeVirtualServiceOutputError>(id: "describeVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeVirtualServiceInput, DescribeVirtualServiceOutputResponse, DescribeVirtualServiceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing gateway routes that are associated to a virtual
    ///          gateway.
    public func listGatewayRoutes(input: ListGatewayRoutesInput, completion: @escaping (ClientRuntime.SdkResult<ListGatewayRoutesOutputResponse, ListGatewayRoutesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGatewayRoutes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGatewayRoutesInput, ListGatewayRoutesOutputResponse, ListGatewayRoutesOutputError>(id: "listGatewayRoutes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGatewayRoutesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGatewayRoutesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListGatewayRoutesInput, ListGatewayRoutesOutputResponse, ListGatewayRoutesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing service meshes.
    public func listMeshes(input: ListMeshesInput, completion: @escaping (ClientRuntime.SdkResult<ListMeshesOutputResponse, ListMeshesOutputError>) -> Void)
    {
        let urlPath = "/v20190125/meshes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMeshes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListMeshesInput, ListMeshesOutputResponse, ListMeshesOutputError>(id: "listMeshes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListMeshesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListMeshesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListMeshesInput, ListMeshesOutputResponse, ListMeshesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing routes in a service mesh.
    public func listRoutes(input: ListRoutesInput, completion: @escaping (ClientRuntime.SdkResult<ListRoutesOutputResponse, ListRoutesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoutes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoutesInput, ListRoutesOutputResponse, ListRoutesOutputError>(id: "listRoutes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoutesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoutesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListRoutesInput, ListRoutesOutputResponse, ListRoutesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// List the tags for an App Mesh resource.
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (ClientRuntime.SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/v20190125/tags"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing virtual gateways in a service mesh.
    public func listVirtualGateways(input: ListVirtualGatewaysInput, completion: @escaping (ClientRuntime.SdkResult<ListVirtualGatewaysOutputResponse, ListVirtualGatewaysOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualGateways")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualGatewaysInput, ListVirtualGatewaysOutputResponse, ListVirtualGatewaysOutputError>(id: "listVirtualGateways")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualGatewaysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualGatewaysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListVirtualGatewaysInput, ListVirtualGatewaysOutputResponse, ListVirtualGatewaysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing virtual nodes.
    public func listVirtualNodes(input: ListVirtualNodesInput, completion: @escaping (ClientRuntime.SdkResult<ListVirtualNodesOutputResponse, ListVirtualNodesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualNodes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualNodesInput, ListVirtualNodesOutputResponse, ListVirtualNodesOutputError>(id: "listVirtualNodes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualNodesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualNodesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListVirtualNodesInput, ListVirtualNodesOutputResponse, ListVirtualNodesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing virtual routers in a service mesh.
    public func listVirtualRouters(input: ListVirtualRoutersInput, completion: @escaping (ClientRuntime.SdkResult<ListVirtualRoutersOutputResponse, ListVirtualRoutersOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualRouters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualRoutersInput, ListVirtualRoutersOutputResponse, ListVirtualRoutersOutputError>(id: "listVirtualRouters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualRoutersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualRoutersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListVirtualRoutersInput, ListVirtualRoutersOutputResponse, ListVirtualRoutersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns a list of existing virtual services in a service mesh.
    public func listVirtualServices(input: ListVirtualServicesInput, completion: @escaping (ClientRuntime.SdkResult<ListVirtualServicesOutputResponse, ListVirtualServicesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualServices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualServicesInput, ListVirtualServicesOutputResponse, ListVirtualServicesOutputError>(id: "listVirtualServices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualServicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualServicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListVirtualServicesInput, ListVirtualServicesOutputResponse, ListVirtualServicesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Associates the specified tags to a resource with the specified resourceArn.
    ///          If existing tags on a resource aren't specified in the request parameters, they aren't
    ///          changed. When a resource is deleted, the tags associated with that resource are also
    ///          deleted.
    public func tagResource(input: TagResourceInput, completion: @escaping (ClientRuntime.SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/v20190125/tag"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes specified tags from a resource.
    public func untagResource(input: UntagResourceInput, completion: @escaping (ClientRuntime.SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/v20190125/untag"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing gateway route that is associated to a specified virtual gateway in a
    ///          service mesh.
    public func updateGatewayRoute(input: UpdateGatewayRouteInput, completion: @escaping (ClientRuntime.SdkResult<UpdateGatewayRouteOutputResponse, UpdateGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        guard let gatewayRouteName = input.gatewayRouteName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component gatewayRouteName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes/\(gatewayRouteName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGatewayRouteInput, UpdateGatewayRouteOutputResponse, UpdateGatewayRouteOutputError>(id: "updateGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayRouteOutputResponse>, ClientRuntime.SdkError<UpdateGatewayRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateGatewayRouteInput, UpdateGatewayRouteOutputResponse, UpdateGatewayRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing service mesh.
    public func updateMesh(input: UpdateMeshInput, completion: @escaping (ClientRuntime.SdkResult<UpdateMeshOutputResponse, UpdateMeshOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMeshInput, UpdateMeshOutputResponse, UpdateMeshOutputError>(id: "updateMesh")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMeshOutputResponse>, ClientRuntime.SdkError<UpdateMeshOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateMeshInput, UpdateMeshOutputResponse, UpdateMeshOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMeshInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing route for a specified service mesh and virtual router.
    public func updateRoute(input: UpdateRouteInput, completion: @escaping (ClientRuntime.SdkResult<UpdateRouteOutputResponse, UpdateRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        guard let routeName = input.routeName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component routeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes/\(routeName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRouteInput, UpdateRouteOutputResponse, UpdateRouteOutputError>(id: "updateRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRouteOutputResponse>, ClientRuntime.SdkError<UpdateRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateRouteInput, UpdateRouteOutputResponse, UpdateRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing virtual gateway in a specified service mesh.
    public func updateVirtualGateway(input: UpdateVirtualGatewayInput, completion: @escaping (ClientRuntime.SdkResult<UpdateVirtualGatewayOutputResponse, UpdateVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways/\(virtualGatewayName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualGatewayInput, UpdateVirtualGatewayOutputResponse, UpdateVirtualGatewayOutputError>(id: "updateVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVirtualGatewayOutputResponse>, ClientRuntime.SdkError<UpdateVirtualGatewayOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateVirtualGatewayInput, UpdateVirtualGatewayOutputResponse, UpdateVirtualGatewayOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing virtual node in a specified service mesh.
    public func updateVirtualNode(input: UpdateVirtualNodeInput, completion: @escaping (ClientRuntime.SdkResult<UpdateVirtualNodeOutputResponse, UpdateVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualNodeName = input.virtualNodeName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualNodeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes/\(virtualNodeName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualNodeInput, UpdateVirtualNodeOutputResponse, UpdateVirtualNodeOutputError>(id: "updateVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVirtualNodeOutputResponse>, ClientRuntime.SdkError<UpdateVirtualNodeOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateVirtualNodeInput, UpdateVirtualNodeOutputResponse, UpdateVirtualNodeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualNodeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing virtual router in a specified service mesh.
    public func updateVirtualRouter(input: UpdateVirtualRouterInput, completion: @escaping (ClientRuntime.SdkResult<UpdateVirtualRouterOutputResponse, UpdateVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters/\(virtualRouterName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualRouterInput, UpdateVirtualRouterOutputResponse, UpdateVirtualRouterOutputError>(id: "updateVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVirtualRouterOutputResponse>, ClientRuntime.SdkError<UpdateVirtualRouterOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateVirtualRouterInput, UpdateVirtualRouterOutputResponse, UpdateVirtualRouterOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualRouterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing virtual service in a specified service mesh.
    public func updateVirtualService(input: UpdateVirtualServiceInput, completion: @escaping (ClientRuntime.SdkResult<UpdateVirtualServiceOutputResponse, UpdateVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualServiceName = input.virtualServiceName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component virtualServiceName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices/\(virtualServiceName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualServiceInput, UpdateVirtualServiceOutputResponse, UpdateVirtualServiceOutputError>(id: "updateVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UpdateVirtualServiceOutputResponse>, ClientRuntime.SdkError<UpdateVirtualServiceOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateVirtualServiceInput, UpdateVirtualServiceOutputResponse, UpdateVirtualServiceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
