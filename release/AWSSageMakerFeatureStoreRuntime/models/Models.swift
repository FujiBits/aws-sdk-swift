// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessForbidden: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessForbidden(message: \(Swift.String(describing: message)))"}
}

extension AccessForbidden {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessForbiddenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to perform an action.
public struct AccessForbidden: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessForbiddenBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessForbiddenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case featureGroupName = "FeatureGroupName"
        case recordIdentifierValueAsString = "RecordIdentifierValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let featureGroupName = featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let recordIdentifierValueAsString = recordIdentifierValueAsString {
            try encodeContainer.encode(recordIdentifierValueAsString, forKey: .recordIdentifierValueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifierValueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordIdentifierValueAsString)
        recordIdentifierValueAsString = recordIdentifierValueAsStringDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetRecordError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), featureGroupName: \(Swift.String(describing: featureGroupName)), recordIdentifierValueAsString: \(Swift.String(describing: recordIdentifierValueAsString)))"}
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The error that has occurred when attempting to retrieve a batch of Records.
    public struct BatchGetRecordError: Swift.Equatable {
        /// The error code of an error that has occured when attempting to retrieve a batch of Records. For more information on errors, see <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_GetRecord.html#API_feature_store_GetRecord_Errors"> Errors.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message of an error that has occured when attempting to retrieve a record in the batch.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the feature group that the record belongs to.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The value for the RecordIdentifier in string format of a Record from a FeatureGroup that is causing
        ///       an error when attempting to be retrieved.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            featureGroupName: Swift.String? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.featureGroupName = featureGroupName
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }

}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureGroupName = "FeatureGroupName"
        case featureNames = "FeatureNames"
        case recordIdentifiersValueAsString = "RecordIdentifiersValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureGroupName = featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let featureNames = featureNames {
            var featureNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featureNames)
            for featurenames0 in featureNames {
                try featureNamesContainer.encode(featurenames0)
            }
        }
        if let recordIdentifiersValueAsString = recordIdentifiersValueAsString {
            var recordIdentifiersValueAsStringContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordIdentifiersValueAsString)
            for recordidentifiers0 in recordIdentifiersValueAsString {
                try recordIdentifiersValueAsStringContainer.encode(recordidentifiers0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifiersValueAsStringContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recordIdentifiersValueAsString)
        var recordIdentifiersValueAsStringDecoded0:[Swift.String]? = nil
        if let recordIdentifiersValueAsStringContainer = recordIdentifiersValueAsStringContainer {
            recordIdentifiersValueAsStringDecoded0 = [Swift.String]()
            for string0 in recordIdentifiersValueAsStringContainer {
                if let string0 = string0 {
                    recordIdentifiersValueAsStringDecoded0?.append(string0)
                }
            }
        }
        recordIdentifiersValueAsString = recordIdentifiersValueAsStringDecoded0
        let featureNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .featureNames)
        var featureNamesDecoded0:[Swift.String]? = nil
        if let featureNamesContainer = featureNamesContainer {
            featureNamesDecoded0 = [Swift.String]()
            for string0 in featureNamesContainer {
                if let string0 = string0 {
                    featureNamesDecoded0?.append(string0)
                }
            }
        }
        featureNames = featureNamesDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetRecordIdentifier(featureGroupName: \(Swift.String(describing: featureGroupName)), featureNames: \(Swift.String(describing: featureNames)), recordIdentifiersValueAsString: \(Swift.String(describing: recordIdentifiersValueAsString)))"}
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The identifier that identifies the batch of Records you are retrieving in a batch.
    public struct BatchGetRecordIdentifier: Swift.Equatable {
        /// A FeatureGroupName containing Records you are retrieving in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// List of names of Features to be retrieved. If not specified, the latest value for all
        ///          the Features are returned.
        public var featureNames: [Swift.String]?
        /// The value for a list of record identifiers in string format.
        /// This member is required.
        public var recordIdentifiersValueAsString: [Swift.String]?

        public init (
            featureGroupName: Swift.String? = nil,
            featureNames: [Swift.String]? = nil,
            recordIdentifiersValueAsString: [Swift.String]? = nil
        )
        {
            self.featureGroupName = featureGroupName
            self.featureNames = featureNames
            self.recordIdentifiersValueAsString = recordIdentifiersValueAsString
        }
    }

}

public struct BatchGetRecordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetRecordOutputError>
}

extension BatchGetRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetRecordInput(identifiers: \(Swift.String(describing: identifiers)))"}
}

extension BatchGetRecordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers = "Identifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for batchgetrecordidentifiers0 in identifiers {
                try identifiersContainer.encode(batchgetrecordidentifiers0)
            }
        }
    }
}

public struct BatchGetRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetRecordOutputError>
}

public struct BatchGetRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetRecordOutputError>
}

public struct BatchGetRecordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetRecordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchGetRecordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/BatchGetRecord"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchGetRecordInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetRecordOutputError>
}

public struct BatchGetRecordInput: Swift.Equatable {
    /// A list of FeatureGroup names, with their corresponding RecordIdentifier value, and Feature name
    ///       that have been requested to be retrieved in batch.
    /// This member is required.
    public var identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init (
        identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.identifiers = identifiers
    }
}

struct BatchGetRecordInputBody: Swift.Equatable {
    public let identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?
}

extension BatchGetRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers = "Identifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifiersContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?].self, forKey: .identifiers)
        var identifiersDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]()
            for structure0 in identifiersContainer {
                if let structure0 = structure0 {
                    identifiersDecoded0?.append(structure0)
                }
            }
        }
        identifiers = identifiersDecoded0
    }
}

extension BatchGetRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetRecordOutputResponse(errors: \(Swift.String(describing: errors)), records: \(Swift.String(describing: records)), unprocessedIdentifiers: \(Swift.String(describing: unprocessedIdentifiers)))"}
}

extension BatchGetRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.records = output.records
            self.unprocessedIdentifiers = output.unprocessedIdentifiers
        } else {
            self.errors = nil
            self.records = nil
            self.unprocessedIdentifiers = nil
        }
    }
}

public struct BatchGetRecordOutputResponse: Swift.Equatable {
    /// A list of errors that have occured when retrieving a batch of Records.
    /// This member is required.
    public var errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    /// A list of Records you requested to be retrieved in batch.
    /// This member is required.
    public var records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    /// A unprocessed list of FeatureGroup names, with their corresponding RecordIdentifier value,
    ///        and Feature name.
    /// This member is required.
    public var unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init (
        errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil,
        records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil,
        unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.errors = errors
        self.records = records
        self.unprocessedIdentifiers = unprocessedIdentifiers
    }
}

struct BatchGetRecordOutputResponseBody: Swift.Equatable {
    public let records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    public let errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    public let unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?
}

extension BatchGetRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
        case records = "Records"
        case unprocessedIdentifiers = "UnprocessedIdentifiers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail?].self, forKey: .records)
        var recordsDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError?].self, forKey: .errors)
        var errorsDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let unprocessedIdentifiersContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?].self, forKey: .unprocessedIdentifiers)
        var unprocessedIdentifiersDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
        if let unprocessedIdentifiersContainer = unprocessedIdentifiersContainer {
            unprocessedIdentifiersDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]()
            for structure0 in unprocessedIdentifiersContainer {
                if let structure0 = structure0 {
                    unprocessedIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentifiers = unprocessedIdentifiersDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureGroupName = "FeatureGroupName"
        case record = "Record"
        case recordIdentifierValueAsString = "RecordIdentifierValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureGroupName = featureGroupName {
            try encodeContainer.encode(featureGroupName, forKey: .featureGroupName)
        }
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for record0 in record {
                try recordContainer.encode(record0)
            }
        }
        if let recordIdentifierValueAsString = recordIdentifierValueAsString {
            try encodeContainer.encode(recordIdentifierValueAsString, forKey: .recordIdentifierValueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureGroupName)
        featureGroupName = featureGroupNameDecoded
        let recordIdentifierValueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordIdentifierValueAsString)
        recordIdentifierValueAsString = recordIdentifierValueAsStringDecoded
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetRecordResultDetail(featureGroupName: \(Swift.String(describing: featureGroupName)), record: \(Swift.String(describing: record)), recordIdentifierValueAsString: \(Swift.String(describing: recordIdentifierValueAsString)))"}
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The output of Records that have been retrieved in a batch.
    public struct BatchGetRecordResultDetail: Swift.Equatable {
        /// The FeatureGroupName containing Records you retrieved in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The Record retrieved.
        /// This member is required.
        public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
        /// The value of the record identifer in string format.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init (
            featureGroupName: Swift.String? = nil,
            record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.featureGroupName = featureGroupName
            self.record = record
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }

}

extension DeleteRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecordInput(eventTime: \(Swift.String(describing: eventTime)), featureGroupName: \(Swift.String(describing: featureGroupName)), recordIdentifierValueAsString: \(Swift.String(describing: recordIdentifierValueAsString)))"}
}

extension DeleteRecordInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recordIdentifierValueAsString = input.operationInput.recordIdentifierValueAsString {
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            input.builder.withQueryItem(recordIdentifierValueAsStringQueryItem)
        }
        if let eventTime = input.operationInput.eventTime {
            let eventTimeQueryItem = ClientRuntime.URLQueryItem(name: "EventTime".urlPercentEncoding(), value: Swift.String(eventTime).urlPercentEncoding())
            input.builder.withQueryItem(eventTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRecordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let featureGroupName = input.featureGroupName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("featureGroupName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRecordInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInput: Swift.Equatable {
    /// Timestamp indicating when the deletion event occurred. EventTime can be
    ///          used to query data at a certain point in time.
    /// This member is required.
    public var eventTime: Swift.String?
    /// The name of the feature group to delete the record from.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// The value for the RecordIdentifier that uniquely identifies the record, in
    ///          string format.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?

    public init (
        eventTime: Swift.String? = nil,
        featureGroupName: Swift.String? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.eventTime = eventTime
        self.featureGroupName = featureGroupName
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct DeleteRecordInputBody: Swift.Equatable {
}

extension DeleteRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecordOutputResponse()"}
}

extension DeleteRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRecordOutputResponseBody: Swift.Equatable {
}

extension DeleteRecordOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case valueAsString = "ValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let valueAsString = valueAsString {
            try encodeContainer.encode(valueAsString, forKey: .valueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let valueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueAsString)
        valueAsString = valueAsStringDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FeatureValue(featureName: \(Swift.String(describing: featureName)), valueAsString: \(Swift.String(describing: valueAsString)))"}
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// The value associated with a feature.
    public struct FeatureValue: Swift.Equatable {
        /// The name of a feature that a feature value corresponds to.
        /// This member is required.
        public var featureName: Swift.String?
        /// The value associated with a feature, in string format. Note that features types can be
        ///          String, Integral, or Fractional. This value represents all three types as a string.
        /// This member is required.
        public var valueAsString: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            valueAsString: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.valueAsString = valueAsString
        }
    }

}

extension GetRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordInput(featureGroupName: \(Swift.String(describing: featureGroupName)), featureNames: \(Swift.String(describing: featureNames)), recordIdentifierValueAsString: \(Swift.String(describing: recordIdentifierValueAsString)))"}
}

extension GetRecordInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordOutputError>
}

public struct GetRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recordIdentifierValueAsString = input.operationInput.recordIdentifierValueAsString {
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            input.builder.withQueryItem(recordIdentifierValueAsStringQueryItem)
        }
        if let featureNames = input.operationInput.featureNames {
            featureNames.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "FeatureName".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordOutputError>
}

public struct GetRecordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetRecordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let featureGroupName = input.featureGroupName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("featureGroupName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRecordInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordOutputError>
}

public struct GetRecordInput: Swift.Equatable {
    /// The name of the feature group in which you want to put the records.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of names of Features to be retrieved. If not specified, the latest value for all
    ///          the Features are returned.
    public var featureNames: [Swift.String]?
    /// The value that corresponds to RecordIdentifier type and uniquely identifies
    ///          the record in the FeatureGroup.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?

    public init (
        featureGroupName: Swift.String? = nil,
        featureNames: [Swift.String]? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.featureNames = featureNames
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct GetRecordInputBody: Swift.Equatable {
}

extension GetRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case resourceNotFound(ResourceNotFound)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordOutputResponse(record: \(Swift.String(describing: record)))"}
}

extension GetRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.record = output.record
        } else {
            self.record = nil
        }
    }
}

public struct GetRecordOutputResponse: Swift.Equatable {
    /// The record you requested. A list of FeatureValues.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init (
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.record = record
    }
}

struct GetRecordOutputResponseBody: Swift.Equatable {
    public let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
}

extension GetRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension InternalFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailure(message: \(Swift.String(describing: message)))"}
}

extension InternalFailure {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal failure occurred. Try your request again. If the problem
///       persists, contact AWS customer support.
public struct InternalFailure: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRecordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

extension PutRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordInput(featureGroupName: \(Swift.String(describing: featureGroupName)), record: \(Swift.String(describing: record)))"}
}

extension PutRecordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for record0 in record {
                try recordContainer.encode(record0)
            }
        }
    }
}

public struct PutRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

public struct PutRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

public struct PutRecordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutRecordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let featureGroupName = input.featureGroupName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("featureGroupName is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRecordInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

public struct PutRecordInput: Swift.Equatable {
    /// The name of the feature group that you want to insert the record into.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of FeatureValues to be inserted. This will be a full over-write. If you only want
    ///          to update few of the feature values, do the following:
    ///
    ///
    ///                Use GetRecord to retrieve the latest record.
    ///
    ///
    ///                Update the record returned from GetRecord.
    ///
    ///
    ///                Use PutRecord to update feature values.
    ///
    ///
    /// This member is required.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init (
        featureGroupName: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.record = record
    }
}

struct PutRecordInputBody: Swift.Equatable {
    public let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
}

extension PutRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension PutRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordOutputResponse()"}
}

extension PutRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRecordOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutRecordOutputResponseBody: Swift.Equatable {
}

extension PutRecordOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFound(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that is required to perform an action was not found.
public struct ResourceNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailable(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailable {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailable: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationError(message: \(Swift.String(describing: message)))"}
}

extension ValidationError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an error validating your request.
public struct ValidationError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
