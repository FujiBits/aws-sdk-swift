// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyStreamedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlreadyStreamedException(message: \(Swift.String(describing: message)))"}
}

extension AlreadyStreamedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyStreamedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception thrown when a bulk publish operation is requested less than 24 hours after a previous bulk publish operation completed successfully.
public struct AlreadyStreamedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message associated with the AlreadyStreamedException exception.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyStreamedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AlreadyStreamedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BulkPublishInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BulkPublishInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension BulkPublishInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct BulkPublishInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BulkPublishInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BulkPublishInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BulkPublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BulkPublishInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BulkPublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BulkPublishOutputError>
}

public struct BulkPublishInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BulkPublishInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BulkPublishInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BulkPublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BulkPublishInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BulkPublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BulkPublishOutputError>
}

public struct BulkPublishInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BulkPublishInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: BulkPublishInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BulkPublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BulkPublishInput
    public typealias MOutput = ClientRuntime.OperationOutput<BulkPublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BulkPublishOutputError>
}

public struct BulkPublishInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BulkPublishInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: BulkPublishInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BulkPublishOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/bulkpublish"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BulkPublishInput
    public typealias MOutput = ClientRuntime.OperationOutput<BulkPublishOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BulkPublishOutputError>
}

/// The input for the BulkPublish operation.
public struct BulkPublishInput: Swift.Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct BulkPublishInputBody: Swift.Equatable {
}

extension BulkPublishInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension BulkPublishOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BulkPublishOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyStreamedException" : self = .alreadyStreamedException(try AlreadyStreamedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRequestException" : self = .duplicateRequestException(try DuplicateRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BulkPublishOutputError: Swift.Error, Swift.Equatable {
    case alreadyStreamedException(AlreadyStreamedException)
    case duplicateRequestException(DuplicateRequestException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BulkPublishOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BulkPublishOutputResponse(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension BulkPublishOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BulkPublishOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolId = output.identityPoolId
        } else {
            self.identityPoolId = nil
        }
    }
}

/// The output for the BulkPublish operation.
public struct BulkPublishOutputResponse: Swift.Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct BulkPublishOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
}

extension BulkPublishOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension CognitoSyncClientTypes {
    public enum BulkPublishStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BulkPublishStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BulkPublishStatus(rawValue: rawValue) ?? BulkPublishStatus.sdkUnknown(rawValue)
        }
    }
}

extension CognitoSyncClientTypes.CognitoStreams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case streamingStatus = "StreamingStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let streamingStatus = streamingStatus {
            try encodeContainer.encode(streamingStatus.rawValue, forKey: .streamingStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
    }
}

extension CognitoSyncClientTypes.CognitoStreams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoStreams(roleArn: \(Swift.String(describing: roleArn)), streamName: \(Swift.String(describing: streamName)), streamingStatus: \(Swift.String(describing: streamingStatus)))"}
}

extension CognitoSyncClientTypes {
    /// Configuration options for configure Cognito streams.
    public struct CognitoStreams: Swift.Equatable {
        /// The ARN of the role Amazon Cognito can assume in order to publish to the stream. This role must grant access to Amazon Cognito (cognito-sync) to invoke PutRecord on your Cognito stream.
        public var roleArn: Swift.String?
        /// The name of the Cognito stream to receive updates. This stream must be in the developers account and in the same region as the identity pool.
        public var streamName: Swift.String?
        /// Status of the Cognito streams. Valid values are:
        ///       ENABLED - Streaming of updates to identity pool is enabled.
        ///       DISABLED - Streaming of updates to identity pool is disabled. Bulk publish will also fail if StreamingStatus is DISABLED.
        public var streamingStatus: CognitoSyncClientTypes.StreamingStatus?

        public init (
            roleArn: Swift.String? = nil,
            streamName: Swift.String? = nil,
            streamingStatus: CognitoSyncClientTypes.StreamingStatus? = nil
        )
        {
            self.roleArn = roleArn
            self.streamName = streamName
            self.streamingStatus = streamingStatus
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if there are parallel requests to modify a resource.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a ConcurrentModicationException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoSyncClientTypes.Dataset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case dataStorage = "DataStorage"
        case datasetName = "DatasetName"
        case identityId = "IdentityId"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case numRecords = "NumRecords"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let numRecords = numRecords {
            try encodeContainer.encode(numRecords, forKey: .numRecords)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
        let numRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numRecords)
        numRecords = numRecordsDecoded
    }
}

extension CognitoSyncClientTypes.Dataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Dataset(creationDate: \(Swift.String(describing: creationDate)), dataStorage: \(Swift.String(describing: dataStorage)), datasetName: \(Swift.String(describing: datasetName)), identityId: \(Swift.String(describing: identityId)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), numRecords: \(Swift.String(describing: numRecords)))"}
}

extension CognitoSyncClientTypes {
    /// A collection of data for an identity pool. An identity pool can
    ///       have multiple datasets. A dataset is per identity and can be general or associated with a
    ///       particular entity in an application (like a saved game). Datasets are automatically created if
    ///       they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value
    ///       pairs.
    public struct Dataset: Swift.Equatable {
        /// Date on which the dataset was
        ///       created.
        public var creationDate: ClientRuntime.Date?
        /// Total size in bytes of the records in this
        ///       dataset.
        public var dataStorage: Swift.Int?
        /// A string of up to 128 characters. Allowed characters
        ///       are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
        public var datasetName: Swift.String?
        /// A name-spaced GUID (for example,
        ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
        ///       unique within a region.
        public var identityId: Swift.String?
        /// The device that made the last change to this
        ///       dataset.
        public var lastModifiedBy: Swift.String?
        /// Date when the dataset was last
        ///       modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Number of records in this dataset.
        public var numRecords: Swift.Int?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            dataStorage: Swift.Int? = nil,
            datasetName: Swift.String? = nil,
            identityId: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            numRecords: Swift.Int? = nil
        )
        {
            self.creationDate = creationDate
            self.dataStorage = dataStorage
            self.datasetName = datasetName
            self.identityId = identityId
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.numRecords = numRecords
        }
    }

}

extension DeleteDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetInput(datasetName: \(Swift.String(describing: datasetName)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension DeleteDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        guard let datasetName = input.datasetName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

/// A request to delete the specific
///       dataset.
public struct DeleteDatasetInput: Swift.Equatable {
    /// A string of up to 128 characters.
    ///       Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.'
    ///       (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetOutputResponse(dataset: \(Swift.String(describing: dataset)))"}
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

/// Response to a successful DeleteDataset
///       request.
public struct DeleteDatasetOutputResponse: Swift.Equatable {
    /// A collection of data for an identity pool.
    ///       An identity pool can have multiple datasets. A dataset is per identity and can be general or
    ///       associated with a particular entity in an application (like a saved game). Datasets are
    ///       automatically created if they don't exist. Data is synced by dataset, and a dataset can hold
    ///       up to 1MB of key-value pairs.
    public var dataset: CognitoSyncClientTypes.Dataset?

    public init (
        dataset: CognitoSyncClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
    public let dataset: CognitoSyncClientTypes.Dataset?
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset = "Dataset"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetInput(datasetName: \(Swift.String(describing: datasetName)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension DescribeDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        guard let datasetName = input.datasetName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

/// A request for meta data about a dataset (creation
///       date, number of records, size) by owner and dataset name.
public struct DescribeDatasetInput: Swift.Equatable {
    /// A string of up to 128 characters.
    ///       Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.'
    ///       (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
}

extension DescribeDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetOutputResponse(dataset: \(Swift.String(describing: dataset)))"}
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

/// Response to a successful DescribeDataset
///       request.
public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// Meta data for a collection of data for an
    ///       identity. An identity can have multiple datasets. A dataset can be general or associated with
    ///       a particular entity in an application (like a saved game). Datasets are automatically created
    ///       if they don't exist. Data is synced by dataset, and a dataset can hold up to 1MB of key-value
    ///       pairs.
    public var dataset: CognitoSyncClientTypes.Dataset?

    public init (
        dataset: CognitoSyncClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    public let dataset: CognitoSyncClientTypes.Dataset?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset = "Dataset"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

extension DescribeIdentityPoolUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityPoolUsageInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension DescribeIdentityPoolUsageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeIdentityPoolUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityPoolUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolUsageOutputError>
}

public struct DescribeIdentityPoolUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityPoolUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolUsageOutputError>
}

public struct DescribeIdentityPoolUsageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolUsageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeIdentityPoolUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIdentityPoolUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolUsageOutputError>
}

public struct DescribeIdentityPoolUsageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityPoolUsageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeIdentityPoolUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIdentityPoolUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityPoolUsageOutputError>
}

/// A request for usage information about
///       the identity pool.
public struct DescribeIdentityPoolUsageInput: Swift.Equatable {
    /// A name-spaced GUID (for
    ///       example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID
    ///       generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolUsageInputBody: Swift.Equatable {
}

extension DescribeIdentityPoolUsageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIdentityPoolUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityPoolUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityPoolUsageOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityPoolUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityPoolUsageOutputResponse(identityPoolUsage: \(Swift.String(describing: identityPoolUsage)))"}
}

extension DescribeIdentityPoolUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityPoolUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityPoolUsage = output.identityPoolUsage
        } else {
            self.identityPoolUsage = nil
        }
    }
}

/// Response to a successful
///       DescribeIdentityPoolUsage request.
public struct DescribeIdentityPoolUsageOutputResponse: Swift.Equatable {
    /// Information about the
    ///       usage of the identity pool.
    public var identityPoolUsage: CognitoSyncClientTypes.IdentityPoolUsage?

    public init (
        identityPoolUsage: CognitoSyncClientTypes.IdentityPoolUsage? = nil
    )
    {
        self.identityPoolUsage = identityPoolUsage
    }
}

struct DescribeIdentityPoolUsageOutputResponseBody: Swift.Equatable {
    public let identityPoolUsage: CognitoSyncClientTypes.IdentityPoolUsage?
}

extension DescribeIdentityPoolUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolUsage = "IdentityPoolUsage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolUsageDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.IdentityPoolUsage.self, forKey: .identityPoolUsage)
        identityPoolUsage = identityPoolUsageDecoded
    }
}

extension DescribeIdentityUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityUsageInput(identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension DescribeIdentityUsageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeIdentityUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityUsageOutputError>
}

public struct DescribeIdentityUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeIdentityUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeIdentityUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityUsageOutputError>
}

public struct DescribeIdentityUsageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityUsageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeIdentityUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIdentityUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityUsageOutputError>
}

public struct DescribeIdentityUsageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeIdentityUsageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeIdentityUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeIdentityUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeIdentityUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeIdentityUsageOutputError>
}

/// A request for information about the usage of
///       an identity pool.
public struct DescribeIdentityUsageInput: Swift.Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for
    ///       example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID
    ///       generation is unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityUsageInputBody: Swift.Equatable {
}

extension DescribeIdentityUsageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeIdentityUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityUsageOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeIdentityUsageOutputResponse(identityUsage: \(Swift.String(describing: identityUsage)))"}
}

extension DescribeIdentityUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeIdentityUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityUsage = output.identityUsage
        } else {
            self.identityUsage = nil
        }
    }
}

/// The response to a successful
///       DescribeIdentityUsage request.
public struct DescribeIdentityUsageOutputResponse: Swift.Equatable {
    /// Usage information for the
    ///       identity.
    public var identityUsage: CognitoSyncClientTypes.IdentityUsage?

    public init (
        identityUsage: CognitoSyncClientTypes.IdentityUsage? = nil
    )
    {
        self.identityUsage = identityUsage
    }
}

struct DescribeIdentityUsageOutputResponseBody: Swift.Equatable {
    public let identityUsage: CognitoSyncClientTypes.IdentityUsage?
}

extension DescribeIdentityUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityUsage = "IdentityUsage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityUsageDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.IdentityUsage.self, forKey: .identityUsage)
        identityUsage = identityUsageDecoded
    }
}

extension DuplicateRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateRequestException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception thrown when there is an IN_PROGRESS bulk publish operation for the given identity pool.
public struct DuplicateRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message associated with the DuplicateRequestException exception.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetBulkPublishDetailsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBulkPublishDetailsInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension GetBulkPublishDetailsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBulkPublishDetailsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBulkPublishDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBulkPublishDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBulkPublishDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBulkPublishDetailsOutputError>
}

public struct GetBulkPublishDetailsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBulkPublishDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBulkPublishDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBulkPublishDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBulkPublishDetailsOutputError>
}

public struct GetBulkPublishDetailsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBulkPublishDetailsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBulkPublishDetailsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBulkPublishDetailsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBulkPublishDetailsOutputError>
}

public struct GetBulkPublishDetailsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBulkPublishDetailsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBulkPublishDetailsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/getBulkPublishDetails"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBulkPublishDetailsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBulkPublishDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBulkPublishDetailsOutputError>
}

/// The input for the GetBulkPublishDetails operation.
public struct GetBulkPublishDetailsInput: Swift.Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetBulkPublishDetailsInputBody: Swift.Equatable {
}

extension GetBulkPublishDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBulkPublishDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBulkPublishDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBulkPublishDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBulkPublishDetailsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBulkPublishDetailsOutputResponse(bulkPublishCompleteTime: \(Swift.String(describing: bulkPublishCompleteTime)), bulkPublishStartTime: \(Swift.String(describing: bulkPublishStartTime)), bulkPublishStatus: \(Swift.String(describing: bulkPublishStatus)), failureMessage: \(Swift.String(describing: failureMessage)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension GetBulkPublishDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBulkPublishDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bulkPublishCompleteTime = output.bulkPublishCompleteTime
            self.bulkPublishStartTime = output.bulkPublishStartTime
            self.bulkPublishStatus = output.bulkPublishStatus
            self.failureMessage = output.failureMessage
            self.identityPoolId = output.identityPoolId
        } else {
            self.bulkPublishCompleteTime = nil
            self.bulkPublishStartTime = nil
            self.bulkPublishStatus = nil
            self.failureMessage = nil
            self.identityPoolId = nil
        }
    }
}

/// The output for the GetBulkPublishDetails operation.
public struct GetBulkPublishDetailsOutputResponse: Swift.Equatable {
    /// If BulkPublishStatus is SUCCEEDED, the time the last bulk publish operation completed.
    public var bulkPublishCompleteTime: ClientRuntime.Date?
    /// The date/time at which the last bulk publish was initiated.
    public var bulkPublishStartTime: ClientRuntime.Date?
    /// Status of the last bulk publish operation, valid values are:
    ///       NOT_STARTED - No bulk publish has been requested for this identity pool
    ///       IN_PROGRESS - Data is being published to the configured stream
    ///       SUCCEEDED - All data for the identity pool has been published to the configured stream
    ///       FAILED - Some portion of the data has failed to publish, check FailureMessage for the cause.
    public var bulkPublishStatus: CognitoSyncClientTypes.BulkPublishStatus?
    /// If BulkPublishStatus is FAILED this field will contain the error message that caused the bulk publish to fail.
    public var failureMessage: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    public var identityPoolId: Swift.String?

    public init (
        bulkPublishCompleteTime: ClientRuntime.Date? = nil,
        bulkPublishStartTime: ClientRuntime.Date? = nil,
        bulkPublishStatus: CognitoSyncClientTypes.BulkPublishStatus? = nil,
        failureMessage: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.bulkPublishCompleteTime = bulkPublishCompleteTime
        self.bulkPublishStartTime = bulkPublishStartTime
        self.bulkPublishStatus = bulkPublishStatus
        self.failureMessage = failureMessage
        self.identityPoolId = identityPoolId
    }
}

struct GetBulkPublishDetailsOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let bulkPublishStartTime: ClientRuntime.Date?
    public let bulkPublishCompleteTime: ClientRuntime.Date?
    public let bulkPublishStatus: CognitoSyncClientTypes.BulkPublishStatus?
    public let failureMessage: Swift.String?
}

extension GetBulkPublishDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkPublishCompleteTime = "BulkPublishCompleteTime"
        case bulkPublishStartTime = "BulkPublishStartTime"
        case bulkPublishStatus = "BulkPublishStatus"
        case failureMessage = "FailureMessage"
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let bulkPublishStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .bulkPublishStartTime)
        bulkPublishStartTime = bulkPublishStartTimeDecoded
        let bulkPublishCompleteTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .bulkPublishCompleteTime)
        bulkPublishCompleteTime = bulkPublishCompleteTimeDecoded
        let bulkPublishStatusDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.BulkPublishStatus.self, forKey: .bulkPublishStatus)
        bulkPublishStatus = bulkPublishStatusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension GetCognitoEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCognitoEventsInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension GetCognitoEventsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCognitoEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCognitoEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCognitoEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCognitoEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCognitoEventsOutputError>
}

public struct GetCognitoEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCognitoEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCognitoEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCognitoEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCognitoEventsOutputError>
}

public struct GetCognitoEventsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCognitoEventsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetCognitoEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCognitoEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCognitoEventsOutputError>
}

public struct GetCognitoEventsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCognitoEventsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetCognitoEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/events"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetCognitoEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCognitoEventsOutputError>
}

/// A request for a list of the configured Cognito Events
public struct GetCognitoEventsInput: Swift.Equatable {
    /// The Cognito Identity Pool ID for the request
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetCognitoEventsInputBody: Swift.Equatable {
}

extension GetCognitoEventsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCognitoEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCognitoEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCognitoEventsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCognitoEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCognitoEventsOutputResponse(events: \(Swift.String(describing: events)))"}
}

extension GetCognitoEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCognitoEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
        } else {
            self.events = nil
        }
    }
}

/// The response from the GetCognitoEvents request
public struct GetCognitoEventsOutputResponse: Swift.Equatable {
    /// The Cognito Events returned from the GetCognitoEvents request
    public var events: [Swift.String:Swift.String]?

    public init (
        events: [Swift.String:Swift.String]? = nil
    )
    {
        self.events = events
    }
}

struct GetCognitoEventsOutputResponseBody: Swift.Equatable {
    public let events: [Swift.String:Swift.String]?
}

extension GetCognitoEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:Swift.String]()
            for (key0, lambdafunctionarn0) in eventsContainer {
                if let lambdafunctionarn0 = lambdafunctionarn0 {
                    eventsDecoded0?[key0] = lambdafunctionarn0
                }
            }
        }
        events = eventsDecoded0
    }
}

extension GetIdentityPoolConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentityPoolConfigurationInput(identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension GetIdentityPoolConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetIdentityPoolConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityPoolConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolConfigurationOutputError>
}

public struct GetIdentityPoolConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityPoolConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolConfigurationOutputError>
}

public struct GetIdentityPoolConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetIdentityPoolConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetIdentityPoolConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolConfigurationOutputError>
}

public struct GetIdentityPoolConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityPoolConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetIdentityPoolConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetIdentityPoolConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityPoolConfigurationOutputError>
}

/// The input for the GetIdentityPoolConfiguration operation.
public struct GetIdentityPoolConfigurationInput: Swift.Equatable {
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. This is the ID of the pool for which to return a configuration.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        identityPoolId: Swift.String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolConfigurationInputBody: Swift.Equatable {
}

extension GetIdentityPoolConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIdentityPoolConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityPoolConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityPoolConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityPoolConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentityPoolConfigurationOutputResponse(cognitoStreams: \(Swift.String(describing: cognitoStreams)), identityPoolId: \(Swift.String(describing: identityPoolId)), pushSync: \(Swift.String(describing: pushSync)))"}
}

extension GetIdentityPoolConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIdentityPoolConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cognitoStreams = output.cognitoStreams
            self.identityPoolId = output.identityPoolId
            self.pushSync = output.pushSync
        } else {
            self.cognitoStreams = nil
            self.identityPoolId = nil
            self.pushSync = nil
        }
    }
}

/// The output for the GetIdentityPoolConfiguration operation.
public struct GetIdentityPoolConfigurationOutputResponse: Swift.Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public var cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito.
    public var identityPoolId: Swift.String?
    /// Options to apply to this identity pool for push synchronization.
    public var pushSync: CognitoSyncClientTypes.PushSync?

    public init (
        cognitoStreams: CognitoSyncClientTypes.CognitoStreams? = nil,
        identityPoolId: Swift.String? = nil,
        pushSync: CognitoSyncClientTypes.PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct GetIdentityPoolConfigurationOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let pushSync: CognitoSyncClientTypes.PushSync?
    public let cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
}

extension GetIdentityPoolConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case identityPoolId = "IdentityPoolId"
        case pushSync = "PushSync"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let pushSyncDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

extension CognitoSyncClientTypes.IdentityPoolUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataStorage = "DataStorage"
        case identityPoolId = "IdentityPoolId"
        case lastModifiedDate = "LastModifiedDate"
        case syncSessionsCount = "SyncSessionsCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let syncSessionsCount = syncSessionsCount {
            try encodeContainer.encode(syncSessionsCount, forKey: .syncSessionsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let syncSessionsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .syncSessionsCount)
        syncSessionsCount = syncSessionsCountDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension CognitoSyncClientTypes.IdentityPoolUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityPoolUsage(dataStorage: \(Swift.String(describing: dataStorage)), identityPoolId: \(Swift.String(describing: identityPoolId)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), syncSessionsCount: \(Swift.String(describing: syncSessionsCount)))"}
}

extension CognitoSyncClientTypes {
    /// Usage information for the identity
    ///       pool.
    public struct IdentityPoolUsage: Swift.Equatable {
        /// Data storage information for the identity
        ///       pool.
        public var dataStorage: Swift.Int?
        /// A name-spaced GUID (for example,
        ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
        ///       unique within a region.
        public var identityPoolId: Swift.String?
        /// Date on which the identity pool was
        ///       last modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// Number of sync sessions for the
        ///       identity pool.
        public var syncSessionsCount: Swift.Int?

        public init (
            dataStorage: Swift.Int? = nil,
            identityPoolId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            syncSessionsCount: Swift.Int? = nil
        )
        {
            self.dataStorage = dataStorage
            self.identityPoolId = identityPoolId
            self.lastModifiedDate = lastModifiedDate
            self.syncSessionsCount = syncSessionsCount
        }
    }

}

extension CognitoSyncClientTypes.IdentityUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataStorage = "DataStorage"
        case datasetCount = "DatasetCount"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case lastModifiedDate = "LastModifiedDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataStorage = dataStorage {
            try encodeContainer.encode(dataStorage, forKey: .dataStorage)
        }
        if datasetCount != 0 {
            try encodeContainer.encode(datasetCount, forKey: .datasetCount)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let datasetCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .datasetCount)
        datasetCount = datasetCountDecoded
        let dataStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataStorage)
        dataStorage = dataStorageDecoded
    }
}

extension CognitoSyncClientTypes.IdentityUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityUsage(dataStorage: \(Swift.String(describing: dataStorage)), datasetCount: \(Swift.String(describing: datasetCount)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)))"}
}

extension CognitoSyncClientTypes {
    /// Usage information for the identity.
    public struct IdentityUsage: Swift.Equatable {
        /// Total data storage for this
        ///       identity.
        public var dataStorage: Swift.Int?
        /// Number of datasets for the
        ///       identity.
        public var datasetCount: Swift.Int
        /// A name-spaced GUID (for example,
        ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
        ///       unique within a region.
        public var identityId: Swift.String?
        /// A name-spaced GUID (for example,
        ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
        ///       unique within a region.
        public var identityPoolId: Swift.String?
        /// Date on which the identity was last
        ///       modified.
        public var lastModifiedDate: ClientRuntime.Date?

        public init (
            dataStorage: Swift.Int? = nil,
            datasetCount: Swift.Int = 0,
            identityId: Swift.String? = nil,
            identityPoolId: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil
        )
        {
            self.dataStorage = dataStorage
            self.datasetCount = datasetCount
            self.identityId = identityId
            self.identityPoolId = identityPoolId
            self.lastModifiedDate = lastModifiedDate
        }
    }

}

extension InternalErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates an internal service
///       error.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Message returned by
    ///       InternalErrorException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidConfigurationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InvalidConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message returned by
    ///       InvalidConfigurationException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionOutputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLambdaFunctionOutputException(message: \(Swift.String(describing: message)))"}
}

extension InvalidLambdaFunctionOutputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLambdaFunctionOutputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS Lambda function returned invalid output or an exception.
public struct InvalidLambdaFunctionOutputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message returned when an InvalidLambdaFunctionOutputException occurs
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaFunctionOutputExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLambdaFunctionOutputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a request parameter does not comply
///       with the associated constraints.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message returned by
    ///       InvalidParameterException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaThrottledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaThrottledException(message: \(Swift.String(describing: message)))"}
}

extension LambdaThrottledException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LambdaThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AWS Lambda throttled your account, please contact AWS Support
public struct LambdaThrottledException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message returned when an LambdaThrottledException is thrown
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LambdaThrottledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LambdaThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when the limit on the number of objects or
///       operations has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message returned by
    ///       LimitExceededException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsInput(identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDatasetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDatasetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDatasetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

/// Request for a list of datasets for an
///       identity.
public struct ListDatasetsInput: Swift.Equatable {
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The maximum number of results to be
    ///       returned.
    public var maxResults: Swift.Int
    /// A pagination token for obtaining the next
    ///       page of results.
    public var nextToken: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsOutputResponse(count: \(Swift.String(describing: count)), datasets: \(Swift.String(describing: datasets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.count = output.count
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.count = 0
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

/// Returned for a successful ListDatasets
///       request.
public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// Number of datasets returned.
    public var count: Swift.Int
    /// A set of datasets.
    public var datasets: [CognitoSyncClientTypes.Dataset]?
    /// A pagination token for obtaining the next
    ///       page of results.
    public var nextToken: Swift.String?

    public init (
        count: Swift.Int = 0,
        datasets: [CognitoSyncClientTypes.Dataset]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.count = count
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    public let datasets: [CognitoSyncClientTypes.Dataset]?
    public let count: Swift.Int
    public let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[CognitoSyncClientTypes.Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [CognitoSyncClientTypes.Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentityPoolUsageInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentityPoolUsageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListIdentityPoolUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityPoolUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolUsageOutputError>
}

public struct ListIdentityPoolUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityPoolUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityPoolUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolUsageOutputError>
}

public struct ListIdentityPoolUsageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolUsageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListIdentityPoolUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIdentityPoolUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolUsageOutputError>
}

public struct ListIdentityPoolUsageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityPoolUsageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListIdentityPoolUsageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/identitypools"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIdentityPoolUsageInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityPoolUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityPoolUsageOutputError>
}

/// A request for usage information on an
///       identity pool.
public struct ListIdentityPoolUsageInput: Swift.Equatable {
    /// The maximum number of results to
    ///       be returned.
    public var maxResults: Swift.Int
    /// A pagination token for obtaining
    ///       the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolUsageInputBody: Swift.Equatable {
}

extension ListIdentityPoolUsageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIdentityPoolUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityPoolUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityPoolUsageOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityPoolUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentityPoolUsageOutputResponse(count: \(Swift.String(describing: count)), identityPoolUsages: \(Swift.String(describing: identityPoolUsages)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentityPoolUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIdentityPoolUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.count = output.count
            self.identityPoolUsages = output.identityPoolUsages
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.count = 0
            self.identityPoolUsages = nil
            self.maxResults = 0
            self.nextToken = nil
        }
    }
}

/// Returned for a successful
///       ListIdentityPoolUsage request.
public struct ListIdentityPoolUsageOutputResponse: Swift.Equatable {
    /// Total number of identities for the
    ///       identity pool.
    public var count: Swift.Int
    /// Usage information for
    ///       the identity pools.
    public var identityPoolUsages: [CognitoSyncClientTypes.IdentityPoolUsage]?
    /// The maximum number of results to
    ///       be returned.
    public var maxResults: Swift.Int
    /// A pagination token for obtaining
    ///       the next page of results.
    public var nextToken: Swift.String?

    public init (
        count: Swift.Int = 0,
        identityPoolUsages: [CognitoSyncClientTypes.IdentityPoolUsage]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.count = count
        self.identityPoolUsages = identityPoolUsages
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolUsageOutputResponseBody: Swift.Equatable {
    public let identityPoolUsages: [CognitoSyncClientTypes.IdentityPoolUsage]?
    public let maxResults: Swift.Int
    public let count: Swift.Int
    public let nextToken: Swift.String?
}

extension ListIdentityPoolUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case identityPoolUsages = "IdentityPoolUsages"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolUsagesContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.IdentityPoolUsage?].self, forKey: .identityPoolUsages)
        var identityPoolUsagesDecoded0:[CognitoSyncClientTypes.IdentityPoolUsage]? = nil
        if let identityPoolUsagesContainer = identityPoolUsagesContainer {
            identityPoolUsagesDecoded0 = [CognitoSyncClientTypes.IdentityPoolUsage]()
            for structure0 in identityPoolUsagesContainer {
                if let structure0 = structure0 {
                    identityPoolUsagesDecoded0?.append(structure0)
                }
            }
        }
        identityPoolUsages = identityPoolUsagesDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecordsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordsInput(datasetName: \(Swift.String(describing: datasetName)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), lastSyncCount: \(Swift.String(describing: lastSyncCount)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), syncSessionToken: \(Swift.String(describing: syncSessionToken)))"}
}

extension ListRecordsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecordsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordsOutputError>
}

public struct ListRecordsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let syncSessionToken = input.operationInput.syncSessionToken {
            let syncSessionTokenQueryItem = ClientRuntime.URLQueryItem(name: "syncSessionToken".urlPercentEncoding(), value: Swift.String(syncSessionToken).urlPercentEncoding())
            input.builder.withQueryItem(syncSessionTokenQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let lastSyncCount = input.operationInput.lastSyncCount {
            let lastSyncCountQueryItem = ClientRuntime.URLQueryItem(name: "lastSyncCount".urlPercentEncoding(), value: Swift.String(lastSyncCount).urlPercentEncoding())
            input.builder.withQueryItem(lastSyncCountQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordsOutputError>
}

public struct ListRecordsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRecordsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecordsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordsOutputError>
}

public struct ListRecordsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRecordsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        guard let datasetName = input.datasetName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())/records"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecordsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordsOutputError>
}

/// A request for a list of records.
public struct ListRecordsInput: Swift.Equatable {
    /// A string of up to 128 characters. Allowed
    ///       characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.' (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The last server sync count for this
    ///       record.
    public var lastSyncCount: Swift.Int?
    /// The maximum number of results to be
    ///       returned.
    public var maxResults: Swift.Int
    /// A pagination token for obtaining the next
    ///       page of results.
    public var nextToken: Swift.String?
    /// A token containing a session ID,
    ///       identity ID, and expiration.
    public var syncSessionToken: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        lastSyncCount: Swift.Int? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        syncSessionToken: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.lastSyncCount = lastSyncCount
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncSessionToken = syncSessionToken
    }
}

struct ListRecordsInputBody: Swift.Equatable {
}

extension ListRecordsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecordsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordsOutputResponse(count: \(Swift.String(describing: count)), datasetDeletedAfterRequestedSyncCount: \(Swift.String(describing: datasetDeletedAfterRequestedSyncCount)), datasetExists: \(Swift.String(describing: datasetExists)), datasetSyncCount: \(Swift.String(describing: datasetSyncCount)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), mergedDatasetNames: \(Swift.String(describing: mergedDatasetNames)), nextToken: \(Swift.String(describing: nextToken)), records: \(Swift.String(describing: records)), syncSessionToken: \(Swift.String(describing: syncSessionToken)))"}
}

extension ListRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.count = output.count
            self.datasetDeletedAfterRequestedSyncCount = output.datasetDeletedAfterRequestedSyncCount
            self.datasetExists = output.datasetExists
            self.datasetSyncCount = output.datasetSyncCount
            self.lastModifiedBy = output.lastModifiedBy
            self.mergedDatasetNames = output.mergedDatasetNames
            self.nextToken = output.nextToken
            self.records = output.records
            self.syncSessionToken = output.syncSessionToken
        } else {
            self.count = 0
            self.datasetDeletedAfterRequestedSyncCount = false
            self.datasetExists = false
            self.datasetSyncCount = nil
            self.lastModifiedBy = nil
            self.mergedDatasetNames = nil
            self.nextToken = nil
            self.records = nil
            self.syncSessionToken = nil
        }
    }
}

/// Returned for a successful
///       ListRecordsRequest.
public struct ListRecordsOutputResponse: Swift.Equatable {
    /// Total number of records.
    public var count: Swift.Int
    /// A boolean value
    ///       specifying whether to delete the dataset locally.
    public var datasetDeletedAfterRequestedSyncCount: Swift.Bool
    /// Indicates whether the dataset
    ///       exists.
    public var datasetExists: Swift.Bool
    /// Server sync count for this
    ///       dataset.
    public var datasetSyncCount: Swift.Int?
    /// The user/device that made the last
    ///       change to this record.
    public var lastModifiedBy: Swift.String?
    /// Names of merged
    ///       datasets.
    public var mergedDatasetNames: [Swift.String]?
    /// A pagination token for obtaining the next
    ///       page of results.
    public var nextToken: Swift.String?
    /// A list of all records.
    public var records: [CognitoSyncClientTypes.Record]?
    /// A token containing a session ID,
    ///       identity ID, and expiration.
    public var syncSessionToken: Swift.String?

    public init (
        count: Swift.Int = 0,
        datasetDeletedAfterRequestedSyncCount: Swift.Bool = false,
        datasetExists: Swift.Bool = false,
        datasetSyncCount: Swift.Int? = nil,
        lastModifiedBy: Swift.String? = nil,
        mergedDatasetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        records: [CognitoSyncClientTypes.Record]? = nil,
        syncSessionToken: Swift.String? = nil
    )
    {
        self.count = count
        self.datasetDeletedAfterRequestedSyncCount = datasetDeletedAfterRequestedSyncCount
        self.datasetExists = datasetExists
        self.datasetSyncCount = datasetSyncCount
        self.lastModifiedBy = lastModifiedBy
        self.mergedDatasetNames = mergedDatasetNames
        self.nextToken = nextToken
        self.records = records
        self.syncSessionToken = syncSessionToken
    }
}

struct ListRecordsOutputResponseBody: Swift.Equatable {
    public let records: [CognitoSyncClientTypes.Record]?
    public let nextToken: Swift.String?
    public let count: Swift.Int
    public let datasetSyncCount: Swift.Int?
    public let lastModifiedBy: Swift.String?
    public let mergedDatasetNames: [Swift.String]?
    public let datasetExists: Swift.Bool
    public let datasetDeletedAfterRequestedSyncCount: Swift.Bool
    public let syncSessionToken: Swift.String?
}

extension ListRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case datasetDeletedAfterRequestedSyncCount = "DatasetDeletedAfterRequestedSyncCount"
        case datasetExists = "DatasetExists"
        case datasetSyncCount = "DatasetSyncCount"
        case lastModifiedBy = "LastModifiedBy"
        case mergedDatasetNames = "MergedDatasetNames"
        case nextToken = "NextToken"
        case records = "Records"
        case syncSessionToken = "SyncSessionToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[CognitoSyncClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [CognitoSyncClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let datasetSyncCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .datasetSyncCount)
        datasetSyncCount = datasetSyncCountDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let mergedDatasetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .mergedDatasetNames)
        var mergedDatasetNamesDecoded0:[Swift.String]? = nil
        if let mergedDatasetNamesContainer = mergedDatasetNamesContainer {
            mergedDatasetNamesDecoded0 = [Swift.String]()
            for string0 in mergedDatasetNamesContainer {
                if let string0 = string0 {
                    mergedDatasetNamesDecoded0?.append(string0)
                }
            }
        }
        mergedDatasetNames = mergedDatasetNamesDecoded0
        let datasetExistsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .datasetExists)
        datasetExists = datasetExistsDecoded
        let datasetDeletedAfterRequestedSyncCountDecoded = try containerValues.decode(Swift.Bool.self, forKey: .datasetDeletedAfterRequestedSyncCount)
        datasetDeletedAfterRequestedSyncCount = datasetDeletedAfterRequestedSyncCountDecoded
        let syncSessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSessionToken)
        syncSessionToken = syncSessionTokenDecoded
    }
}

extension NotAuthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotAuthorizedException(message: \(Swift.String(describing: message)))"}
}

extension NotAuthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown when a user is not authorized to access the
///       requested resource.
public struct NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a
    ///       NotAuthorizedException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CognitoSyncClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .remove: return "remove"
            case .replace: return "replace"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension CognitoSyncClientTypes {
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adm
        case apns
        case apnsSandbox
        case gcm
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .adm,
                .apns,
                .apnsSandbox,
                .gcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adm: return "ADM"
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .gcm: return "GCM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension CognitoSyncClientTypes.PushSync: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArns = "ApplicationArns"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArns = applicationArns {
            var applicationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationArns)
            for applicationarnlist0 in applicationArns {
                try applicationArnsContainer.encode(applicationarnlist0)
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationArns)
        var applicationArnsDecoded0:[Swift.String]? = nil
        if let applicationArnsContainer = applicationArnsContainer {
            applicationArnsDecoded0 = [Swift.String]()
            for string0 in applicationArnsContainer {
                if let string0 = string0 {
                    applicationArnsDecoded0?.append(string0)
                }
            }
        }
        applicationArns = applicationArnsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CognitoSyncClientTypes.PushSync: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PushSync(applicationArns: \(Swift.String(describing: applicationArns)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension CognitoSyncClientTypes {
    /// Configuration options to be applied to the identity pool.
    public struct PushSync: Swift.Equatable {
        /// List of SNS platform application ARNs that could be used by clients.
        public var applicationArns: [Swift.String]?
        /// A role configured to allow Cognito to call SNS on behalf of the developer.
        public var roleArn: Swift.String?

        public init (
            applicationArns: [Swift.String]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.applicationArns = applicationArns
            self.roleArn = roleArn
        }
    }

}

extension CognitoSyncClientTypes.Record: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
        case key = "Key"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case syncCount = "SyncCount"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceLastModifiedDate = deviceLastModifiedDate {
            try encodeContainer.encode(deviceLastModifiedDate.timeIntervalSince1970, forKey: .deviceLastModifiedDate)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let syncCount = syncCount {
            try encodeContainer.encode(syncCount, forKey: .syncCount)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let syncCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .syncCount)
        syncCount = syncCountDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
    }
}

extension CognitoSyncClientTypes.Record: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Record(deviceLastModifiedDate: \(Swift.String(describing: deviceLastModifiedDate)), key: \(Swift.String(describing: key)), lastModifiedBy: \(Swift.String(describing: lastModifiedBy)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), syncCount: \(Swift.String(describing: syncCount)), value: \(Swift.String(describing: value)))"}
}

extension CognitoSyncClientTypes {
    /// The basic data structure of a dataset.
    public struct Record: Swift.Equatable {
        /// The last modified date of the client
        ///       device.
        public var deviceLastModifiedDate: ClientRuntime.Date?
        /// The key for the record.
        public var key: Swift.String?
        /// The user/device that made the last change to this
        ///       record.
        public var lastModifiedBy: Swift.String?
        /// The date on which the record was last
        ///       modified.
        public var lastModifiedDate: ClientRuntime.Date?
        /// The server sync count for this record.
        public var syncCount: Swift.Int?
        /// The value for the record.
        public var value: Swift.String?

        public init (
            deviceLastModifiedDate: ClientRuntime.Date? = nil,
            key: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedDate: ClientRuntime.Date? = nil,
            syncCount: Swift.Int? = nil,
            value: Swift.String? = nil
        )
        {
            self.deviceLastModifiedDate = deviceLastModifiedDate
            self.key = key
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedDate = lastModifiedDate
            self.syncCount = syncCount
            self.value = value
        }
    }

}

extension CognitoSyncClientTypes.RecordPatch: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceLastModifiedDate = "DeviceLastModifiedDate"
        case key = "Key"
        case op = "Op"
        case syncCount = "SyncCount"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceLastModifiedDate = deviceLastModifiedDate {
            try encodeContainer.encode(deviceLastModifiedDate.timeIntervalSince1970, forKey: .deviceLastModifiedDate)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let op = op {
            try encodeContainer.encode(op.rawValue, forKey: .op)
        }
        if let syncCount = syncCount {
            try encodeContainer.encode(syncCount, forKey: .syncCount)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Operation.self, forKey: .op)
        op = opDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let syncCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .syncCount)
        syncCount = syncCountDecoded
        let deviceLastModifiedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deviceLastModifiedDate)
        deviceLastModifiedDate = deviceLastModifiedDateDecoded
    }
}

extension CognitoSyncClientTypes.RecordPatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordPatch(deviceLastModifiedDate: \(Swift.String(describing: deviceLastModifiedDate)), key: \(Swift.String(describing: key)), op: \(Swift.String(describing: op)), syncCount: \(Swift.String(describing: syncCount)), value: \(Swift.String(describing: value)))"}
}

extension CognitoSyncClientTypes {
    /// An update operation for a record.
    public struct RecordPatch: Swift.Equatable {
        /// The last modified date of the client
        ///       device.
        public var deviceLastModifiedDate: ClientRuntime.Date?
        /// The key associated with the record patch.
        /// This member is required.
        public var key: Swift.String?
        /// An operation, either replace or remove.
        /// This member is required.
        public var op: CognitoSyncClientTypes.Operation?
        /// Last known server sync count for this record. Set
        ///       to 0 if unknown.
        /// This member is required.
        public var syncCount: Swift.Int?
        /// The value associated with the record
        ///       patch.
        public var value: Swift.String?

        public init (
            deviceLastModifiedDate: ClientRuntime.Date? = nil,
            key: Swift.String? = nil,
            op: CognitoSyncClientTypes.Operation? = nil,
            syncCount: Swift.Int? = nil,
            value: Swift.String? = nil
        )
        {
            self.deviceLastModifiedDate = deviceLastModifiedDate
            self.key = key
            self.op = op
            self.syncCount = syncCount
            self.value = value
        }
    }

}

public struct RegisterDeviceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDeviceOutputError>
}

extension RegisterDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDeviceInput(identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), platform: \(Swift.String(describing: platform)), token: \(Swift.String(describing: token)))"}
}

extension RegisterDeviceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform = "Platform"
        case token = "Token"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

public struct RegisterDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDeviceOutputError>
}

public struct RegisterDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDeviceOutputError>
}

public struct RegisterDeviceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDeviceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDeviceOutputError>
}

public struct RegisterDeviceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDeviceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterDeviceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identity/\(identityId.urlPercentEncoding())/device"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterDeviceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDeviceOutputError>
}

/// A request to RegisterDevice.
public struct RegisterDeviceInput: Swift.Equatable {
    /// The unique ID for this identity.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. Here, the ID of the pool that the identity belongs to.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// The SNS platform type (e.g. GCM, SDM, APNS, APNS_SANDBOX).
    /// This member is required.
    public var platform: CognitoSyncClientTypes.Platform?
    /// The push token.
    /// This member is required.
    public var token: Swift.String?

    public init (
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        platform: CognitoSyncClientTypes.Platform? = nil,
        token: Swift.String? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.platform = platform
        self.token = token
    }
}

struct RegisterDeviceInputBody: Swift.Equatable {
    public let platform: CognitoSyncClientTypes.Platform?
    public let token: Swift.String?
}

extension RegisterDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platform = "Platform"
        case token = "Token"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let platformDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension RegisterDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidConfigurationException(InvalidConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDeviceOutputResponse(deviceId: \(Swift.String(describing: deviceId)))"}
}

extension RegisterDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

/// Response to a RegisterDevice request.
public struct RegisterDeviceOutputResponse: Swift.Equatable {
    /// The unique ID generated for this device by Cognito.
    public var deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct RegisterDeviceOutputResponseBody: Swift.Equatable {
    public let deviceId: Swift.String?
}

extension RegisterDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension ResourceConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConflictException(message: \(Swift.String(describing: message)))"}
}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if an update can't be applied because
///       the resource was changed by another call and this would result in a conflict.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The message returned by a
    ///       ResourceConflictException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if the resource doesn't
///       exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message returned by a
    ///       ResourceNotFoundException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetCognitoEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetCognitoEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetCognitoEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetCognitoEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetCognitoEventsOutputError>
}

extension SetCognitoEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetCognitoEventsInput(events: \(Swift.String(describing: events)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension SetCognitoEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, events0) in events {
                try eventsContainer.encode(events0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct SetCognitoEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetCognitoEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetCognitoEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetCognitoEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetCognitoEventsOutputError>
}

public struct SetCognitoEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetCognitoEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetCognitoEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetCognitoEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetCognitoEventsOutputError>
}

public struct SetCognitoEventsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetCognitoEventsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SetCognitoEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetCognitoEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetCognitoEventsOutputError>
}

public struct SetCognitoEventsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetCognitoEventsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SetCognitoEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/events"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetCognitoEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetCognitoEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetCognitoEventsOutputError>
}

/// A request to configure Cognito Events""
public struct SetCognitoEventsInput: Swift.Equatable {
    /// The events to configure
    /// This member is required.
    public var events: [Swift.String:Swift.String]?
    /// The Cognito Identity Pool to use when configuring Cognito Events
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        events: [Swift.String:Swift.String]? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.events = events
        self.identityPoolId = identityPoolId
    }
}

struct SetCognitoEventsInputBody: Swift.Equatable {
    public let events: [Swift.String:Swift.String]?
}

extension SetCognitoEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:Swift.String]()
            for (key0, lambdafunctionarn0) in eventsContainer {
                if let lambdafunctionarn0 = lambdafunctionarn0 {
                    eventsDecoded0?[key0] = lambdafunctionarn0
                }
            }
        }
        events = eventsDecoded0
    }
}

extension SetCognitoEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetCognitoEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetCognitoEventsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetCognitoEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetCognitoEventsOutputResponse()"}
}

extension SetCognitoEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SetCognitoEventsOutputResponse: Swift.Equatable {

    public init() {}
}

struct SetCognitoEventsOutputResponseBody: Swift.Equatable {
}

extension SetCognitoEventsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct SetIdentityPoolConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIdentityPoolConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolConfigurationOutputError>
}

extension SetIdentityPoolConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetIdentityPoolConfigurationInput(cognitoStreams: \(Swift.String(describing: cognitoStreams)), identityPoolId: \(Swift.String(describing: identityPoolId)), pushSync: \(Swift.String(describing: pushSync)))"}
}

extension SetIdentityPoolConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case pushSync = "PushSync"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoStreams = cognitoStreams {
            try encodeContainer.encode(cognitoStreams, forKey: .cognitoStreams)
        }
        if let pushSync = pushSync {
            try encodeContainer.encode(pushSync, forKey: .pushSync)
        }
    }
}

public struct SetIdentityPoolConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIdentityPoolConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolConfigurationOutputError>
}

public struct SetIdentityPoolConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIdentityPoolConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIdentityPoolConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolConfigurationOutputError>
}

public struct SetIdentityPoolConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SetIdentityPoolConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetIdentityPoolConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolConfigurationOutputError>
}

public struct SetIdentityPoolConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIdentityPoolConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SetIdentityPoolConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SetIdentityPoolConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<SetIdentityPoolConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIdentityPoolConfigurationOutputError>
}

/// The input for the SetIdentityPoolConfiguration operation.
public struct SetIdentityPoolConfigurationInput: Swift.Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public var cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. This is the ID of the pool to modify.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// Options to apply to this identity pool for push synchronization.
    public var pushSync: CognitoSyncClientTypes.PushSync?

    public init (
        cognitoStreams: CognitoSyncClientTypes.CognitoStreams? = nil,
        identityPoolId: Swift.String? = nil,
        pushSync: CognitoSyncClientTypes.PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct SetIdentityPoolConfigurationInputBody: Swift.Equatable {
    public let pushSync: CognitoSyncClientTypes.PushSync?
    public let cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
}

extension SetIdentityPoolConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case pushSync = "PushSync"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushSyncDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

extension SetIdentityPoolConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetIdentityPoolConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityPoolConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityPoolConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetIdentityPoolConfigurationOutputResponse(cognitoStreams: \(Swift.String(describing: cognitoStreams)), identityPoolId: \(Swift.String(describing: identityPoolId)), pushSync: \(Swift.String(describing: pushSync)))"}
}

extension SetIdentityPoolConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetIdentityPoolConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cognitoStreams = output.cognitoStreams
            self.identityPoolId = output.identityPoolId
            self.pushSync = output.pushSync
        } else {
            self.cognitoStreams = nil
            self.identityPoolId = nil
            self.pushSync = nil
        }
    }
}

/// The output for the SetIdentityPoolConfiguration operation
public struct SetIdentityPoolConfigurationOutputResponse: Swift.Equatable {
    /// Options to apply to this identity pool for Amazon Cognito streams.
    public var cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito.
    public var identityPoolId: Swift.String?
    /// Options to apply to this identity pool for push synchronization.
    public var pushSync: CognitoSyncClientTypes.PushSync?

    public init (
        cognitoStreams: CognitoSyncClientTypes.CognitoStreams? = nil,
        identityPoolId: Swift.String? = nil,
        pushSync: CognitoSyncClientTypes.PushSync? = nil
    )
    {
        self.cognitoStreams = cognitoStreams
        self.identityPoolId = identityPoolId
        self.pushSync = pushSync
    }
}

struct SetIdentityPoolConfigurationOutputResponseBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let pushSync: CognitoSyncClientTypes.PushSync?
    public let cognitoStreams: CognitoSyncClientTypes.CognitoStreams?
}

extension SetIdentityPoolConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoStreams = "CognitoStreams"
        case identityPoolId = "IdentityPoolId"
        case pushSync = "PushSync"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let pushSyncDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.PushSync.self, forKey: .pushSync)
        pushSync = pushSyncDecoded
        let cognitoStreamsDecoded = try containerValues.decodeIfPresent(CognitoSyncClientTypes.CognitoStreams.self, forKey: .cognitoStreams)
        cognitoStreams = cognitoStreamsDecoded
    }
}

extension CognitoSyncClientTypes {
    public enum StreamingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
        }
    }
}

extension SubscribeToDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToDatasetInput(datasetName: \(Swift.String(describing: datasetName)), deviceId: \(Swift.String(describing: deviceId)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension SubscribeToDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct SubscribeToDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToDatasetOutputError>
}

public struct SubscribeToDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubscribeToDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubscribeToDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToDatasetOutputError>
}

public struct SubscribeToDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SubscribeToDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SubscribeToDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToDatasetOutputError>
}

public struct SubscribeToDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubscribeToDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SubscribeToDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        guard let datasetName = input.datasetName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetName is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())/subscriptions/\(deviceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SubscribeToDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<SubscribeToDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubscribeToDatasetOutputError>
}

/// A request to SubscribeToDatasetRequest.
public struct SubscribeToDatasetInput: Swift.Equatable {
    /// The name of the dataset to subcribe to.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The unique ID generated for this device by Cognito.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Unique ID for this identity.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. The ID of the pool to which the identity belongs.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct SubscribeToDatasetInputBody: Swift.Equatable {
}

extension SubscribeToDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SubscribeToDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeToDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeToDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidConfigurationException(InvalidConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeToDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscribeToDatasetOutputResponse()"}
}

extension SubscribeToDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response to a SubscribeToDataset request.
public struct SubscribeToDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct SubscribeToDatasetOutputResponseBody: Swift.Equatable {
}

extension SubscribeToDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Thrown if the request is
///       throttled.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Message returned by a
    ///       TooManyRequestsException.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsubscribeFromDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeFromDatasetInput(datasetName: \(Swift.String(describing: datasetName)), deviceId: \(Swift.String(describing: deviceId)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)))"}
}

extension UnsubscribeFromDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UnsubscribeFromDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeFromDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeFromDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromDatasetOutputError>
}

public struct UnsubscribeFromDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnsubscribeFromDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnsubscribeFromDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromDatasetOutputError>
}

public struct UnsubscribeFromDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UnsubscribeFromDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnsubscribeFromDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromDatasetOutputError>
}

public struct UnsubscribeFromDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnsubscribeFromDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UnsubscribeFromDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        guard let datasetName = input.datasetName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetName is nil and needs a value for the path of this operation"))))
        }
        guard let deviceId = input.deviceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("deviceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())/subscriptions/\(deviceId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UnsubscribeFromDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UnsubscribeFromDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnsubscribeFromDatasetOutputError>
}

/// A request to UnsubscribeFromDataset.
public struct UnsubscribeFromDatasetInput: Swift.Equatable {
    /// The name of the dataset from which to unsubcribe.
    /// This member is required.
    public var datasetName: Swift.String?
    /// The unique ID generated for this device by Cognito.
    /// This member is required.
    public var deviceId: Swift.String?
    /// Unique ID for this identity.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example, us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by
    ///          Amazon Cognito. The ID of the pool to which this identity belongs.
    /// This member is required.
    public var identityPoolId: Swift.String?

    public init (
        datasetName: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil
    )
    {
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnsubscribeFromDatasetInputBody: Swift.Equatable {
}

extension UnsubscribeFromDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnsubscribeFromDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnsubscribeFromDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeFromDatasetOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidConfigurationException(InvalidConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeFromDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeFromDatasetOutputResponse()"}
}

extension UnsubscribeFromDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response to an UnsubscribeFromDataset request.
public struct UnsubscribeFromDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct UnsubscribeFromDatasetOutputResponseBody: Swift.Equatable {
}

extension UnsubscribeFromDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateRecordsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecordsOutputError>
}

extension UpdateRecordsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecordsInput(clientContext: \(Swift.String(describing: clientContext)), datasetName: \(Swift.String(describing: datasetName)), deviceId: \(Swift.String(describing: deviceId)), identityId: \(Swift.String(describing: identityId)), identityPoolId: \(Swift.String(describing: identityPoolId)), recordPatches: \(Swift.String(describing: recordPatches)), syncSessionToken: \(Swift.String(describing: syncSessionToken)))"}
}

extension UpdateRecordsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case recordPatches = "RecordPatches"
        case syncSessionToken = "SyncSessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let recordPatches = recordPatches {
            var recordPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordPatches)
            for recordpatchlist0 in recordPatches {
                try recordPatchesContainer.encode(recordpatchlist0)
            }
        }
        if let syncSessionToken = syncSessionToken {
            try encodeContainer.encode(syncSessionToken, forKey: .syncSessionToken)
        }
    }
}

public struct UpdateRecordsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientContext = input.operationInput.clientContext {
            input.builder.withHeader(name: "x-amz-Client-Context", value: Swift.String(clientContext))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecordsOutputError>
}

public struct UpdateRecordsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecordsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecordsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecordsOutputError>
}

public struct UpdateRecordsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecordsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRecordsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRecordsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecordsOutputError>
}

public struct UpdateRecordsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecordsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRecordsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityPoolId = input.identityPoolId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityPoolId is nil and needs a value for the path of this operation"))))
        }
        guard let identityId = input.identityId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityId is nil and needs a value for the path of this operation"))))
        }
        guard let datasetName = input.datasetName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identitypools/\(identityPoolId.urlPercentEncoding())/identities/\(identityId.urlPercentEncoding())/datasets/\(datasetName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRecordsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecordsOutputError>
}

/// A request to post updates to records or add and
///       delete records for a dataset and user.
public struct UpdateRecordsInput: Swift.Equatable {
    /// Intended to supply a device ID that
    ///       will populate the lastModifiedBy field referenced in other methods. The
    ///          ClientContext field is not yet implemented.
    public var clientContext: Swift.String?
    /// A string of up to 128 characters.
    ///       Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (dash), and '.'
    ///       (dot).
    /// This member is required.
    public var datasetName: Swift.String?
    /// The unique ID generated for this device by Cognito.
    public var deviceId: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityId: Swift.String?
    /// A name-spaced GUID (for example,
    ///       us-east-1:23EC4050-6AEA-7089-A2DD-08002EXAMPLE) created by Amazon Cognito. GUID generation is
    ///       unique within a region.
    /// This member is required.
    public var identityPoolId: Swift.String?
    /// A list of patch
    ///       operations.
    public var recordPatches: [CognitoSyncClientTypes.RecordPatch]?
    /// The SyncSessionToken returned by a
    ///       previous call to ListRecords for this dataset and identity.
    /// This member is required.
    public var syncSessionToken: Swift.String?

    public init (
        clientContext: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        recordPatches: [CognitoSyncClientTypes.RecordPatch]? = nil,
        syncSessionToken: Swift.String? = nil
    )
    {
        self.clientContext = clientContext
        self.datasetName = datasetName
        self.deviceId = deviceId
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.recordPatches = recordPatches
        self.syncSessionToken = syncSessionToken
    }
}

struct UpdateRecordsInputBody: Swift.Equatable {
    public let deviceId: Swift.String?
    public let recordPatches: [CognitoSyncClientTypes.RecordPatch]?
    public let syncSessionToken: Swift.String?
}

extension UpdateRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case recordPatches = "RecordPatches"
        case syncSessionToken = "SyncSessionToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let recordPatchesContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.RecordPatch?].self, forKey: .recordPatches)
        var recordPatchesDecoded0:[CognitoSyncClientTypes.RecordPatch]? = nil
        if let recordPatchesContainer = recordPatchesContainer {
            recordPatchesDecoded0 = [CognitoSyncClientTypes.RecordPatch]()
            for structure0 in recordPatchesContainer {
                if let structure0 = structure0 {
                    recordPatchesDecoded0?.append(structure0)
                }
            }
        }
        recordPatches = recordPatchesDecoded0
        let syncSessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syncSessionToken)
        syncSessionToken = syncSessionTokenDecoded
    }
}

extension UpdateRecordsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecordsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionOutputException" : self = .invalidLambdaFunctionOutputException(try InvalidLambdaFunctionOutputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LambdaThrottledException" : self = .lambdaThrottledException(try LambdaThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecordsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidLambdaFunctionOutputException(InvalidLambdaFunctionOutputException)
    case invalidParameterException(InvalidParameterException)
    case lambdaThrottledException(LambdaThrottledException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecordsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecordsOutputResponse(records: \(Swift.String(describing: records)))"}
}

extension UpdateRecordsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRecordsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.records = output.records
        } else {
            self.records = nil
        }
    }
}

/// Returned for a successful
///       UpdateRecordsRequest.
public struct UpdateRecordsOutputResponse: Swift.Equatable {
    /// A list of records that have been
    ///       updated.
    public var records: [CognitoSyncClientTypes.Record]?

    public init (
        records: [CognitoSyncClientTypes.Record]? = nil
    )
    {
        self.records = records
    }
}

struct UpdateRecordsOutputResponseBody: Swift.Equatable {
    public let records: [CognitoSyncClientTypes.Record]?
}

extension UpdateRecordsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records = "Records"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([CognitoSyncClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[CognitoSyncClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [CognitoSyncClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}
