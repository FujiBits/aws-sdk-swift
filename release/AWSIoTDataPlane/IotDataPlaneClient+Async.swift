// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension IotDataPlaneClient {
    /// Deletes the shadow for the specified thing. Requires permission to access the [DeleteThingShadow](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action. For more information, see [DeleteThingShadow](http://docs.aws.amazon.com/iot/latest/developerguide/API_DeleteThingShadow.html) in the IoT Developer Guide.
    func deleteThingShadow(input: DeleteThingShadowInput) async throws -> DeleteThingShadowOutputResponse
    {
        typealias deleteThingShadowContinuation = CheckedContinuation<DeleteThingShadowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteThingShadowContinuation) in
            deleteThingShadow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the details of a single retained message for the specified topic. This action returns the message payload of the retained message, which can incur messaging costs. To list only the topic names of the retained messages, call [ListRetainedMessages]. Requires permission to access the [GetRetainedMessage](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiotfleethubfordevicemanagement.html#awsiotfleethubfordevicemanagement-actions-as-permissions) action. For more information about messaging costs, see [IoT Core pricing - Messaging](http://aws.amazon.com/iot-core/pricing/#Messaging).
    func getRetainedMessage(input: GetRetainedMessageInput) async throws -> GetRetainedMessageOutputResponse
    {
        typealias getRetainedMessageContinuation = CheckedContinuation<GetRetainedMessageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRetainedMessageContinuation) in
            getRetainedMessage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the shadow for the specified thing. Requires permission to access the [GetThingShadow](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action. For more information, see [GetThingShadow](http://docs.aws.amazon.com/iot/latest/developerguide/API_GetThingShadow.html) in the IoT Developer Guide.
    func getThingShadow(input: GetThingShadowInput) async throws -> GetThingShadowOutputResponse
    {
        typealias getThingShadowContinuation = CheckedContinuation<GetThingShadowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getThingShadowContinuation) in
            getThingShadow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the shadows for the specified thing. Requires permission to access the [ListNamedShadowsForThing](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
    func listNamedShadowsForThing(input: ListNamedShadowsForThingInput) async throws -> ListNamedShadowsForThingOutputResponse
    {
        typealias listNamedShadowsForThingContinuation = CheckedContinuation<ListNamedShadowsForThingOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listNamedShadowsForThingContinuation) in
            listNamedShadowsForThing(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists summary information about the retained messages stored for the account. This action returns only the topic names of the retained messages. It doesn't return any message payloads. Although this action doesn't return a message payload, it can still incur messaging costs. To get the message payload of a retained message, call [GetRetainedMessage](https://docs.aws.amazon.com/iot/latest/developerguide/API_iotdata_GetRetainedMessage.html) with the topic name of the retained message. Requires permission to access the [ListRetainedMessages](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiotfleethubfordevicemanagement.html#awsiotfleethubfordevicemanagement-actions-as-permissions) action. For more information about messaging costs, see [IoT Core pricing - Messaging](http://aws.amazon.com/iot-core/pricing/#Messaging).
    func listRetainedMessages(input: ListRetainedMessagesInput) async throws -> ListRetainedMessagesOutputResponse
    {
        typealias listRetainedMessagesContinuation = CheckedContinuation<ListRetainedMessagesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRetainedMessagesContinuation) in
            listRetainedMessages(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Publishes an MQTT message. Requires permission to access the [Publish](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action. For more information about MQTT messages, see [MQTT Protocol](http://docs.aws.amazon.com/iot/latest/developerguide/mqtt.html) in the IoT Developer Guide. For more information about messaging costs, see [IoT Core pricing - Messaging](http://aws.amazon.com/iot-core/pricing/#Messaging).
    func publish(input: PublishInput) async throws -> PublishOutputResponse
    {
        typealias publishContinuation = CheckedContinuation<PublishOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: publishContinuation) in
            publish(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the shadow for the specified thing. Requires permission to access the [UpdateThingShadow](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action. For more information, see [UpdateThingShadow](http://docs.aws.amazon.com/iot/latest/developerguide/API_UpdateThingShadow.html) in the IoT Developer Guide.
    func updateThingShadow(input: UpdateThingShadowInput) async throws -> UpdateThingShadowOutputResponse
    {
        typealias updateThingShadowContinuation = CheckedContinuation<UpdateThingShadowOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateThingShadowContinuation) in
            updateThingShadow(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
