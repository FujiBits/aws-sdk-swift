// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateTeamMemberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTeamMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTeamMemberOutputError>
}

extension AssociateTeamMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTeamMemberInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), projectId: \(Swift.String(describing: projectId)), projectRole: \(Swift.String(describing: projectRole)), remoteAccessAllowed: \(Swift.String(describing: remoteAccessAllowed)), userArn: \(Swift.String(describing: userArn)))"}
}

extension AssociateTeamMemberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if remoteAccessAllowed != false {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct AssociateTeamMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTeamMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTeamMemberOutputError>
}

public struct AssociateTeamMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTeamMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTeamMemberOutputError>
}

public struct AssociateTeamMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTeamMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateTeamMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTeamMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTeamMemberOutputError>
}

public struct AssociateTeamMemberInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested the team
    ///       member association to the project. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The ID of the project to which you will add the IAM user.
    /// This member is required.
    public var projectId: Swift.String?
    /// The AWS CodeStar project role that will apply to this user. This role determines what actions
    ///       a user can take in an AWS CodeStar project.
    /// This member is required.
    public var projectRole: Swift.String?
    /// Whether the team member is allowed to use an SSH public/private key pair to remotely
    ///       access project resources, for example Amazon EC2 instances.
    public var remoteAccessAllowed: Swift.Bool
    /// The Amazon Resource Name (ARN) for the IAM user you want to add to the AWS CodeStar
    ///       project.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool = false,
        userArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct AssociateTeamMemberInputBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let userArn: Swift.String?
    public let projectRole: Swift.String?
    public let remoteAccessAllowed: Swift.Bool
}

extension AssociateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension AssociateTeamMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTeamMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TeamMemberAlreadyAssociatedException" : self = .teamMemberAlreadyAssociatedException(try TeamMemberAlreadyAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTeamMemberOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case teamMemberAlreadyAssociatedException(TeamMemberAlreadyAssociatedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTeamMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTeamMemberOutputResponse(clientRequestToken: \(Swift.String(describing: clientRequestToken)))"}
}

extension AssociateTeamMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateTeamMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientRequestToken = output.clientRequestToken
        } else {
            self.clientRequestToken = nil
        }
    }
}

public struct AssociateTeamMemberOutputResponse: Swift.Equatable {
    /// The user- or system-generated token from the initial request that can be used to repeat
    ///       the request.
    public var clientRequestToken: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
    }
}

struct AssociateTeamMemberOutputResponseBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
}

extension AssociateTeamMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CodeStarClientTypes.Code: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeSource.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension CodeStarClientTypes.Code: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Code(destination: \(Swift.String(describing: destination)), source: \(Swift.String(describing: source)))"}
}

extension CodeStarClientTypes {
    /// Location and destination information about the source code files provided with the
    ///       project request. The source code is uploaded to the new project source repository after
    ///       project creation.
    public struct Code: Swift.Equatable {
        /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the
        ///       source code files provided with the project request are placed in the repository.
        /// This member is required.
        public var destination: CodeStarClientTypes.CodeDestination?
        /// The location where the source code files provided with the project request are
        ///       stored. AWS CodeStar retrieves the files during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.CodeSource?

        public init (
            destination: CodeStarClientTypes.CodeDestination? = nil,
            source: CodeStarClientTypes.CodeSource? = nil
        )
        {
            self.destination = destination
            self.source = source
        }
    }

}

extension CodeStarClientTypes.CodeCommitCodeDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeStarClientTypes.CodeCommitCodeDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeCommitCodeDestination(name: \(Swift.String(describing: name)))"}
}

extension CodeStarClientTypes {
    /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided
    ///       with the project request will be uploaded after project creation.
    public struct CodeCommitCodeDestination: Swift.Equatable {
        /// The name of the AWS CodeCommit repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CodeStarClientTypes.CodeDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeCommit
        case gitHub
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeCommit = codeCommit {
            try encodeContainer.encode(codeCommit, forKey: .codeCommit)
        }
        if let gitHub = gitHub {
            try encodeContainer.encode(gitHub, forKey: .gitHub)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeCommitDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.CodeCommitCodeDestination.self, forKey: .codeCommit)
        codeCommit = codeCommitDecoded
        let gitHubDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.GitHubCodeDestination.self, forKey: .gitHub)
        gitHub = gitHubDecoded
    }
}

extension CodeStarClientTypes.CodeDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeDestination(codeCommit: \(Swift.String(describing: codeCommit)), gitHub: \(Swift.String(describing: gitHub)))"}
}

extension CodeStarClientTypes {
    /// The repository to be created in AWS CodeStar. Valid values are AWS CodeCommit or GitHub. After AWS CodeStar provisions the new repository, the
    ///       source code files provided with the project request are placed in the repository.
    public struct CodeDestination: Swift.Equatable {
        /// Information about the AWS CodeCommit repository to be created in AWS CodeStar. This is where the source code files provided
        ///       with the project request will be uploaded after project creation.
        public var codeCommit: CodeStarClientTypes.CodeCommitCodeDestination?
        /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the
        ///       project request will be uploaded after project creation.
        public var gitHub: CodeStarClientTypes.GitHubCodeDestination?

        public init (
            codeCommit: CodeStarClientTypes.CodeCommitCodeDestination? = nil,
            gitHub: CodeStarClientTypes.GitHubCodeDestination? = nil
        )
        {
            self.codeCommit = codeCommit
            self.gitHub = gitHub
        }
    }

}

extension CodeStarClientTypes.CodeSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CodeStarClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeStarClientTypes.CodeSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeSource(s3: \(Swift.String(describing: s3)))"}
}

extension CodeStarClientTypes {
    /// The location where the source code files provided with the project request are
    ///       stored. AWS CodeStar retrieves the files during project creation.
    public struct CodeSource: Swift.Equatable {
        /// Information about the Amazon S3 location where the source code files provided with the
        ///       project request are stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init (
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another modification is being made. That modification must complete before you can make
///       your change.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), sourceCode: \(Swift.String(describing: sourceCode)), tags: \(Swift.String(describing: tags)), toolchain: \(Swift.String(describing: toolchain)))"}
}

extension CreateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceCode = sourceCode {
            var sourceCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCode)
            for sourcecode0 in sourceCode {
                try sourceCodeContainer.encode(sourcecode0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toolchain = toolchain {
            try encodeContainer.encode(toolchain, forKey: .toolchain)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested project
    ///       creation. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project to be created in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?
    /// The display name for the project to be created in AWS CodeStar.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Code objects submitted with the project request. If this
    ///       parameter is specified, the request must also include the toolchain parameter.
    public var sourceCode: [CodeStarClientTypes.Code]?
    /// The tags created for the project.
    public var tags: [Swift.String:Swift.String]?
    /// The name of the toolchain template file submitted with the project request. If
    ///       this parameter is specified, the request must also include the sourceCode parameter.
    public var toolchain: CodeStarClientTypes.Toolchain?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourceCode: [CodeStarClientTypes.Code]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        toolchain: CodeStarClientTypes.Toolchain? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.id = id
        self.name = name
        self.sourceCode = sourceCode
        self.tags = tags
        self.toolchain = toolchain
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let id: Swift.String?
    public let description: Swift.String?
    public let clientRequestToken: Swift.String?
    public let sourceCode: [CodeStarClientTypes.Code]?
    public let toolchain: CodeStarClientTypes.Toolchain?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case description
        case id
        case name
        case sourceCode
        case tags
        case toolchain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sourceCodeContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.Code?].self, forKey: .sourceCode)
        var sourceCodeDecoded0:[CodeStarClientTypes.Code]? = nil
        if let sourceCodeContainer = sourceCodeContainer {
            sourceCodeDecoded0 = [CodeStarClientTypes.Code]()
            for structure0 in sourceCodeContainer {
                if let structure0 = structure0 {
                    sourceCodeDecoded0?.append(structure0)
                }
            }
        }
        sourceCode = sourceCodeDecoded0
        let toolchainDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.Toolchain.self, forKey: .toolchain)
        toolchain = toolchainDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectAlreadyExistsException" : self = .projectAlreadyExistsException(try ProjectAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectCreationFailedException" : self = .projectCreationFailedException(try ProjectCreationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectAlreadyExistsException(ProjectAlreadyExistsException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectCreationFailedException(ProjectCreationFailedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), id: \(Swift.String(describing: id)), projectTemplateId: \(Swift.String(describing: projectTemplateId)))"}
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.id = output.id
            self.projectTemplateId = output.projectTemplateId
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.id = nil
            self.projectTemplateId = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created project.
    /// This member is required.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project
    ///       creation.
    public var clientRequestToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var projectTemplateId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        id: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.id = id
        self.projectTemplateId = projectTemplateId
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let arn: Swift.String?
    public let clientRequestToken: Swift.String?
    public let projectTemplateId: Swift.String?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case id
        case projectTemplateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
    }
}

public struct CreateUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

extension CreateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileInput(displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)))"}
}

extension CreateUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct CreateUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserProfileOutputError>
}

public struct CreateUserProfileInput: Swift.Equatable {
    /// The name that will be displayed as the friendly name for the user in AWS CodeStar.
    /// This member is required.
    public var displayName: Swift.String?
    /// The email address that will be displayed as part of the user's profile in
    ///       AWS CodeStar.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the
    ///       user remote access to project resources, this public key will be used along with the user's
    ///       private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileInputBody: Swift.Equatable {
    public let userArn: Swift.String?
    public let displayName: Swift.String?
    public let emailAddress: Swift.String?
    public let sshPublicKey: Swift.String?
}

extension CreateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CreateUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UserProfileAlreadyExistsException" : self = .userProfileAlreadyExistsException(try UserProfileAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserProfileOutputError: Swift.Error, Swift.Equatable {
    case userProfileAlreadyExistsException(UserProfileAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserProfileOutputResponse(createdTimestamp: \(Swift.String(describing: createdTimestamp)), displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)))"}
}

extension CreateUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct CreateUserProfileOutputResponse: Swift.Equatable {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the
    ///       public/private keypair the user can use to access project resources if a project owner allows
    ///       the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct CreateUserProfileOutputResponseBody: Swift.Equatable {
    public let userArn: Swift.String?
    public let displayName: Swift.String?
    public let emailAddress: Swift.String?
    public let sshPublicKey: Swift.String?
    public let createdTimestamp: ClientRuntime.Date?
    public let lastModifiedTimestamp: ClientRuntime.Date?
}

extension CreateUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

public struct DeleteProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

extension DeleteProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), deleteStack: \(Swift.String(describing: deleteStack)), id: \(Swift.String(describing: id)))"}
}

extension DeleteProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if deleteStack != false {
            try encodeContainer.encode(deleteStack, forKey: .deleteStack)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Swift.Equatable {
    /// A user- or system-generated token that identifies the entity that requested project
    ///       deletion. This token can be used to repeat the request.
    public var clientRequestToken: Swift.String?
    /// Whether to send a delete request for the primary stack in AWS CloudFormation originally
    ///       used to generate the project and its resources. This option will delete all AWS resources for
    ///       the project (except for any buckets in Amazon S3) as well as deleting the project itself.
    ///       Recommended for most use cases.
    public var deleteStack: Swift.Bool
    /// The ID of the project to be deleted in AWS CodeStar.
    /// This member is required.
    public var id: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        deleteStack: Swift.Bool = false,
        id: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.deleteStack = deleteStack
        self.id = id
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let clientRequestToken: Swift.String?
    public let deleteStack: Swift.Bool
}

extension DeleteProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case deleteStack
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let deleteStackDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteStack)
        deleteStack = deleteStackDecoded
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectOutputResponse(projectArn: \(Swift.String(describing: projectArn)), stackId: \(Swift.String(describing: stackId)))"}
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.stackId = output.stackId
        } else {
            self.projectArn = nil
            self.stackId = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted project.
    public var projectArn: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation that will be deleted as part of
    ///       deleting the project and its resources.
    public var stackId: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.stackId = stackId
    }
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
    public let stackId: Swift.String?
    public let projectArn: Swift.String?
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case stackId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

public struct DeleteUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

extension DeleteUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserProfileInput(userArn: \(Swift.String(describing: userArn)))"}
}

extension DeleteUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DeleteUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserProfileOutputError>
}

public struct DeleteUserProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user to delete from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileInputBody: Swift.Equatable {
    public let userArn: Swift.String?
}

extension DeleteUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserProfileOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserProfileOutputResponse(userArn: \(Swift.String(describing: userArn)))"}
}

extension DeleteUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct DeleteUserProfileOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user deleted from AWS CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DeleteUserProfileOutputResponseBody: Swift.Equatable {
    public let userArn: Swift.String?
}

extension DeleteUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

public struct DescribeProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

extension DescribeProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
    public let id: Swift.String?
}

extension DescribeProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutputResponse(arn: \(Swift.String(describing: arn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), projectTemplateId: \(Swift.String(describing: projectTemplateId)), stackId: \(Swift.String(describing: stackId)), status: \(Swift.String(describing: status)))"}
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.clientRequestToken = output.clientRequestToken
            self.createdTimeStamp = output.createdTimeStamp
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.projectTemplateId = output.projectTemplateId
            self.stackId = output.stackId
            self.status = output.status
        } else {
            self.arn = nil
            self.clientRequestToken = nil
            self.createdTimeStamp = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.projectTemplateId = nil
            self.stackId = nil
            self.status = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the project.
    public var arn: Swift.String?
    /// A user- or system-generated token that identifies the entity that requested project
    ///       creation.
    public var clientRequestToken: Swift.String?
    /// The date and time the project was created, in timestamp format.
    public var createdTimeStamp: ClientRuntime.Date?
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project.
    public var id: Swift.String?
    /// The display name for the project.
    public var name: Swift.String?
    /// The ID for the AWS CodeStar project template used to create the project.
    public var projectTemplateId: Swift.String?
    /// The ID of the primary stack in AWS CloudFormation used to generate resources for the
    ///       project.
    public var stackId: Swift.String?
    /// The project creation or deletion status.
    public var status: CodeStarClientTypes.ProjectStatus?

    public init (
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        createdTimeStamp: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        projectTemplateId: Swift.String? = nil,
        stackId: Swift.String? = nil,
        status: CodeStarClientTypes.ProjectStatus? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.createdTimeStamp = createdTimeStamp
        self.description = description
        self.id = id
        self.name = name
        self.projectTemplateId = projectTemplateId
        self.stackId = stackId
        self.status = status
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let id: Swift.String?
    public let arn: Swift.String?
    public let description: Swift.String?
    public let clientRequestToken: Swift.String?
    public let createdTimeStamp: ClientRuntime.Date?
    public let stackId: Swift.String?
    public let projectTemplateId: Swift.String?
    public let status: CodeStarClientTypes.ProjectStatus?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case createdTimeStamp
        case description
        case id
        case name
        case projectTemplateId
        case stackId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let projectTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectTemplateId)
        projectTemplateId = projectTemplateIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.ProjectStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfileOutputError>
}

extension DescribeUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfileInput(userArn: \(Swift.String(describing: userArn)))"}
}

extension DescribeUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DescribeUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfileOutputError>
}

public struct DescribeUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfileOutputError>
}

public struct DescribeUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserProfileOutputError>
}

public struct DescribeUserProfileInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct DescribeUserProfileInputBody: Swift.Equatable {
    public let userArn: Swift.String?
}

extension DescribeUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DescribeUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UserProfileNotFoundException" : self = .userProfileNotFoundException(try UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserProfileOutputError: Swift.Error, Swift.Equatable {
    case userProfileNotFoundException(UserProfileNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserProfileOutputResponse(createdTimestamp: \(Swift.String(describing: createdTimestamp)), displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)))"}
}

extension DescribeUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct DescribeUserProfileOutputResponse: Swift.Equatable {
    /// The date and time when the user profile was created in AWS CodeStar, in timestamp
    ///       format.
    /// This member is required.
    public var createdTimestamp: ClientRuntime.Date?
    /// The display name shown for the user in AWS CodeStar projects. For example, this could be set
    ///       to both first and last name ("Mary Major") or a single name ("Mary"). The display name is also
    ///       used to generate the initial icon associated with the user in AWS CodeStar projects. If spaces are
    ///       included in the display name, the first character that appears after the space will be used as
    ///       the second character in the user initial icon. The initial icon displays a maximum of two
    ///       characters, so a display name with more than one space (for example "Mary Jane Major") would
    ///       generate an initial icon using the first character and the first character after the space
    ///       ("MJ", not "MM").
    public var displayName: Swift.String?
    /// The email address for the user. Optional.
    public var emailAddress: Swift.String?
    /// The date and time when the user profile was last modified, in timestamp
    ///       format.
    /// This member is required.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user. This SSH public key is associated with the
    ///       user profile, and can be used in conjunction with the associated private key for access to
    ///       project resources, such as Amazon EC2 instances, if a project owner grants remote access to
    ///       those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct DescribeUserProfileOutputResponseBody: Swift.Equatable {
    public let userArn: Swift.String?
    public let displayName: Swift.String?
    public let emailAddress: Swift.String?
    public let sshPublicKey: Swift.String?
    public let createdTimestamp: ClientRuntime.Date?
    public let lastModifiedTimestamp: ClientRuntime.Date?
}

extension DescribeUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

public struct DisassociateTeamMemberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTeamMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTeamMemberOutputError>
}

extension DisassociateTeamMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTeamMemberInput(projectId: \(Swift.String(describing: projectId)), userArn: \(Swift.String(describing: userArn)))"}
}

extension DisassociateTeamMemberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct DisassociateTeamMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTeamMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTeamMemberOutputError>
}

public struct DisassociateTeamMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTeamMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTeamMemberOutputError>
}

public struct DisassociateTeamMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTeamMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateTeamMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTeamMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTeamMemberOutputError>
}

public struct DisassociateTeamMemberInput: Swift.Equatable {
    /// The ID of the AWS CodeStar project from which you want to remove a team member.
    /// This member is required.
    public var projectId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM user or group whom you want to remove from
    ///       the project.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        projectId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.userArn = userArn
    }
}

struct DisassociateTeamMemberInputBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let userArn: Swift.String?
}

extension DisassociateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DisassociateTeamMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTeamMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTeamMemberOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTeamMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTeamMemberOutputResponse()"}
}

extension DisassociateTeamMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTeamMemberOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateTeamMemberOutputResponseBody: Swift.Equatable {
}

extension DisassociateTeamMemberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case issuesEnabled
        case name
        case owner
        case privateRepository
        case token
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if issuesEnabled != false {
            try encodeContainer.encode(issuesEnabled, forKey: .issuesEnabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if privateRepository != false {
            try encodeContainer.encode(privateRepository, forKey: .privateRepository)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let privateRepositoryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .privateRepository)
        privateRepository = privateRepositoryDecoded
        let issuesEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .issuesEnabled)
        issuesEnabled = issuesEnabledDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension CodeStarClientTypes.GitHubCodeDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GitHubCodeDestination(description: \(Swift.String(describing: description)), issuesEnabled: \(Swift.String(describing: issuesEnabled)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), privateRepository: \(Swift.String(describing: privateRepository)), token: \(Swift.String(describing: token)), type: \(Swift.String(describing: type)))"}
}

extension CodeStarClientTypes {
    /// Information about the GitHub repository to be created in AWS CodeStar. This is where the source code files provided with the
    ///       project request will be uploaded after project creation.
    public struct GitHubCodeDestination: Swift.Equatable {
        /// Description for the GitHub repository to be created in AWS CodeStar. This description displays in
        ///       GitHub after the repository is created.
        public var description: Swift.String?
        /// Whether to enable issues for the GitHub repository.
        /// This member is required.
        public var issuesEnabled: Swift.Bool
        /// Name of the GitHub repository to be created in AWS CodeStar.
        /// This member is required.
        public var name: Swift.String?
        /// The GitHub username for the owner of the GitHub repository to be created in AWS CodeStar. If this repository should
        ///       be owned by a GitHub organization, provide its name.
        /// This member is required.
        public var owner: Swift.String?
        /// Whether the GitHub repository is to be a private repository.
        /// This member is required.
        public var privateRepository: Swift.Bool
        /// The GitHub user's personal access token for the GitHub repository.
        /// This member is required.
        public var token: Swift.String?
        /// The type of GitHub repository to be created in AWS CodeStar. Valid values are User or Organization.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            issuesEnabled: Swift.Bool = false,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            privateRepository: Swift.Bool = false,
            token: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.issuesEnabled = issuesEnabled
            self.name = name
            self.owner = owner
            self.privateRepository = privateRepository
            self.token = token
            self.type = type
        }
    }

}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The next token is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceRoleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidServiceRoleException(message: \(Swift.String(describing: message)))"}
}

extension InvalidServiceRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidServiceRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service role is not valid.
public struct InvalidServiceRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidServiceRoleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidServiceRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource limit has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListProjectsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProjectsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int
    /// The continuation token to be used to return the next set of results, if the results
    ///       cannot be returned in one response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListProjectsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), projects: \(Swift.String(describing: projects)))"}
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.
    public var nextToken: Swift.String?
    /// A list of projects.
    /// This member is required.
    public var projects: [CodeStarClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projects: [CodeStarClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    public let projects: [CodeStarClientTypes.ProjectSummary]?
    public let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[CodeStarClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [CodeStarClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension ListResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Swift.Equatable {
    /// The maximum amount of data that can be contained in a single set of results.
    public var maxResults: Swift.Int
    /// The continuation token for the next set of results, if the results cannot be returned
    ///       in one response.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.
    public var nextToken: Swift.String?
    /// An array of resources associated with the project.
    public var resources: [CodeStarClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [CodeStarClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [CodeStarClientTypes.Resource]?
    public let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[CodeStarClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [CodeStarClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForProjectOutputError>
}

extension ListTagsForProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForProjectInput(id: \(Swift.String(describing: id)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTagsForProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsForProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForProjectOutputError>
}

public struct ListTagsForProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForProjectOutputError>
}

public struct ListTagsForProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForProjectOutputError>
}

public struct ListTagsForProjectInput: Swift.Equatable {
    /// The ID of the project to get tags for.
    /// This member is required.
    public var id: Swift.String?
    /// Reserved for future use.
    public var maxResults: Swift.Int
    /// Reserved for future use.
    public var nextToken: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForProjectInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListTagsForProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForProjectOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForProjectOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForProjectOutputResponse: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForProjectOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
    public let nextToken: Swift.String?
}

extension ListTagsForProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTeamMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTeamMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTeamMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTeamMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTeamMembersOutputError>
}

extension ListTeamMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTeamMembersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension ListTeamMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }
}

public struct ListTeamMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTeamMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTeamMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTeamMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTeamMembersOutputError>
}

public struct ListTeamMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTeamMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTeamMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTeamMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTeamMembersOutputError>
}

public struct ListTeamMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTeamMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTeamMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTeamMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTeamMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTeamMembersOutputError>
}

public struct ListTeamMembersInput: Swift.Equatable {
    /// The maximum number of team members you want returned in a response.
    public var maxResults: Swift.Int
    /// The continuation token for the next set of results, if the results cannot be returned
    ///       in one response.
    public var nextToken: Swift.String?
    /// The ID of the project for which you want to list team members.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListTeamMembersInputBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListTeamMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTeamMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTeamMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTeamMembersOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTeamMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTeamMembersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), teamMembers: \(Swift.String(describing: teamMembers)))"}
}

extension ListTeamMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTeamMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.teamMembers = output.teamMembers
        } else {
            self.nextToken = nil
            self.teamMembers = nil
        }
    }
}

public struct ListTeamMembersOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.
    public var nextToken: Swift.String?
    /// A list of team member objects for the project.
    /// This member is required.
    public var teamMembers: [CodeStarClientTypes.TeamMember]?

    public init (
        nextToken: Swift.String? = nil,
        teamMembers: [CodeStarClientTypes.TeamMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.teamMembers = teamMembers
    }
}

struct ListTeamMembersOutputResponseBody: Swift.Equatable {
    public let teamMembers: [CodeStarClientTypes.TeamMember]?
    public let nextToken: Swift.String?
}

extension ListTeamMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case teamMembers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamMembersContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.TeamMember?].self, forKey: .teamMembers)
        var teamMembersDecoded0:[CodeStarClientTypes.TeamMember]? = nil
        if let teamMembersContainer = teamMembersContainer {
            teamMembersDecoded0 = [CodeStarClientTypes.TeamMember]()
            for structure0 in teamMembersContainer {
                if let structure0 = structure0 {
                    teamMembersDecoded0?.append(structure0)
                }
            }
        }
        teamMembers = teamMembersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListUserProfilesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserProfilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUserProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUserProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserProfilesOutputError>
}

extension ListUserProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUserProfilesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUserProfilesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListUserProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUserProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUserProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserProfilesOutputError>
}

public struct ListUserProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUserProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUserProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserProfilesOutputError>
}

public struct ListUserProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserProfilesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListUserProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUserProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserProfilesOutputError>
}

public struct ListUserProfilesInput: Swift.Equatable {
    /// The maximum number of results to return in a response.
    public var maxResults: Swift.Int
    /// The continuation token for the next set of results, if the results cannot be returned
    ///       in one response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserProfilesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int
}

extension ListUserProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUserProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserProfilesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUserProfilesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), userProfiles: \(Swift.String(describing: userProfiles)))"}
}

extension ListUserProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUserProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userProfiles = output.userProfiles
        } else {
            self.nextToken = nil
            self.userProfiles = nil
        }
    }
}

public struct ListUserProfilesOutputResponse: Swift.Equatable {
    /// The continuation token to use when requesting the next set of results, if there are
    ///       more results to be returned.
    public var nextToken: Swift.String?
    /// All the user profiles configured in AWS CodeStar for an AWS account.
    /// This member is required.
    public var userProfiles: [CodeStarClientTypes.UserProfileSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userProfiles: [CodeStarClientTypes.UserProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userProfiles = userProfiles
    }
}

struct ListUserProfilesOutputResponseBody: Swift.Equatable {
    public let userProfiles: [CodeStarClientTypes.UserProfileSummary]?
    public let nextToken: Swift.String?
}

extension ListUserProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userProfiles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userProfilesContainer = try containerValues.decodeIfPresent([CodeStarClientTypes.UserProfileSummary?].self, forKey: .userProfiles)
        var userProfilesDecoded0:[CodeStarClientTypes.UserProfileSummary]? = nil
        if let userProfilesContainer = userProfilesContainer {
            userProfilesDecoded0 = [CodeStarClientTypes.UserProfileSummary]()
            for structure0 in userProfilesContainer {
                if let structure0 = structure0 {
                    userProfilesDecoded0?.append(structure0)
                }
            }
        }
        userProfiles = userProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ProjectAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ProjectAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProjectAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An AWS CodeStar project with the same ID already exists in this region for the AWS account.
///       AWS CodeStar project IDs must be unique within a region for the AWS account.
public struct ProjectAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProjectAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectConfigurationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectConfigurationException(message: \(Swift.String(describing: message)))"}
}

extension ProjectConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProjectConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Project configuration information is required but not specified.
public struct ProjectConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectConfigurationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProjectConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectCreationFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectCreationFailedException(message: \(Swift.String(describing: message)))"}
}

extension ProjectCreationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProjectCreationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The project creation request was valid, but a nonspecific exception or error occurred
///       during project creation. The project could not be created in AWS CodeStar.
public struct ProjectCreationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectCreationFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProjectCreationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProjectNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ProjectNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProjectNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified AWS CodeStar project was not found.
public struct ProjectNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProjectNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProjectNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.ProjectStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodeStarClientTypes.ProjectStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectStatus(reason: \(Swift.String(describing: reason)), state: \(Swift.String(describing: state)))"}
}

extension CodeStarClientTypes {
    /// An indication of whether a project creation or deletion is failed or
    ///       successful.
    public struct ProjectStatus: Swift.Equatable {
        /// In the case of a project creation or deletion failure, a reason for the
        ///       failure.
        public var reason: Swift.String?
        /// The phase of completion for a project creation or deletion.
        /// This member is required.
        public var state: Swift.String?

        public init (
            reason: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.reason = reason
            self.state = state
        }
    }

}

extension CodeStarClientTypes.ProjectSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension CodeStarClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(projectArn: \(Swift.String(describing: projectArn)), projectId: \(Swift.String(describing: projectId)))"}
}

extension CodeStarClientTypes {
    /// Information about the metadata for a project.
    public struct ProjectSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the project.
        public var projectArn: Swift.String?
        /// The ID of the project.
        public var projectId: Swift.String?

        public init (
            projectArn: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.projectArn = projectArn
            self.projectId = projectId
        }
    }

}

extension CodeStarClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CodeStarClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(id: \(Swift.String(describing: id)))"}
}

extension CodeStarClientTypes {
    /// Information about a resource for a project.
    public struct Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension CodeStarClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketKey
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketKey = bucketKey {
            try encodeContainer.encode(bucketKey, forKey: .bucketKey)
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketKey)
        bucketKey = bucketKeyDecoded
    }
}

extension CodeStarClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(bucketKey: \(Swift.String(describing: bucketKey)), bucketName: \(Swift.String(describing: bucketName)))"}
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the source code files provided with the project
    ///       request are stored.
    public struct S3Location: Swift.Equatable {
        /// The Amazon S3 object key where the source code files provided with the project
        ///       request are stored.
        public var bucketKey: Swift.String?
        /// The Amazon S3 bucket name where the source code files provided with the project
        ///       request are stored.
        public var bucketName: Swift.String?

        public init (
            bucketKey: Swift.String? = nil,
            bucketName: Swift.String? = nil
        )
        {
            self.bucketKey = bucketKey
            self.bucketName = bucketName
        }
    }

}

public struct TagProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagProjectOutputError>
}

extension TagProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagProjectInput(id: \(Swift.String(describing: id)), tags: \(Swift.String(describing: tags)))"}
}

extension TagProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagProjectOutputError>
}

public struct TagProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagProjectOutputError>
}

public struct TagProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagProjectOutputError>
}

public struct TagProjectInput: Swift.Equatable {
    /// The ID of the project you want to add a tag to.
    /// This member is required.
    public var id: Swift.String?
    /// The tags you want to add to the project.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct TagProjectInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension TagProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagProjectOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension TagProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagProjectOutputResponse: Swift.Equatable {
    /// The tags for the project.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagProjectOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeStarClientTypes.TeamMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectRole = projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if remoteAccessAllowed != false {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension CodeStarClientTypes.TeamMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TeamMember(projectRole: \(Swift.String(describing: projectRole)), remoteAccessAllowed: \(Swift.String(describing: remoteAccessAllowed)), userArn: \(Swift.String(describing: userArn)))"}
}

extension CodeStarClientTypes {
    /// Information about a team member in a project.
    public struct TeamMember: Swift.Equatable {
        /// The role assigned to the user in the project. Project roles have different levels of
        ///       access. For more information, see <a href="http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html">Working with
        ///         Teams in the AWS CodeStar User Guide.
        /// This member is required.
        public var projectRole: Swift.String?
        /// Whether the user is allowed to remotely access project resources using an SSH
        ///       public/private key pair.
        public var remoteAccessAllowed: Swift.Bool
        /// The Amazon Resource Name (ARN) of the user in IAM.
        /// This member is required.
        public var userArn: Swift.String?

        public init (
            projectRole: Swift.String? = nil,
            remoteAccessAllowed: Swift.Bool = false,
            userArn: Swift.String? = nil
        )
        {
            self.projectRole = projectRole
            self.remoteAccessAllowed = remoteAccessAllowed
            self.userArn = userArn
        }
    }

}

extension TeamMemberAlreadyAssociatedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TeamMemberAlreadyAssociatedException(message: \(Swift.String(describing: message)))"}
}

extension TeamMemberAlreadyAssociatedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TeamMemberAlreadyAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The team member is already associated with a role in this project.
public struct TeamMemberAlreadyAssociatedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TeamMemberAlreadyAssociatedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TeamMemberAlreadyAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TeamMemberNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TeamMemberNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension TeamMemberNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TeamMemberNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified team member was not found.
public struct TeamMemberNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TeamMemberNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TeamMemberNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.Toolchain: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case source
        case stackParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let stackParameters = stackParameters {
            var stackParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stackParameters)
            for (dictKey0, templateparametermap0) in stackParameters {
                try stackParametersContainer.encode(templateparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(CodeStarClientTypes.ToolchainSource.self, forKey: .source)
        source = sourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stackParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stackParameters)
        var stackParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let stackParametersContainer = stackParametersContainer {
            stackParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templateparametervalue0) in stackParametersContainer {
                if let templateparametervalue0 = templateparametervalue0 {
                    stackParametersDecoded0?[key0] = templateparametervalue0
                }
            }
        }
        stackParameters = stackParametersDecoded0
    }
}

extension CodeStarClientTypes.Toolchain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Toolchain(roleArn: \(Swift.String(describing: roleArn)), source: \(Swift.String(describing: source)), stackParameters: \(Swift.String(describing: stackParameters)))"}
}

extension CodeStarClientTypes {
    /// The toolchain template file provided with the project request. AWS CodeStar uses
    ///       the template to provision the toolchain stack in AWS CloudFormation.
    public struct Toolchain: Swift.Equatable {
        /// The service role ARN for AWS CodeStar to use for the toolchain template during stack
        ///       provisioning.
        public var roleArn: Swift.String?
        /// The Amazon S3 location where the toolchain template file provided with the
        ///       project request is stored. AWS CodeStar retrieves the file during project creation.
        /// This member is required.
        public var source: CodeStarClientTypes.ToolchainSource?
        /// The list of parameter overrides to be passed into the toolchain template during stack
        ///       provisioning, if any.
        public var stackParameters: [Swift.String:Swift.String]?

        public init (
            roleArn: Swift.String? = nil,
            source: CodeStarClientTypes.ToolchainSource? = nil,
            stackParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.source = source
            self.stackParameters = stackParameters
        }
    }

}

extension CodeStarClientTypes.ToolchainSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CodeStarClientTypes.S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CodeStarClientTypes.ToolchainSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ToolchainSource(s3: \(Swift.String(describing: s3)))"}
}

extension CodeStarClientTypes {
    /// The Amazon S3 location where the toolchain template file provided with the
    ///       project request is stored. AWS CodeStar retrieves the file during project creation.
    public struct ToolchainSource: Swift.Equatable {
        /// The Amazon S3 bucket where the toolchain template file provided with the project
        ///       request is stored.
        /// This member is required.
        public var s3: CodeStarClientTypes.S3Location?

        public init (
            s3: CodeStarClientTypes.S3Location? = nil
        )
        {
            self.s3 = s3
        }
    }

}

public struct UntagProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagProjectOutputError>
}

extension UntagProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagProjectInput(id: \(Swift.String(describing: id)), tags: \(Swift.String(describing: tags)))"}
}

extension UntagProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagkeys0 in tags {
                try tagsContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagProjectOutputError>
}

public struct UntagProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagProjectOutputError>
}

public struct UntagProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagProjectOutputError>
}

public struct UntagProjectInput: Swift.Equatable {
    /// The ID of the project to remove tags from.
    /// This member is required.
    public var id: Swift.String?
    /// The tags to remove from the project.
    /// This member is required.
    public var tags: [Swift.String]?

    public init (
        id: Swift.String? = nil,
        tags: [Swift.String]? = nil
    )
    {
        self.id = id
        self.tags = tags
    }
}

struct UntagProjectInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let tags: [Swift.String]?
}

extension UntagProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UntagProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagProjectOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagProjectOutputResponse()"}
}

extension UntagProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagProjectOutputResponseBody: Swift.Equatable {
}

extension UntagProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension UpdateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Swift.Equatable {
    /// The description of the project, if any.
    public var description: Swift.String?
    /// The ID of the project you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the project you want to update.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case projectNotFoundException(ProjectNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutputResponse()"}
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateTeamMemberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTeamMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTeamMemberOutputError>
}

extension UpdateTeamMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTeamMemberInput(projectId: \(Swift.String(describing: projectId)), projectRole: \(Swift.String(describing: projectRole)), remoteAccessAllowed: \(Swift.String(describing: remoteAccessAllowed)), userArn: \(Swift.String(describing: userArn)))"}
}

extension UpdateTeamMemberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let projectRole = projectRole {
            try encodeContainer.encode(projectRole, forKey: .projectRole)
        }
        if remoteAccessAllowed != false {
            try encodeContainer.encode(remoteAccessAllowed, forKey: .remoteAccessAllowed)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct UpdateTeamMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTeamMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTeamMemberOutputError>
}

public struct UpdateTeamMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTeamMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTeamMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTeamMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTeamMemberOutputError>
}

public struct UpdateTeamMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTeamMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateTeamMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTeamMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTeamMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTeamMemberOutputError>
}

public struct UpdateTeamMemberInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The role assigned to the user in the project. Project roles have different levels of
    ///       access. For more information, see <a href="http://docs.aws.amazon.com/codestar/latest/userguide/working-with-teams.html">Working with
    ///         Teams in the AWS CodeStar User Guide.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH
    ///       public key associated with the user's profile. Even if this is set to True, the user must
    ///       associate a public key with their profile before the user can access resources.
    public var remoteAccessAllowed: Swift.Bool
    /// The Amazon Resource Name (ARN) of the user for whom you want to change team membership
    ///       attributes.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        projectId: Swift.String? = nil,
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool = false,
        userArn: Swift.String? = nil
    )
    {
        self.projectId = projectId
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberInputBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let userArn: Swift.String?
    public let projectRole: Swift.String?
    public let remoteAccessAllowed: Swift.Bool
}

extension UpdateTeamMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectId
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

extension UpdateTeamMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTeamMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceRoleException" : self = .invalidServiceRoleException(try InvalidServiceRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectConfigurationException" : self = .projectConfigurationException(try ProjectConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProjectNotFoundException" : self = .projectNotFoundException(try ProjectNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TeamMemberNotFoundException" : self = .teamMemberNotFoundException(try TeamMemberNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTeamMemberOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidServiceRoleException(InvalidServiceRoleException)
    case limitExceededException(LimitExceededException)
    case projectConfigurationException(ProjectConfigurationException)
    case projectNotFoundException(ProjectNotFoundException)
    case teamMemberNotFoundException(TeamMemberNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTeamMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTeamMemberOutputResponse(projectRole: \(Swift.String(describing: projectRole)), remoteAccessAllowed: \(Swift.String(describing: remoteAccessAllowed)), userArn: \(Swift.String(describing: userArn)))"}
}

extension UpdateTeamMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTeamMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectRole = output.projectRole
            self.remoteAccessAllowed = output.remoteAccessAllowed
            self.userArn = output.userArn
        } else {
            self.projectRole = nil
            self.remoteAccessAllowed = false
            self.userArn = nil
        }
    }
}

public struct UpdateTeamMemberOutputResponse: Swift.Equatable {
    /// The project role granted to the user.
    public var projectRole: Swift.String?
    /// Whether a team member is allowed to remotely access project resources using the SSH
    ///       public key associated with the user's profile.
    public var remoteAccessAllowed: Swift.Bool
    /// The Amazon Resource Name (ARN) of the user whose team membership attributes were
    ///       updated.
    public var userArn: Swift.String?

    public init (
        projectRole: Swift.String? = nil,
        remoteAccessAllowed: Swift.Bool = false,
        userArn: Swift.String? = nil
    )
    {
        self.projectRole = projectRole
        self.remoteAccessAllowed = remoteAccessAllowed
        self.userArn = userArn
    }
}

struct UpdateTeamMemberOutputResponseBody: Swift.Equatable {
    public let userArn: Swift.String?
    public let projectRole: Swift.String?
    public let remoteAccessAllowed: Swift.Bool
}

extension UpdateTeamMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectRole
        case remoteAccessAllowed
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let projectRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectRole)
        projectRole = projectRoleDecoded
        let remoteAccessAllowedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .remoteAccessAllowed)
        remoteAccessAllowed = remoteAccessAllowedDecoded
    }
}

public struct UpdateUserProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

extension UpdateUserProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileInput(displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)))"}
}

extension UpdateUserProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

public struct UpdateUserProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateUserProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserProfileOutputError>
}

public struct UpdateUserProfileInput: Swift.Equatable {
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS
    ///       CodeStar.
    public var emailAddress: Swift.String?
    /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the
    ///       user remote access to project resources, this public key will be used along with the user's
    ///       private key for SSH access.
    public var sshPublicKey: Swift.String?
    /// The name that will be displayed as the friendly name for the user in AWS
    ///       CodeStar.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileInputBody: Swift.Equatable {
    public let userArn: Swift.String?
    public let displayName: Swift.String?
    public let emailAddress: Swift.String?
    public let sshPublicKey: Swift.String?
}

extension UpdateUserProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension UpdateUserProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UserProfileNotFoundException" : self = .userProfileNotFoundException(try UserProfileNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserProfileOutputError: Swift.Error, Swift.Equatable {
    case userProfileNotFoundException(UserProfileNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserProfileOutputResponse(createdTimestamp: \(Swift.String(describing: createdTimestamp)), displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)))"}
}

extension UpdateUserProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.displayName = output.displayName
            self.emailAddress = output.emailAddress
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.sshPublicKey = output.sshPublicKey
            self.userArn = output.userArn
        } else {
            self.createdTimestamp = nil
            self.displayName = nil
            self.emailAddress = nil
            self.lastModifiedTimestamp = nil
            self.sshPublicKey = nil
            self.userArn = nil
        }
    }
}

public struct UpdateUserProfileOutputResponse: Swift.Equatable {
    /// The date the user profile was created, in timestamp format.
    public var createdTimestamp: ClientRuntime.Date?
    /// The name that is displayed as the friendly name for the user in AWS CodeStar.
    public var displayName: Swift.String?
    /// The email address that is displayed as part of the user's profile in AWS
    ///       CodeStar.
    public var emailAddress: Swift.String?
    /// The date the user profile was last modified, in timestamp format.
    public var lastModifiedTimestamp: ClientRuntime.Date?
    /// The SSH public key associated with the user in AWS CodeStar. This is the public portion of the
    ///       public/private keypair the user can use to access project resources if a project owner allows
    ///       the user remote access to those resources.
    public var sshPublicKey: Swift.String?
    /// The Amazon Resource Name (ARN) of the user in IAM.
    /// This member is required.
    public var userArn: Swift.String?

    public init (
        createdTimestamp: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        lastModifiedTimestamp: ClientRuntime.Date? = nil,
        sshPublicKey: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.sshPublicKey = sshPublicKey
        self.userArn = userArn
    }
}

struct UpdateUserProfileOutputResponseBody: Swift.Equatable {
    public let userArn: Swift.String?
    public let displayName: Swift.String?
    public let emailAddress: Swift.String?
    public let sshPublicKey: Swift.String?
    public let createdTimestamp: ClientRuntime.Date?
    public let lastModifiedTimestamp: ClientRuntime.Date?
}

extension UpdateUserProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp
        case displayName
        case emailAddress
        case lastModifiedTimestamp
        case sshPublicKey
        case userArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
    }
}

extension UserProfileAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfileAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension UserProfileAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UserProfileAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A user profile with that name already exists in this region for the AWS account. AWS
///       CodeStar user profile names must be unique within a region for the AWS account.
public struct UserProfileAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserProfileAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UserProfileAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UserProfileNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfileNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension UserProfileNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UserProfileNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user profile was not found.
public struct UserProfileNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UserProfileNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UserProfileNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case emailAddress
        case sshPublicKey
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let sshPublicKey = sshPublicKey {
            try encodeContainer.encode(sshPublicKey, forKey: .sshPublicKey)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
    }
}

extension CodeStarClientTypes.UserProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserProfileSummary(displayName: \(Swift.String(describing: displayName)), emailAddress: \(Swift.String(describing: emailAddress)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), userArn: \(Swift.String(describing: userArn)))"}
}

extension CodeStarClientTypes {
    /// Information about a user's profile in AWS CodeStar.
    public struct UserProfileSummary: Swift.Equatable {
        /// The display name of a user in AWS CodeStar. For example, this could be set to both first and
        ///       last name ("Mary Major") or a single name ("Mary"). The display name is also used to generate
        ///       the initial icon associated with the user in AWS CodeStar projects. If spaces are included in the
        ///       display name, the first character that appears after the space will be used as the second
        ///       character in the user initial icon. The initial icon displays a maximum of two characters, so
        ///       a display name with more than one space (for example "Mary Jane Major") would generate an
        ///       initial icon using the first character and the first character after the space ("MJ", not
        ///       "MM").
        public var displayName: Swift.String?
        /// The email address associated with the user.
        public var emailAddress: Swift.String?
        /// The SSH public key associated with the user in AWS CodeStar. If a project owner allows the
        ///       user remote access to project resources, this public key will be used along with the user's
        ///       private key for SSH access.
        public var sshPublicKey: Swift.String?
        /// The Amazon Resource Name (ARN) of the user in IAM.
        public var userArn: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            sshPublicKey: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.sshPublicKey = sshPublicKey
            self.userArn = userArn
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified input is either not valid, or it could not be validated.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
