// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ALPNPolicyNotSupportedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ALPNPolicyNotSupportedException(message: \(Swift.String(describing: message)))"}
}

extension ALPNPolicyNotSupportedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ALPNPolicyNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified ALPN policy is not supported.</p>
public struct ALPNPolicyNotSupportedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ALPNPolicyNotSupportedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ALPNPolicyNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticateCognitoConfig = "AuthenticateCognitoConfig"
        case authenticateOidcConfig = "AuthenticateOidcConfig"
        case fixedResponseConfig = "FixedResponseConfig"
        case forwardConfig = "ForwardConfig"
        case order = "Order"
        case redirectConfig = "RedirectConfig"
        case targetGroupArn = "TargetGroupArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticateCognitoConfig = authenticateCognitoConfig {
            try container.encode(authenticateCognitoConfig, forKey: ClientRuntime.Key("AuthenticateCognitoConfig"))
        }
        if let authenticateOidcConfig = authenticateOidcConfig {
            try container.encode(authenticateOidcConfig, forKey: ClientRuntime.Key("AuthenticateOidcConfig"))
        }
        if let fixedResponseConfig = fixedResponseConfig {
            try container.encode(fixedResponseConfig, forKey: ClientRuntime.Key("FixedResponseConfig"))
        }
        if let forwardConfig = forwardConfig {
            try container.encode(forwardConfig, forKey: ClientRuntime.Key("ForwardConfig"))
        }
        if let order = order {
            try container.encode(order, forKey: ClientRuntime.Key("Order"))
        }
        if let redirectConfig = redirectConfig {
            try container.encode(redirectConfig, forKey: ClientRuntime.Key("RedirectConfig"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.ActionTypeEnum.self, forKey: .type)
        type = typeDecoded
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let authenticateOidcConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConfig.self, forKey: .authenticateOidcConfig)
        authenticateOidcConfig = authenticateOidcConfigDecoded
        let authenticateCognitoConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConfig.self, forKey: .authenticateCognitoConfig)
        authenticateCognitoConfig = authenticateCognitoConfigDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let redirectConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.RedirectActionConfig.self, forKey: .redirectConfig)
        redirectConfig = redirectConfigDecoded
        let fixedResponseConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.FixedResponseActionConfig.self, forKey: .fixedResponseConfig)
        fixedResponseConfig = fixedResponseConfigDecoded
        let forwardConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.ForwardActionConfig.self, forKey: .forwardConfig)
        forwardConfig = forwardConfigDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Action(authenticateCognitoConfig: \(Swift.String(describing: authenticateCognitoConfig)), authenticateOidcConfig: \(Swift.String(describing: authenticateOidcConfig)), fixedResponseConfig: \(Swift.String(describing: fixedResponseConfig)), forwardConfig: \(Swift.String(describing: forwardConfig)), order: \(Swift.String(describing: order)), redirectConfig: \(Swift.String(describing: redirectConfig)), targetGroupArn: \(Swift.String(describing: targetGroupArn)), type: \(Swift.String(describing: type)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an action.</p>
    ///          <p>Each rule must include exactly one of the following types of actions:
    ///       <code>forward</code>, <code>fixed-response</code>, or <code>redirect</code>, and it must be
    ///       the last action to be performed.</p>
    public struct Action: Swift.Equatable {
        /// <p>[HTTPS listeners] Information for using Amazon Cognito to authenticate users. Specify only
        ///       when <code>Type</code> is <code>authenticate-cognito</code>.</p>
        public let authenticateCognitoConfig: ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConfig?
        /// <p>[HTTPS listeners] Information about an identity provider that is compliant with OpenID
        ///       Connect (OIDC). Specify only when <code>Type</code> is <code>authenticate-oidc</code>.</p>
        public let authenticateOidcConfig: ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConfig?
        /// <p>[Application Load Balancer] Information for creating an action that returns a custom HTTP
        ///       response. Specify only when <code>Type</code> is <code>fixed-response</code>.</p>
        public let fixedResponseConfig: ElasticLoadBalancingV2ClientTypes.FixedResponseActionConfig?
        /// <p>Information for creating an action that distributes requests among one or more target
        ///       groups. For Network Load Balancers, you can specify a single target group. Specify only when
        ///         <code>Type</code> is <code>forward</code>. If you specify both <code>ForwardConfig</code>
        ///       and <code>TargetGroupArn</code>, you can specify only one target group using
        ///         <code>ForwardConfig</code> and it must be the same target group specified in
        ///         <code>TargetGroupArn</code>.</p>
        public let forwardConfig: ElasticLoadBalancingV2ClientTypes.ForwardActionConfig?
        /// <p>The order for the action. This value is required for rules with multiple actions. The
        ///       action with the lowest value for order is performed first.</p>
        public let order: Swift.Int?
        /// <p>[Application Load Balancer] Information for creating a redirect action. Specify only when
        ///         <code>Type</code> is <code>redirect</code>.</p>
        public let redirectConfig: ElasticLoadBalancingV2ClientTypes.RedirectActionConfig?
        /// <p>The Amazon Resource Name (ARN) of the target group. Specify only when <code>Type</code> is
        ///         <code>forward</code> and you want to route to a single target group. To route to one or more
        ///       target groups, use <code>ForwardConfig</code> instead.</p>
        public let targetGroupArn: Swift.String?
        /// <p>The type of action.</p>
        public let type: ElasticLoadBalancingV2ClientTypes.ActionTypeEnum?

        public init (
            authenticateCognitoConfig: ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConfig? = nil,
            authenticateOidcConfig: ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConfig? = nil,
            fixedResponseConfig: ElasticLoadBalancingV2ClientTypes.FixedResponseActionConfig? = nil,
            forwardConfig: ElasticLoadBalancingV2ClientTypes.ForwardActionConfig? = nil,
            order: Swift.Int? = nil,
            redirectConfig: ElasticLoadBalancingV2ClientTypes.RedirectActionConfig? = nil,
            targetGroupArn: Swift.String? = nil,
            type: ElasticLoadBalancingV2ClientTypes.ActionTypeEnum? = nil
        )
        {
            self.authenticateCognitoConfig = authenticateCognitoConfig
            self.authenticateOidcConfig = authenticateOidcConfig
            self.fixedResponseConfig = fixedResponseConfig
            self.forwardConfig = forwardConfig
            self.order = order
            self.redirectConfig = redirectConfig
            self.targetGroupArn = targetGroupArn
            self.type = type
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes {
    public enum ActionTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authenticateCognito
        case authenticateOidc
        case fixedResponse
        case forward
        case redirect
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionTypeEnum] {
            return [
                .authenticateCognito,
                .authenticateOidc,
                .fixedResponse,
                .forward,
                .redirect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authenticateCognito: return "authenticate-cognito"
            case .authenticateOidc: return "authenticate-oidc"
            case .fixedResponse: return "fixed-response"
            case .forward: return "forward"
            case .redirect: return "redirect"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionTypeEnum(rawValue: rawValue) ?? ActionTypeEnum.sdkUnknown(rawValue)
        }
    }
}

public struct AddListenerCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddListenerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddListenerCertificatesOutputError>
}

extension AddListenerCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddListenerCertificatesInput(certificates: \(Swift.String(describing: certificates)), listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension AddListenerCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        try container.encode("AddListenerCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddListenerCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddListenerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddListenerCertificatesOutputError>
}

public struct AddListenerCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddListenerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddListenerCertificatesOutputError>
}

public struct AddListenerCertificatesInput: Swift.Equatable {
    /// <p>The certificate to add. You can specify one certificate per call. Set
    ///         <code>CertificateArn</code> to the certificate ARN but do not set
    ///       <code>IsDefault</code>.</p>
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?

    public init (
        certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil,
        listenerArn: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.listenerArn = listenerArn
    }
}

extension AddListenerCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddListenerCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificatesException" : self = .tooManyCertificatesException(try TooManyCertificatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddListenerCertificatesOutputError: Swift.Error, Swift.Equatable {
    case certificateNotFoundException(CertificateNotFoundException)
    case listenerNotFoundException(ListenerNotFoundException)
    case tooManyCertificatesException(TooManyCertificatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddListenerCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddListenerCertificatesOutputResponse(certificates: \(Swift.String(describing: certificates)))"}
}

extension AddListenerCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddListenerCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
        } else {
            self.certificates = nil
        }
    }
}

public struct AddListenerCertificatesOutputResponse: Swift.Equatable {
    /// <p>Information about the certificates in the certificate list.</p>
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?

    public init (
        certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil
    )
    {
        self.certificates = certificates
    }
}

struct AddListenerCertificatesOutputResponseBody: Swift.Equatable {
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
}

extension AddListenerCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AddListenerCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Certificate].self, forKey: .member)
                var certificatesBuffer:[ElasticLoadBalancingV2ClientTypes.Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [ElasticLoadBalancingV2ClientTypes.Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
    }
}

public struct AddTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsOutputError>
}

extension AddTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsInput(resourceArns: \(Swift.String(describing: resourceArns)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
            for (index0, resourcearn0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcearn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsOutputError>
}

public struct AddTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsOutputError>
}

public struct AddTagsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArns: [Swift.String]?
    /// <p>The tags.</p>
    public let tags: [ElasticLoadBalancingV2ClientTypes.Tag]?

    public init (
        resourceArns: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArns = resourceArns
        self.tags = tags
    }
}

extension AddTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Swift.Error, Swift.Equatable {
    case duplicateTagKeysException(DuplicateTagKeysException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsOutputResponse()"}
}

extension AddTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsOutputResponseBody: Swift.Equatable {
}

extension AddTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AllocationIdNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllocationIdNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension AllocationIdNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AllocationIdNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified allocation ID does not exist.</p>
public struct AllocationIdNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AllocationIdNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AllocationIdNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum AuthenticateCognitoActionConditionalBehaviorEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case authenticate
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticateCognitoActionConditionalBehaviorEnum] {
            return [
                .allow,
                .authenticate,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "allow"
            case .authenticate: return "authenticate"
            case .deny: return "deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticateCognitoActionConditionalBehaviorEnum(rawValue: rawValue) ?? AuthenticateCognitoActionConditionalBehaviorEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationRequestExtraParams = "AuthenticationRequestExtraParams"
        case onUnauthenticatedRequest = "OnUnauthenticatedRequest"
        case scope = "Scope"
        case sessionCookieName = "SessionCookieName"
        case sessionTimeout = "SessionTimeout"
        case userPoolArn = "UserPoolArn"
        case userPoolClientId = "UserPoolClientId"
        case userPoolDomain = "UserPoolDomain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationRequestExtraParams = authenticationRequestExtraParams {
            var authenticationRequestExtraParamsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AuthenticationRequestExtraParams"))
            for (index0, element0) in authenticationRequestExtraParams.sorted(by: { $0.key < $1.key }).enumerated() {
                let authenticatecognitoactionauthenticationrequestparamnameKey0 = element0.key
                let authenticatecognitoactionauthenticationrequestparamvalueValue0 = element0.value
                var entryContainer0 = authenticationRequestExtraParamsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(authenticatecognitoactionauthenticationrequestparamnameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(authenticatecognitoactionauthenticationrequestparamvalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let onUnauthenticatedRequest = onUnauthenticatedRequest {
            try container.encode(onUnauthenticatedRequest, forKey: ClientRuntime.Key("OnUnauthenticatedRequest"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: ClientRuntime.Key("Scope"))
        }
        if let sessionCookieName = sessionCookieName {
            try container.encode(sessionCookieName, forKey: ClientRuntime.Key("SessionCookieName"))
        }
        if let sessionTimeout = sessionTimeout {
            try container.encode(sessionTimeout, forKey: ClientRuntime.Key("SessionTimeout"))
        }
        if let userPoolArn = userPoolArn {
            try container.encode(userPoolArn, forKey: ClientRuntime.Key("UserPoolArn"))
        }
        if let userPoolClientId = userPoolClientId {
            try container.encode(userPoolClientId, forKey: ClientRuntime.Key("UserPoolClientId"))
        }
        if let userPoolDomain = userPoolDomain {
            try container.encode(userPoolDomain, forKey: ClientRuntime.Key("UserPoolDomain"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolArn)
        userPoolArn = userPoolArnDecoded
        let userPoolClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolClientId)
        userPoolClientId = userPoolClientIdDecoded
        let userPoolDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolDomain)
        userPoolDomain = userPoolDomainDecoded
        let sessionCookieNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionCookieName)
        sessionCookieName = sessionCookieNameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
        if containerValues.contains(.authenticationRequestExtraParams) {
            struct KeyVal0{struct key{}; struct value{}}
            let authenticationRequestExtraParamsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .authenticationRequestExtraParams)
            if let authenticationRequestExtraParamsWrappedContainer = authenticationRequestExtraParamsWrappedContainer {
                let authenticationRequestExtraParamsContainer = try authenticationRequestExtraParamsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var authenticationRequestExtraParamsBuffer: [Swift.String:Swift.String]? = nil
                if let authenticationRequestExtraParamsContainer = authenticationRequestExtraParamsContainer {
                    authenticationRequestExtraParamsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in authenticationRequestExtraParamsContainer {
                        authenticationRequestExtraParamsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                authenticationRequestExtraParams = authenticationRequestExtraParamsBuffer
            } else {
                authenticationRequestExtraParams = [:]
            }
        } else {
            authenticationRequestExtraParams = nil
        }
        let onUnauthenticatedRequestDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConditionalBehaviorEnum.self, forKey: .onUnauthenticatedRequest)
        onUnauthenticatedRequest = onUnauthenticatedRequestDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticateCognitoActionConfig(authenticationRequestExtraParams: \(Swift.String(describing: authenticationRequestExtraParams)), onUnauthenticatedRequest: \(Swift.String(describing: onUnauthenticatedRequest)), scope: \(Swift.String(describing: scope)), sessionCookieName: \(Swift.String(describing: sessionCookieName)), sessionTimeout: \(Swift.String(describing: sessionTimeout)), userPoolArn: \(Swift.String(describing: userPoolArn)), userPoolClientId: \(Swift.String(describing: userPoolClientId)), userPoolDomain: \(Swift.String(describing: userPoolDomain)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Request parameters to use when integrating with Amazon Cognito to authenticate
    ///       users.</p>
    public struct AuthenticateCognitoActionConfig: Swift.Equatable {
        /// <p>The query parameters (up to 10) to include in the redirect request to the authorization
        ///       endpoint.</p>
        public let authenticationRequestExtraParams: [Swift.String:Swift.String]?
        /// <p>The behavior if the user is not authenticated. The following are possible values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>deny<code></code> - Return an HTTP 401 Unauthorized error.</p>
        ///             </li>
        ///             <li>
        ///                <p>allow<code></code> - Allow the request to be forwarded to the target.</p>
        ///             </li>
        ///             <li>
        ///                <p>authenticate<code></code> - Redirect the request to the IdP authorization endpoint. This is
        ///           the default value.</p>
        ///             </li>
        ///          </ul>
        public let onUnauthenticatedRequest: ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConditionalBehaviorEnum?
        /// <p>The set of user claims to be requested from the IdP. The default is
        ///       <code>openid</code>.</p>
        ///          <p>To verify which scope values your IdP supports and how to separate multiple values, see
        ///       the documentation for your IdP.</p>
        public let scope: Swift.String?
        /// <p>The name of the cookie used to maintain session information. The default is
        ///       AWSELBAuthSessionCookie.</p>
        public let sessionCookieName: Swift.String?
        /// <p>The maximum duration of the authentication session, in seconds. The default is 604800
        ///       seconds (7 days).</p>
        public let sessionTimeout: Swift.Int?
        /// <p>The Amazon Resource Name (ARN) of the Amazon Cognito user pool.</p>
        public let userPoolArn: Swift.String?
        /// <p>The ID of the Amazon Cognito user pool client.</p>
        public let userPoolClientId: Swift.String?
        /// <p>The domain prefix or fully-qualified domain name of the Amazon Cognito user pool.</p>
        public let userPoolDomain: Swift.String?

        public init (
            authenticationRequestExtraParams: [Swift.String:Swift.String]? = nil,
            onUnauthenticatedRequest: ElasticLoadBalancingV2ClientTypes.AuthenticateCognitoActionConditionalBehaviorEnum? = nil,
            scope: Swift.String? = nil,
            sessionCookieName: Swift.String? = nil,
            sessionTimeout: Swift.Int? = nil,
            userPoolArn: Swift.String? = nil,
            userPoolClientId: Swift.String? = nil,
            userPoolDomain: Swift.String? = nil
        )
        {
            self.authenticationRequestExtraParams = authenticationRequestExtraParams
            self.onUnauthenticatedRequest = onUnauthenticatedRequest
            self.scope = scope
            self.sessionCookieName = sessionCookieName
            self.sessionTimeout = sessionTimeout
            self.userPoolArn = userPoolArn
            self.userPoolClientId = userPoolClientId
            self.userPoolDomain = userPoolDomain
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes {
    public enum AuthenticateOidcActionConditionalBehaviorEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case authenticate
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticateOidcActionConditionalBehaviorEnum] {
            return [
                .allow,
                .authenticate,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "allow"
            case .authenticate: return "authenticate"
            case .deny: return "deny"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticateOidcActionConditionalBehaviorEnum(rawValue: rawValue) ?? AuthenticateOidcActionConditionalBehaviorEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationRequestExtraParams = "AuthenticationRequestExtraParams"
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientId = "ClientId"
        case clientSecret = "ClientSecret"
        case issuer = "Issuer"
        case onUnauthenticatedRequest = "OnUnauthenticatedRequest"
        case scope = "Scope"
        case sessionCookieName = "SessionCookieName"
        case sessionTimeout = "SessionTimeout"
        case tokenEndpoint = "TokenEndpoint"
        case useExistingClientSecret = "UseExistingClientSecret"
        case userInfoEndpoint = "UserInfoEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticationRequestExtraParams = authenticationRequestExtraParams {
            var authenticationRequestExtraParamsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AuthenticationRequestExtraParams"))
            for (index0, element0) in authenticationRequestExtraParams.sorted(by: { $0.key < $1.key }).enumerated() {
                let authenticateoidcactionauthenticationrequestparamnameKey0 = element0.key
                let authenticateoidcactionauthenticationrequestparamvalueValue0 = element0.value
                var entryContainer0 = authenticationRequestExtraParamsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(authenticateoidcactionauthenticationrequestparamnameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(authenticateoidcactionauthenticationrequestparamvalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let authorizationEndpoint = authorizationEndpoint {
            try container.encode(authorizationEndpoint, forKey: ClientRuntime.Key("AuthorizationEndpoint"))
        }
        if let clientId = clientId {
            try container.encode(clientId, forKey: ClientRuntime.Key("ClientId"))
        }
        if let clientSecret = clientSecret {
            try container.encode(clientSecret, forKey: ClientRuntime.Key("ClientSecret"))
        }
        if let issuer = issuer {
            try container.encode(issuer, forKey: ClientRuntime.Key("Issuer"))
        }
        if let onUnauthenticatedRequest = onUnauthenticatedRequest {
            try container.encode(onUnauthenticatedRequest, forKey: ClientRuntime.Key("OnUnauthenticatedRequest"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: ClientRuntime.Key("Scope"))
        }
        if let sessionCookieName = sessionCookieName {
            try container.encode(sessionCookieName, forKey: ClientRuntime.Key("SessionCookieName"))
        }
        if let sessionTimeout = sessionTimeout {
            try container.encode(sessionTimeout, forKey: ClientRuntime.Key("SessionTimeout"))
        }
        if let tokenEndpoint = tokenEndpoint {
            try container.encode(tokenEndpoint, forKey: ClientRuntime.Key("TokenEndpoint"))
        }
        if let useExistingClientSecret = useExistingClientSecret {
            try container.encode(useExistingClientSecret, forKey: ClientRuntime.Key("UseExistingClientSecret"))
        }
        if let userInfoEndpoint = userInfoEndpoint {
            try container.encode(userInfoEndpoint, forKey: ClientRuntime.Key("UserInfoEndpoint"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let tokenEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenEndpoint)
        tokenEndpoint = tokenEndpointDecoded
        let userInfoEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userInfoEndpoint)
        userInfoEndpoint = userInfoEndpointDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let sessionCookieNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionCookieName)
        sessionCookieName = sessionCookieNameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
        if containerValues.contains(.authenticationRequestExtraParams) {
            struct KeyVal0{struct key{}; struct value{}}
            let authenticationRequestExtraParamsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .authenticationRequestExtraParams)
            if let authenticationRequestExtraParamsWrappedContainer = authenticationRequestExtraParamsWrappedContainer {
                let authenticationRequestExtraParamsContainer = try authenticationRequestExtraParamsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var authenticationRequestExtraParamsBuffer: [Swift.String:Swift.String]? = nil
                if let authenticationRequestExtraParamsContainer = authenticationRequestExtraParamsContainer {
                    authenticationRequestExtraParamsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in authenticationRequestExtraParamsContainer {
                        authenticationRequestExtraParamsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                authenticationRequestExtraParams = authenticationRequestExtraParamsBuffer
            } else {
                authenticationRequestExtraParams = [:]
            }
        } else {
            authenticationRequestExtraParams = nil
        }
        let onUnauthenticatedRequestDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConditionalBehaviorEnum.self, forKey: .onUnauthenticatedRequest)
        onUnauthenticatedRequest = onUnauthenticatedRequestDecoded
        let useExistingClientSecretDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useExistingClientSecret)
        useExistingClientSecret = useExistingClientSecretDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticateOidcActionConfig(authenticationRequestExtraParams: \(Swift.String(describing: authenticationRequestExtraParams)), authorizationEndpoint: \(Swift.String(describing: authorizationEndpoint)), clientId: \(Swift.String(describing: clientId)), clientSecret: \(Swift.String(describing: clientSecret)), issuer: \(Swift.String(describing: issuer)), onUnauthenticatedRequest: \(Swift.String(describing: onUnauthenticatedRequest)), scope: \(Swift.String(describing: scope)), sessionCookieName: \(Swift.String(describing: sessionCookieName)), sessionTimeout: \(Swift.String(describing: sessionTimeout)), tokenEndpoint: \(Swift.String(describing: tokenEndpoint)), useExistingClientSecret: \(Swift.String(describing: useExistingClientSecret)), userInfoEndpoint: \(Swift.String(describing: userInfoEndpoint)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Request parameters when using an identity provider (IdP) that is compliant with OpenID
    ///       Connect (OIDC) to authenticate users.</p>
    public struct AuthenticateOidcActionConfig: Swift.Equatable {
        /// <p>The query parameters (up to 10) to include in the redirect request to the authorization
        ///       endpoint.</p>
        public let authenticationRequestExtraParams: [Swift.String:Swift.String]?
        /// <p>The authorization endpoint of the IdP. This must be a full URL, including the HTTPS
        ///       protocol, the domain, and the path.</p>
        public let authorizationEndpoint: Swift.String?
        /// <p>The OAuth 2.0 client identifier.</p>
        public let clientId: Swift.String?
        /// <p>The OAuth 2.0 client secret. This parameter is required if you are creating a rule. If you
        ///       are modifying a rule, you can omit this parameter if you set
        ///         <code>UseExistingClientSecret</code> to true.</p>
        public let clientSecret: Swift.String?
        /// <p>The OIDC issuer identifier of the IdP. This must be a full URL, including the HTTPS
        ///       protocol, the domain, and the path.</p>
        public let issuer: Swift.String?
        /// <p>The behavior if the user is not authenticated. The following are possible values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>deny<code></code> - Return an HTTP 401 Unauthorized error.</p>
        ///             </li>
        ///             <li>
        ///                <p>allow<code></code> - Allow the request to be forwarded to the target.</p>
        ///             </li>
        ///             <li>
        ///                <p>authenticate<code></code> - Redirect the request to the IdP authorization endpoint. This is
        ///           the default value.</p>
        ///             </li>
        ///          </ul>
        public let onUnauthenticatedRequest: ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConditionalBehaviorEnum?
        /// <p>The set of user claims to be requested from the IdP. The default is
        ///       <code>openid</code>.</p>
        ///          <p>To verify which scope values your IdP supports and how to separate multiple values, see
        ///       the documentation for your IdP.</p>
        public let scope: Swift.String?
        /// <p>The name of the cookie used to maintain session information. The default is
        ///       AWSELBAuthSessionCookie.</p>
        public let sessionCookieName: Swift.String?
        /// <p>The maximum duration of the authentication session, in seconds. The default is 604800
        ///       seconds (7 days).</p>
        public let sessionTimeout: Swift.Int?
        /// <p>The token endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the
        ///       domain, and the path.</p>
        public let tokenEndpoint: Swift.String?
        /// <p>Indicates whether to use the existing client secret when modifying a rule. If you are
        ///       creating a rule, you can omit this parameter or set it to false.</p>
        public let useExistingClientSecret: Swift.Bool?
        /// <p>The user info endpoint of the IdP. This must be a full URL, including the HTTPS protocol,
        ///       the domain, and the path.</p>
        public let userInfoEndpoint: Swift.String?

        public init (
            authenticationRequestExtraParams: [Swift.String:Swift.String]? = nil,
            authorizationEndpoint: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            issuer: Swift.String? = nil,
            onUnauthenticatedRequest: ElasticLoadBalancingV2ClientTypes.AuthenticateOidcActionConditionalBehaviorEnum? = nil,
            scope: Swift.String? = nil,
            sessionCookieName: Swift.String? = nil,
            sessionTimeout: Swift.Int? = nil,
            tokenEndpoint: Swift.String? = nil,
            useExistingClientSecret: Swift.Bool? = nil,
            userInfoEndpoint: Swift.String? = nil
        )
        {
            self.authenticationRequestExtraParams = authenticationRequestExtraParams
            self.authorizationEndpoint = authorizationEndpoint
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.issuer = issuer
            self.onUnauthenticatedRequest = onUnauthenticatedRequest
            self.scope = scope
            self.sessionCookieName = sessionCookieName
            self.sessionTimeout = sessionTimeout
            self.tokenEndpoint = tokenEndpoint
            self.useExistingClientSecret = useExistingClientSecret
            self.userInfoEndpoint = userInfoEndpoint
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.AvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancerAddresses = "LoadBalancerAddresses"
        case outpostId = "OutpostId"
        case subnetId = "SubnetId"
        case zoneName = "ZoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerAddresses = loadBalancerAddresses {
            var loadBalancerAddressesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerAddresses"))
            for (index0, loadbalanceraddress0) in loadBalancerAddresses.enumerated() {
                try loadBalancerAddressesContainer.encode(loadbalanceraddress0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let outpostId = outpostId {
            try container.encode(outpostId, forKey: ClientRuntime.Key("OutpostId"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: ClientRuntime.Key("SubnetId"))
        }
        if let zoneName = zoneName {
            try container.encode(zoneName, forKey: ClientRuntime.Key("ZoneName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zoneName)
        zoneName = zoneNameDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        if containerValues.contains(.loadBalancerAddresses) {
            struct KeyVal0{struct member{}}
            let loadBalancerAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerAddresses)
            if let loadBalancerAddressesWrappedContainer = loadBalancerAddressesWrappedContainer {
                let loadBalancerAddressesContainer = try loadBalancerAddressesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress].self, forKey: .member)
                var loadBalancerAddressesBuffer:[ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress]? = nil
                if let loadBalancerAddressesContainer = loadBalancerAddressesContainer {
                    loadBalancerAddressesBuffer = [ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress]()
                    for structureContainer0 in loadBalancerAddressesContainer {
                        loadBalancerAddressesBuffer?.append(structureContainer0)
                    }
                }
                loadBalancerAddresses = loadBalancerAddressesBuffer
            } else {
                loadBalancerAddresses = []
            }
        } else {
            loadBalancerAddresses = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.AvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZone(loadBalancerAddresses: \(Swift.String(describing: loadBalancerAddresses)), outpostId: \(Swift.String(describing: outpostId)), subnetId: \(Swift.String(describing: subnetId)), zoneName: \(Swift.String(describing: zoneName)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an Availability Zone.</p>
    public struct AvailabilityZone: Swift.Equatable {
        /// <p>[Network Load Balancers] If you need static IP addresses for your load balancer, you can
        ///       specify one Elastic IP address per Availability Zone when you create an internal-facing load
        ///       balancer. For internal load balancers, you can specify a private IP address from the IPv4
        ///       range of the subnet.</p>
        public let loadBalancerAddresses: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress]?
        /// <p>[Application Load Balancers on Outposts] The ID of the Outpost.</p>
        public let outpostId: Swift.String?
        /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
        public let subnetId: Swift.String?
        /// <p>The name of the Availability Zone.</p>
        public let zoneName: Swift.String?

        public init (
            loadBalancerAddresses: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress]? = nil,
            outpostId: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            zoneName: Swift.String? = nil
        )
        {
            self.loadBalancerAddresses = loadBalancerAddresses
            self.outpostId = outpostId
            self.subnetId = subnetId
            self.zoneName = zoneName
        }
    }

}

extension AvailabilityZoneNotSupportedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZoneNotSupportedException(message: \(Swift.String(describing: message)))"}
}

extension AvailabilityZoneNotSupportedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AvailabilityZoneNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Availability Zone is not supported.</p>
public struct AvailabilityZoneNotSupportedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AvailabilityZoneNotSupportedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AvailabilityZoneNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Certificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case isDefault = "IsDefault"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateArn = certificateArn {
            try container.encode(certificateArn, forKey: ClientRuntime.Key("CertificateArn"))
        }
        if let isDefault = isDefault {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Certificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Certificate(certificateArn: \(Swift.String(describing: certificateArn)), isDefault: \(Swift.String(describing: isDefault)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an SSL server certificate.</p>
    public struct Certificate: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the certificate.</p>
        public let certificateArn: Swift.String?
        /// <p>Indicates whether the certificate is the default certificate. Do not set this value when
        ///       specifying a certificate as an input. This value is not included in the output when describing
        ///       a listener, but is included when describing listener certificates.</p>
        public let isDefault: Swift.Bool?

        public init (
            certificateArn: Swift.String? = nil,
            isDefault: Swift.Bool? = nil
        )
        {
            self.certificateArn = certificateArn
            self.isDefault = isDefault
        }
    }

}

extension CertificateNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension CertificateNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CertificateNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified certificate does not exist.</p>
public struct CertificateNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CertificateNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Cipher: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Cipher: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Cipher(name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a cipher used in a policy.</p>
    public struct Cipher: Swift.Equatable {
        /// <p>The name of the cipher.</p>
        public let name: Swift.String?
        /// <p>The priority of the cipher.</p>
        public let priority: Swift.Int

        public init (
            name: Swift.String? = nil,
            priority: Swift.Int = 0
        )
        {
            self.name = name
            self.priority = priority
        }
    }

}

public struct CreateListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateListenerOutputError>
}

extension CreateListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateListenerInput(alpnPolicy: \(Swift.String(describing: alpnPolicy)), certificates: \(Swift.String(describing: certificates)), defaultActions: \(Swift.String(describing: defaultActions)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), port: \(Swift.String(describing: port)), protocol: \(Swift.String(describing: `protocol`)), sslPolicy: \(Swift.String(describing: sslPolicy)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let alpnPolicy = alpnPolicy {
            var alpnPolicyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AlpnPolicy"))
            for (index0, alpnpolicyvalue0) in alpnPolicy.enumerated() {
                try alpnPolicyContainer.encode(alpnpolicyvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultActions = defaultActions {
            var defaultActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DefaultActions"))
            for (index0, action0) in defaultActions.enumerated() {
                try defaultActionsContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let sslPolicy = sslPolicy {
            try container.encode(sslPolicy, forKey: ClientRuntime.Key("SslPolicy"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateListener", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateListenerOutputError>
}

public struct CreateListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateListenerOutputError>
}

public struct CreateListenerInput: Swift.Equatable {
    /// <p>The protocol for connections from clients to the load balancer. For Application Load
    ///       Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the
    ///       supported protocols are TCP, TLS, UDP, and TCP_UDP. You can’t specify the UDP or TCP_UDP
    ///       protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load
    ///       Balancer.</p>
    public let `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
    /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
    ///       can specify one policy name. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP1Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Optional</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Preferred</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>None</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
    ///         policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let alpnPolicy: [Swift.String]?
    /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
    ///       exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
    ///         <code>IsDefault</code>.</p>
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
    /// <p>The actions for the default rule.</p>
    public let defaultActions: [ElasticLoadBalancingV2ClientTypes.Action]?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?
    /// <p>The port on which the load balancer is listening. You cannot specify a port for a Gateway
    ///       Load Balancer.</p>
    public let port: Swift.Int?
    /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
    ///       supported.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> and
    ///         <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let sslPolicy: Swift.String?
    /// <p>The tags to assign to the listener.</p>
    public let tags: [ElasticLoadBalancingV2ClientTypes.Tag]?

    public init (
        `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
        alpnPolicy: [Swift.String]? = nil,
        certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil,
        defaultActions: [ElasticLoadBalancingV2ClientTypes.Action]? = nil,
        loadBalancerArn: Swift.String? = nil,
        port: Swift.Int? = nil,
        sslPolicy: Swift.String? = nil,
        tags: [ElasticLoadBalancingV2ClientTypes.Tag]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.alpnPolicy = alpnPolicy
        self.certificates = certificates
        self.defaultActions = defaultActions
        self.loadBalancerArn = loadBalancerArn
        self.port = port
        self.sslPolicy = sslPolicy
        self.tags = tags
    }
}

extension CreateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ALPNPolicyNotSupportedException" : self = .aLPNPolicyNotSupportedException(try ALPNPolicyNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateListenerException" : self = .duplicateListenerException(try DuplicateListenerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SSLPolicyNotFoundException" : self = .sSLPolicyNotFoundException(try SSLPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificatesException" : self = .tooManyCertificatesException(try TooManyCertificatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyListenersException" : self = .tooManyListenersException(try TooManyListenersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateListenerOutputError: Swift.Error, Swift.Equatable {
    case aLPNPolicyNotSupportedException(ALPNPolicyNotSupportedException)
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateListenerException(DuplicateListenerException)
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case sSLPolicyNotFoundException(SSLPolicyNotFoundException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyCertificatesException(TooManyCertificatesException)
    case tooManyListenersException(TooManyListenersException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTagsException(TooManyTagsException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateListenerOutputResponse(listeners: \(Swift.String(describing: listeners)))"}
}

extension CreateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
        } else {
            self.listeners = nil
        }
    }
}

public struct CreateListenerOutputResponse: Swift.Equatable {
    /// <p>Information about the listener.</p>
    public let listeners: [ElasticLoadBalancingV2ClientTypes.Listener]?

    public init (
        listeners: [ElasticLoadBalancingV2ClientTypes.Listener]? = nil
    )
    {
        self.listeners = listeners
    }
}

struct CreateListenerOutputResponseBody: Swift.Equatable {
    public let listeners: [ElasticLoadBalancingV2ClientTypes.Listener]?
}

extension CreateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateListenerResult"))
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Listener].self, forKey: .member)
                var listenersBuffer:[ElasticLoadBalancingV2ClientTypes.Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [ElasticLoadBalancingV2ClientTypes.Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
    }
}

public struct CreateLoadBalancerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLoadBalancerOutputError>
}

extension CreateLoadBalancerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLoadBalancerInput(customerOwnedIpv4Pool: \(Swift.String(describing: customerOwnedIpv4Pool)), ipAddressType: \(Swift.String(describing: ipAddressType)), name: \(Swift.String(describing: name)), scheme: \(Swift.String(describing: scheme)), securityGroups: \(Swift.String(describing: securityGroups)), subnetMappings: \(Swift.String(describing: subnetMappings)), subnets: \(Swift.String(describing: subnets)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateLoadBalancerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try container.encode(customerOwnedIpv4Pool, forKey: ClientRuntime.Key("CustomerOwnedIpv4Pool"))
        }
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: ClientRuntime.Key("IpAddressType"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: ClientRuntime.Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetMappings"))
            for (index0, subnetmapping0) in subnetMappings.enumerated() {
                try subnetMappingsContainer.encode(subnetmapping0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
        try container.encode("CreateLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateLoadBalancerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLoadBalancerOutputError>
}

public struct CreateLoadBalancerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLoadBalancerOutputError>
}

public struct CreateLoadBalancerInput: Swift.Equatable {
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool (CoIP
    ///       pool).</p>
    public let customerOwnedIpv4Pool: Swift.String?
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
    ///       are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
    ///       addresses). Internal load balancers must use <code>ipv4</code>.</p>
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?
    /// <p>The name of the load balancer.</p>
    ///          <p>This name must be unique per region per account, can have a maximum of 32 characters, must
    ///       contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must
    ///       not begin with "internal-".</p>
    public let name: Swift.String?
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an
    ///       Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
    ///       Therefore, Internet-facing load balancers can route requests from clients over the
    ///       internet.</p>
    ///          <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an
    ///       internal load balancer is publicly resolvable to the private IP addresses of the nodes.
    ///       Therefore, internal load balancers can route requests only from clients with access to the VPC
    ///       for the load balancer.</p>
    ///          <p>The default is an Internet-facing load balancer.</p>
    ///          <p>You cannot specify a scheme for a Gateway Load Balancer.</p>
    public let scheme: ElasticLoadBalancingV2ClientTypes.LoadBalancerSchemeEnum?
    /// <p>[Application Load Balancers] The IDs of the security groups for the load balancer.</p>
    public let securityGroups: [Swift.String]?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones. You cannot specify Elastic IP addresses for your subnets.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
    ///       can specify one Elastic IP address per subnet if you need static IP addresses for your
    ///       internet-facing load balancer. For internal load balancers, you can specify one private IP
    ///       address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
    ///       can specify one IPv6 address per subnet.</p>
    ///          <p>[Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You
    ///       cannot specify Elastic IP addresses for your subnets.</p>
    public let subnetMappings: [ElasticLoadBalancingV2ClientTypes.SubnetMapping]?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability
    ///       Zones.</p>
    ///          <p>[Gateway Load Balancers] You can specify subnets from one or more Availability
    ///       Zones.</p>
    public let subnets: [Swift.String]?
    /// <p>The tags to assign to the load balancer.</p>
    public let tags: [ElasticLoadBalancingV2ClientTypes.Tag]?
    /// <p>The type of load balancer. The default is <code>application</code>.</p>
    public let type: ElasticLoadBalancingV2ClientTypes.LoadBalancerTypeEnum?

    public init (
        customerOwnedIpv4Pool: Swift.String? = nil,
        ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        scheme: ElasticLoadBalancingV2ClientTypes.LoadBalancerSchemeEnum? = nil,
        securityGroups: [Swift.String]? = nil,
        subnetMappings: [ElasticLoadBalancingV2ClientTypes.SubnetMapping]? = nil,
        subnets: [Swift.String]? = nil,
        tags: [ElasticLoadBalancingV2ClientTypes.Tag]? = nil,
        type: ElasticLoadBalancingV2ClientTypes.LoadBalancerTypeEnum? = nil
    )
    {
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.ipAddressType = ipAddressType
        self.name = name
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.subnetMappings = subnetMappings
        self.subnets = subnets
        self.tags = tags
        self.type = type
    }
}

extension CreateLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AllocationIdNotFoundException" : self = .allocationIdNotFoundException(try AllocationIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AvailabilityZoneNotSupportedException" : self = .availabilityZoneNotSupportedException(try AvailabilityZoneNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateLoadBalancerNameException" : self = .duplicateLoadBalancerNameException(try DuplicateLoadBalancerNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchemeException" : self = .invalidSchemeException(try InvalidSchemeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupException" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFoundException" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLoadBalancersException" : self = .tooManyLoadBalancersException(try TooManyLoadBalancersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case allocationIdNotFoundException(AllocationIdNotFoundException)
    case availabilityZoneNotSupportedException(AvailabilityZoneNotSupportedException)
    case duplicateLoadBalancerNameException(DuplicateLoadBalancerNameException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSchemeException(InvalidSchemeException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case invalidSubnetException(InvalidSubnetException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case subnetNotFoundException(SubnetNotFoundException)
    case tooManyLoadBalancersException(TooManyLoadBalancersException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLoadBalancerOutputResponse(loadBalancers: \(Swift.String(describing: loadBalancers)))"}
}

extension CreateLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loadBalancers = output.loadBalancers
        } else {
            self.loadBalancers = nil
        }
    }
}

public struct CreateLoadBalancerOutputResponse: Swift.Equatable {
    /// <p>Information about the load balancer.</p>
    public let loadBalancers: [ElasticLoadBalancingV2ClientTypes.LoadBalancer]?

    public init (
        loadBalancers: [ElasticLoadBalancingV2ClientTypes.LoadBalancer]? = nil
    )
    {
        self.loadBalancers = loadBalancers
    }
}

struct CreateLoadBalancerOutputResponseBody: Swift.Equatable {
    public let loadBalancers: [ElasticLoadBalancingV2ClientTypes.LoadBalancer]?
}

extension CreateLoadBalancerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancers = "LoadBalancers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateLoadBalancerResult"))
        if containerValues.contains(.loadBalancers) {
            struct KeyVal0{struct member{}}
            let loadBalancersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancers)
            if let loadBalancersWrappedContainer = loadBalancersWrappedContainer {
                let loadBalancersContainer = try loadBalancersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.LoadBalancer].self, forKey: .member)
                var loadBalancersBuffer:[ElasticLoadBalancingV2ClientTypes.LoadBalancer]? = nil
                if let loadBalancersContainer = loadBalancersContainer {
                    loadBalancersBuffer = [ElasticLoadBalancingV2ClientTypes.LoadBalancer]()
                    for structureContainer0 in loadBalancersContainer {
                        loadBalancersBuffer?.append(structureContainer0)
                    }
                }
                loadBalancers = loadBalancersBuffer
            } else {
                loadBalancers = []
            }
        } else {
            loadBalancers = nil
        }
    }
}

public struct CreateRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleOutputError>
}

extension CreateRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleInput(actions: \(Swift.String(describing: actions)), conditions: \(Swift.String(describing: conditions)), listenerArn: \(Swift.String(describing: listenerArn)), priority: \(Swift.String(describing: priority)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Actions"))
            for (index0, action0) in actions.enumerated() {
                try actionsContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let conditions = conditions {
            var conditionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Conditions"))
            for (index0, rulecondition0) in conditions.enumerated() {
                try conditionsContainer.encode(rulecondition0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        if let priority = priority {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateRule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleOutputError>
}

public struct CreateRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleOutputError>
}

public struct CreateRuleInput: Swift.Equatable {
    /// <p>The actions.</p>
    public let actions: [ElasticLoadBalancingV2ClientTypes.Action]?
    /// <p>The conditions.</p>
    public let conditions: [ElasticLoadBalancingV2ClientTypes.RuleCondition]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?
    /// <p>The rule priority. A listener can't have multiple rules with the same priority.</p>
    public let priority: Swift.Int?
    /// <p>The tags to assign to the rule.</p>
    public let tags: [ElasticLoadBalancingV2ClientTypes.Tag]?

    public init (
        actions: [ElasticLoadBalancingV2ClientTypes.Action]? = nil,
        conditions: [ElasticLoadBalancingV2ClientTypes.RuleCondition]? = nil,
        listenerArn: Swift.String? = nil,
        priority: Swift.Int? = nil,
        tags: [ElasticLoadBalancingV2ClientTypes.Tag]? = nil
    )
    {
        self.actions = actions
        self.conditions = conditions
        self.listenerArn = listenerArn
        self.priority = priority
        self.tags = tags
    }
}

extension CreateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PriorityInUseException" : self = .priorityInUseException(try PriorityInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRulesException" : self = .tooManyRulesException(try TooManyRulesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetGroupsException" : self = .tooManyTargetGroupsException(try TooManyTargetGroupsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleOutputError: Swift.Error, Swift.Equatable {
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case listenerNotFoundException(ListenerNotFoundException)
    case priorityInUseException(PriorityInUseException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyRulesException(TooManyRulesException)
    case tooManyTagsException(TooManyTagsException)
    case tooManyTargetGroupsException(TooManyTargetGroupsException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleOutputResponse(rules: \(Swift.String(describing: rules)))"}
}

extension CreateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct CreateRuleOutputResponse: Swift.Equatable {
    /// <p>Information about the rule.</p>
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?

    public init (
        rules: [ElasticLoadBalancingV2ClientTypes.Rule]? = nil
    )
    {
        self.rules = rules
    }
}

struct CreateRuleOutputResponseBody: Swift.Equatable {
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?
}

extension CreateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateRuleResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Rule].self, forKey: .member)
                var rulesBuffer:[ElasticLoadBalancingV2ClientTypes.Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ElasticLoadBalancingV2ClientTypes.Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct CreateTargetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTargetGroupOutputError>
}

extension CreateTargetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTargetGroupInput(healthCheckEnabled: \(Swift.String(describing: healthCheckEnabled)), healthCheckIntervalSeconds: \(Swift.String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(Swift.String(describing: healthCheckPath)), healthCheckPort: \(Swift.String(describing: healthCheckPort)), healthCheckProtocol: \(Swift.String(describing: healthCheckProtocol)), healthCheckTimeoutSeconds: \(Swift.String(describing: healthCheckTimeoutSeconds)), healthyThresholdCount: \(Swift.String(describing: healthyThresholdCount)), matcher: \(Swift.String(describing: matcher)), name: \(Swift.String(describing: name)), port: \(Swift.String(describing: port)), protocol: \(Swift.String(describing: `protocol`)), protocolVersion: \(Swift.String(describing: protocolVersion)), tags: \(Swift.String(describing: tags)), targetType: \(Swift.String(describing: targetType)), unhealthyThresholdCount: \(Swift.String(describing: unhealthyThresholdCount)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension CreateTargetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthCheckEnabled = healthCheckEnabled {
            try container.encode(healthCheckEnabled, forKey: ClientRuntime.Key("HealthCheckEnabled"))
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try container.encode(healthCheckIntervalSeconds, forKey: ClientRuntime.Key("HealthCheckIntervalSeconds"))
        }
        if let healthCheckPath = healthCheckPath {
            try container.encode(healthCheckPath, forKey: ClientRuntime.Key("HealthCheckPath"))
        }
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: ClientRuntime.Key("HealthCheckPort"))
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try container.encode(healthCheckProtocol, forKey: ClientRuntime.Key("HealthCheckProtocol"))
        }
        if let healthCheckTimeoutSeconds = healthCheckTimeoutSeconds {
            try container.encode(healthCheckTimeoutSeconds, forKey: ClientRuntime.Key("HealthCheckTimeoutSeconds"))
        }
        if let healthyThresholdCount = healthyThresholdCount {
            try container.encode(healthyThresholdCount, forKey: ClientRuntime.Key("HealthyThresholdCount"))
        }
        if let matcher = matcher {
            try container.encode(matcher, forKey: ClientRuntime.Key("Matcher"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let protocolVersion = protocolVersion {
            try container.encode(protocolVersion, forKey: ClientRuntime.Key("ProtocolVersion"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let targetType = targetType {
            try container.encode(targetType, forKey: ClientRuntime.Key("TargetType"))
        }
        if let unhealthyThresholdCount = unhealthyThresholdCount {
            try container.encode(unhealthyThresholdCount, forKey: ClientRuntime.Key("UnhealthyThresholdCount"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        try container.encode("CreateTargetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateTargetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTargetGroupOutputError>
}

public struct CreateTargetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTargetGroupOutputError>
}

public struct CreateTargetGroupInput: Swift.Equatable {
    /// <p>The protocol to use for routing traffic to the targets. For Application Load Balancers,
    ///       the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported
    ///       protocols are TCP, TLS, UDP, or TCP_UDP. For Gateway Load Balancers, the supported protocol is
    ///       GENEVE. A TCP_UDP listener must be associated with a TCP_UDP target group. If the target is a
    ///       Lambda function, this parameter does not apply.</p>
    public let `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
    /// <p>Indicates whether health checks are enabled. If the target type is <code>lambda</code>,
    ///       health checks are disabled by default but can be enabled. If the target type is
    ///         <code>instance</code> or <code>ip</code>, health checks are always enabled and cannot be
    ///       disabled.</p>
    public let healthCheckEnabled: Swift.Bool?
    /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
    ///       If the target group protocol is TCP, TLS, UDP, or TCP_UDP, the supported values are 10 and 30
    ///       seconds. If the target group protocol is HTTP or HTTPS, the default is 30 seconds. If the
    ///       target group protocol is GENEVE, the default is 10 seconds. If the target type is
    ///         <code>lambda</code>, the default is 35 seconds.</p>
    public let healthCheckIntervalSeconds: Swift.Int?
    /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
    ///          <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
    ///          <p>[GRPC protocol version] The path of a custom health check method with the format
    ///       /package.service/method. The default is /AWS.ALB/healthcheck.</p>
    public let healthCheckPath: Swift.String?
    /// <p>The port the load balancer uses when performing health checks on targets. If the protocol
    ///       is HTTP, HTTPS, TCP, TLS, UDP, or TCP_UDP, the default is <code>traffic-port</code>, which is
    ///       the port on which each target receives traffic from the load balancer. If the protocol is
    ///       GENEVE, the default is port 80.</p>
    public let healthCheckPort: Swift.String?
    /// <p>The protocol the load balancer uses when performing health checks on targets. For
    ///       Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load
    ///       Balancers, the default is TCP. The TCP protocol is not supported for health checks if the
    ///       protocol of the target group is HTTP or HTTPS. The GENEVE, TLS, UDP, and TCP_UDP protocols are
    ///       not supported for health checks.</p>
    public let healthCheckProtocol: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
    /// <p>The amount of time, in seconds, during which no response from a target means a failed
    ///       health check. For target groups with a protocol of HTTP, HTTPS, or GENEVE, the default is 5
    ///       seconds. For target groups with a protocol of TCP or TLS, this value must be 6 seconds for
    ///       HTTP health checks and 10 seconds for TCP and HTTPS health checks. If the target type is
    ///         <code>lambda</code>, the default is 30 seconds.</p>
    public let healthCheckTimeoutSeconds: Swift.Int?
    /// <p>The number of consecutive health checks successes required before considering an unhealthy
    ///       target healthy. For target groups with a protocol of HTTP or HTTPS, the default is 5. For
    ///       target groups with a protocol of TCP, TLS, or GENEVE, the default is 3. If the target type is
    ///         <code>lambda</code>, the default is 5.</p>
    public let healthyThresholdCount: Swift.Int?
    /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
    ///       response from a target.</p>
    public let matcher: ElasticLoadBalancingV2ClientTypes.Matcher?
    /// <p>The name of the target group.</p>
    ///          <p>This name must be unique per region per account, can have a maximum of 32 characters, must
    ///       contain only alphanumeric characters or hyphens, and must not begin or end with a
    ///       hyphen.</p>
    public let name: Swift.String?
    /// <p>The port on which the targets receive traffic. This port is used unless you specify a port
    ///       override when registering the target. If the target is a Lambda function, this parameter does
    ///       not apply. If the protocol is GENEVE, the supported port is 6081.</p>
    public let port: Swift.Int?
    /// <p>[HTTP/HTTPS protocol] The protocol version. Specify <code>GRPC</code> to send requests to
    ///       targets using gRPC. Specify <code>HTTP2</code> to send requests to targets using HTTP/2. The
    ///       default is <code>HTTP1</code>, which sends requests to targets using HTTP/1.1.</p>
    public let protocolVersion: Swift.String?
    /// <p>The tags to assign to the target group.</p>
    public let tags: [ElasticLoadBalancingV2ClientTypes.Tag]?
    /// <p>The type of target that you must specify when registering targets with this target group.
    ///       You can't specify targets for a target group using more than one target type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>instance</code> - Register targets by instance ID. This is the default
    ///           value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ip</code> - Register targets by IP address. You can specify IP addresses from
    ///           the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range
    ///           (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10).
    ///           You can't specify publicly routable IP addresses.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>lambda</code> - Register a single Lambda function as a target.</p>
    ///             </li>
    ///          </ul>
    public let targetType: ElasticLoadBalancingV2ClientTypes.TargetTypeEnum?
    /// <p>The number of consecutive health check failures required before considering a target
    ///       unhealthy. If the target group protocol is HTTP or HTTPS, the default is 2. If the target
    ///       group protocol is TCP or TLS, this value must be the same as the healthy threshold count. If
    ///       the target group protocol is GENEVE, the default is 3. If the target type is
    ///         <code>lambda</code>, the default is 2.</p>
    public let unhealthyThresholdCount: Swift.Int?
    /// <p>The identifier of the virtual private cloud (VPC). If the target is a Lambda function,
    ///       this parameter does not apply. Otherwise, this parameter is required.</p>
    public let vpcId: Swift.String?

    public init (
        `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
        healthCheckEnabled: Swift.Bool? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.String? = nil,
        healthCheckProtocol: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
        healthCheckTimeoutSeconds: Swift.Int? = nil,
        healthyThresholdCount: Swift.Int? = nil,
        matcher: ElasticLoadBalancingV2ClientTypes.Matcher? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        protocolVersion: Swift.String? = nil,
        tags: [ElasticLoadBalancingV2ClientTypes.Tag]? = nil,
        targetType: ElasticLoadBalancingV2ClientTypes.TargetTypeEnum? = nil,
        unhealthyThresholdCount: Swift.Int? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.healthCheckEnabled = healthCheckEnabled
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
        self.healthyThresholdCount = healthyThresholdCount
        self.matcher = matcher
        self.name = name
        self.port = port
        self.protocolVersion = protocolVersion
        self.tags = tags
        self.targetType = targetType
        self.unhealthyThresholdCount = unhealthyThresholdCount
        self.vpcId = vpcId
    }
}

extension CreateTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateTargetGroupNameException" : self = .duplicateTargetGroupNameException(try DuplicateTargetGroupNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetGroupsException" : self = .tooManyTargetGroupsException(try TooManyTargetGroupsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case duplicateTargetGroupNameException(DuplicateTargetGroupNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case tooManyTagsException(TooManyTagsException)
    case tooManyTargetGroupsException(TooManyTargetGroupsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTargetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTargetGroupOutputResponse(targetGroups: \(Swift.String(describing: targetGroups)))"}
}

extension CreateTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetGroups = output.targetGroups
        } else {
            self.targetGroups = nil
        }
    }
}

public struct CreateTargetGroupOutputResponse: Swift.Equatable {
    /// <p>Information about the target group.</p>
    public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]?

    public init (
        targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]? = nil
    )
    {
        self.targetGroups = targetGroups
    }
}

struct CreateTargetGroupOutputResponseBody: Swift.Equatable {
    public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]?
}

extension CreateTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateTargetGroupResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[ElasticLoadBalancingV2ClientTypes.TargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [ElasticLoadBalancingV2ClientTypes.TargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
    }
}

public struct DeleteListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteListenerOutputError>
}

extension DeleteListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteListenerInput(listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension DeleteListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        try container.encode("DeleteListener", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?

    public init (
        listenerArn: Swift.String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

extension DeleteListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteListenerOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteListenerOutputResponse()"}
}

extension DeleteListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteListenerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteListenerOutputResponseBody: Swift.Equatable {
}

extension DeleteListenerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteLoadBalancerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLoadBalancerOutputError>
}

extension DeleteLoadBalancerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLoadBalancerInput(loadBalancerArn: \(Swift.String(describing: loadBalancerArn)))"}
}

extension DeleteLoadBalancerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        try container.encode("DeleteLoadBalancer", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteLoadBalancerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLoadBalancerOutputError>
}

public struct DeleteLoadBalancerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLoadBalancerOutputError>
}

public struct DeleteLoadBalancerInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?

    public init (
        loadBalancerArn: Swift.String? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
    }
}

extension DeleteLoadBalancerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoadBalancerOutputError: Swift.Error, Swift.Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLoadBalancerOutputResponse()"}
}

extension DeleteLoadBalancerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoadBalancerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLoadBalancerOutputResponseBody: Swift.Equatable {
}

extension DeleteLoadBalancerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleInput(ruleArn: \(Swift.String(describing: ruleArn)))"}
}

extension DeleteRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: ClientRuntime.Key("RuleArn"))
        }
        try container.encode("DeleteRule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: Swift.String?

    public init (
        ruleArn: Swift.String? = nil
    )
    {
        self.ruleArn = ruleArn
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case ruleNotFoundException(RuleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleOutputResponse()"}
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteTargetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTargetGroupOutputError>
}

extension DeleteTargetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTargetGroupInput(targetGroupArn: \(Swift.String(describing: targetGroupArn)))"}
}

extension DeleteTargetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        try container.encode("DeleteTargetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteTargetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTargetGroupOutputError>
}

public struct DeleteTargetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTargetGroupOutputError>
}

public struct DeleteTargetGroupInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?

    public init (
        targetGroupArn: Swift.String? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
    }
}

extension DeleteTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTargetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTargetGroupOutputResponse()"}
}

extension DeleteTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTargetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTargetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteTargetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetsOutputError>
}

extension DeregisterTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTargetsInput(targetGroupArn: \(Swift.String(describing: targetGroupArn)), targets: \(Swift.String(describing: targets)))"}
}

extension DeregisterTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let targets = targets {
            var targetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Targets"))
            for (index0, targetdescription0) in targets.enumerated() {
                try targetsContainer.encode(targetdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DeregisterTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeregisterTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetsOutputError>
}

public struct DeregisterTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterTargetsOutputError>
}

public struct DeregisterTargetsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?
    /// <p>The targets. If you specified a port override when you registered a target, you must
    ///       specify both the target ID and the port when you deregister it.</p>
    public let targets: [ElasticLoadBalancingV2ClientTypes.TargetDescription]?

    public init (
        targetGroupArn: Swift.String? = nil,
        targets: [ElasticLoadBalancingV2ClientTypes.TargetDescription]? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.targets = targets
    }
}

extension DeregisterTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTargetsOutputError: Swift.Error, Swift.Equatable {
    case invalidTargetException(InvalidTargetException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterTargetsOutputResponse()"}
}

extension DeregisterTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterTargetsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterTargetsOutputResponseBody: Swift.Equatable {
}

extension DeregisterTargetsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAccountLimitsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountLimitsOutputError>
}

extension DescribeAccountLimitsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountLimitsInput(marker: \(Swift.String(describing: marker)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension DescribeAccountLimitsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeAccountLimits", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeAccountLimitsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInput: Swift.Equatable {
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeAccountLimitsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountLimitsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountLimitsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountLimitsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountLimitsOutputResponse(limits: \(Swift.String(describing: limits)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension DescribeAccountLimitsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountLimitsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.limits = output.limits
            self.nextMarker = output.nextMarker
        } else {
            self.limits = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeAccountLimitsOutputResponse: Swift.Equatable {
    /// <p>Information about the limits.</p>
    public let limits: [ElasticLoadBalancingV2ClientTypes.Limit]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?

    public init (
        limits: [ElasticLoadBalancingV2ClientTypes.Limit]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.limits = limits
        self.nextMarker = nextMarker
    }
}

struct DescribeAccountLimitsOutputResponseBody: Swift.Equatable {
    public let limits: [ElasticLoadBalancingV2ClientTypes.Limit]?
    public let nextMarker: Swift.String?
}

extension DescribeAccountLimitsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limits = "Limits"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAccountLimitsResult"))
        if containerValues.contains(.limits) {
            struct KeyVal0{struct member{}}
            let limitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .limits)
            if let limitsWrappedContainer = limitsWrappedContainer {
                let limitsContainer = try limitsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Limit].self, forKey: .member)
                var limitsBuffer:[ElasticLoadBalancingV2ClientTypes.Limit]? = nil
                if let limitsContainer = limitsContainer {
                    limitsBuffer = [ElasticLoadBalancingV2ClientTypes.Limit]()
                    for structureContainer0 in limitsContainer {
                        limitsBuffer?.append(structureContainer0)
                    }
                }
                limits = limitsBuffer
            } else {
                limits = []
            }
        } else {
            limits = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeListenerCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenerCertificatesOutputError>
}

extension DescribeListenerCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeListenerCertificatesInput(listenerArn: \(Swift.String(describing: listenerArn)), marker: \(Swift.String(describing: marker)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension DescribeListenerCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeListenerCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeListenerCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenerCertificatesOutputError>
}

public struct DescribeListenerCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenerCertificatesOutputError>
}

public struct DescribeListenerCertificatesInput: Swift.Equatable {
    /// <p>The Amazon Resource Names (ARN) of the listener.</p>
    public let listenerArn: Swift.String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?

    public init (
        listenerArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.listenerArn = listenerArn
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeListenerCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeListenerCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeListenerCertificatesOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenerCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeListenerCertificatesOutputResponse(certificates: \(Swift.String(describing: certificates)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension DescribeListenerCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeListenerCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeListenerCertificatesOutputResponse: Swift.Equatable {
    /// <p>Information about the certificates.</p>
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?

    public init (
        certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct DescribeListenerCertificatesOutputResponseBody: Swift.Equatable {
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
    public let nextMarker: Swift.String?
}

extension DescribeListenerCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeListenerCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Certificate].self, forKey: .member)
                var certificatesBuffer:[ElasticLoadBalancingV2ClientTypes.Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [ElasticLoadBalancingV2ClientTypes.Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeListenersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenersOutputError>
}

extension DescribeListenersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeListenersInput(listenerArns: \(Swift.String(describing: listenerArns)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), marker: \(Swift.String(describing: marker)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension DescribeListenersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listenerArns = listenerArns {
            var listenerArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ListenerArns"))
            for (index0, listenerarn0) in listenerArns.enumerated() {
                try listenerArnsContainer.encode(listenerarn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeListeners", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeListenersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenersOutputError>
}

public struct DescribeListenersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeListenersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeListenersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeListenersOutputError>
}

public struct DescribeListenersInput: Swift.Equatable {
    /// <p>The Amazon Resource Names (ARN) of the listeners.</p>
    public let listenerArns: [Swift.String]?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?

    public init (
        listenerArns: [Swift.String]? = nil,
        loadBalancerArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.listenerArns = listenerArns
        self.loadBalancerArn = loadBalancerArn
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeListenersOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeListenersOutputResponse(listeners: \(Swift.String(describing: listeners)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension DescribeListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeListenersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
            self.nextMarker = output.nextMarker
        } else {
            self.listeners = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeListenersOutputResponse: Swift.Equatable {
    /// <p>Information about the listeners.</p>
    public let listeners: [ElasticLoadBalancingV2ClientTypes.Listener]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?

    public init (
        listeners: [ElasticLoadBalancingV2ClientTypes.Listener]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.listeners = listeners
        self.nextMarker = nextMarker
    }
}

struct DescribeListenersOutputResponseBody: Swift.Equatable {
    public let listeners: [ElasticLoadBalancingV2ClientTypes.Listener]?
    public let nextMarker: Swift.String?
}

extension DescribeListenersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeListenersResult"))
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Listener].self, forKey: .member)
                var listenersBuffer:[ElasticLoadBalancingV2ClientTypes.Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [ElasticLoadBalancingV2ClientTypes.Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeLoadBalancerAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBalancerAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBalancerAttributesOutputError>
}

extension DescribeLoadBalancerAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoadBalancerAttributesInput(loadBalancerArn: \(Swift.String(describing: loadBalancerArn)))"}
}

extension DescribeLoadBalancerAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        try container.encode("DescribeLoadBalancerAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeLoadBalancerAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBalancerAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBalancerAttributesOutputError>
}

public struct DescribeLoadBalancerAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBalancerAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBalancerAttributesOutputError>
}

public struct DescribeLoadBalancerAttributesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?

    public init (
        loadBalancerArn: Swift.String? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
    }
}

extension DescribeLoadBalancerAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancerAttributesOutputError: Swift.Error, Swift.Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoadBalancerAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension DescribeLoadBalancerAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeLoadBalancerAttributesOutputResponse: Swift.Equatable {
    /// <p>Information about the load balancer attributes.</p>
    public let attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]?

    public init (
        attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeLoadBalancerAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]?
}

extension DescribeLoadBalancerAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoadBalancerAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute].self, forKey: .member)
                var attributesBuffer:[ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct DescribeLoadBalancersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBalancersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBalancersOutputError>
}

extension DescribeLoadBalancersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoadBalancersInput(loadBalancerArns: \(Swift.String(describing: loadBalancerArns)), marker: \(Swift.String(describing: marker)), names: \(Swift.String(describing: names)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension DescribeLoadBalancersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerArns = loadBalancerArns {
            var loadBalancerArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerArns"))
            for (index0, loadbalancerarn0) in loadBalancerArns.enumerated() {
                try loadBalancerArnsContainer.encode(loadbalancerarn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let names = names {
            var namesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Names"))
            for (index0, loadbalancername0) in names.enumerated() {
                try namesContainer.encode(loadbalancername0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeLoadBalancers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeLoadBalancersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBalancersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBalancersOutputError>
}

public struct DescribeLoadBalancersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoadBalancersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoadBalancersOutputError>
}

public struct DescribeLoadBalancersInput: Swift.Equatable {
    /// <p>The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load
    ///       balancers in a single call.</p>
    public let loadBalancerArns: [Swift.String]?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The names of the load balancers.</p>
    public let names: [Swift.String]?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?

    public init (
        loadBalancerArns: [Swift.String]? = nil,
        marker: Swift.String? = nil,
        names: [Swift.String]? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.loadBalancerArns = loadBalancerArns
        self.marker = marker
        self.names = names
        self.pageSize = pageSize
    }
}

extension DescribeLoadBalancersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancersOutputError: Swift.Error, Swift.Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoadBalancersOutputResponse(loadBalancers: \(Swift.String(describing: loadBalancers)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension DescribeLoadBalancersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoadBalancersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loadBalancers = output.loadBalancers
            self.nextMarker = output.nextMarker
        } else {
            self.loadBalancers = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeLoadBalancersOutputResponse: Swift.Equatable {
    /// <p>Information about the load balancers.</p>
    public let loadBalancers: [ElasticLoadBalancingV2ClientTypes.LoadBalancer]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?

    public init (
        loadBalancers: [ElasticLoadBalancingV2ClientTypes.LoadBalancer]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.loadBalancers = loadBalancers
        self.nextMarker = nextMarker
    }
}

struct DescribeLoadBalancersOutputResponseBody: Swift.Equatable {
    public let loadBalancers: [ElasticLoadBalancingV2ClientTypes.LoadBalancer]?
    public let nextMarker: Swift.String?
}

extension DescribeLoadBalancersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loadBalancers = "LoadBalancers"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeLoadBalancersResult"))
        if containerValues.contains(.loadBalancers) {
            struct KeyVal0{struct member{}}
            let loadBalancersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancers)
            if let loadBalancersWrappedContainer = loadBalancersWrappedContainer {
                let loadBalancersContainer = try loadBalancersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.LoadBalancer].self, forKey: .member)
                var loadBalancersBuffer:[ElasticLoadBalancingV2ClientTypes.LoadBalancer]? = nil
                if let loadBalancersContainer = loadBalancersContainer {
                    loadBalancersBuffer = [ElasticLoadBalancingV2ClientTypes.LoadBalancer]()
                    for structureContainer0 in loadBalancersContainer {
                        loadBalancersBuffer?.append(structureContainer0)
                    }
                }
                loadBalancers = loadBalancersBuffer
            } else {
                loadBalancers = []
            }
        } else {
            loadBalancers = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeRulesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesOutputError>
}

extension DescribeRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRulesInput(listenerArn: \(Swift.String(describing: listenerArn)), marker: \(Swift.String(describing: marker)), pageSize: \(Swift.String(describing: pageSize)), ruleArns: \(Swift.String(describing: ruleArns)))"}
}

extension DescribeRulesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        if let ruleArns = ruleArns {
            var ruleArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RuleArns"))
            for (index0, rulearn0) in ruleArns.enumerated() {
                try ruleArnsContainer.encode(rulearn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeRules", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesOutputError>
}

public struct DescribeRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRulesOutputError>
}

public struct DescribeRulesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?
    /// <p>The Amazon Resource Names (ARN) of the rules.</p>
    public let ruleArns: [Swift.String]?

    public init (
        listenerArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        ruleArns: [Swift.String]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.marker = marker
        self.pageSize = pageSize
        self.ruleArns = ruleArns
    }
}

extension DescribeRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRulesOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case ruleNotFoundException(RuleNotFoundException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRulesOutputResponse(nextMarker: \(Swift.String(describing: nextMarker)), rules: \(Swift.String(describing: rules)))"}
}

extension DescribeRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.rules = output.rules
        } else {
            self.nextMarker = nil
            self.rules = nil
        }
    }
}

public struct DescribeRulesOutputResponse: Swift.Equatable {
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?
    /// <p>Information about the rules.</p>
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?

    public init (
        nextMarker: Swift.String? = nil,
        rules: [ElasticLoadBalancingV2ClientTypes.Rule]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.rules = rules
    }
}

struct DescribeRulesOutputResponseBody: Swift.Equatable {
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?
    public let nextMarker: Swift.String?
}

extension DescribeRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeRulesResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Rule].self, forKey: .member)
                var rulesBuffer:[ElasticLoadBalancingV2ClientTypes.Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ElasticLoadBalancingV2ClientTypes.Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeSSLPoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSSLPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSSLPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSSLPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSSLPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSSLPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSSLPoliciesOutputError>
}

extension DescribeSSLPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSSLPoliciesInput(marker: \(Swift.String(describing: marker)), names: \(Swift.String(describing: names)), pageSize: \(Swift.String(describing: pageSize)))"}
}

extension DescribeSSLPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let names = names {
            var namesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Names"))
            for (index0, sslpolicyname0) in names.enumerated() {
                try namesContainer.encode(sslpolicyname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        try container.encode("DescribeSSLPolicies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeSSLPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSSLPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSSLPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSSLPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSSLPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSSLPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSSLPoliciesOutputError>
}

public struct DescribeSSLPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSSLPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSSLPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSSLPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSSLPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSSLPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSSLPoliciesOutputError>
}

public struct DescribeSSLPoliciesInput: Swift.Equatable {
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The names of the policies.</p>
    public let names: [Swift.String]?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        names: [Swift.String]? = nil,
        pageSize: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.names = names
        self.pageSize = pageSize
    }
}

extension DescribeSSLPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSSLPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SSLPolicyNotFoundException" : self = .sSLPolicyNotFoundException(try SSLPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSSLPoliciesOutputError: Swift.Error, Swift.Equatable {
    case sSLPolicyNotFoundException(SSLPolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSSLPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSSLPoliciesOutputResponse(nextMarker: \(Swift.String(describing: nextMarker)), sslPolicies: \(Swift.String(describing: sslPolicies)))"}
}

extension DescribeSSLPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSSLPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.sslPolicies = output.sslPolicies
        } else {
            self.nextMarker = nil
            self.sslPolicies = nil
        }
    }
}

public struct DescribeSSLPoliciesOutputResponse: Swift.Equatable {
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?
    /// <p>Information about the security policies.</p>
    public let sslPolicies: [ElasticLoadBalancingV2ClientTypes.SslPolicy]?

    public init (
        nextMarker: Swift.String? = nil,
        sslPolicies: [ElasticLoadBalancingV2ClientTypes.SslPolicy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.sslPolicies = sslPolicies
    }
}

struct DescribeSSLPoliciesOutputResponseBody: Swift.Equatable {
    public let sslPolicies: [ElasticLoadBalancingV2ClientTypes.SslPolicy]?
    public let nextMarker: Swift.String?
}

extension DescribeSSLPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case sslPolicies = "SslPolicies"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSSLPoliciesResult"))
        if containerValues.contains(.sslPolicies) {
            struct KeyVal0{struct member{}}
            let sslPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sslPolicies)
            if let sslPoliciesWrappedContainer = sslPoliciesWrappedContainer {
                let sslPoliciesContainer = try sslPoliciesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.SslPolicy].self, forKey: .member)
                var sslPoliciesBuffer:[ElasticLoadBalancingV2ClientTypes.SslPolicy]? = nil
                if let sslPoliciesContainer = sslPoliciesContainer {
                    sslPoliciesBuffer = [ElasticLoadBalancingV2ClientTypes.SslPolicy]()
                    for structureContainer0 in sslPoliciesContainer {
                        sslPoliciesBuffer?.append(structureContainer0)
                    }
                }
                sslPolicies = sslPoliciesBuffer
            } else {
                sslPolicies = []
            }
        } else {
            sslPolicies = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagsInput(resourceArns: \(Swift.String(describing: resourceArns)))"}
}

extension DescribeTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
            for (index0, resourcearn0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcearn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInput: Swift.Equatable {
    /// <p>The Amazon Resource Names (ARN) of the resources. You can specify up to 20 resources in a
    ///       single call.</p>
    public let resourceArns: [Swift.String]?

    public init (
        resourceArns: [Swift.String]? = nil
    )
    {
        self.resourceArns = resourceArns
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case ruleNotFoundException(RuleNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagsOutputResponse(tagDescriptions: \(Swift.String(describing: tagDescriptions)))"}
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagDescriptions = output.tagDescriptions
        } else {
            self.tagDescriptions = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// <p>Information about the tags.</p>
    public let tagDescriptions: [ElasticLoadBalancingV2ClientTypes.TagDescription]?

    public init (
        tagDescriptions: [ElasticLoadBalancingV2ClientTypes.TagDescription]? = nil
    )
    {
        self.tagDescriptions = tagDescriptions
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    public let tagDescriptions: [ElasticLoadBalancingV2ClientTypes.TagDescription]?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagDescriptions = "TagDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTagsResult"))
        if containerValues.contains(.tagDescriptions) {
            struct KeyVal0{struct member{}}
            let tagDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagDescriptions)
            if let tagDescriptionsWrappedContainer = tagDescriptionsWrappedContainer {
                let tagDescriptionsContainer = try tagDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TagDescription].self, forKey: .member)
                var tagDescriptionsBuffer:[ElasticLoadBalancingV2ClientTypes.TagDescription]? = nil
                if let tagDescriptionsContainer = tagDescriptionsContainer {
                    tagDescriptionsBuffer = [ElasticLoadBalancingV2ClientTypes.TagDescription]()
                    for structureContainer0 in tagDescriptionsContainer {
                        tagDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                tagDescriptions = tagDescriptionsBuffer
            } else {
                tagDescriptions = []
            }
        } else {
            tagDescriptions = nil
        }
    }
}

public struct DescribeTargetGroupAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetGroupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetGroupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetGroupAttributesOutputError>
}

extension DescribeTargetGroupAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTargetGroupAttributesInput(targetGroupArn: \(Swift.String(describing: targetGroupArn)))"}
}

extension DescribeTargetGroupAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        try container.encode("DescribeTargetGroupAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeTargetGroupAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetGroupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetGroupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetGroupAttributesOutputError>
}

public struct DescribeTargetGroupAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetGroupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetGroupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetGroupAttributesOutputError>
}

public struct DescribeTargetGroupAttributesInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?

    public init (
        targetGroupArn: Swift.String? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
    }
}

extension DescribeTargetGroupAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTargetGroupAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTargetGroupAttributesOutputError: Swift.Error, Swift.Equatable {
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTargetGroupAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTargetGroupAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension DescribeTargetGroupAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTargetGroupAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeTargetGroupAttributesOutputResponse: Swift.Equatable {
    /// <p>Information about the target group attributes</p>
    public let attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]?

    public init (
        attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeTargetGroupAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]?
}

extension DescribeTargetGroupAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTargetGroupAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute].self, forKey: .member)
                var attributesBuffer:[ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct DescribeTargetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetGroupsOutputError>
}

extension DescribeTargetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTargetGroupsInput(loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), marker: \(Swift.String(describing: marker)), names: \(Swift.String(describing: names)), pageSize: \(Swift.String(describing: pageSize)), targetGroupArns: \(Swift.String(describing: targetGroupArns)))"}
}

extension DescribeTargetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let names = names {
            var namesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Names"))
            for (index0, targetgroupname0) in names.enumerated() {
                try namesContainer.encode(targetgroupname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: ClientRuntime.Key("PageSize"))
        }
        if let targetGroupArns = targetGroupArns {
            var targetGroupArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TargetGroupArns"))
            for (index0, targetgrouparn0) in targetGroupArns.enumerated() {
                try targetGroupArnsContainer.encode(targetgrouparn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTargetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeTargetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetGroupsOutputError>
}

public struct DescribeTargetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetGroupsOutputError>
}

public struct DescribeTargetGroupsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: Swift.String?
    /// <p>The names of the target groups.</p>
    public let names: [Swift.String]?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Swift.Int?
    /// <p>The Amazon Resource Names (ARN) of the target groups.</p>
    public let targetGroupArns: [Swift.String]?

    public init (
        loadBalancerArn: Swift.String? = nil,
        marker: Swift.String? = nil,
        names: [Swift.String]? = nil,
        pageSize: Swift.Int? = nil,
        targetGroupArns: [Swift.String]? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
        self.marker = marker
        self.names = names
        self.pageSize = pageSize
        self.targetGroupArns = targetGroupArns
    }
}

extension DescribeTargetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTargetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTargetGroupsOutputError: Swift.Error, Swift.Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTargetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTargetGroupsOutputResponse(nextMarker: \(Swift.String(describing: nextMarker)), targetGroups: \(Swift.String(describing: targetGroups)))"}
}

extension DescribeTargetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTargetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextMarker = output.nextMarker
            self.targetGroups = output.targetGroups
        } else {
            self.nextMarker = nil
            self.targetGroups = nil
        }
    }
}

public struct DescribeTargetGroupsOutputResponse: Swift.Equatable {
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: Swift.String?
    /// <p>Information about the target groups.</p>
    public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]?

    public init (
        nextMarker: Swift.String? = nil,
        targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.targetGroups = targetGroups
    }
}

struct DescribeTargetGroupsOutputResponseBody: Swift.Equatable {
    public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]?
    public let nextMarker: Swift.String?
}

extension DescribeTargetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextMarker = "NextMarker"
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTargetGroupsResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[ElasticLoadBalancingV2ClientTypes.TargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [ElasticLoadBalancingV2ClientTypes.TargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeTargetHealthInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetHealthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetHealthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetHealthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetHealthOutputError>
}

extension DescribeTargetHealthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTargetHealthInput(targetGroupArn: \(Swift.String(describing: targetGroupArn)), targets: \(Swift.String(describing: targets)))"}
}

extension DescribeTargetHealthInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let targets = targets {
            var targetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Targets"))
            for (index0, targetdescription0) in targets.enumerated() {
                try targetsContainer.encode(targetdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTargetHealth", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeTargetHealthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetHealthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetHealthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetHealthOutputError>
}

public struct DescribeTargetHealthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTargetHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTargetHealthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTargetHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTargetHealthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTargetHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTargetHealthOutputError>
}

public struct DescribeTargetHealthInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?
    /// <p>The targets.</p>
    public let targets: [ElasticLoadBalancingV2ClientTypes.TargetDescription]?

    public init (
        targetGroupArn: Swift.String? = nil,
        targets: [ElasticLoadBalancingV2ClientTypes.TargetDescription]? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.targets = targets
    }
}

extension DescribeTargetHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTargetHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "HealthUnavailableException" : self = .healthUnavailableException(try HealthUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTargetHealthOutputError: Swift.Error, Swift.Equatable {
    case healthUnavailableException(HealthUnavailableException)
    case invalidTargetException(InvalidTargetException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTargetHealthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTargetHealthOutputResponse(targetHealthDescriptions: \(Swift.String(describing: targetHealthDescriptions)))"}
}

extension DescribeTargetHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTargetHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetHealthDescriptions = output.targetHealthDescriptions
        } else {
            self.targetHealthDescriptions = nil
        }
    }
}

public struct DescribeTargetHealthOutputResponse: Swift.Equatable {
    /// <p>Information about the health of the targets.</p>
    public let targetHealthDescriptions: [ElasticLoadBalancingV2ClientTypes.TargetHealthDescription]?

    public init (
        targetHealthDescriptions: [ElasticLoadBalancingV2ClientTypes.TargetHealthDescription]? = nil
    )
    {
        self.targetHealthDescriptions = targetHealthDescriptions
    }
}

struct DescribeTargetHealthOutputResponseBody: Swift.Equatable {
    public let targetHealthDescriptions: [ElasticLoadBalancingV2ClientTypes.TargetHealthDescription]?
}

extension DescribeTargetHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetHealthDescriptions = "TargetHealthDescriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeTargetHealthResult"))
        if containerValues.contains(.targetHealthDescriptions) {
            struct KeyVal0{struct member{}}
            let targetHealthDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetHealthDescriptions)
            if let targetHealthDescriptionsWrappedContainer = targetHealthDescriptionsWrappedContainer {
                let targetHealthDescriptionsContainer = try targetHealthDescriptionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetHealthDescription].self, forKey: .member)
                var targetHealthDescriptionsBuffer:[ElasticLoadBalancingV2ClientTypes.TargetHealthDescription]? = nil
                if let targetHealthDescriptionsContainer = targetHealthDescriptionsContainer {
                    targetHealthDescriptionsBuffer = [ElasticLoadBalancingV2ClientTypes.TargetHealthDescription]()
                    for structureContainer0 in targetHealthDescriptionsContainer {
                        targetHealthDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                targetHealthDescriptions = targetHealthDescriptionsBuffer
            } else {
                targetHealthDescriptions = []
            }
        } else {
            targetHealthDescriptions = nil
        }
    }
}

extension DuplicateListenerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateListenerException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateListenerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DuplicateListenerExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A listener with the specified port already exists.</p>
public struct DuplicateListenerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateListenerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateListenerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateLoadBalancerNameException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateLoadBalancerNameException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateLoadBalancerNameException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DuplicateLoadBalancerNameExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A load balancer with the specified name already exists.</p>
public struct DuplicateLoadBalancerNameException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateLoadBalancerNameExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateLoadBalancerNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateTagKeysException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateTagKeysException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateTagKeysException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DuplicateTagKeysExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A tag key was specified more than once.</p>
public struct DuplicateTagKeysException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTagKeysExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateTagKeysExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateTargetGroupNameException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateTargetGroupNameException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateTargetGroupNameException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DuplicateTargetGroupNameExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A target group with the specified name already exists.</p>
public struct DuplicateTargetGroupNameException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTargetGroupNameExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateTargetGroupNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.FixedResponseActionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case messageBody = "MessageBody"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let contentType = contentType {
            try container.encode(contentType, forKey: ClientRuntime.Key("ContentType"))
        }
        if let messageBody = messageBody {
            try container.encode(messageBody, forKey: ClientRuntime.Key("MessageBody"))
        }
        if let statusCode = statusCode {
            try container.encode(statusCode, forKey: ClientRuntime.Key("StatusCode"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.FixedResponseActionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FixedResponseActionConfig(contentType: \(Swift.String(describing: contentType)), messageBody: \(Swift.String(describing: messageBody)), statusCode: \(Swift.String(describing: statusCode)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an action that returns a custom HTTP response.</p>
    public struct FixedResponseActionConfig: Swift.Equatable {
        /// <p>The content type.</p>
        ///          <p>Valid Values: text/plain | text/css | text/html | application/javascript |
        ///       application/json</p>
        public let contentType: Swift.String?
        /// <p>The message.</p>
        public let messageBody: Swift.String?
        /// <p>The HTTP response code (2XX, 4XX, or 5XX).</p>
        public let statusCode: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            messageBody: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.messageBody = messageBody
            self.statusCode = statusCode
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.ForwardActionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroupStickinessConfig = "TargetGroupStickinessConfig"
        case targetGroups = "TargetGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupStickinessConfig = targetGroupStickinessConfig {
            try container.encode(targetGroupStickinessConfig, forKey: ClientRuntime.Key("TargetGroupStickinessConfig"))
        }
        if let targetGroups = targetGroups {
            var targetGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TargetGroups"))
            for (index0, targetgrouptuple0) in targetGroups.enumerated() {
                try targetGroupsContainer.encode(targetgrouptuple0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetGroupTuple].self, forKey: .member)
                var targetGroupsBuffer:[ElasticLoadBalancingV2ClientTypes.TargetGroupTuple]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [ElasticLoadBalancingV2ClientTypes.TargetGroupTuple]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let targetGroupStickinessConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.TargetGroupStickinessConfig.self, forKey: .targetGroupStickinessConfig)
        targetGroupStickinessConfig = targetGroupStickinessConfigDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.ForwardActionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForwardActionConfig(targetGroupStickinessConfig: \(Swift.String(describing: targetGroupStickinessConfig)), targetGroups: \(Swift.String(describing: targetGroups)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a forward action.</p>
    public struct ForwardActionConfig: Swift.Equatable {
        /// <p>The target group stickiness for the rule.</p>
        public let targetGroupStickinessConfig: ElasticLoadBalancingV2ClientTypes.TargetGroupStickinessConfig?
        /// <p>One or more target groups. For Network Load Balancers, you can specify a single target
        ///       group.</p>
        public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroupTuple]?

        public init (
            targetGroupStickinessConfig: ElasticLoadBalancingV2ClientTypes.TargetGroupStickinessConfig? = nil,
            targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroupTuple]? = nil
        )
        {
            self.targetGroupStickinessConfig = targetGroupStickinessConfig
            self.targetGroups = targetGroups
        }
    }

}

extension HealthUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension HealthUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<HealthUnavailableExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The health of the specified targets could not be retrieved due to an internal
///       error.</p>
public struct HealthUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HealthUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HealthUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.HostHeaderConditionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.HostHeaderConditionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HostHeaderConditionConfig(values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a host header condition.</p>
    public struct HostHeaderConditionConfig: Swift.Equatable {
        /// <p>One or more host names. The maximum size of each name is 128 characters. The comparison is
        ///       case insensitive. The following wildcard characters are supported: * (matches 0 or more
        ///       characters) and ? (matches exactly 1 character).</p>
        ///          <p>If you specify multiple strings, the condition is satisfied if one of the strings matches
        ///       the host name.</p>
        public let values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.HttpHeaderConditionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpHeaderName = "HttpHeaderName"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let httpHeaderName = httpHeaderName {
            try container.encode(httpHeaderName, forKey: ClientRuntime.Key("HttpHeaderName"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpHeaderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpHeaderName)
        httpHeaderName = httpHeaderNameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.HttpHeaderConditionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpHeaderConditionConfig(httpHeaderName: \(Swift.String(describing: httpHeaderName)), values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an HTTP header condition.</p>
    ///          <p>There is a set of standard HTTP header fields. You can also define custom HTTP header
    ///       fields.</p>
    public struct HttpHeaderConditionConfig: Swift.Equatable {
        /// <p>The name of the HTTP header field. The maximum size is 40 characters. The header name is
        ///       case insensitive. The allowed characters are specified by RFC 7230. Wildcards are not
        ///       supported.</p>
        ///          <p>You can't use an HTTP header condition to specify the host header. Use <a>HostHeaderConditionConfig</a> to specify a host header condition.</p>
        public let httpHeaderName: Swift.String?
        /// <p>One or more strings to compare against the value of the HTTP header. The maximum size of
        ///       each string is 128 characters. The comparison strings are case insensitive. The following
        ///       wildcard characters are supported: * (matches 0 or more characters) and ? (matches exactly 1
        ///       character).</p>
        ///          <p>If the same header appears multiple times in the request, we search them in order until a
        ///       match is found.</p>
        ///          <p>If you specify multiple strings, the condition is satisfied if one of the strings matches
        ///       the value of the HTTP header. To require that all of the strings are a match, create one
        ///       condition per string.</p>
        public let values: [Swift.String]?

        public init (
            httpHeaderName: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.httpHeaderName = httpHeaderName
            self.values = values
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.HttpRequestMethodConditionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.HttpRequestMethodConditionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HttpRequestMethodConditionConfig(values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an HTTP method condition.</p>
    ///          <p>HTTP defines a set of request methods, also referred to as HTTP verbs. For more
    ///       information, see the <a href="https://www.iana.org/assignments/http-methods/http-methods.xhtml">HTTP Method
    ///         Registry</a>. You can also define custom HTTP methods.</p>
    public struct HttpRequestMethodConditionConfig: Swift.Equatable {
        /// <p>The name of the request method. The maximum size is 40 characters. The allowed characters
        ///       are A-Z, hyphen (-), and underscore (_). The comparison is case sensitive. Wildcards are not
        ///       supported; therefore, the method name must be an exact match.</p>
        ///          <p>If you specify multiple strings, the condition is satisfied if one of the strings matches
        ///       the HTTP request method. We recommend that you route GET and HEAD requests in the same way,
        ///       because the response to a HEAD request may be cached.</p>
        public let values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension IncompatibleProtocolsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleProtocolsException(message: \(Swift.String(describing: message)))"}
}

extension IncompatibleProtocolsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IncompatibleProtocolsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration is not valid with this protocol.</p>
public struct IncompatibleProtocolsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleProtocolsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatibleProtocolsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidConfigurationRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidConfigurationRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidConfigurationRequestExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested configuration is not valid.</p>
public struct InvalidConfigurationRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidConfigurationRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLoadBalancerActionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLoadBalancerActionException(message: \(Swift.String(describing: message)))"}
}

extension InvalidLoadBalancerActionException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidLoadBalancerActionExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested action is not valid.</p>
public struct InvalidLoadBalancerActionException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLoadBalancerActionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLoadBalancerActionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSchemeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidSchemeException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSchemeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested scheme is not valid.</p>
public struct InvalidSchemeException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSchemeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSchemeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSecurityGroupException(message: \(Swift.String(describing: message)))"}
}

extension InvalidSecurityGroupException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSecurityGroupExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified security group does not exist.</p>
public struct InvalidSecurityGroupException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityGroupExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSecurityGroupExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnetException(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnetException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidSubnetExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet is out of available addresses.</p>
public struct InvalidSubnetException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTargetException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTargetException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidTargetExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target does not exist, is not in the same VPC as the target group, or has an
///       unsupported instance type.</p>
public struct InvalidTargetException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTargetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dualstack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .dualstack,
                .ipv4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "dualstack"
            case .ipv4: return "ipv4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.Limit: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let max = max {
            try container.encode(max, forKey: ClientRuntime.Key("Max"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .max)
        max = maxDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Limit: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Limit(max: \(Swift.String(describing: max)), name: \(Swift.String(describing: name)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about an Elastic Load Balancing resource limit for your AWS account.</p>
    public struct Limit: Swift.Equatable {
        /// <p>The maximum value of the limit.</p>
        public let max: Swift.String?
        /// <p>The name of the limit. The possible values are:</p>
        ///          <ul>
        ///             <li>
        ///                <p>application-load-balancers</p>
        ///             </li>
        ///             <li>
        ///                <p>condition-values-per-alb-rule</p>
        ///             </li>
        ///             <li>
        ///                <p>condition-wildcards-per-alb-rule</p>
        ///             </li>
        ///             <li>
        ///                <p>gateway-load-balancers</p>
        ///             </li>
        ///             <li>
        ///                <p>gateway-load-balancers-per-vpc</p>
        ///             </li>
        ///             <li>
        ///                <p>geneve-target-groups</p>
        ///             </li>
        ///             <li>
        ///                <p>listeners-per-application-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>listeners-per-network-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>network-load-balancers</p>
        ///             </li>
        ///             <li>
        ///                <p>rules-per-application-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>target-groups</p>
        ///             </li>
        ///             <li>
        ///                <p>target-groups-per-action-on-application-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>target-groups-per-action-on-network-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>target-groups-per-application-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>targets-per-application-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>targets-per-availability-zone-per-gateway-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>targets-per-availability-zone-per-network-load-balancer</p>
        ///             </li>
        ///             <li>
        ///                <p>targets-per-network-load-balancer</p>
        ///             </li>
        ///          </ul>
        public let name: Swift.String?

        public init (
            max: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.max = max
            self.name = name
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.Listener: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alpnPolicy = "AlpnPolicy"
        case certificates = "Certificates"
        case defaultActions = "DefaultActions"
        case listenerArn = "ListenerArn"
        case loadBalancerArn = "LoadBalancerArn"
        case port = "Port"
        case `protocol` = "Protocol"
        case sslPolicy = "SslPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let alpnPolicy = alpnPolicy {
            var alpnPolicyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AlpnPolicy"))
            for (index0, alpnpolicyvalue0) in alpnPolicy.enumerated() {
                try alpnPolicyContainer.encode(alpnpolicyvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultActions = defaultActions {
            var defaultActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DefaultActions"))
            for (index0, action0) in defaultActions.enumerated() {
                try defaultActionsContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let sslPolicy = sslPolicy {
            try container.encode(sslPolicy, forKey: ClientRuntime.Key("SslPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let loadBalancerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerArn)
        loadBalancerArn = loadBalancerArnDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.ProtocolEnum.self, forKey: .protocol)
        `protocol` = protocolDecoded
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Certificate].self, forKey: .member)
                var certificatesBuffer:[ElasticLoadBalancingV2ClientTypes.Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [ElasticLoadBalancingV2ClientTypes.Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let sslPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslPolicy)
        sslPolicy = sslPolicyDecoded
        if containerValues.contains(.defaultActions) {
            struct KeyVal0{struct member{}}
            let defaultActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .defaultActions)
            if let defaultActionsWrappedContainer = defaultActionsWrappedContainer {
                let defaultActionsContainer = try defaultActionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Action].self, forKey: .member)
                var defaultActionsBuffer:[ElasticLoadBalancingV2ClientTypes.Action]? = nil
                if let defaultActionsContainer = defaultActionsContainer {
                    defaultActionsBuffer = [ElasticLoadBalancingV2ClientTypes.Action]()
                    for structureContainer0 in defaultActionsContainer {
                        defaultActionsBuffer?.append(structureContainer0)
                    }
                }
                defaultActions = defaultActionsBuffer
            } else {
                defaultActions = []
            }
        } else {
            defaultActions = nil
        }
        if containerValues.contains(.alpnPolicy) {
            struct KeyVal0{struct member{}}
            let alpnPolicyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alpnPolicy)
            if let alpnPolicyWrappedContainer = alpnPolicyWrappedContainer {
                let alpnPolicyContainer = try alpnPolicyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var alpnPolicyBuffer:[Swift.String]? = nil
                if let alpnPolicyContainer = alpnPolicyContainer {
                    alpnPolicyBuffer = [Swift.String]()
                    for stringContainer0 in alpnPolicyContainer {
                        alpnPolicyBuffer?.append(stringContainer0)
                    }
                }
                alpnPolicy = alpnPolicyBuffer
            } else {
                alpnPolicy = []
            }
        } else {
            alpnPolicy = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.Listener: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Listener(alpnPolicy: \(Swift.String(describing: alpnPolicy)), certificates: \(Swift.String(describing: certificates)), defaultActions: \(Swift.String(describing: defaultActions)), listenerArn: \(Swift.String(describing: listenerArn)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), port: \(Swift.String(describing: port)), protocol: \(Swift.String(describing: `protocol`)), sslPolicy: \(Swift.String(describing: sslPolicy)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a listener.</p>
    public struct Listener: Swift.Equatable {
        /// <p>The protocol for connections from clients to the load balancer.</p>
        public let `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
        /// <p>[TLS listener] The name of the Application-Layer Protocol Negotiation (ALPN)
        ///       policy.</p>
        public let alpnPolicy: [Swift.String]?
        /// <p>[HTTPS or TLS listener] The default certificate for the listener.</p>
        public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
        /// <p>The default actions for the listener.</p>
        public let defaultActions: [ElasticLoadBalancingV2ClientTypes.Action]?
        /// <p>The Amazon Resource Name (ARN) of the listener.</p>
        public let listenerArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        public let loadBalancerArn: Swift.String?
        /// <p>The port on which the load balancer is listening.</p>
        public let port: Swift.Int?
        /// <p>[HTTPS or TLS listener] The security policy that defines which protocols and ciphers are
        ///       supported.</p>
        public let sslPolicy: Swift.String?

        public init (
            `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
            alpnPolicy: [Swift.String]? = nil,
            certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil,
            defaultActions: [ElasticLoadBalancingV2ClientTypes.Action]? = nil,
            listenerArn: Swift.String? = nil,
            loadBalancerArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            sslPolicy: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.alpnPolicy = alpnPolicy
            self.certificates = certificates
            self.defaultActions = defaultActions
            self.listenerArn = listenerArn
            self.loadBalancerArn = loadBalancerArn
            self.port = port
            self.sslPolicy = sslPolicy
        }
    }

}

extension ListenerNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListenerNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ListenerNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ListenerNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified listener does not exist.</p>
public struct ListenerNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ListenerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case canonicalHostedZoneId = "CanonicalHostedZoneId"
        case createdTime = "CreatedTime"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case dNSName = "DNSName"
        case ipAddressType = "IpAddressType"
        case loadBalancerArn = "LoadBalancerArn"
        case loadBalancerName = "LoadBalancerName"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case state = "State"
        case type = "Type"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let canonicalHostedZoneId = canonicalHostedZoneId {
            try container.encode(canonicalHostedZoneId, forKey: ClientRuntime.Key("CanonicalHostedZoneId"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("createdTime"))
        }
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try container.encode(customerOwnedIpv4Pool, forKey: ClientRuntime.Key("CustomerOwnedIpv4Pool"))
        }
        if let dNSName = dNSName {
            try container.encode(dNSName, forKey: ClientRuntime.Key("DNSName"))
        }
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: ClientRuntime.Key("IpAddressType"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: ClientRuntime.Key("LoadBalancerName"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: ClientRuntime.Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerArn)
        loadBalancerArn = loadBalancerArnDecoded
        let dNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let canonicalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canonicalHostedZoneId)
        canonicalHostedZoneId = canonicalHostedZoneIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.LoadBalancerSchemeEnum.self, forKey: .scheme)
        scheme = schemeDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.LoadBalancerState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.LoadBalancerTypeEnum.self, forKey: .type)
        type = typeDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[ElasticLoadBalancingV2ClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoadBalancer(availabilityZones: \(Swift.String(describing: availabilityZones)), canonicalHostedZoneId: \(Swift.String(describing: canonicalHostedZoneId)), createdTime: \(Swift.String(describing: createdTime)), customerOwnedIpv4Pool: \(Swift.String(describing: customerOwnedIpv4Pool)), dNSName: \(Swift.String(describing: dNSName)), ipAddressType: \(Swift.String(describing: ipAddressType)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), loadBalancerName: \(Swift.String(describing: loadBalancerName)), scheme: \(Swift.String(describing: scheme)), securityGroups: \(Swift.String(describing: securityGroups)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a load balancer.</p>
    public struct LoadBalancer: Swift.Equatable {
        /// <p>The subnets for the load balancer.</p>
        public let availabilityZones: [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]?
        /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
        public let canonicalHostedZoneId: Swift.String?
        /// <p>The date and time the load balancer was created.</p>
        public let createdTime: ClientRuntime.Date?
        /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
        public let customerOwnedIpv4Pool: Swift.String?
        /// <p>The public DNS name of the load balancer.</p>
        public let dNSName: Swift.String?
        /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
        ///       are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
        ///       addresses).</p>
        public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?
        /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
        public let loadBalancerArn: Swift.String?
        /// <p>The name of the load balancer.</p>
        public let loadBalancerName: Swift.String?
        /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an
        ///       Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
        ///       Therefore, Internet-facing load balancers can route requests from clients over the
        ///       internet.</p>
        ///          <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an
        ///       internal load balancer is publicly resolvable to the private IP addresses of the nodes.
        ///       Therefore, internal load balancers can route requests only from clients with access to the VPC
        ///       for the load balancer.</p>
        public let scheme: ElasticLoadBalancingV2ClientTypes.LoadBalancerSchemeEnum?
        /// <p>The IDs of the security groups for the load balancer.</p>
        public let securityGroups: [Swift.String]?
        /// <p>The state of the load balancer.</p>
        public let state: ElasticLoadBalancingV2ClientTypes.LoadBalancerState?
        /// <p>The type of load balancer.</p>
        public let type: ElasticLoadBalancingV2ClientTypes.LoadBalancerTypeEnum?
        /// <p>The ID of the VPC for the load balancer.</p>
        public let vpcId: Swift.String?

        public init (
            availabilityZones: [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]? = nil,
            canonicalHostedZoneId: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            customerOwnedIpv4Pool: Swift.String? = nil,
            dNSName: Swift.String? = nil,
            ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType? = nil,
            loadBalancerArn: Swift.String? = nil,
            loadBalancerName: Swift.String? = nil,
            scheme: ElasticLoadBalancingV2ClientTypes.LoadBalancerSchemeEnum? = nil,
            securityGroups: [Swift.String]? = nil,
            state: ElasticLoadBalancingV2ClientTypes.LoadBalancerState? = nil,
            type: ElasticLoadBalancingV2ClientTypes.LoadBalancerTypeEnum? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
            self.dNSName = dNSName
            self.ipAddressType = ipAddressType
            self.loadBalancerArn = loadBalancerArn
            self.loadBalancerName = loadBalancerName
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.type = type
            self.vpcId = vpcId
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocationId = "AllocationId"
        case iPv6Address = "IPv6Address"
        case ipAddress = "IpAddress"
        case privateIPv4Address = "PrivateIPv4Address"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocationId = allocationId {
            try container.encode(allocationId, forKey: ClientRuntime.Key("AllocationId"))
        }
        if let iPv6Address = iPv6Address {
            try container.encode(iPv6Address, forKey: ClientRuntime.Key("IPv6Address"))
        }
        if let ipAddress = ipAddress {
            try container.encode(ipAddress, forKey: ClientRuntime.Key("IpAddress"))
        }
        if let privateIPv4Address = privateIPv4Address {
            try container.encode(privateIPv4Address, forKey: ClientRuntime.Key("PrivateIPv4Address"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let allocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allocationId)
        allocationId = allocationIdDecoded
        let privateIPv4AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIPv4Address)
        privateIPv4Address = privateIPv4AddressDecoded
        let iPv6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iPv6Address)
        iPv6Address = iPv6AddressDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancerAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoadBalancerAddress(allocationId: \(Swift.String(describing: allocationId)), iPv6Address: \(Swift.String(describing: iPv6Address)), ipAddress: \(Swift.String(describing: ipAddress)), privateIPv4Address: \(Swift.String(describing: privateIPv4Address)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a static IP address for a load balancer.</p>
    public struct LoadBalancerAddress: Swift.Equatable {
        /// <p>[Network Load Balancers] The allocation ID of the Elastic IP address for an
        ///       internal-facing load balancer.</p>
        public let allocationId: Swift.String?
        /// <p>[Network Load Balancers] The IPv6 address.</p>
        public let iPv6Address: Swift.String?
        /// <p>The static IP address.</p>
        public let ipAddress: Swift.String?
        /// <p>[Network Load Balancers] The private IPv4 address for an internal load balancer.</p>
        public let privateIPv4Address: Swift.String?

        public init (
            allocationId: Swift.String? = nil,
            iPv6Address: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            privateIPv4Address: Swift.String? = nil
        )
        {
            self.allocationId = allocationId
            self.iPv6Address = iPv6Address
            self.ipAddress = ipAddress
            self.privateIPv4Address = privateIPv4Address
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoadBalancerAttribute(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a load balancer attribute.</p>
    public struct LoadBalancerAttribute: Swift.Equatable {
        /// <p>The name of the attribute.</p>
        ///
        ///          <p>The following attribute is supported by all load balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>deletion_protection.enabled</code> - Indicates whether deletion protection is
        ///           enabled. The value is <code>true</code> or <code>false</code>. The default is
        ///             <code>false</code>.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attributes are supported by both Application Load Balancers and Network Load
        ///       Balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>access_logs.s3.enabled</code> - Indicates whether access logs are enabled. The
        ///           value is <code>true</code> or <code>false</code>. The default is
        ///           <code>false</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>access_logs.s3.bucket</code> - The name of the S3 bucket for the access logs.
        ///           This attribute is required if access logs are enabled. The bucket must exist in the same
        ///           region as the load balancer and have a bucket policy that grants Elastic Load Balancing
        ///           permissions to write to the bucket.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>access_logs.s3.prefix</code> - The prefix for the location in the S3 bucket for the
        ///           access logs.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attributes are supported by only Application Load Balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>idle_timeout.timeout_seconds</code> - The idle timeout value, in seconds. The
        ///           valid range is 1-4000 seconds. The default is 60 seconds.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>routing.http.desync_mitigation_mode</code> - Determines how the load balancer
        ///           handles requests that might pose a security risk to your application. The possible values
        ///           are <code>monitor</code>, <code>defensive</code>, and <code>strictest</code>. The default
        ///           is <code>defensive</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>routing.http.drop_invalid_header_fields.enabled</code> - Indicates whether HTTP
        ///           headers with invalid header fields are removed by the load balancer (<code>true</code>) or
        ///           routed to targets (<code>false</code>). The default is <code>false</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>routing.http2.enabled</code> - Indicates whether HTTP/2 is enabled. The value is
        ///             <code>true</code> or <code>false</code>. The default is <code>true</code>. Elastic Load
        ///           Balancing requires that message header names contain only alphanumeric characters and
        ///           hyphens.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>waf.fail_open.enabled</code> - Indicates whether to allow a WAF-enabled load
        ///           balancer to route requests to targets if it is unable to forward the request to AWS WAF.
        ///           The value is <code>true</code> or <code>false</code>. The default is
        ///           <code>false</code>.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attribute is supported by Network Load Balancers and Gateway Load
        ///       Balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>load_balancing.cross_zone.enabled</code> - Indicates whether cross-zone load
        ///           balancing is enabled. The value is <code>true</code> or <code>false</code>. The default is
        ///             <code>false</code>.</p>
        ///             </li>
        ///          </ul>
        public let key: Swift.String?
        /// <p>The value of the attribute.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension LoadBalancerNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoadBalancerNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension LoadBalancerNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<LoadBalancerNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified load balancer does not exist.</p>
public struct LoadBalancerNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LoadBalancerNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LoadBalancerNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum LoadBalancerSchemeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `internal`
        case internetFacing
        case sdkUnknown(Swift.String)

        public static var allCases: [LoadBalancerSchemeEnum] {
            return [
                .internal,
                .internetFacing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internal: return "internal"
            case .internetFacing: return "internet-facing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoadBalancerSchemeEnum(rawValue: rawValue) ?? LoadBalancerSchemeEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancerState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.LoadBalancerStateEnum.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.LoadBalancerState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoadBalancerState(code: \(Swift.String(describing: code)), reason: \(Swift.String(describing: reason)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about the state of the load balancer.</p>
    public struct LoadBalancerState: Swift.Equatable {
        /// <p>The state code. The initial state of the load balancer is <code>provisioning</code>. After
        ///       the load balancer is fully set up and ready to route traffic, its state is
        ///       <code>active</code>. If load balancer is routing traffic but does not have the resources it
        ///       needs to scale, its state is<code>active_impaired</code>. If the load balancer could not be
        ///       set up, its state is <code>failed</code>.</p>
        public let code: ElasticLoadBalancingV2ClientTypes.LoadBalancerStateEnum?
        /// <p>A description of the state.</p>
        public let reason: Swift.String?

        public init (
            code: ElasticLoadBalancingV2ClientTypes.LoadBalancerStateEnum? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes {
    public enum LoadBalancerStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case activeImpaired
        case failed
        case provisioning
        case sdkUnknown(Swift.String)

        public static var allCases: [LoadBalancerStateEnum] {
            return [
                .active,
                .activeImpaired,
                .failed,
                .provisioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "active"
            case .activeImpaired: return "active_impaired"
            case .failed: return "failed"
            case .provisioning: return "provisioning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoadBalancerStateEnum(rawValue: rawValue) ?? LoadBalancerStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum LoadBalancerTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case gateway
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [LoadBalancerTypeEnum] {
            return [
                .application,
                .gateway,
                .network,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "application"
            case .gateway: return "gateway"
            case .network: return "network"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoadBalancerTypeEnum(rawValue: rawValue) ?? LoadBalancerTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.Matcher: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grpcCode = "GrpcCode"
        case httpCode = "HttpCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let grpcCode = grpcCode {
            try container.encode(grpcCode, forKey: ClientRuntime.Key("GrpcCode"))
        }
        if let httpCode = httpCode {
            try container.encode(httpCode, forKey: ClientRuntime.Key("HttpCode"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpCode)
        httpCode = httpCodeDecoded
        let grpcCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grpcCode)
        grpcCode = grpcCodeDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Matcher: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Matcher(grpcCode: \(Swift.String(describing: grpcCode)), httpCode: \(Swift.String(describing: httpCode)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>The codes to use when checking for a successful response from a target. If the protocol
    ///       version is gRPC, these are gRPC codes. Otherwise, these are HTTP codes.</p>
    public struct Matcher: Swift.Equatable {
        /// <p>You can specify values between 0 and 99. You can specify multiple values (for example,
        ///       "0,1") or a range of values (for example, "0-5"). The default value is 12.</p>
        public let grpcCode: Swift.String?
        /// <p>For Application Load Balancers, you can specify values between 200 and 499, and the
        ///       default value is 200. You can specify multiple values (for example, "200,202") or a range of
        ///       values (for example, "200-299").</p>
        ///          <p>For Network Load Balancers and Gateway Load Balancers, this must be "200–399".</p>
        public let httpCode: Swift.String?

        public init (
            grpcCode: Swift.String? = nil,
            httpCode: Swift.String? = nil
        )
        {
            self.grpcCode = grpcCode
            self.httpCode = httpCode
        }
    }

}

public struct ModifyListenerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyListenerOutputError>
}

extension ModifyListenerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyListenerInput(alpnPolicy: \(Swift.String(describing: alpnPolicy)), certificates: \(Swift.String(describing: certificates)), defaultActions: \(Swift.String(describing: defaultActions)), listenerArn: \(Swift.String(describing: listenerArn)), port: \(Swift.String(describing: port)), protocol: \(Swift.String(describing: `protocol`)), sslPolicy: \(Swift.String(describing: sslPolicy)))"}
}

extension ModifyListenerInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let alpnPolicy = alpnPolicy {
            var alpnPolicyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AlpnPolicy"))
            for (index0, alpnpolicyvalue0) in alpnPolicy.enumerated() {
                try alpnPolicyContainer.encode(alpnpolicyvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultActions = defaultActions {
            var defaultActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DefaultActions"))
            for (index0, action0) in defaultActions.enumerated() {
                try defaultActionsContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let sslPolicy = sslPolicy {
            try container.encode(sslPolicy, forKey: ClientRuntime.Key("SslPolicy"))
        }
        try container.encode("ModifyListener", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyListenerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyListenerOutputError>
}

public struct ModifyListenerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyListenerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyListenerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyListenerOutputError>
}

public struct ModifyListenerInput: Swift.Equatable {
    /// <p>The protocol for connections from clients to the load balancer. Application Load Balancers
    ///       support the HTTP and HTTPS protocols. Network Load Balancers support the TCP, TLS, UDP, and
    ///       TCP_UDP protocols. You can’t change the protocol to UDP or TCP_UDP if dual-stack mode is
    ///       enabled. You cannot specify a protocol for a Gateway Load Balancer.</p>
    public let `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
    /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
    ///       can specify one policy name. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP1Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Optional</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Preferred</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>None</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
    ///         policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let alpnPolicy: [Swift.String]?
    /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
    ///       exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
    ///         <code>IsDefault</code>.</p>
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
    /// <p>The actions for the default rule.</p>
    public let defaultActions: [ElasticLoadBalancingV2ClientTypes.Action]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?
    /// <p>The port for connections from clients to the load balancer. You cannot specify a port for
    ///       a Gateway Load Balancer.</p>
    public let port: Swift.Int?
    /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
    ///       supported.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> or
    ///         <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let sslPolicy: Swift.String?

    public init (
        `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
        alpnPolicy: [Swift.String]? = nil,
        certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil,
        defaultActions: [ElasticLoadBalancingV2ClientTypes.Action]? = nil,
        listenerArn: Swift.String? = nil,
        port: Swift.Int? = nil,
        sslPolicy: Swift.String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.alpnPolicy = alpnPolicy
        self.certificates = certificates
        self.defaultActions = defaultActions
        self.listenerArn = listenerArn
        self.port = port
        self.sslPolicy = sslPolicy
    }
}

extension ModifyListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ALPNPolicyNotSupportedException" : self = .aLPNPolicyNotSupportedException(try ALPNPolicyNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateListenerException" : self = .duplicateListenerException(try DuplicateListenerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SSLPolicyNotFoundException" : self = .sSLPolicyNotFoundException(try SSLPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificatesException" : self = .tooManyCertificatesException(try TooManyCertificatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyListenersException" : self = .tooManyListenersException(try TooManyListenersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyListenerOutputError: Swift.Error, Swift.Equatable {
    case aLPNPolicyNotSupportedException(ALPNPolicyNotSupportedException)
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateListenerException(DuplicateListenerException)
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case listenerNotFoundException(ListenerNotFoundException)
    case sSLPolicyNotFoundException(SSLPolicyNotFoundException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyCertificatesException(TooManyCertificatesException)
    case tooManyListenersException(TooManyListenersException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyListenerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyListenerOutputResponse(listeners: \(Swift.String(describing: listeners)))"}
}

extension ModifyListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.listeners = output.listeners
        } else {
            self.listeners = nil
        }
    }
}

public struct ModifyListenerOutputResponse: Swift.Equatable {
    /// <p>Information about the modified listener.</p>
    public let listeners: [ElasticLoadBalancingV2ClientTypes.Listener]?

    public init (
        listeners: [ElasticLoadBalancingV2ClientTypes.Listener]? = nil
    )
    {
        self.listeners = listeners
    }
}

struct ModifyListenerOutputResponseBody: Swift.Equatable {
    public let listeners: [ElasticLoadBalancingV2ClientTypes.Listener]?
}

extension ModifyListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listeners = "Listeners"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyListenerResult"))
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Listener].self, forKey: .member)
                var listenersBuffer:[ElasticLoadBalancingV2ClientTypes.Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [ElasticLoadBalancingV2ClientTypes.Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
    }
}

public struct ModifyLoadBalancerAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyLoadBalancerAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyLoadBalancerAttributesOutputError>
}

extension ModifyLoadBalancerAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyLoadBalancerAttributesInput(attributes: \(Swift.String(describing: attributes)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)))"}
}

extension ModifyLoadBalancerAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, loadbalancerattribute0) in attributes.enumerated() {
                try attributesContainer.encode(loadbalancerattribute0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        try container.encode("ModifyLoadBalancerAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyLoadBalancerAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyLoadBalancerAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyLoadBalancerAttributesOutputError>
}

public struct ModifyLoadBalancerAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyLoadBalancerAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyLoadBalancerAttributesOutputError>
}

public struct ModifyLoadBalancerAttributesInput: Swift.Equatable {
    /// <p>The load balancer attributes.</p>
    public let attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?

    public init (
        attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]? = nil,
        loadBalancerArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.loadBalancerArn = loadBalancerArn
    }
}

extension ModifyLoadBalancerAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyLoadBalancerAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyLoadBalancerAttributesOutputError: Swift.Error, Swift.Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLoadBalancerAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyLoadBalancerAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension ModifyLoadBalancerAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct ModifyLoadBalancerAttributesOutputResponse: Swift.Equatable {
    /// <p>Information about the load balancer attributes.</p>
    public let attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]?

    public init (
        attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct ModifyLoadBalancerAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]?
}

extension ModifyLoadBalancerAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyLoadBalancerAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute].self, forKey: .member)
                var attributesBuffer:[ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [ElasticLoadBalancingV2ClientTypes.LoadBalancerAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct ModifyRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyRuleOutputError>
}

extension ModifyRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyRuleInput(actions: \(Swift.String(describing: actions)), conditions: \(Swift.String(describing: conditions)), ruleArn: \(Swift.String(describing: ruleArn)))"}
}

extension ModifyRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Actions"))
            for (index0, action0) in actions.enumerated() {
                try actionsContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let conditions = conditions {
            var conditionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Conditions"))
            for (index0, rulecondition0) in conditions.enumerated() {
                try conditionsContainer.encode(rulecondition0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: ClientRuntime.Key("RuleArn"))
        }
        try container.encode("ModifyRule", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyRuleOutputError>
}

public struct ModifyRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyRuleOutputError>
}

public struct ModifyRuleInput: Swift.Equatable {
    /// <p>The actions.</p>
    public let actions: [ElasticLoadBalancingV2ClientTypes.Action]?
    /// <p>The conditions.</p>
    public let conditions: [ElasticLoadBalancingV2ClientTypes.RuleCondition]?
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: Swift.String?

    public init (
        actions: [ElasticLoadBalancingV2ClientTypes.Action]? = nil,
        conditions: [ElasticLoadBalancingV2ClientTypes.RuleCondition]? = nil,
        ruleArn: Swift.String? = nil
    )
    {
        self.actions = actions
        self.conditions = conditions
        self.ruleArn = ruleArn
    }
}

extension ModifyRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyRuleOutputError: Swift.Error, Swift.Equatable {
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case operationNotPermittedException(OperationNotPermittedException)
    case ruleNotFoundException(RuleNotFoundException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyRuleOutputResponse(rules: \(Swift.String(describing: rules)))"}
}

extension ModifyRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ModifyRuleOutputResponse: Swift.Equatable {
    /// <p>Information about the modified rule.</p>
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?

    public init (
        rules: [ElasticLoadBalancingV2ClientTypes.Rule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ModifyRuleOutputResponseBody: Swift.Equatable {
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?
}

extension ModifyRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyRuleResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Rule].self, forKey: .member)
                var rulesBuffer:[ElasticLoadBalancingV2ClientTypes.Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ElasticLoadBalancingV2ClientTypes.Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct ModifyTargetGroupAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyTargetGroupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyTargetGroupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyTargetGroupAttributesOutputError>
}

extension ModifyTargetGroupAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyTargetGroupAttributesInput(attributes: \(Swift.String(describing: attributes)), targetGroupArn: \(Swift.String(describing: targetGroupArn)))"}
}

extension ModifyTargetGroupAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, targetgroupattribute0) in attributes.enumerated() {
                try attributesContainer.encode(targetgroupattribute0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        try container.encode("ModifyTargetGroupAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyTargetGroupAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyTargetGroupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyTargetGroupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyTargetGroupAttributesOutputError>
}

public struct ModifyTargetGroupAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyTargetGroupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyTargetGroupAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyTargetGroupAttributesOutputError>
}

public struct ModifyTargetGroupAttributesInput: Swift.Equatable {
    /// <p>The attributes.</p>
    public let attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]?
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?

    public init (
        attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]? = nil,
        targetGroupArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.targetGroupArn = targetGroupArn
    }
}

extension ModifyTargetGroupAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyTargetGroupAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyTargetGroupAttributesOutputError: Swift.Error, Swift.Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyTargetGroupAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyTargetGroupAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension ModifyTargetGroupAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyTargetGroupAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct ModifyTargetGroupAttributesOutputResponse: Swift.Equatable {
    /// <p>Information about the attributes.</p>
    public let attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]?

    public init (
        attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct ModifyTargetGroupAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]?
}

extension ModifyTargetGroupAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyTargetGroupAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute].self, forKey: .member)
                var attributesBuffer:[ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct ModifyTargetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyTargetGroupOutputError>
}

extension ModifyTargetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyTargetGroupInput(healthCheckEnabled: \(Swift.String(describing: healthCheckEnabled)), healthCheckIntervalSeconds: \(Swift.String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(Swift.String(describing: healthCheckPath)), healthCheckPort: \(Swift.String(describing: healthCheckPort)), healthCheckProtocol: \(Swift.String(describing: healthCheckProtocol)), healthCheckTimeoutSeconds: \(Swift.String(describing: healthCheckTimeoutSeconds)), healthyThresholdCount: \(Swift.String(describing: healthyThresholdCount)), matcher: \(Swift.String(describing: matcher)), targetGroupArn: \(Swift.String(describing: targetGroupArn)), unhealthyThresholdCount: \(Swift.String(describing: unhealthyThresholdCount)))"}
}

extension ModifyTargetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthCheckEnabled = healthCheckEnabled {
            try container.encode(healthCheckEnabled, forKey: ClientRuntime.Key("HealthCheckEnabled"))
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try container.encode(healthCheckIntervalSeconds, forKey: ClientRuntime.Key("HealthCheckIntervalSeconds"))
        }
        if let healthCheckPath = healthCheckPath {
            try container.encode(healthCheckPath, forKey: ClientRuntime.Key("HealthCheckPath"))
        }
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: ClientRuntime.Key("HealthCheckPort"))
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try container.encode(healthCheckProtocol, forKey: ClientRuntime.Key("HealthCheckProtocol"))
        }
        if let healthCheckTimeoutSeconds = healthCheckTimeoutSeconds {
            try container.encode(healthCheckTimeoutSeconds, forKey: ClientRuntime.Key("HealthCheckTimeoutSeconds"))
        }
        if let healthyThresholdCount = healthyThresholdCount {
            try container.encode(healthyThresholdCount, forKey: ClientRuntime.Key("HealthyThresholdCount"))
        }
        if let matcher = matcher {
            try container.encode(matcher, forKey: ClientRuntime.Key("Matcher"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let unhealthyThresholdCount = unhealthyThresholdCount {
            try container.encode(unhealthyThresholdCount, forKey: ClientRuntime.Key("UnhealthyThresholdCount"))
        }
        try container.encode("ModifyTargetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyTargetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyTargetGroupOutputError>
}

public struct ModifyTargetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyTargetGroupOutputError>
}

public struct ModifyTargetGroupInput: Swift.Equatable {
    /// <p>Indicates whether health checks are enabled.</p>
    public let healthCheckEnabled: Swift.Bool?
    /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
    ///       For TCP health checks, the supported values are 10 or 30 seconds.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let healthCheckIntervalSeconds: Swift.Int?
    /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
    ///          <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
    ///          <p>[GRPC protocol version] The path of a custom health check method with the format
    ///       /package.service/method. The default is /AWS.ALB/healthcheck.</p>
    public let healthCheckPath: Swift.String?
    /// <p>The port the load balancer uses when performing health checks on targets.</p>
    public let healthCheckPort: Swift.String?
    /// <p>The protocol the load balancer uses when performing health checks on targets. The TCP
    ///       protocol is supported for health checks only if the protocol of the target group is TCP, TLS,
    ///       UDP, or TCP_UDP. The GENEVE, TLS, UDP, and TCP_UDP protocols are not supported for health
    ///       checks.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let healthCheckProtocol: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
    /// <p>[HTTP/HTTPS health checks] The amount of time, in seconds, during which no response means
    ///       a failed health check.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let healthCheckTimeoutSeconds: Swift.Int?
    /// <p>The number of consecutive health checks successes required before considering an unhealthy
    ///       target healthy.</p>
    public let healthyThresholdCount: Swift.Int?
    /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
    ///       response from a target.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let matcher: ElasticLoadBalancingV2ClientTypes.Matcher?
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?
    /// <p>The number of consecutive health check failures required before considering the target
    ///       unhealthy. For target groups with a protocol of TCP or TLS, this value must be the same as the
    ///       healthy threshold count.</p>
    public let unhealthyThresholdCount: Swift.Int?

    public init (
        healthCheckEnabled: Swift.Bool? = nil,
        healthCheckIntervalSeconds: Swift.Int? = nil,
        healthCheckPath: Swift.String? = nil,
        healthCheckPort: Swift.String? = nil,
        healthCheckProtocol: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
        healthCheckTimeoutSeconds: Swift.Int? = nil,
        healthyThresholdCount: Swift.Int? = nil,
        matcher: ElasticLoadBalancingV2ClientTypes.Matcher? = nil,
        targetGroupArn: Swift.String? = nil,
        unhealthyThresholdCount: Swift.Int? = nil
    )
    {
        self.healthCheckEnabled = healthCheckEnabled
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
        self.healthyThresholdCount = healthyThresholdCount
        self.matcher = matcher
        self.targetGroupArn = targetGroupArn
        self.unhealthyThresholdCount = unhealthyThresholdCount
    }
}

extension ModifyTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyTargetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyTargetGroupOutputResponse(targetGroups: \(Swift.String(describing: targetGroups)))"}
}

extension ModifyTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.targetGroups = output.targetGroups
        } else {
            self.targetGroups = nil
        }
    }
}

public struct ModifyTargetGroupOutputResponse: Swift.Equatable {
    /// <p>Information about the modified target group.</p>
    public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]?

    public init (
        targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]? = nil
    )
    {
        self.targetGroups = targetGroups
    }
}

struct ModifyTargetGroupOutputResponseBody: Swift.Equatable {
    public let targetGroups: [ElasticLoadBalancingV2ClientTypes.TargetGroup]?
}

extension ModifyTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyTargetGroupResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.TargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[ElasticLoadBalancingV2ClientTypes.TargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [ElasticLoadBalancingV2ClientTypes.TargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
    }
}

extension OperationNotPermittedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotPermittedException(message: \(Swift.String(describing: message)))"}
}

extension OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<OperationNotPermittedExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not allowed.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.PathPatternConditionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.PathPatternConditionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PathPatternConditionConfig(values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a path pattern condition.</p>
    public struct PathPatternConditionConfig: Swift.Equatable {
        /// <p>One or more path patterns to compare against the request URL. The maximum size of each
        ///       string is 128 characters. The comparison is case sensitive. The following wildcard characters
        ///       are supported: * (matches 0 or more characters) and ? (matches exactly 1 character).</p>
        ///          <p>If you specify multiple strings, the condition is satisfied if one of them matches the
        ///       request URL. The path pattern is compared only to the path of the URL, not to its query
        ///       string. To compare against the query string, use <a>QueryStringConditionConfig</a>.</p>
        public let values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension PriorityInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PriorityInUseException(message: \(Swift.String(describing: message)))"}
}

extension PriorityInUseException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PriorityInUseExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified priority is in use.</p>
public struct PriorityInUseException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PriorityInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PriorityInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum ProtocolEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case geneve
        case http
        case https
        case tcp
        case tcpUdp
        case tls
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolEnum] {
            return [
                .geneve,
                .http,
                .https,
                .tcp,
                .tcpUdp,
                .tls,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .geneve: return "GENEVE"
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case .tcpUdp: return "TCP_UDP"
            case .tls: return "TLS"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtocolEnum(rawValue: rawValue) ?? ProtocolEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.QueryStringConditionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, querystringkeyvaluepair0) in values.enumerated() {
                try valuesContainer.encode(querystringkeyvaluepair0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair].self, forKey: .member)
                var valuesBuffer:[ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair]()
                    for structureContainer0 in valuesContainer {
                        valuesBuffer?.append(structureContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.QueryStringConditionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStringConditionConfig(values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a query string condition.</p>
    ///          <p>The query string component of a URI starts after the first '?' character and is terminated
    ///       by either a '#' character or the end of the URI. A typical query string contains key/value
    ///       pairs separated by '&' characters. The allowed characters are specified by RFC 3986. Any
    ///       character can be percentage encoded.</p>
    public struct QueryStringConditionConfig: Swift.Equatable {
        /// <p>One or more key/value pairs or values to find in the query string. The maximum size of
        ///       each string is 128 characters. The comparison is case insensitive. The following wildcard
        ///       characters are supported: * (matches 0 or more characters) and ? (matches exactly 1
        ///       character). To search for a literal '*' or '?' character in a query string, you must escape
        ///       these characters in <code>Values</code> using a '\' character.</p>
        ///          <p>If you specify multiple key/value pairs or values, the condition is satisfied if one of
        ///       them is found in the query string.</p>
        public let values: [ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair]?

        public init (
            values: [ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair]? = nil
        )
        {
            self.values = values
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.QueryStringKeyValuePair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStringKeyValuePair(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a key/value pair.</p>
    public struct QueryStringKeyValuePair: Swift.Equatable {
        /// <p>The key. You can omit the key.</p>
        public let key: Swift.String?
        /// <p>The value.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.RedirectActionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case path = "Path"
        case port = "Port"
        case `protocol` = "Protocol"
        case query = "Query"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let host = host {
            try container.encode(host, forKey: ClientRuntime.Key("Host"))
        }
        if let path = path {
            try container.encode(path, forKey: ClientRuntime.Key("Path"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let query = query {
            try container.encode(query, forKey: ClientRuntime.Key("Query"))
        }
        if let statusCode = statusCode {
            try container.encode(statusCode, forKey: ClientRuntime.Key("StatusCode"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let queryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .query)
        query = queryDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.RedirectActionStatusCodeEnum.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.RedirectActionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedirectActionConfig(host: \(Swift.String(describing: host)), path: \(Swift.String(describing: path)), port: \(Swift.String(describing: port)), protocol: \(Swift.String(describing: `protocol`)), query: \(Swift.String(describing: query)), statusCode: \(Swift.String(describing: statusCode)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a redirect action.</p>
    ///          <p>A URI consists of the following components: protocol://hostname:port/path?query. You must
    ///       modify at least one of the following components to avoid a redirect loop: protocol, hostname,
    ///       port, or path. Any components that you do not modify retain their original values.</p>
    ///          <p>You can reuse URI components using the following reserved keywords:</p>
    ///          <ul>
    ///             <li>
    ///                <p>#{protocol}</p>
    ///             </li>
    ///             <li>
    ///                <p>#{host}</p>
    ///             </li>
    ///             <li>
    ///                <p>#{port}</p>
    ///             </li>
    ///             <li>
    ///                <p>#{path} (the leading "/" is removed)</p>
    ///             </li>
    ///             <li>
    ///                <p>#{query}</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, you can change the path to "/new/#{path}", the hostname to "example.#{host}",
    ///       or the query to "#{query}&value=xyz".</p>
    public struct RedirectActionConfig: Swift.Equatable {
        /// <p>The protocol. You can specify HTTP, HTTPS, or #{protocol}. You can redirect HTTP to HTTP,
        ///       HTTP to HTTPS, and HTTPS to HTTPS. You cannot redirect HTTPS to HTTP.</p>
        public let `protocol`: Swift.String?
        /// <p>The hostname. This component is not percent-encoded. The hostname can contain
        ///       #{host}.</p>
        public let host: Swift.String?
        /// <p>The absolute path, starting with the leading "/". This component is not percent-encoded.
        ///       The path can contain #{host}, #{path}, and #{port}.</p>
        public let path: Swift.String?
        /// <p>The port. You can specify a value from 1 to 65535 or #{port}.</p>
        public let port: Swift.String?
        /// <p>The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include
        ///       the leading "?", as it is automatically added. You can specify any of the reserved
        ///       keywords.</p>
        public let query: Swift.String?
        /// <p>The HTTP redirect code. The redirect is either permanent (HTTP 301) or temporary (HTTP
        ///       302).</p>
        public let statusCode: ElasticLoadBalancingV2ClientTypes.RedirectActionStatusCodeEnum?

        public init (
            `protocol`: Swift.String? = nil,
            host: Swift.String? = nil,
            path: Swift.String? = nil,
            port: Swift.String? = nil,
            query: Swift.String? = nil,
            statusCode: ElasticLoadBalancingV2ClientTypes.RedirectActionStatusCodeEnum? = nil
        )
        {
            self.`protocol` = `protocol`
            self.host = host
            self.path = path
            self.port = port
            self.query = query
            self.statusCode = statusCode
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes {
    public enum RedirectActionStatusCodeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http301
        case http302
        case sdkUnknown(Swift.String)

        public static var allCases: [RedirectActionStatusCodeEnum] {
            return [
                .http301,
                .http302,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http301: return "HTTP_301"
            case .http302: return "HTTP_302"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RedirectActionStatusCodeEnum(rawValue: rawValue) ?? RedirectActionStatusCodeEnum.sdkUnknown(rawValue)
        }
    }
}

public struct RegisterTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetsOutputError>
}

extension RegisterTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTargetsInput(targetGroupArn: \(Swift.String(describing: targetGroupArn)), targets: \(Swift.String(describing: targets)))"}
}

extension RegisterTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let targets = targets {
            var targetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Targets"))
            for (index0, targetdescription0) in targets.enumerated() {
                try targetsContainer.encode(targetdescription0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RegisterTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RegisterTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetsOutputError>
}

public struct RegisterTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterTargetsOutputError>
}

public struct RegisterTargetsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: Swift.String?
    /// <p>The targets.</p>
    public let targets: [ElasticLoadBalancingV2ClientTypes.TargetDescription]?

    public init (
        targetGroupArn: Swift.String? = nil,
        targets: [ElasticLoadBalancingV2ClientTypes.TargetDescription]? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.targets = targets
    }
}

extension RegisterTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTargetsOutputError: Swift.Error, Swift.Equatable {
    case invalidTargetException(InvalidTargetException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTargetsException(TooManyTargetsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTargetsOutputResponse()"}
}

extension RegisterTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterTargetsOutputResponse: Swift.Equatable {

    public init() {}
}

struct RegisterTargetsOutputResponseBody: Swift.Equatable {
}

extension RegisterTargetsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveListenerCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveListenerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveListenerCertificatesOutputError>
}

extension RemoveListenerCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveListenerCertificatesInput(certificates: \(Swift.String(describing: certificates)), listenerArn: \(Swift.String(describing: listenerArn)))"}
}

extension RemoveListenerCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: ClientRuntime.Key("ListenerArn"))
        }
        try container.encode("RemoveListenerCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveListenerCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveListenerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveListenerCertificatesOutputError>
}

public struct RemoveListenerCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveListenerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveListenerCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveListenerCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveListenerCertificatesOutputError>
}

public struct RemoveListenerCertificatesInput: Swift.Equatable {
    /// <p>The certificate to remove. You can specify one certificate per call. Set
    ///         <code>CertificateArn</code> to the certificate ARN but do not set
    ///       <code>IsDefault</code>.</p>
    public let certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: Swift.String?

    public init (
        certificates: [ElasticLoadBalancingV2ClientTypes.Certificate]? = nil,
        listenerArn: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.listenerArn = listenerArn
    }
}

extension RemoveListenerCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveListenerCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveListenerCertificatesOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveListenerCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveListenerCertificatesOutputResponse()"}
}

extension RemoveListenerCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveListenerCertificatesOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveListenerCertificatesOutputResponseBody: Swift.Equatable {
}

extension RemoveListenerCertificatesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsOutputError>
}

extension RemoveTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsInput(resourceArns: \(Swift.String(describing: resourceArns)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ResourceArns"))
            for (index0, resourcearn0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcearn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, tagkey0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkey0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTags", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArns: [Swift.String]?
    /// <p>The tag keys for the tags to remove.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArns: [Swift.String]? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArns = resourceArns
        self.tagKeys = tagKeys
    }
}

extension RemoveTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Swift.Error, Swift.Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case ruleNotFoundException(RuleNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsOutputResponse()"}
}

extension RemoveTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ResourceInUseExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Rule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case conditions = "Conditions"
        case isDefault = "IsDefault"
        case priority = "Priority"
        case ruleArn = "RuleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Actions"))
            for (index0, action0) in actions.enumerated() {
                try actionsContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let conditions = conditions {
            var conditionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Conditions"))
            for (index0, rulecondition0) in conditions.enumerated() {
                try conditionsContainer.encode(rulecondition0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let priority = priority {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: ClientRuntime.Key("RuleArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .priority)
        priority = priorityDecoded
        if containerValues.contains(.conditions) {
            struct KeyVal0{struct member{}}
            let conditionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .conditions)
            if let conditionsWrappedContainer = conditionsWrappedContainer {
                let conditionsContainer = try conditionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.RuleCondition].self, forKey: .member)
                var conditionsBuffer:[ElasticLoadBalancingV2ClientTypes.RuleCondition]? = nil
                if let conditionsContainer = conditionsContainer {
                    conditionsBuffer = [ElasticLoadBalancingV2ClientTypes.RuleCondition]()
                    for structureContainer0 in conditionsContainer {
                        conditionsBuffer?.append(structureContainer0)
                    }
                }
                conditions = conditionsBuffer
            } else {
                conditions = []
            }
        } else {
            conditions = nil
        }
        if containerValues.contains(.actions) {
            struct KeyVal0{struct member{}}
            let actionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actions)
            if let actionsWrappedContainer = actionsWrappedContainer {
                let actionsContainer = try actionsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Action].self, forKey: .member)
                var actionsBuffer:[ElasticLoadBalancingV2ClientTypes.Action]? = nil
                if let actionsContainer = actionsContainer {
                    actionsBuffer = [ElasticLoadBalancingV2ClientTypes.Action]()
                    for structureContainer0 in actionsContainer {
                        actionsBuffer?.append(structureContainer0)
                    }
                }
                actions = actionsBuffer
            } else {
                actions = []
            }
        } else {
            actions = nil
        }
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Rule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Rule(actions: \(Swift.String(describing: actions)), conditions: \(Swift.String(describing: conditions)), isDefault: \(Swift.String(describing: isDefault)), priority: \(Swift.String(describing: priority)), ruleArn: \(Swift.String(describing: ruleArn)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a rule.</p>
    public struct Rule: Swift.Equatable {
        /// <p>The actions. Each rule must include exactly one of the following types of actions:
        ///         <code>forward</code>, <code>redirect</code>, or <code>fixed-response</code>, and it must be
        ///       the last action to be performed.</p>
        public let actions: [ElasticLoadBalancingV2ClientTypes.Action]?
        /// <p>The conditions. Each rule can include zero or one of the following conditions:
        ///         <code>http-request-method</code>, <code>host-header</code>, <code>path-pattern</code>, and
        ///         <code>source-ip</code>, and zero or more of the following conditions:
        ///         <code>http-header</code> and <code>query-string</code>.</p>
        public let conditions: [ElasticLoadBalancingV2ClientTypes.RuleCondition]?
        /// <p>Indicates whether this is the default rule.</p>
        public let isDefault: Swift.Bool
        /// <p>The priority.</p>
        public let priority: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        public let ruleArn: Swift.String?

        public init (
            actions: [ElasticLoadBalancingV2ClientTypes.Action]? = nil,
            conditions: [ElasticLoadBalancingV2ClientTypes.RuleCondition]? = nil,
            isDefault: Swift.Bool = false,
            priority: Swift.String? = nil,
            ruleArn: Swift.String? = nil
        )
        {
            self.actions = actions
            self.conditions = conditions
            self.isDefault = isDefault
            self.priority = priority
            self.ruleArn = ruleArn
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.RuleCondition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field = "Field"
        case hostHeaderConfig = "HostHeaderConfig"
        case httpHeaderConfig = "HttpHeaderConfig"
        case httpRequestMethodConfig = "HttpRequestMethodConfig"
        case pathPatternConfig = "PathPatternConfig"
        case queryStringConfig = "QueryStringConfig"
        case sourceIpConfig = "SourceIpConfig"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let field = field {
            try container.encode(field, forKey: ClientRuntime.Key("Field"))
        }
        if let hostHeaderConfig = hostHeaderConfig {
            try container.encode(hostHeaderConfig, forKey: ClientRuntime.Key("HostHeaderConfig"))
        }
        if let httpHeaderConfig = httpHeaderConfig {
            try container.encode(httpHeaderConfig, forKey: ClientRuntime.Key("HttpHeaderConfig"))
        }
        if let httpRequestMethodConfig = httpRequestMethodConfig {
            try container.encode(httpRequestMethodConfig, forKey: ClientRuntime.Key("HttpRequestMethodConfig"))
        }
        if let pathPatternConfig = pathPatternConfig {
            try container.encode(pathPatternConfig, forKey: ClientRuntime.Key("PathPatternConfig"))
        }
        if let queryStringConfig = queryStringConfig {
            try container.encode(queryStringConfig, forKey: ClientRuntime.Key("QueryStringConfig"))
        }
        if let sourceIpConfig = sourceIpConfig {
            try container.encode(sourceIpConfig, forKey: ClientRuntime.Key("SourceIpConfig"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
        let hostHeaderConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.HostHeaderConditionConfig.self, forKey: .hostHeaderConfig)
        hostHeaderConfig = hostHeaderConfigDecoded
        let pathPatternConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.PathPatternConditionConfig.self, forKey: .pathPatternConfig)
        pathPatternConfig = pathPatternConfigDecoded
        let httpHeaderConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.HttpHeaderConditionConfig.self, forKey: .httpHeaderConfig)
        httpHeaderConfig = httpHeaderConfigDecoded
        let queryStringConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.QueryStringConditionConfig.self, forKey: .queryStringConfig)
        queryStringConfig = queryStringConfigDecoded
        let httpRequestMethodConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.HttpRequestMethodConditionConfig.self, forKey: .httpRequestMethodConfig)
        httpRequestMethodConfig = httpRequestMethodConfigDecoded
        let sourceIpConfigDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.SourceIpConditionConfig.self, forKey: .sourceIpConfig)
        sourceIpConfig = sourceIpConfigDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.RuleCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleCondition(field: \(Swift.String(describing: field)), hostHeaderConfig: \(Swift.String(describing: hostHeaderConfig)), httpHeaderConfig: \(Swift.String(describing: httpHeaderConfig)), httpRequestMethodConfig: \(Swift.String(describing: httpRequestMethodConfig)), pathPatternConfig: \(Swift.String(describing: pathPatternConfig)), queryStringConfig: \(Swift.String(describing: queryStringConfig)), sourceIpConfig: \(Swift.String(describing: sourceIpConfig)), values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a condition for a rule.</p>
    ///          <p>Each rule can optionally include up to one of each of the following conditions:
    ///         <code>http-request-method</code>, <code>host-header</code>, <code>path-pattern</code>, and
    ///         <code>source-ip</code>. Each rule can also optionally include one or more of each of the
    ///       following conditions: <code>http-header</code> and <code>query-string</code>.</p>
    public struct RuleCondition: Swift.Equatable {
        /// <p>The field in the HTTP request. The following are the possible values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>http-header</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>http-request-method</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>host-header</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>path-pattern</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>query-string</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>source-ip</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let field: Swift.String?
        /// <p>Information for a host header condition. Specify only when <code>Field</code> is
        ///         <code>host-header</code>.</p>
        public let hostHeaderConfig: ElasticLoadBalancingV2ClientTypes.HostHeaderConditionConfig?
        /// <p>Information for an HTTP header condition. Specify only when <code>Field</code> is
        ///         <code>http-header</code>.</p>
        public let httpHeaderConfig: ElasticLoadBalancingV2ClientTypes.HttpHeaderConditionConfig?
        /// <p>Information for an HTTP method condition. Specify only when <code>Field</code> is
        ///         <code>http-request-method</code>.</p>
        public let httpRequestMethodConfig: ElasticLoadBalancingV2ClientTypes.HttpRequestMethodConditionConfig?
        /// <p>Information for a path pattern condition. Specify only when <code>Field</code> is
        ///         <code>path-pattern</code>.</p>
        public let pathPatternConfig: ElasticLoadBalancingV2ClientTypes.PathPatternConditionConfig?
        /// <p>Information for a query string condition. Specify only when <code>Field</code> is
        ///         <code>query-string</code>.</p>
        public let queryStringConfig: ElasticLoadBalancingV2ClientTypes.QueryStringConditionConfig?
        /// <p>Information for a source IP condition. Specify only when <code>Field</code> is
        ///         <code>source-ip</code>.</p>
        public let sourceIpConfig: ElasticLoadBalancingV2ClientTypes.SourceIpConditionConfig?
        /// <p>The condition value. Specify only when <code>Field</code> is <code>host-header</code> or
        ///         <code>path-pattern</code>. Alternatively, to specify multiple host names or multiple path
        ///       patterns, use <code>HostHeaderConfig</code> or <code>PathPatternConfig</code>.</p>
        ///          <p>If <code>Field</code> is <code>host-header</code> and you are not using
        ///         <code>HostHeaderConfig</code>, you can specify a single host name (for example,
        ///       my.example.com) in <code>Values</code>. A host name is case insensitive, can be up to 128
        ///       characters in length, and can contain any of the following characters.</p>
        ///          <ul>
        ///             <li>
        ///                <p>A-Z, a-z, 0-9</p>
        ///             </li>
        ///             <li>
        ///                <p>- .</p>
        ///             </li>
        ///             <li>
        ///                <p>* (matches 0 or more characters)</p>
        ///             </li>
        ///             <li>
        ///                <p>? (matches exactly 1 character)</p>
        ///             </li>
        ///          </ul>
        ///          <p>If <code>Field</code> is <code>path-pattern</code> and you are not using
        ///         <code>PathPatternConfig</code>, you can specify a single path pattern (for example, /img/*)
        ///       in <code>Values</code>. A path pattern is case-sensitive, can be up to 128 characters in
        ///       length, and can contain any of the following characters.</p>
        ///          <ul>
        ///             <li>
        ///                <p>A-Z, a-z, 0-9</p>
        ///             </li>
        ///             <li>
        ///                <p>_ - . $ / ~ " ' @ : +</p>
        ///             </li>
        ///             <li>
        ///                <p>& (using &amp;)</p>
        ///             </li>
        ///             <li>
        ///                <p>* (matches 0 or more characters)</p>
        ///             </li>
        ///             <li>
        ///                <p>? (matches exactly 1 character)</p>
        ///             </li>
        ///          </ul>
        public let values: [Swift.String]?

        public init (
            field: Swift.String? = nil,
            hostHeaderConfig: ElasticLoadBalancingV2ClientTypes.HostHeaderConditionConfig? = nil,
            httpHeaderConfig: ElasticLoadBalancingV2ClientTypes.HttpHeaderConditionConfig? = nil,
            httpRequestMethodConfig: ElasticLoadBalancingV2ClientTypes.HttpRequestMethodConditionConfig? = nil,
            pathPatternConfig: ElasticLoadBalancingV2ClientTypes.PathPatternConditionConfig? = nil,
            queryStringConfig: ElasticLoadBalancingV2ClientTypes.QueryStringConditionConfig? = nil,
            sourceIpConfig: ElasticLoadBalancingV2ClientTypes.SourceIpConditionConfig? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.field = field
            self.hostHeaderConfig = hostHeaderConfig
            self.httpHeaderConfig = httpHeaderConfig
            self.httpRequestMethodConfig = httpRequestMethodConfig
            self.pathPatternConfig = pathPatternConfig
            self.queryStringConfig = queryStringConfig
            self.sourceIpConfig = sourceIpConfig
            self.values = values
        }
    }

}

extension RuleNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RuleNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<RuleNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified rule does not exist.</p>
public struct RuleNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RuleNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RuleNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.RulePriorityPair: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case ruleArn = "RuleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let priority = priority {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: ClientRuntime.Key("RuleArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.RulePriorityPair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RulePriorityPair(priority: \(Swift.String(describing: priority)), ruleArn: \(Swift.String(describing: ruleArn)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about the priorities for the rules for a listener.</p>
    public struct RulePriorityPair: Swift.Equatable {
        /// <p>The rule priority.</p>
        public let priority: Swift.Int?
        /// <p>The Amazon Resource Name (ARN) of the rule.</p>
        public let ruleArn: Swift.String?

        public init (
            priority: Swift.Int? = nil,
            ruleArn: Swift.String? = nil
        )
        {
            self.priority = priority
            self.ruleArn = ruleArn
        }
    }

}

extension SSLPolicyNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SSLPolicyNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension SSLPolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SSLPolicyNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified SSL policy does not exist.</p>
public struct SSLPolicyNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SSLPolicyNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SSLPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetIpAddressTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIpAddressTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIpAddressTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIpAddressTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIpAddressTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIpAddressTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIpAddressTypeOutputError>
}

extension SetIpAddressTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetIpAddressTypeInput(ipAddressType: \(Swift.String(describing: ipAddressType)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)))"}
}

extension SetIpAddressTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: ClientRuntime.Key("IpAddressType"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        try container.encode("SetIpAddressType", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetIpAddressTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIpAddressTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIpAddressTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIpAddressTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIpAddressTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIpAddressTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIpAddressTypeOutputError>
}

public struct SetIpAddressTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetIpAddressTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetIpAddressTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetIpAddressTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetIpAddressTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetIpAddressTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetIpAddressTypeOutputError>
}

public struct SetIpAddressTypeInput: Swift.Equatable {
    /// <p>The IP address type. The possible values are <code>ipv4</code> (for IPv4 addresses) and
    ///         <code>dualstack</code> (for IPv4 and IPv6 addresses). Internal load balancers must use
    ///         <code>ipv4</code>. You can’t specify <code>dualstack</code> for a load balancer with a UDP
    ///       or TCP_UDP listener.</p>
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?

    public init (
        ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType? = nil,
        loadBalancerArn: Swift.String? = nil
    )
    {
        self.ipAddressType = ipAddressType
        self.loadBalancerArn = loadBalancerArn
    }
}

extension SetIpAddressTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIpAddressTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIpAddressTypeOutputError: Swift.Error, Swift.Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSubnetException(InvalidSubnetException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIpAddressTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetIpAddressTypeOutputResponse(ipAddressType: \(Swift.String(describing: ipAddressType)))"}
}

extension SetIpAddressTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetIpAddressTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipAddressType = output.ipAddressType
        } else {
            self.ipAddressType = nil
        }
    }
}

public struct SetIpAddressTypeOutputResponse: Swift.Equatable {
    /// <p>The IP address type.</p>
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?

    public init (
        ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType? = nil
    )
    {
        self.ipAddressType = ipAddressType
    }
}

struct SetIpAddressTypeOutputResponseBody: Swift.Equatable {
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?
}

extension SetIpAddressTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressType = "IpAddressType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SetIpAddressTypeResult"))
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
    }
}

public struct SetRulePrioritiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRulePrioritiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRulePrioritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRulePrioritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRulePrioritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRulePrioritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRulePrioritiesOutputError>
}

extension SetRulePrioritiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetRulePrioritiesInput(rulePriorities: \(Swift.String(describing: rulePriorities)))"}
}

extension SetRulePrioritiesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let rulePriorities = rulePriorities {
            var rulePrioritiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RulePriorities"))
            for (index0, ruleprioritypair0) in rulePriorities.enumerated() {
                try rulePrioritiesContainer.encode(ruleprioritypair0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetRulePriorities", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetRulePrioritiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRulePrioritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRulePrioritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRulePrioritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRulePrioritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRulePrioritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRulePrioritiesOutputError>
}

public struct SetRulePrioritiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRulePrioritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRulePrioritiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRulePrioritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRulePrioritiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRulePrioritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRulePrioritiesOutputError>
}

public struct SetRulePrioritiesInput: Swift.Equatable {
    /// <p>The rule priorities.</p>
    public let rulePriorities: [ElasticLoadBalancingV2ClientTypes.RulePriorityPair]?

    public init (
        rulePriorities: [ElasticLoadBalancingV2ClientTypes.RulePriorityPair]? = nil
    )
    {
        self.rulePriorities = rulePriorities
    }
}

extension SetRulePrioritiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetRulePrioritiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PriorityInUseException" : self = .priorityInUseException(try PriorityInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRulePrioritiesOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case priorityInUseException(PriorityInUseException)
    case ruleNotFoundException(RuleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRulePrioritiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetRulePrioritiesOutputResponse(rules: \(Swift.String(describing: rules)))"}
}

extension SetRulePrioritiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetRulePrioritiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct SetRulePrioritiesOutputResponse: Swift.Equatable {
    /// <p>Information about the rules.</p>
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?

    public init (
        rules: [ElasticLoadBalancingV2ClientTypes.Rule]? = nil
    )
    {
        self.rules = rules
    }
}

struct SetRulePrioritiesOutputResponseBody: Swift.Equatable {
    public let rules: [ElasticLoadBalancingV2ClientTypes.Rule]?
}

extension SetRulePrioritiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SetRulePrioritiesResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Rule].self, forKey: .member)
                var rulesBuffer:[ElasticLoadBalancingV2ClientTypes.Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [ElasticLoadBalancingV2ClientTypes.Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct SetSecurityGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSecurityGroupsOutputError>
}

extension SetSecurityGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSecurityGroupsInput(loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), securityGroups: \(Swift.String(describing: securityGroups)))"}
}

extension SetSecurityGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetSecurityGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetSecurityGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSecurityGroupsOutputError>
}

public struct SetSecurityGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSecurityGroupsOutputError>
}

public struct SetSecurityGroupsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?
    /// <p>The IDs of the security groups.</p>
    public let securityGroups: [Swift.String]?

    public init (
        loadBalancerArn: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
        self.securityGroups = securityGroups
    }
}

extension SetSecurityGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSecurityGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupException" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSecurityGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSecurityGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSecurityGroupsOutputResponse(securityGroupIds: \(Swift.String(describing: securityGroupIds)))"}
}

extension SetSecurityGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.securityGroupIds = output.securityGroupIds
        } else {
            self.securityGroupIds = nil
        }
    }
}

public struct SetSecurityGroupsOutputResponse: Swift.Equatable {
    /// <p>The IDs of the security groups associated with the load balancer.</p>
    public let securityGroupIds: [Swift.String]?

    public init (
        securityGroupIds: [Swift.String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
    }
}

struct SetSecurityGroupsOutputResponseBody: Swift.Equatable {
    public let securityGroupIds: [Swift.String]?
}

extension SetSecurityGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SetSecurityGroupsResult"))
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct member{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
    }
}

public struct SetSubnetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSubnetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSubnetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSubnetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSubnetsOutputError>
}

extension SetSubnetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSubnetsInput(ipAddressType: \(Swift.String(describing: ipAddressType)), loadBalancerArn: \(Swift.String(describing: loadBalancerArn)), subnetMappings: \(Swift.String(describing: subnetMappings)), subnets: \(Swift.String(describing: subnets)))"}
}

extension SetSubnetsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: ClientRuntime.Key("IpAddressType"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: ClientRuntime.Key("LoadBalancerArn"))
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetMappings"))
            for (index0, subnetmapping0) in subnetMappings.enumerated() {
                try subnetMappingsContainer.encode(subnetmapping0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetSubnets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2015-12-01", forKey:ClientRuntime.Key("Version"))
    }
}

public struct SetSubnetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSubnetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSubnetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSubnetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSubnetsOutputError>
}

public struct SetSubnetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetSubnetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetSubnetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetSubnetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetSubnetsOutputError>
}

public struct SetSubnetsInput: Swift.Equatable {
    /// <p>[Network Load Balancers] The type of IP addresses used by the subnets for your load
    ///       balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and
    ///         <code>dualstack</code> (for IPv4 and IPv6 addresses). You can’t specify
    ///         <code>dualstack</code> for a load balancer with a UDP or TCP_UDP listener. Internal load
    ///       balancers must use <code>ipv4</code>.</p>
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: Swift.String?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones. You cannot specify Elastic IP addresses for your subnets.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
    ///       can specify one Elastic IP address per subnet if you need static IP addresses for your
    ///       internet-facing load balancer. For internal load balancers, you can specify one private IP
    ///       address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
    ///       can specify one IPv6 address per subnet.</p>
    public let subnetMappings: [ElasticLoadBalancingV2ClientTypes.SubnetMapping]?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability
    ///       Zones.</p>
    public let subnets: [Swift.String]?

    public init (
        ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType? = nil,
        loadBalancerArn: Swift.String? = nil,
        subnetMappings: [ElasticLoadBalancingV2ClientTypes.SubnetMapping]? = nil,
        subnets: [Swift.String]? = nil
    )
    {
        self.ipAddressType = ipAddressType
        self.loadBalancerArn = loadBalancerArn
        self.subnetMappings = subnetMappings
        self.subnets = subnets
    }
}

extension SetSubnetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSubnetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AllocationIdNotFoundException" : self = .allocationIdNotFoundException(try AllocationIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AvailabilityZoneNotSupportedException" : self = .availabilityZoneNotSupportedException(try AvailabilityZoneNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFoundException" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSubnetsOutputError: Swift.Error, Swift.Equatable {
    case allocationIdNotFoundException(AllocationIdNotFoundException)
    case availabilityZoneNotSupportedException(AvailabilityZoneNotSupportedException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSubnetException(InvalidSubnetException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case subnetNotFoundException(SubnetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSubnetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetSubnetsOutputResponse(availabilityZones: \(Swift.String(describing: availabilityZones)), ipAddressType: \(Swift.String(describing: ipAddressType)))"}
}

extension SetSubnetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZones = output.availabilityZones
            self.ipAddressType = output.ipAddressType
        } else {
            self.availabilityZones = nil
            self.ipAddressType = nil
        }
    }
}

public struct SetSubnetsOutputResponse: Swift.Equatable {
    /// <p>Information about the subnets.</p>
    public let availabilityZones: [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]?
    /// <p>[Network Load Balancers] The IP address type.</p>
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?

    public init (
        availabilityZones: [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]? = nil,
        ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.ipAddressType = ipAddressType
    }
}

struct SetSubnetsOutputResponseBody: Swift.Equatable {
    public let availabilityZones: [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]?
    public let ipAddressType: ElasticLoadBalancingV2ClientTypes.IpAddressType?
}

extension SetSubnetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case ipAddressType = "IpAddressType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("SetSubnetsResult"))
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[ElasticLoadBalancingV2ClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [ElasticLoadBalancingV2ClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.SourceIpConditionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.SourceIpConditionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceIpConditionConfig(values: \(Swift.String(describing: values)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a source IP condition.</p>
    ///          <p>You can use this condition to route based on the IP address of the source that connects to
    ///       the load balancer. If a client is behind a proxy, this is the IP address of the proxy not the
    ///       IP address of the client.</p>
    public struct SourceIpConditionConfig: Swift.Equatable {
        /// <p>One or more source IP addresses, in CIDR format. You can use both IPv4 and IPv6 addresses.
        ///       Wildcards are not supported.</p>
        ///          <p>If you specify multiple addresses, the condition is satisfied if the source IP address of
        ///       the request matches one of the CIDR blocks. This condition is not satisfied by the addresses
        ///       in the X-Forwarded-For header. To search for addresses in the X-Forwarded-For header, use
        ///         <a>HttpHeaderConditionConfig</a>.</p>
        public let values: [Swift.String]?

        public init (
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.SslPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ciphers = "Ciphers"
        case name = "Name"
        case sslProtocols = "SslProtocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let ciphers = ciphers {
            var ciphersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ciphers"))
            for (index0, cipher0) in ciphers.enumerated() {
                try ciphersContainer.encode(cipher0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let sslProtocols = sslProtocols {
            var sslProtocolsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SslProtocols"))
            for (index0, sslprotocol0) in sslProtocols.enumerated() {
                try sslProtocolsContainer.encode(sslprotocol0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.sslProtocols) {
            struct KeyVal0{struct member{}}
            let sslProtocolsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sslProtocols)
            if let sslProtocolsWrappedContainer = sslProtocolsWrappedContainer {
                let sslProtocolsContainer = try sslProtocolsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sslProtocolsBuffer:[Swift.String]? = nil
                if let sslProtocolsContainer = sslProtocolsContainer {
                    sslProtocolsBuffer = [Swift.String]()
                    for stringContainer0 in sslProtocolsContainer {
                        sslProtocolsBuffer?.append(stringContainer0)
                    }
                }
                sslProtocols = sslProtocolsBuffer
            } else {
                sslProtocols = []
            }
        } else {
            sslProtocols = nil
        }
        if containerValues.contains(.ciphers) {
            struct KeyVal0{struct member{}}
            let ciphersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ciphers)
            if let ciphersWrappedContainer = ciphersWrappedContainer {
                let ciphersContainer = try ciphersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Cipher].self, forKey: .member)
                var ciphersBuffer:[ElasticLoadBalancingV2ClientTypes.Cipher]? = nil
                if let ciphersContainer = ciphersContainer {
                    ciphersBuffer = [ElasticLoadBalancingV2ClientTypes.Cipher]()
                    for structureContainer0 in ciphersContainer {
                        ciphersBuffer?.append(structureContainer0)
                    }
                }
                ciphers = ciphersBuffer
            } else {
                ciphers = []
            }
        } else {
            ciphers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.SslPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SslPolicy(ciphers: \(Swift.String(describing: ciphers)), name: \(Swift.String(describing: name)), sslProtocols: \(Swift.String(describing: sslProtocols)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a policy used for SSL negotiation.</p>
    public struct SslPolicy: Swift.Equatable {
        /// <p>The ciphers.</p>
        public let ciphers: [ElasticLoadBalancingV2ClientTypes.Cipher]?
        /// <p>The name of the policy.</p>
        public let name: Swift.String?
        /// <p>The protocols.</p>
        public let sslProtocols: [Swift.String]?

        public init (
            ciphers: [ElasticLoadBalancingV2ClientTypes.Cipher]? = nil,
            name: Swift.String? = nil,
            sslProtocols: [Swift.String]? = nil
        )
        {
            self.ciphers = ciphers
            self.name = name
            self.sslProtocols = sslProtocols
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.SubnetMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocationId = "AllocationId"
        case iPv6Address = "IPv6Address"
        case privateIPv4Address = "PrivateIPv4Address"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocationId = allocationId {
            try container.encode(allocationId, forKey: ClientRuntime.Key("AllocationId"))
        }
        if let iPv6Address = iPv6Address {
            try container.encode(iPv6Address, forKey: ClientRuntime.Key("IPv6Address"))
        }
        if let privateIPv4Address = privateIPv4Address {
            try container.encode(privateIPv4Address, forKey: ClientRuntime.Key("PrivateIPv4Address"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: ClientRuntime.Key("SubnetId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let allocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allocationId)
        allocationId = allocationIdDecoded
        let privateIPv4AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIPv4Address)
        privateIPv4Address = privateIPv4AddressDecoded
        let iPv6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iPv6Address)
        iPv6Address = iPv6AddressDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.SubnetMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetMapping(allocationId: \(Swift.String(describing: allocationId)), iPv6Address: \(Swift.String(describing: iPv6Address)), privateIPv4Address: \(Swift.String(describing: privateIPv4Address)), subnetId: \(Swift.String(describing: subnetId)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a subnet mapping.</p>
    public struct SubnetMapping: Swift.Equatable {
        /// <p>[Network Load Balancers] The allocation ID of the Elastic IP address for an
        ///       internet-facing load balancer.</p>
        public let allocationId: Swift.String?
        /// <p>[Network Load Balancers] The IPv6 address.</p>
        public let iPv6Address: Swift.String?
        /// <p>[Network Load Balancers] The private IPv4 address for an internal load balancer.</p>
        public let privateIPv4Address: Swift.String?
        /// <p>The ID of the subnet.</p>
        public let subnetId: Swift.String?

        public init (
            allocationId: Swift.String? = nil,
            iPv6Address: Swift.String? = nil,
            privateIPv4Address: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.allocationId = allocationId
            self.iPv6Address = iPv6Address
            self.privateIPv4Address = privateIPv4Address
            self.subnetId = subnetId
        }
    }

}

extension SubnetNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension SubnetNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<SubnetNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet does not exist.</p>
public struct SubnetNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a tag.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key of the tag.</p>
        public let key: Swift.String?
        /// <p>The value of the tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.TagDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[ElasticLoadBalancingV2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElasticLoadBalancingV2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes.TagDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagDescription(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>The tags associated with a resource.</p>
    public struct TagDescription: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        public let resourceArn: Swift.String?
        /// <p>Information about the tags.</p>
        public let tags: [ElasticLoadBalancingV2ClientTypes.Tag]?

        public init (
            resourceArn: Swift.String? = nil,
            tags: [ElasticLoadBalancingV2ClientTypes.Tag]? = nil
        )
        {
            self.resourceArn = resourceArn
            self.tags = tags
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.TargetDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case id = "Id"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetDescription(availabilityZone: \(Swift.String(describing: availabilityZone)), id: \(Swift.String(describing: id)), port: \(Swift.String(describing: port)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a target.</p>
    public struct TargetDescription: Swift.Equatable {
        /// <p>An Availability Zone or <code>all</code>. This determines whether the target receives
        ///       traffic from the load balancer nodes in the specified Availability Zone or from all enabled
        ///       Availability Zones for the load balancer.</p>
        ///          <p>This parameter is not supported if the target type of the target group is
        ///         <code>instance</code>.</p>
        ///          <p>If the target type is <code>ip</code> and the IP address is in a subnet of the VPC for the
        ///       target group, the Availability Zone is automatically detected and this parameter is optional.
        ///       If the IP address is outside the VPC, this parameter is required.</p>
        ///          <p>With an Application Load Balancer, if the target type is <code>ip</code> and the IP
        ///       address is outside the VPC for the target group, the only supported value is
        ///       <code>all</code>.</p>
        ///          <p>If the target type is <code>lambda</code>, this parameter is optional and the only
        ///       supported value is <code>all</code>.</p>
        public let availabilityZone: Swift.String?
        /// <p>The ID of the target. If the target type of the target group is <code>instance</code>,
        ///       specify an instance ID. If the target type is <code>ip</code>, specify an IP address. If the
        ///       target type is <code>lambda</code>, specify the ARN of the Lambda function.</p>
        public let id: Swift.String?
        /// <p>The port on which the target is listening. If the target group protocol is GENEVE, the
        ///       supported port is 6081. Not used if the target is a Lambda function.</p>
        public let port: Swift.Int?

        public init (
            availabilityZone: Swift.String? = nil,
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.id = id
            self.port = port
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.TargetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckEnabled = "HealthCheckEnabled"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case healthCheckTimeoutSeconds = "HealthCheckTimeoutSeconds"
        case healthyThresholdCount = "HealthyThresholdCount"
        case loadBalancerArns = "LoadBalancerArns"
        case matcher = "Matcher"
        case port = "Port"
        case `protocol` = "Protocol"
        case protocolVersion = "ProtocolVersion"
        case targetGroupArn = "TargetGroupArn"
        case targetGroupName = "TargetGroupName"
        case targetType = "TargetType"
        case unhealthyThresholdCount = "UnhealthyThresholdCount"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthCheckEnabled = healthCheckEnabled {
            try container.encode(healthCheckEnabled, forKey: ClientRuntime.Key("HealthCheckEnabled"))
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try container.encode(healthCheckIntervalSeconds, forKey: ClientRuntime.Key("HealthCheckIntervalSeconds"))
        }
        if let healthCheckPath = healthCheckPath {
            try container.encode(healthCheckPath, forKey: ClientRuntime.Key("HealthCheckPath"))
        }
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: ClientRuntime.Key("HealthCheckPort"))
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try container.encode(healthCheckProtocol, forKey: ClientRuntime.Key("HealthCheckProtocol"))
        }
        if let healthCheckTimeoutSeconds = healthCheckTimeoutSeconds {
            try container.encode(healthCheckTimeoutSeconds, forKey: ClientRuntime.Key("HealthCheckTimeoutSeconds"))
        }
        if let healthyThresholdCount = healthyThresholdCount {
            try container.encode(healthyThresholdCount, forKey: ClientRuntime.Key("HealthyThresholdCount"))
        }
        if let loadBalancerArns = loadBalancerArns {
            var loadBalancerArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LoadBalancerArns"))
            for (index0, loadbalancerarn0) in loadBalancerArns.enumerated() {
                try loadBalancerArnsContainer.encode(loadbalancerarn0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let matcher = matcher {
            try container.encode(matcher, forKey: ClientRuntime.Key("Matcher"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let protocolVersion = protocolVersion {
            try container.encode(protocolVersion, forKey: ClientRuntime.Key("ProtocolVersion"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        if let targetType = targetType {
            try container.encode(targetType, forKey: ClientRuntime.Key("TargetType"))
        }
        if let unhealthyThresholdCount = unhealthyThresholdCount {
            try container.encode(unhealthyThresholdCount, forKey: ClientRuntime.Key("UnhealthyThresholdCount"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.ProtocolEnum.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.ProtocolEnum.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .healthCheckEnabled)
        healthCheckEnabled = healthCheckEnabledDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let healthCheckTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckTimeoutSeconds)
        healthCheckTimeoutSeconds = healthCheckTimeoutSecondsDecoded
        let healthyThresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThresholdCount)
        healthyThresholdCount = healthyThresholdCountDecoded
        let unhealthyThresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThresholdCount)
        unhealthyThresholdCount = unhealthyThresholdCountDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let matcherDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.Matcher.self, forKey: .matcher)
        matcher = matcherDecoded
        if containerValues.contains(.loadBalancerArns) {
            struct KeyVal0{struct member{}}
            let loadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerArns)
            if let loadBalancerArnsWrappedContainer = loadBalancerArnsWrappedContainer {
                let loadBalancerArnsContainer = try loadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var loadBalancerArnsBuffer:[Swift.String]? = nil
                if let loadBalancerArnsContainer = loadBalancerArnsContainer {
                    loadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in loadBalancerArnsContainer {
                        loadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerArns = loadBalancerArnsBuffer
            } else {
                loadBalancerArns = []
            }
        } else {
            loadBalancerArns = nil
        }
        let targetTypeDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.TargetTypeEnum.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetGroup(healthCheckEnabled: \(Swift.String(describing: healthCheckEnabled)), healthCheckIntervalSeconds: \(Swift.String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(Swift.String(describing: healthCheckPath)), healthCheckPort: \(Swift.String(describing: healthCheckPort)), healthCheckProtocol: \(Swift.String(describing: healthCheckProtocol)), healthCheckTimeoutSeconds: \(Swift.String(describing: healthCheckTimeoutSeconds)), healthyThresholdCount: \(Swift.String(describing: healthyThresholdCount)), loadBalancerArns: \(Swift.String(describing: loadBalancerArns)), matcher: \(Swift.String(describing: matcher)), port: \(Swift.String(describing: port)), protocol: \(Swift.String(describing: `protocol`)), protocolVersion: \(Swift.String(describing: protocolVersion)), targetGroupArn: \(Swift.String(describing: targetGroupArn)), targetGroupName: \(Swift.String(describing: targetGroupName)), targetType: \(Swift.String(describing: targetType)), unhealthyThresholdCount: \(Swift.String(describing: unhealthyThresholdCount)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a target group.</p>
    public struct TargetGroup: Swift.Equatable {
        /// <p>The protocol to use for routing traffic to the targets.</p>
        public let `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
        /// <p>Indicates whether health checks are enabled.</p>
        public let healthCheckEnabled: Swift.Bool?
        /// <p>The approximate amount of time, in seconds, between health checks of an individual
        ///       target.</p>
        public let healthCheckIntervalSeconds: Swift.Int?
        /// <p>The destination for health checks on the targets.</p>
        public let healthCheckPath: Swift.String?
        /// <p>The port to use to connect with the target.</p>
        public let healthCheckPort: Swift.String?
        /// <p>The protocol to use to connect with the target. The GENEVE, TLS, UDP, and TCP_UDP
        ///       protocols are not supported for health checks.</p>
        public let healthCheckProtocol: ElasticLoadBalancingV2ClientTypes.ProtocolEnum?
        /// <p>The amount of time, in seconds, during which no response means a failed health
        ///       check.</p>
        public let healthCheckTimeoutSeconds: Swift.Int?
        /// <p>The number of consecutive health checks successes required before considering an unhealthy
        ///       target healthy.</p>
        public let healthyThresholdCount: Swift.Int?
        /// <p>The Amazon Resource Names (ARN) of the load balancers that route traffic to this target
        ///       group.</p>
        public let loadBalancerArns: [Swift.String]?
        /// <p>The HTTP or gRPC codes to use when checking for a successful response from a
        ///       target.</p>
        public let matcher: ElasticLoadBalancingV2ClientTypes.Matcher?
        /// <p>The port on which the targets are listening. Not used if the target is a Lambda
        ///       function.</p>
        public let port: Swift.Int?
        /// <p>[HTTP/HTTPS protocol] The protocol version. The possible values are <code>GRPC</code>,
        ///         <code>HTTP1</code>, and <code>HTTP2</code>.</p>
        public let protocolVersion: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        public let targetGroupArn: Swift.String?
        /// <p>The name of the target group.</p>
        public let targetGroupName: Swift.String?
        /// <p>The type of target that you must specify when registering targets with this target group.
        ///       The possible values are <code>instance</code> (register targets by instance ID),
        ///         <code>ip</code> (register targets by IP address), or <code>lambda</code> (register a single
        ///       Lambda function as a target).</p>
        public let targetType: ElasticLoadBalancingV2ClientTypes.TargetTypeEnum?
        /// <p>The number of consecutive health check failures required before considering the target
        ///       unhealthy.</p>
        public let unhealthyThresholdCount: Swift.Int?
        /// <p>The ID of the VPC for the targets.</p>
        public let vpcId: Swift.String?

        public init (
            `protocol`: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
            healthCheckEnabled: Swift.Bool? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckPath: Swift.String? = nil,
            healthCheckPort: Swift.String? = nil,
            healthCheckProtocol: ElasticLoadBalancingV2ClientTypes.ProtocolEnum? = nil,
            healthCheckTimeoutSeconds: Swift.Int? = nil,
            healthyThresholdCount: Swift.Int? = nil,
            loadBalancerArns: [Swift.String]? = nil,
            matcher: ElasticLoadBalancingV2ClientTypes.Matcher? = nil,
            port: Swift.Int? = nil,
            protocolVersion: Swift.String? = nil,
            targetGroupArn: Swift.String? = nil,
            targetGroupName: Swift.String? = nil,
            targetType: ElasticLoadBalancingV2ClientTypes.TargetTypeEnum? = nil,
            unhealthyThresholdCount: Swift.Int? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.healthCheckEnabled = healthCheckEnabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckPath = healthCheckPath
            self.healthCheckPort = healthCheckPort
            self.healthCheckProtocol = healthCheckProtocol
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.loadBalancerArns = loadBalancerArns
            self.matcher = matcher
            self.port = port
            self.protocolVersion = protocolVersion
            self.targetGroupArn = targetGroupArn
            self.targetGroupName = targetGroupName
            self.targetType = targetType
            self.unhealthyThresholdCount = unhealthyThresholdCount
            self.vpcId = vpcId
        }
    }

}

extension TargetGroupAssociationLimitException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetGroupAssociationLimitException(message: \(Swift.String(describing: message)))"}
}

extension TargetGroupAssociationLimitException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TargetGroupAssociationLimitExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of load balancers per target group.</p>
public struct TargetGroupAssociationLimitException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetGroupAssociationLimitExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TargetGroupAssociationLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetGroupAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetGroupAttribute(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about a target group attribute.</p>
    public struct TargetGroupAttribute: Swift.Equatable {
        /// <p>The name of the attribute.</p>
        ///
        ///          <p>The following attribute is supported by all load balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>deregistration_delay.timeout_seconds</code> - The amount of time, in seconds,
        ///           for Elastic Load Balancing to wait before changing the state of a deregistering target
        ///           from <code>draining</code> to <code>unused</code>. The range is 0-3600 seconds. The
        ///           default value is 300 seconds. If the target is a Lambda function, this attribute is not
        ///           supported.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attributes are supported by both Application Load Balancers and Network Load
        ///       Balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>stickiness.enabled</code> - Indicates whether sticky sessions are enabled. The
        ///           value is <code>true</code> or <code>false</code>. The default is
        ///           <code>false</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>stickiness.type</code> - The type of sticky sessions. The possible values are
        ///             <code>lb_cookie</code> and <code>app_cookie</code> for Application Load Balancers or
        ///             <code>source_ip</code> for Network Load Balancers.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attributes are supported only if the load balancer is an Application Load
        ///       Balancer and the target is an instance or an IP address:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>load_balancing.algorithm.type</code> - The load balancing algorithm determines
        ///           how the load balancer selects targets when routing requests. The value is
        ///             <code>round_robin</code> or <code>least_outstanding_requests</code>. The default is
        ///             <code>round_robin</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>slow_start.duration_seconds</code> - The time period, in seconds, during which a
        ///           newly registered target receives an increasing share of the traffic to the target group.
        ///           After this time period ends, the target receives its full share of traffic. The range is
        ///           30-900 seconds (15 minutes). The default is 0 seconds (disabled).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>stickiness.app_cookie.cookie_name</code> - Indicates the name of the
        ///           application-based cookie. Names that start with the following names are not allowed:
        ///             <code>AWSALB</code>, <code>AWSALBAPP</code>, and <code>AWSALBTG</code>. They're reserved
        ///           for use by the load balancer.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>stickiness.app_cookie.duration_seconds</code> - The time period, in seconds,
        ///           during which requests from a client should be routed to the same target. After this time
        ///           period expires, the application-based cookie is considered stale. The range is 1 second to
        ///           1 week (604800 seconds). The default value is 1 day (86400 seconds).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>stickiness.lb_cookie.duration_seconds</code> - The time period, in seconds,
        ///           during which requests from a client should be routed to the same target. After this time
        ///           period expires, the load balancer-generated cookie is considered stale. The range is 1
        ///           second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attribute is supported only if the load balancer is an Application Load
        ///       Balancer and the target is a Lambda function:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>lambda.multi_value_headers.enabled</code> - Indicates whether the request and
        ///           response headers that are exchanged between the load balancer and the Lambda function
        ///           include arrays of values or strings. The value is <code>true</code> or <code>false</code>.
        ///           The default is <code>false</code>. If the value is <code>false</code> and the request
        ///           contains a duplicate header field name or query parameter key, the load balancer uses the
        ///           last value sent by the client.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>The following attributes are supported only by Network Load Balancers:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>deregistration_delay.connection_termination.enabled</code> - Indicates whether
        ///           the load balancer terminates connections at the end of the deregistration timeout. The
        ///           value is <code>true</code> or <code>false</code>. The default is
        ///           <code>false</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>preserve_client_ip.enabled</code> - Indicates whether client IP preservation is
        ///           enabled. The value is <code>true</code> or <code>false</code>. The default is disabled if
        ///           the target group type is IP address and the target group protocol is TCP or TLS.
        ///           Otherwise, the default is enabled. Client IP preservation cannot be disabled for UDP and
        ///           TCP_UDP target groups.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>proxy_protocol_v2.enabled</code> - Indicates whether Proxy Protocol version 2 is
        ///           enabled. The value is <code>true</code> or <code>false</code>. The default is
        ///             <code>false</code>.</p>
        ///             </li>
        ///          </ul>
        public let key: Swift.String?
        /// <p>The value of the attribute.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TargetGroupNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetGroupNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension TargetGroupNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TargetGroupNotFoundExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target group does not exist.</p>
public struct TargetGroupNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TargetGroupNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TargetGroupNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetGroupStickinessConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationSeconds = "DurationSeconds"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetGroupStickinessConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetGroupStickinessConfig(durationSeconds: \(Swift.String(describing: durationSeconds)), enabled: \(Swift.String(describing: enabled)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about the target group stickiness for a rule.</p>
    public struct TargetGroupStickinessConfig: Swift.Equatable {
        /// <p>The time period, in seconds, during which requests from a client should be routed to the
        ///       same target group. The range is 1-604800 seconds (7 days).</p>
        public let durationSeconds: Swift.Int?
        /// <p>Indicates whether target group stickiness is enabled.</p>
        public let enabled: Swift.Bool?

        public init (
            durationSeconds: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationSeconds = durationSeconds
            self.enabled = enabled
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.TargetGroupTuple: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroupArn = "TargetGroupArn"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let weight = weight {
            try container.encode(weight, forKey: ClientRuntime.Key("Weight"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetGroupTuple: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetGroupTuple(targetGroupArn: \(Swift.String(describing: targetGroupArn)), weight: \(Swift.String(describing: weight)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about how traffic will be distributed between multiple target groups in a
    ///       forward rule.</p>
    public struct TargetGroupTuple: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        public let targetGroupArn: Swift.String?
        /// <p>The weight. The range is 0 to 999.</p>
        public let weight: Swift.Int?

        public init (
            targetGroupArn: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.targetGroupArn = targetGroupArn
            self.weight = weight
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.TargetHealth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case reason = "Reason"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.TargetHealthStateEnum.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.TargetHealthReasonEnum.self, forKey: .reason)
        reason = reasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetHealth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetHealth(description: \(Swift.String(describing: description)), reason: \(Swift.String(describing: reason)), state: \(Swift.String(describing: state)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about the current health of a target.</p>
    public struct TargetHealth: Swift.Equatable {
        /// <p>A description of the target health that provides additional details. If the state is
        ///         <code>healthy</code>, a description is not provided.</p>
        public let description: Swift.String?
        /// <p>The reason code.</p>
        ///
        ///          <p>If the target state is <code>healthy</code>, a reason code is not provided.</p>
        ///
        ///          <p>If the target state is <code>initial</code>, the reason code can be one of the following
        ///       values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Elb.RegistrationInProgress</code> - The target is in the process of being registered
        ///           with the load balancer.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Elb.InitialHealthChecking</code> - The load balancer is still sending the target the
        ///           minimum number of health checks required to determine its health status.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>If the target state is <code>unhealthy</code>, the reason code can be one of the following
        ///       values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Target.ResponseCodeMismatch</code> - The health checks did not return an
        ///           expected HTTP code. Applies only to Application Load Balancers and Gateway Load
        ///           Balancers.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Target.Timeout</code> - The health check requests timed out. Applies only to
        ///           Application Load Balancers and Gateway Load Balancers.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Target.FailedHealthChecks</code> - The load balancer received an error while
        ///           establishing a connection to the target or the target response was malformed.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Elb.InternalError</code> - The health checks failed due to an internal error.
        ///           Applies only to Application Load Balancers.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>If the target state is <code>unused</code>, the reason code can be one of the following
        ///       values:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Target.NotRegistered</code> - The target is not registered with the target
        ///           group.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Target.NotInUse</code> - The target group is not used by any load balancer or
        ///           the target is in an Availability Zone that is not enabled for its load balancer.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Target.InvalidState</code> - The target is in the stopped or terminated
        ///           state.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Target.IpUnusable</code> - The target IP address is reserved for use by a load
        ///           balancer.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>If the target state is <code>draining</code>, the reason code can be the following
        ///       value:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Target.DeregistrationInProgress</code> - The target is in the process of being
        ///           deregistered and the deregistration delay period has not expired.</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>If the target state is <code>unavailable</code>, the reason code can be the following
        ///       value:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Target.HealthCheckDisabled</code> - Health checks are disabled for the target
        ///           group. Applies only to Application Load Balancers.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Elb.InternalError</code> - Target health is unavailable due to an internal
        ///           error. Applies only to Network Load Balancers.</p>
        ///             </li>
        ///          </ul>
        public let reason: ElasticLoadBalancingV2ClientTypes.TargetHealthReasonEnum?
        /// <p>The state of the target.</p>
        public let state: ElasticLoadBalancingV2ClientTypes.TargetHealthStateEnum?

        public init (
            description: Swift.String? = nil,
            reason: ElasticLoadBalancingV2ClientTypes.TargetHealthReasonEnum? = nil,
            state: ElasticLoadBalancingV2ClientTypes.TargetHealthStateEnum? = nil
        )
        {
            self.description = description
            self.reason = reason
            self.state = state
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes.TargetHealthDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckPort = "HealthCheckPort"
        case target = "Target"
        case targetHealth = "TargetHealth"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: ClientRuntime.Key("HealthCheckPort"))
        }
        if let target = target {
            try container.encode(target, forKey: ClientRuntime.Key("Target"))
        }
        if let targetHealth = targetHealth {
            try container.encode(targetHealth, forKey: ClientRuntime.Key("TargetHealth"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.TargetDescription.self, forKey: .target)
        target = targetDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let targetHealthDecoded = try containerValues.decodeIfPresent(ElasticLoadBalancingV2ClientTypes.TargetHealth.self, forKey: .targetHealth)
        targetHealth = targetHealthDecoded
    }
}

extension ElasticLoadBalancingV2ClientTypes.TargetHealthDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetHealthDescription(healthCheckPort: \(Swift.String(describing: healthCheckPort)), target: \(Swift.String(describing: target)), targetHealth: \(Swift.String(describing: targetHealth)))"}
}

extension ElasticLoadBalancingV2ClientTypes {
    /// <p>Information about the health of a target.</p>
    public struct TargetHealthDescription: Swift.Equatable {
        /// <p>The port to use to connect with the target.</p>
        public let healthCheckPort: Swift.String?
        /// <p>The description of the target.</p>
        public let target: ElasticLoadBalancingV2ClientTypes.TargetDescription?
        /// <p>The health information for the target.</p>
        public let targetHealth: ElasticLoadBalancingV2ClientTypes.TargetHealth?

        public init (
            healthCheckPort: Swift.String? = nil,
            target: ElasticLoadBalancingV2ClientTypes.TargetDescription? = nil,
            targetHealth: ElasticLoadBalancingV2ClientTypes.TargetHealth? = nil
        )
        {
            self.healthCheckPort = healthCheckPort
            self.target = target
            self.targetHealth = targetHealth
        }
    }

}

extension ElasticLoadBalancingV2ClientTypes {
    public enum TargetHealthReasonEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistrationInProgress
        case failedHealthChecks
        case healthCheckDisabled
        case initialHealthChecking
        case internalError
        case invalidState
        case ipUnusable
        case notInUse
        case notRegistered
        case registrationInProgress
        case responseCodeMismatch
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetHealthReasonEnum] {
            return [
                .deregistrationInProgress,
                .failedHealthChecks,
                .healthCheckDisabled,
                .initialHealthChecking,
                .internalError,
                .invalidState,
                .ipUnusable,
                .notInUse,
                .notRegistered,
                .registrationInProgress,
                .responseCodeMismatch,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistrationInProgress: return "Target.DeregistrationInProgress"
            case .failedHealthChecks: return "Target.FailedHealthChecks"
            case .healthCheckDisabled: return "Target.HealthCheckDisabled"
            case .initialHealthChecking: return "Elb.InitialHealthChecking"
            case .internalError: return "Elb.InternalError"
            case .invalidState: return "Target.InvalidState"
            case .ipUnusable: return "Target.IpUnusable"
            case .notInUse: return "Target.NotInUse"
            case .notRegistered: return "Target.NotRegistered"
            case .registrationInProgress: return "Elb.RegistrationInProgress"
            case .responseCodeMismatch: return "Target.ResponseCodeMismatch"
            case .timeout: return "Target.Timeout"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetHealthReasonEnum(rawValue: rawValue) ?? TargetHealthReasonEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum TargetHealthStateEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draining
        case healthy
        case initial
        case unavailable
        case unhealthy
        case unused
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetHealthStateEnum] {
            return [
                .draining,
                .healthy,
                .initial,
                .unavailable,
                .unhealthy,
                .unused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draining: return "draining"
            case .healthy: return "healthy"
            case .initial: return "initial"
            case .unavailable: return "unavailable"
            case .unhealthy: return "unhealthy"
            case .unused: return "unused"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetHealthStateEnum(rawValue: rawValue) ?? TargetHealthStateEnum.sdkUnknown(rawValue)
        }
    }
}

extension ElasticLoadBalancingV2ClientTypes {
    public enum TargetTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instance
        case ip
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetTypeEnum] {
            return [
                .instance,
                .ip,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instance: return "instance"
            case .ip: return "ip"
            case .lambda: return "lambda"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetTypeEnum(rawValue: rawValue) ?? TargetTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension TooManyActionsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyActionsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyActionsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyActionsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of actions per rule.</p>
public struct TooManyActionsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyActionsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyActionsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificatesException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCertificatesException(message: \(Swift.String(describing: message)))"}
}

extension TooManyCertificatesException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCertificatesExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of certificates per load balancer.</p>
public struct TooManyCertificatesException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCertificatesExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCertificatesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyListenersException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyListenersException(message: \(Swift.String(describing: message)))"}
}

extension TooManyListenersException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyListenersExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of listeners per load balancer.</p>
public struct TooManyListenersException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyListenersExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyListenersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLoadBalancersException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyLoadBalancersException(message: \(Swift.String(describing: message)))"}
}

extension TooManyLoadBalancersException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyLoadBalancersExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of load balancers for your AWS account.</p>
public struct TooManyLoadBalancersException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLoadBalancersExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyLoadBalancersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRegistrationsForTargetIdException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRegistrationsForTargetIdException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRegistrationsForTargetIdException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyRegistrationsForTargetIdExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of times a target can be registered with a load
///       balancer.</p>
public struct TooManyRegistrationsForTargetIdException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRegistrationsForTargetIdExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRegistrationsForTargetIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRulesException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRulesException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRulesException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyRulesExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of rules per load balancer.</p>
public struct TooManyRulesException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRulesExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRulesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of tags per load balancer.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTargetGroupsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTargetGroupsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTargetGroupsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyTargetGroupsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of target groups for your AWS account.</p>
public struct TooManyTargetGroupsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTargetGroupsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTargetGroupsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTargetsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTargetsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTargetsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyTargetsExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of targets.</p>
public struct TooManyTargetsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTargetsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTargetsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyUniqueTargetGroupsPerLoadBalancerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyUniqueTargetGroupsPerLoadBalancerException(message: \(Swift.String(describing: message)))"}
}

extension TooManyUniqueTargetGroupsPerLoadBalancerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyUniqueTargetGroupsPerLoadBalancerExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of unique target groups per load balancer across
///       all listeners. If a target group is used by multiple actions for a load balancer, it is
///       counted as only one use.</p>
public struct TooManyUniqueTargetGroupsPerLoadBalancerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyUniqueTargetGroupsPerLoadBalancerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyUniqueTargetGroupsPerLoadBalancerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedProtocolException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedProtocolException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedProtocolException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnsupportedProtocolExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified protocol is not supported.</p>
public struct UnsupportedProtocolException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedProtocolExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedProtocolExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
