// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class Route53Client {
    public static let clientName = "Route53Client"
    let client: ClientRuntime.SdkHttpClient
    let config: AWSClientRuntime.AWSClientConfiguration
    let serviceName = "Route 53"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: AWSClientRuntime.AWSClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.trimValueWhitespaces = false
        decoder.removeWhitespaceElements = true
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String? = nil) throws {
        let config = try Route53ClientConfiguration(region: region)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class Route53ClientConfiguration: AWSClientRuntime.AWSClientConfiguration {

        public var clientLogMode: ClientRuntime.ClientLogMode
        public var decoder: ClientRuntime.ResponseDecoder?
        public var encoder: ClientRuntime.RequestEncoder?
        public var httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public var httpClientEngine: ClientRuntime.HttpClientEngine
        public var idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public var logger: ClientRuntime.LogAgent
        public var retryer: ClientRuntime.SDKRetryer

        public var credentialsProvider: AWSClientRuntime.CredentialsProvider
        public var endpointResolver: AWSClientRuntime.EndpointResolver
        public var region: Swift.String?
        public var regionResolver: AWSClientRuntime.RegionResolver
        public var signingRegion: Swift.String?

        public init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil,
            runtimeConfig: ClientRuntime.SDKRuntimeConfiguration
        ) throws {
            self.regionResolver = regionResolver ?? DefaultRegionResolver()
            let defaultRegion = self.regionResolver.resolveRegion()
            self.region = region ?? defaultRegion
            self.signingRegion = signingRegion ?? defaultRegion
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromCustom(credProvider)
            } else {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retryer = runtimeConfig.retryer
        }

        public convenience init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil
        ) throws {
            let defaultRuntimeConfig = try ClientRuntime.DefaultSDKRuntimeConfiguration("Route53Client")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, regionResolver: regionResolver, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct Route53ClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "Route53Client"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension Route53Client: Route53ClientProtocol {
    /// Activates a key-signing key (KSK) so that it can be used for signing by DNSSEC. This operation changes the
    /// 			KSK status to ACTIVE.
    public func activateKeySigningKey(input: ActivateKeySigningKeyInput, completion: @escaping (ClientRuntime.SdkResult<ActivateKeySigningKeyOutputResponse, ActivateKeySigningKeyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "activateKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ActivateKeySigningKeyInput, ActivateKeySigningKeyOutputResponse, ActivateKeySigningKeyOutputError>(id: "activateKeySigningKey")
        operation.initializeStep.intercept(position: .after, middleware: ActivateKeySigningKeyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ActivateKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ActivateKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ActivateKeySigningKeyInput, ActivateKeySigningKeyOutputResponse, ActivateKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Associates an Amazon VPC with a private hosted zone.
    /// 		
    ///             To perform the association, the VPC and the private hosted zone must already exist.
    /// 			You can't convert a public hosted zone into a private hosted zone.
    ///
    /// 		
    ///             If you want to associate a VPC that was created by using one Amazon Web Services account with a private hosted zone that was created
    /// 			by using a different account, the Amazon Web Services account that created the private hosted zone must first submit a
    /// 			CreateVPCAssociationAuthorization request. Then the account that created the VPC must submit an
    /// 			AssociateVPCWithHostedZone request.
    ///
    public func associateVPCWithHostedZone(input: AssociateVPCWithHostedZoneInput, completion: @escaping (ClientRuntime.SdkResult<AssociateVPCWithHostedZoneOutputResponse, AssociateVPCWithHostedZoneOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "associateVPCWithHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<AssociateVPCWithHostedZoneInput, AssociateVPCWithHostedZoneOutputResponse, AssociateVPCWithHostedZoneOutputError>(id: "associateVPCWithHostedZone")
        operation.initializeStep.intercept(position: .after, middleware: AssociateVPCWithHostedZoneInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: AssociateVPCWithHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: AssociateVPCWithHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<AssociateVPCWithHostedZoneInput, AssociateVPCWithHostedZoneOutputResponse, AssociateVPCWithHostedZoneOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: AssociateVPCWithHostedZoneInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates, changes, or deletes a resource record set, which contains authoritative DNS information for a specified
    /// 			domain name or subdomain name. For example, you can use ChangeResourceRecordSets to create a resource record set that
    /// 			routes traffic for test.example.com to a web server that has an IP address of 192.0.2.44.
    /// 		
    /// 		
    ///             Deleting Resource Record Sets
    ///
    /// 		       To delete a resource record set, you must specify all the same values that you specified when you created it.
    ///
    /// 		
    ///             Change Batches and Transactional Changes
    ///
    /// 		       The request body must include a document with a ChangeResourceRecordSetsRequest element.
    /// 			The request body contains a list of change items, known as a change batch. Change batches are considered transactional changes.
    /// 			Route 53 validates the changes in the request and then either makes all or none of the changes in the change batch request.
    /// 			This ensures that DNS routing isn't adversely affected by partial changes to the resource record sets in a hosted zone.
    /// 		       For example, suppose a change batch request contains two changes: it deletes the CNAME resource record set for www.example.com and
    /// 			creates an alias resource record set for www.example.com. If validation for both records succeeds, Route 53 deletes the first resource record set and
    /// 			creates the second resource record set in a single operation. If validation for either the DELETE or the CREATE action fails,
    /// 			then the request is canceled, and the original CNAME record continues to exist.
    /// 		
    /// 			         If you try to delete the same resource record set more than once in a single change batch, Route 53 returns an InvalidChangeBatch error.
    /// 		
    /// 		
    /// 		
    ///             Traffic Flow
    ///
    /// 		       To create resource record sets for complex routing configurations, use either the traffic flow visual editor in the
    /// 			Route 53 console or the API actions for traffic policies and traffic policy instances. Save the configuration as a traffic policy,
    /// 			then associate the traffic policy with one or more domain names (such as example.com) or subdomain names (such as www.example.com),
    /// 			in the same hosted zone or in multiple hosted zones. You can roll back the updates if the new configuration isn't performing
    /// 			as expected. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/traffic-flow.html">Using Traffic Flow to Route DNS Traffic
    /// 			in the Amazon Route 53 Developer Guide.
    /// 		
    /// 		
    ///             Create, Delete, and Upsert
    ///
    /// 		       Use ChangeResourceRecordsSetsRequest to perform the following actions:
    /// 			
    ///
    /// 					
    ///                   CREATE: Creates a resource record set that has the specified values.
    /// 				
    ///
    /// 					
    ///                   DELETE: Deletes an existing resource record set that has the specified values.
    /// 				
    ///
    /// 					
    ///                   UPSERT: If a resource record set does not already exist, Amazon Web Services creates it.
    /// 						If a resource set does exist, Route 53 updates it with the values in the request.
    /// 				
    ///
    /// 		
    /// 		
    ///             Syntaxes for Creating, Updating, and Deleting Resource Record Sets
    ///
    /// 		       The syntax for a request depends on the type of resource record set that you want to create, delete, or update, such as
    /// 			weighted, alias, or failover. The XML elements in your request must appear in the order listed in the syntax.
    ///
    /// 		
    /// 		       For an example for each type of resource record set, see "Examples."
    /// 		
    /// 		
    /// 		       Don't refer to the syntax in the "Parameter Syntax" section, which includes all of the elements for every kind of
    /// 			resource record set that you can create, delete, or update by using ChangeResourceRecordSets.
    /// 		
    /// 		
    ///             Change Propagation to Route 53 DNS Servers
    ///
    /// 		       When you submit a ChangeResourceRecordSets request, Route 53 propagates your changes to all of the
    /// 			Route 53 authoritative DNS servers. While your changes are propagating, GetChange returns a status of
    /// 			PENDING. When propagation is complete, GetChange returns a status of INSYNC.
    /// 			Changes generally propagate to all Route 53 name servers within 60 seconds. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetChange.html">GetChange.
    ///
    /// 		
    ///             Limits on ChangeResourceRecordSets Requests
    ///
    /// 		       For information about the limits on a ChangeResourceRecordSets request, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits in the
    /// 			Amazon Route 53 Developer Guide.
    public func changeResourceRecordSets(input: ChangeResourceRecordSetsInput, completion: @escaping (ClientRuntime.SdkResult<ChangeResourceRecordSetsOutputResponse, ChangeResourceRecordSetsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "changeResourceRecordSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ChangeResourceRecordSetsInput, ChangeResourceRecordSetsOutputResponse, ChangeResourceRecordSetsOutputError>(id: "changeResourceRecordSets")
        operation.initializeStep.intercept(position: .after, middleware: ChangeResourceRecordSetsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ChangeResourceRecordSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ChangeResourceRecordSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ChangeResourceRecordSetsInput, ChangeResourceRecordSetsOutputResponse, ChangeResourceRecordSetsOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: ChangeResourceRecordSetsInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Adds, edits, or deletes tags for a health check or a hosted zone.
    /// 		       For information about using tags for cost allocation, see
    /// 			<a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags
    /// 			in the Billing and Cost Management User Guide.
    public func changeTagsForResource(input: ChangeTagsForResourceInput, completion: @escaping (ClientRuntime.SdkResult<ChangeTagsForResourceOutputResponse, ChangeTagsForResourceOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "changeTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ChangeTagsForResourceInput, ChangeTagsForResourceOutputResponse, ChangeTagsForResourceOutputError>(id: "changeTagsForResource")
        operation.initializeStep.intercept(position: .after, middleware: ChangeTagsForResourceInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ChangeTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ChangeTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ChangeTagsForResourceInput, ChangeTagsForResourceOutputResponse, ChangeTagsForResourceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: ChangeTagsForResourceInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new health check.
    /// 		       For information about adding health checks to resource record sets, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ResourceRecordSet.html#Route53-Type-ResourceRecordSet-HealthCheckId">HealthCheckId
    /// 			in
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets.
    /// 		
    /// 		
    ///             ELB Load Balancers
    ///
    /// 		       If you're registering EC2 instances with an Elastic Load Balancing (ELB) load balancer, do not create Amazon Route 53 health checks for the
    /// 			EC2 instances. When you register an EC2 instance with a load balancer, you configure settings for an ELB health check, which performs a
    /// 			similar function to a Route 53 health check.
    /// 		
    /// 		
    ///             Private Hosted Zones
    ///
    /// 		       You can associate health checks with failover resource record sets in a private hosted zone. Note the following:
    /// 		
    ///
    /// 				           Route 53 health checkers are outside the VPC. To check the health of an endpoint within a VPC by IP address, you must
    /// 					assign a public IP address to the instance in the VPC.
    /// 			
    ///
    /// 				           You can configure a health checker to check the health of an external resource that the instance relies on, such as a
    /// 					database server.
    /// 			
    ///
    /// 				           You can create a CloudWatch metric, associate an alarm with the metric, and then create a health check that is based on the
    /// 					state of the alarm. For example, you might create a CloudWatch metric that checks the status of the Amazon EC2 StatusCheckFailed metric,
    /// 					add an alarm to the metric, and then create a health check that is based on the state of the alarm. For information about creating
    /// 					CloudWatch metrics and alarms by using the CloudWatch console, see the
    /// 					<a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/WhatIsCloudWatch.html">Amazon CloudWatch User Guide.
    /// 			
    ///
    public func createHealthCheck(input: CreateHealthCheckInput, completion: @escaping (ClientRuntime.SdkResult<CreateHealthCheckOutputResponse, CreateHealthCheckOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateHealthCheckInput, CreateHealthCheckOutputResponse, CreateHealthCheckOutputError>(id: "createHealthCheck")
        operation.initializeStep.intercept(position: .after, middleware: CreateHealthCheckInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateHealthCheckInput, CreateHealthCheckOutputResponse, CreateHealthCheckOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateHealthCheckInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new public or private hosted zone. You create records in a public hosted zone to define how you want to route traffic
    /// 			on the internet for a domain, such as example.com, and its subdomains (apex.example.com, acme.example.com). You create records in a
    /// 			private hosted zone to define how you want to route traffic for a domain and its subdomains within one or more
    /// 			Amazon Virtual Private Clouds (Amazon VPCs).
    /// 		
    /// 			         You can't convert a public hosted zone to a private hosted zone or vice versa. Instead, you must create a new hosted zone
    /// 				with the same name and create new resource record sets.
    /// 		
    /// 		       For more information about charges for hosted zones, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing.
    /// 		       Note the following:
    /// 		
    ///
    /// 				           You can't create a hosted zone for a top-level domain (TLD) such as .com.
    /// 			
    ///
    /// 				           For public hosted zones, Route 53 automatically creates a default SOA record and four NS records for the zone.
    /// 					For more information about SOA and NS records, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/SOA-NSrecords.html">NS and SOA Records that Route 53 Creates for a Hosted Zone in the
    /// 					Amazon Route 53 Developer Guide.
    /// 				           If you want to use the same name servers for multiple public hosted zones, you can optionally associate a reusable delegation set
    /// 					with the hosted zone. See the DelegationSetId element.
    /// 			
    ///
    /// 				           If your domain is registered with a registrar other than Route 53, you must update the name servers with your registrar to make
    /// 					Route 53 the DNS service for the domain. For more information, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/MigratingDNS.html">Migrating DNS Service for an Existing Domain to Amazon Route 53 in the
    /// 					Amazon Route 53 Developer Guide.
    /// 			
    ///
    /// 		       When you submit a CreateHostedZone request, the initial status of the hosted zone is PENDING.
    /// 			For public hosted zones, this means that the NS and SOA records are not yet available on all Route 53 DNS servers. When the
    /// 			NS and SOA records are available, the status of the zone changes to INSYNC.
    /// 		       The CreateHostedZone request requires the caller to have an ec2:DescribeVpcs permission.
    public func createHostedZone(input: CreateHostedZoneInput, completion: @escaping (ClientRuntime.SdkResult<CreateHostedZoneOutputResponse, CreateHostedZoneOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateHostedZoneInput, CreateHostedZoneOutputResponse, CreateHostedZoneOutputError>(id: "createHostedZone")
        operation.initializeStep.intercept(position: .after, middleware: CreateHostedZoneInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateHostedZoneInput, CreateHostedZoneOutputResponse, CreateHostedZoneOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateHostedZoneInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new key-signing key (KSK) associated with a hosted zone. You can only have two KSKs per hosted zone.
    public func createKeySigningKey(input: CreateKeySigningKeyInput, completion: @escaping (ClientRuntime.SdkResult<CreateKeySigningKeyOutputResponse, CreateKeySigningKeyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateKeySigningKeyInput, CreateKeySigningKeyOutputResponse, CreateKeySigningKeyOutputError>(id: "createKeySigningKey")
        operation.initializeStep.intercept(position: .after, middleware: CreateKeySigningKeyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateKeySigningKeyInput, CreateKeySigningKeyOutputResponse, CreateKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateKeySigningKeyInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a configuration for DNS query logging. After you create a query logging configuration, Amazon Route 53 begins to publish
    /// 			log data to an Amazon CloudWatch Logs log group.
    /// 		       DNS query logs contain information about the queries that Route 53 receives for a specified public hosted zone, such as the following:
    /// 		
    ///
    ///                Route 53 edge location that responded to the DNS query
    ///
    ///
    ///                Domain or subdomain that was requested
    ///
    ///
    ///                DNS record type, such as A or AAAA
    ///
    ///
    ///                DNS response code, such as NoError or ServFail
    ///
    ///
    ///
    /// 		
    /// 		
    ///             Log Group and Resource Policy
    ///
    ///                Before you create a query logging configuration, perform the following operations.
    /// 					
    ///                   If you create a query logging configuration using the Route 53 console, Route 53 performs these operations automatically.
    ///
    /// 					          <ol>
    ///
    ///                      Create a CloudWatch Logs log group, and make note of the ARN, which you specify when you create a
    /// 							query logging configuration. Note the following:
    /// 							
    ///
    ///                            You must create the log group in the us-east-1 region.
    ///
    ///
    ///                            You must use the same Amazon Web Services account to create the log group and the hosted zone that you want to
    /// 									configure query logging for.
    ///
    ///
    ///                            When you create log groups for query logging, we recommend that you use a consistent prefix, for example:
    /// 									
    ///                               /aws/route53/hosted zone name
    ///
    ///
    /// 									                  In the next step, you'll create a resource policy, which controls access to one or more log groups and the associated
    /// 										Amazon Web Services resources, such as Route 53 hosted zones. There's a limit on the number of resource policies that you can create, so
    /// 										we recommend that you use a consistent prefix so you can use the same resource policy for all the log groups that you create
    /// 										for query logging.
    /// 								
    ///
    /// 						
    ///
    ///                      Create a CloudWatch Logs resource policy, and give it the permissions that Route 53 needs to create log streams and to
    /// 							send query logs to log streams. For the value of Resource, specify the ARN for the log group that you created
    /// 							in the previous step. To use the same resource policy for all the CloudWatch Logs log groups that you created for query logging configurations,
    /// 							replace the hosted zone name with *, for example:
    /// 							
    ///                         arn:aws:logs:us-east-1:123412341234:log-group:/aws/route53/*
    ///
    /// 							
    ///                         You can't use the CloudWatch console to create or edit a resource policy. You must use the CloudWatch API, one of the Amazon Web Services SDKs,
    /// 								or the CLI.
    ///
    /// 						
    ///                </ol>
    /// 				
    ///             Log Streams and Edge Locations
    ///
    ///                When Route 53 finishes creating the configuration for DNS query logging, it does the following:
    /// 					
    ///
    ///                      Creates a log stream for an edge location the first time that the edge location responds to DNS queries for the
    /// 							specified hosted zone. That log stream is used to log all queries that Route 53 responds to for that edge location.
    ///
    ///
    ///                      Begins to send query logs to the applicable log stream.
    ///
    ///
    /// 					          The name of each log stream is in the following format:
    /// 					
    ///
    ///                      hosted zone ID/edge location code
    ///
    ///
    /// 					          The edge location code is a three-letter code and an arbitrarily assigned number, for example, DFW3. The three-letter code
    /// 						typically corresponds with the International Air Transport Association airport code for an airport near the edge location.
    /// 						(These abbreviations might change in the future.) For a list of edge locations, see "The Route 53 Global Network" on the
    /// 						<a href="http://aws.amazon.com/route53/details/">Route 53 Product Details page.
    /// 				
    ///             Queries That Are Logged
    ///
    ///                Query logs contain only the queries that DNS resolvers forward to Route 53. If a DNS resolver has already cached
    /// 					the response to a query (such as the IP address for a load balancer for example.com), the resolver will continue to return
    /// 					the cached response. It doesn't forward another query to Route 53 until the TTL for the corresponding resource record set expires.
    /// 					Depending on how many DNS queries are submitted for a resource record set, and depending on the TTL for that resource record set,
    /// 					query logs might contain information about only one query out of every several thousand queries that are submitted to DNS.
    /// 					For more information about how DNS works, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-dns-service.html">Routing Internet Traffic to Your Website or Web Application
    /// 					in the Amazon Route 53 Developer Guide.
    /// 				
    ///             Log File Format
    ///
    ///                For a list of the values in each query log and the format of each value, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries in the
    /// 					Amazon Route 53 Developer Guide.
    /// 				
    ///             Pricing
    ///
    ///                For information about charges for query logs, see
    /// 					<a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing.
    ///
    ///             How to Stop Logging
    ///
    ///                If you want Route 53 to stop sending query logs to CloudWatch Logs, delete the query logging configuration. For more information, see
    /// 					<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteQueryLoggingConfig.html">DeleteQueryLoggingConfig.
    /// 				
    ///
    public func createQueryLoggingConfig(input: CreateQueryLoggingConfigInput, completion: @escaping (ClientRuntime.SdkResult<CreateQueryLoggingConfigOutputResponse, CreateQueryLoggingConfigOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createQueryLoggingConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateQueryLoggingConfigInput, CreateQueryLoggingConfigOutputResponse, CreateQueryLoggingConfigOutputError>(id: "createQueryLoggingConfig")
        operation.initializeStep.intercept(position: .after, middleware: CreateQueryLoggingConfigInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateQueryLoggingConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateQueryLoggingConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateQueryLoggingConfigInput, CreateQueryLoggingConfigOutputResponse, CreateQueryLoggingConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateQueryLoggingConfigInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a delegation set (a group of four name servers) that can be reused by multiple hosted zones that were created by
    /// 			the same Amazon Web Services account.
    /// 		       You can also create a reusable delegation set that uses the four name servers that are associated
    /// 			with an existing hosted zone. Specify the hosted zone ID in the CreateReusableDelegationSet request.
    /// 		
    /// 			         You can't associate a reusable delegation set with a private hosted zone.
    /// 		
    /// 		       For information about using a reusable delegation set to configure white label name servers, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/white-label-name-servers.html">Configuring White Label Name Servers.
    /// 		
    /// 		       The process for migrating existing hosted zones to use a reusable delegation set is comparable to the process for
    /// 			configuring white label name servers. You need to perform the following steps:
    /// 		       <ol>
    ///
    ///                Create a reusable delegation set.
    ///
    ///
    ///                Recreate hosted zones, and reduce the TTL to 60 seconds or less.
    ///
    ///
    ///                Recreate resource record sets in the new hosted zones.
    ///
    ///
    ///                Change the registrar's name servers to use the name servers for the new hosted zones.
    ///
    ///
    ///                Monitor traffic for the website or application.
    ///
    ///
    ///                Change TTLs back to their original values.
    ///
    ///          </ol>
    /// 		
    /// 		       If you want to migrate existing hosted zones to use a reusable delegation set, the existing hosted zones can't use
    /// 			any of the name servers that are assigned to the reusable delegation set. If one or more hosted zones do use one or more
    /// 			name servers that are assigned to the reusable delegation set, you can do one of the following:
    /// 		
    ///
    ///                For small numbers of hosted zones—up to a few hundred—it's relatively easy to create
    /// 				reusable delegation sets until you get one that has four name servers that don't overlap with any of the name servers
    /// 				in your hosted zones.
    ///
    ///
    ///                For larger numbers of hosted zones, the easiest solution is to use more than one reusable delegation set.
    ///
    ///
    ///                For larger numbers of hosted zones, you can also migrate hosted zones that have overlapping name servers
    /// 				to hosted zones that don't have overlapping name servers, then migrate the hosted zones again to use the
    /// 				reusable delegation set.
    ///
    ///
    public func createReusableDelegationSet(input: CreateReusableDelegationSetInput, completion: @escaping (ClientRuntime.SdkResult<CreateReusableDelegationSetOutputResponse, CreateReusableDelegationSetOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createReusableDelegationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateReusableDelegationSetInput, CreateReusableDelegationSetOutputResponse, CreateReusableDelegationSetOutputError>(id: "createReusableDelegationSet")
        operation.initializeStep.intercept(position: .after, middleware: CreateReusableDelegationSetInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateReusableDelegationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateReusableDelegationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateReusableDelegationSetInput, CreateReusableDelegationSetOutputResponse, CreateReusableDelegationSetOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateReusableDelegationSetInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a traffic policy, which you use to create multiple DNS resource record sets for one domain name (such as example.com) or
    /// 			one subdomain name (such as www.example.com).
    public func createTrafficPolicy(input: CreateTrafficPolicyInput, completion: @escaping (ClientRuntime.SdkResult<CreateTrafficPolicyOutputResponse, CreateTrafficPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTrafficPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateTrafficPolicyInput, CreateTrafficPolicyOutputResponse, CreateTrafficPolicyOutputError>(id: "createTrafficPolicy")
        operation.initializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateTrafficPolicyInput, CreateTrafficPolicyOutputResponse, CreateTrafficPolicyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates resource record sets in a specified hosted zone based on the settings in a specified traffic policy version.
    /// 			In addition, CreateTrafficPolicyInstance associates the resource record sets with a specified domain name (such as example.com) or
    /// 			subdomain name (such as www.example.com). Amazon Route 53 responds to DNS queries for the domain or subdomain name by using the resource record sets
    /// 			that CreateTrafficPolicyInstance created.
    public func createTrafficPolicyInstance(input: CreateTrafficPolicyInstanceInput, completion: @escaping (ClientRuntime.SdkResult<CreateTrafficPolicyInstanceOutputResponse, CreateTrafficPolicyInstanceOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateTrafficPolicyInstanceInput, CreateTrafficPolicyInstanceOutputResponse, CreateTrafficPolicyInstanceOutputError>(id: "createTrafficPolicyInstance")
        operation.initializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInstanceInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateTrafficPolicyInstanceInput, CreateTrafficPolicyInstanceOutputResponse, CreateTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyInstanceInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new version of an existing traffic policy. When you create a new version of a traffic policy, you specify the ID of the
    /// 			traffic policy that you want to update and a JSON-formatted document that describes the new version. You use traffic policies to create
    /// 			multiple DNS resource record sets for one domain name (such as example.com) or one subdomain name (such as www.example.com). You can
    /// 			create a maximum of 1000 versions of a traffic policy. If you reach the limit and need to create another version, you'll need to start a new
    /// 			traffic policy.
    public func createTrafficPolicyVersion(input: CreateTrafficPolicyVersionInput, completion: @escaping (ClientRuntime.SdkResult<CreateTrafficPolicyVersionOutputResponse, CreateTrafficPolicyVersionOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createTrafficPolicyVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateTrafficPolicyVersionInput, CreateTrafficPolicyVersionOutputResponse, CreateTrafficPolicyVersionOutputError>(id: "createTrafficPolicyVersion")
        operation.initializeStep.intercept(position: .after, middleware: CreateTrafficPolicyVersionInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateTrafficPolicyVersionInput, CreateTrafficPolicyVersionOutputResponse, CreateTrafficPolicyVersionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateTrafficPolicyVersionInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Authorizes the Amazon Web Services account that created a specified VPC to submit an AssociateVPCWithHostedZone
    /// 			request to associate the VPC with a specified hosted zone that was created by a different account.
    /// 			To submit a CreateVPCAssociationAuthorization request, you must use the account that created the
    /// 			hosted zone. After you authorize the association, use the account that created the VPC to submit an
    /// 			AssociateVPCWithHostedZone request.
    /// 		
    ///             If you want to associate multiple VPCs that you created by using one account with a hosted zone
    /// 			that you created by using a different account, you must submit one authorization request for each VPC.
    ///
    public func createVPCAssociationAuthorization(input: CreateVPCAssociationAuthorizationInput, completion: @escaping (ClientRuntime.SdkResult<CreateVPCAssociationAuthorizationOutputResponse, CreateVPCAssociationAuthorizationOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVPCAssociationAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateVPCAssociationAuthorizationInput, CreateVPCAssociationAuthorizationOutputResponse, CreateVPCAssociationAuthorizationOutputError>(id: "createVPCAssociationAuthorization")
        operation.initializeStep.intercept(position: .after, middleware: CreateVPCAssociationAuthorizationInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: CreateVPCAssociationAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateVPCAssociationAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVPCAssociationAuthorizationInput, CreateVPCAssociationAuthorizationOutputResponse, CreateVPCAssociationAuthorizationOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: CreateVPCAssociationAuthorizationInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deactivates a key-signing key (KSK) so that it will not be used for signing by DNSSEC. This operation changes the
    /// 			KSK status to INACTIVE.
    public func deactivateKeySigningKey(input: DeactivateKeySigningKeyInput, completion: @escaping (ClientRuntime.SdkResult<DeactivateKeySigningKeyOutputResponse, DeactivateKeySigningKeyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deactivateKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeactivateKeySigningKeyInput, DeactivateKeySigningKeyOutputResponse, DeactivateKeySigningKeyOutputError>(id: "deactivateKeySigningKey")
        operation.initializeStep.intercept(position: .after, middleware: DeactivateKeySigningKeyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeactivateKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeactivateKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeactivateKeySigningKeyInput, DeactivateKeySigningKeyOutputResponse, DeactivateKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a health check.
    /// 		
    /// 			         Amazon Route 53 does not prevent you from deleting a health check even if the health check is associated with one or more
    /// 				resource record sets. If you delete a health check and you don't update the associated resource record sets, the future status
    /// 				of the health check can't be predicted and may change. This will affect the routing of DNS queries for your DNS failover
    /// 				configuration. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html#health-checks-deleting.html">Replacing and Deleting Health Checks
    /// 				in the Amazon Route 53 Developer Guide.
    /// 		
    /// 		
    /// 		       If you're using Cloud Map and you configured Cloud Map to create a Route 53 health check when you register an instance,
    /// 			you can't use the Route 53 DeleteHealthCheck command to delete the health check. The health check is deleted
    /// 			automatically when you deregister the instance; there can be a delay of several hours before the health check is deleted
    /// 			from Route 53.
    public func deleteHealthCheck(input: DeleteHealthCheckInput, completion: @escaping (ClientRuntime.SdkResult<DeleteHealthCheckOutputResponse, DeleteHealthCheckOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteHealthCheckInput, DeleteHealthCheckOutputResponse, DeleteHealthCheckOutputError>(id: "deleteHealthCheck")
        operation.initializeStep.intercept(position: .after, middleware: DeleteHealthCheckInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteHealthCheckInput, DeleteHealthCheckOutputResponse, DeleteHealthCheckOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a hosted zone.
    /// 		
    /// 		       If the hosted zone was created by another service, such as Cloud Map, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DeleteHostedZone.html#delete-public-hosted-zone-created-by-another-service">Deleting
    /// 			Public Hosted Zones That Were Created by Another Service in the Amazon Route 53 Developer Guide for information about how to delete it.
    /// 			(The process is the same for public and private hosted zones that were created by another service.)
    /// 		
    /// 		       If you want to keep your domain registration but you want to stop routing internet traffic to your website or web application,
    /// 			we recommend that you delete resource record sets in the hosted zone instead of deleting the hosted zone.
    /// 		
    /// 		
    /// 			         If you delete a hosted zone, you can't undelete it. You must create a new hosted zone and update the name servers for your
    /// 				domain registration, which can require up to 48 hours to take effect. (If you delegated responsibility for a subdomain to a hosted zone
    /// 				and you delete the child hosted zone, you must update the name servers in the parent hosted zone.) In addition, if you delete a hosted zone,
    /// 				someone could hijack the domain and route traffic to their own resources using your domain name.
    /// 		
    /// 		
    /// 		       If you want to avoid the monthly charge for the hosted zone, you can transfer DNS service for the domain to a free DNS service.
    /// 			When you transfer DNS service, you have to update the name servers for the domain registration. If the domain is registered with Route 53,
    /// 			see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_UpdateDomainNameservers.html">UpdateDomainNameservers
    /// 			for information about how to replace Route 53 name servers with name servers for the new DNS service. If the domain is registered with
    /// 			another registrar, use the method provided by the registrar to update name servers for the domain registration. For more information,
    /// 			perform an internet search on "free DNS service."
    ///
    /// 		       You can delete a hosted zone only if it contains only the default SOA record and NS resource record sets.
    /// 			If the hosted zone contains other resource record sets, you must delete them before you can delete the hosted zone.
    /// 			If you try to delete a hosted zone that contains other resource record sets, the request fails, and Route 53 returns a
    /// 			HostedZoneNotEmpty error. For information about deleting records from your hosted zone, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets.
    /// 		       To verify that the hosted zone has been deleted, do one of the following:
    /// 		
    ///
    ///                Use the GetHostedZone action to request information about the hosted zone.
    ///
    ///
    ///                Use the ListHostedZones action to get a list of the hosted zones associated with the current
    /// 				Amazon Web Services account.
    ///
    ///
    public func deleteHostedZone(input: DeleteHostedZoneInput, completion: @escaping (ClientRuntime.SdkResult<DeleteHostedZoneOutputResponse, DeleteHostedZoneOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteHostedZoneInput, DeleteHostedZoneOutputResponse, DeleteHostedZoneOutputError>(id: "deleteHostedZone")
        operation.initializeStep.intercept(position: .after, middleware: DeleteHostedZoneInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteHostedZoneInput, DeleteHostedZoneOutputResponse, DeleteHostedZoneOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a key-signing key (KSK). Before you can delete a KSK, you must deactivate it. The KSK must be
    /// 		deactivated before you can delete it regardless of whether the hosted zone is enabled for DNSSEC signing.
    public func deleteKeySigningKey(input: DeleteKeySigningKeyInput, completion: @escaping (ClientRuntime.SdkResult<DeleteKeySigningKeyOutputResponse, DeleteKeySigningKeyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteKeySigningKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteKeySigningKeyInput, DeleteKeySigningKeyOutputResponse, DeleteKeySigningKeyOutputError>(id: "deleteKeySigningKey")
        operation.initializeStep.intercept(position: .after, middleware: DeleteKeySigningKeyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteKeySigningKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteKeySigningKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteKeySigningKeyInput, DeleteKeySigningKeyOutputResponse, DeleteKeySigningKeyOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a configuration for DNS query logging. If you delete a configuration, Amazon Route 53 stops sending query logs to CloudWatch Logs.
    /// 			Route 53 doesn't delete any logs that are already in CloudWatch Logs.
    /// 		
    /// 		       For more information about DNS query logs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig.
    public func deleteQueryLoggingConfig(input: DeleteQueryLoggingConfigInput, completion: @escaping (ClientRuntime.SdkResult<DeleteQueryLoggingConfigOutputResponse, DeleteQueryLoggingConfigOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteQueryLoggingConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteQueryLoggingConfigInput, DeleteQueryLoggingConfigOutputResponse, DeleteQueryLoggingConfigOutputError>(id: "deleteQueryLoggingConfig")
        operation.initializeStep.intercept(position: .after, middleware: DeleteQueryLoggingConfigInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteQueryLoggingConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteQueryLoggingConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteQueryLoggingConfigInput, DeleteQueryLoggingConfigOutputResponse, DeleteQueryLoggingConfigOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a reusable delegation set.
    /// 		
    /// 			         You can delete a reusable delegation set only if it isn't associated with any hosted zones.
    /// 		
    /// 		       To verify that the reusable delegation set is not associated with any hosted zones, submit a
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSet.html">GetReusableDelegationSet
    /// 			request and specify the ID of the reusable delegation set that you want to delete.
    public func deleteReusableDelegationSet(input: DeleteReusableDelegationSetInput, completion: @escaping (ClientRuntime.SdkResult<DeleteReusableDelegationSetOutputResponse, DeleteReusableDelegationSetOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteReusableDelegationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteReusableDelegationSetInput, DeleteReusableDelegationSetOutputResponse, DeleteReusableDelegationSetOutputError>(id: "deleteReusableDelegationSet")
        operation.initializeStep.intercept(position: .after, middleware: DeleteReusableDelegationSetInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteReusableDelegationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteReusableDelegationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteReusableDelegationSetInput, DeleteReusableDelegationSetOutputResponse, DeleteReusableDelegationSetOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a traffic policy.
    /// 		       When you delete a traffic policy, Route 53 sets a flag on the policy to indicate that it has been deleted. However, Route 53 never fully deletes
    /// 			the traffic policy. Note the following:
    /// 		
    ///
    ///                Deleted traffic policies aren't listed if you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListTrafficPolicies.html">ListTrafficPolicies.
    ///
    ///
    ///                	There's no way to get a list of deleted policies.
    ///
    ///
    ///                If you retain the ID of the policy, you can get information about the policy, including the traffic policy document, by running
    /// 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetTrafficPolicy.html">GetTrafficPolicy.
    ///
    ///
    public func deleteTrafficPolicy(input: DeleteTrafficPolicyInput, completion: @escaping (ClientRuntime.SdkResult<DeleteTrafficPolicyOutputResponse, DeleteTrafficPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTrafficPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteTrafficPolicyInput, DeleteTrafficPolicyOutputResponse, DeleteTrafficPolicyOutputError>(id: "deleteTrafficPolicy")
        operation.initializeStep.intercept(position: .after, middleware: DeleteTrafficPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteTrafficPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteTrafficPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteTrafficPolicyInput, DeleteTrafficPolicyOutputResponse, DeleteTrafficPolicyOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a traffic policy instance and all of the resource record sets that Amazon Route 53 created when you created the instance.
    /// 		
    /// 			         In the Route 53 console, traffic policy instances are known as policy records.
    /// 		
    public func deleteTrafficPolicyInstance(input: DeleteTrafficPolicyInstanceInput, completion: @escaping (ClientRuntime.SdkResult<DeleteTrafficPolicyInstanceOutputResponse, DeleteTrafficPolicyInstanceOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteTrafficPolicyInstanceInput, DeleteTrafficPolicyInstanceOutputResponse, DeleteTrafficPolicyInstanceOutputError>(id: "deleteTrafficPolicyInstance")
        operation.initializeStep.intercept(position: .after, middleware: DeleteTrafficPolicyInstanceInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteTrafficPolicyInstanceInput, DeleteTrafficPolicyInstanceOutputResponse, DeleteTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Removes authorization to submit an AssociateVPCWithHostedZone request to associate a specified VPC
    /// 			with a hosted zone that was created by a different account. You must use the account that created the hosted zone
    /// 			to submit a DeleteVPCAssociationAuthorization request.
    /// 		
    /// 			         Sending this request only prevents the Amazon Web Services account that created the VPC from associating the VPC
    /// 				with the Amazon Route 53 hosted zone in the future. If the VPC is already associated with the hosted zone,
    /// 				DeleteVPCAssociationAuthorization won't disassociate the VPC from the hosted zone.
    /// 				If you want to delete an existing association, use DisassociateVPCFromHostedZone.
    /// 		
    public func deleteVPCAssociationAuthorization(input: DeleteVPCAssociationAuthorizationInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVPCAssociationAuthorizationOutputResponse, DeleteVPCAssociationAuthorizationOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVPCAssociationAuthorization")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteVPCAssociationAuthorizationInput, DeleteVPCAssociationAuthorizationOutputResponse, DeleteVPCAssociationAuthorizationOutputError>(id: "deleteVPCAssociationAuthorization")
        operation.initializeStep.intercept(position: .after, middleware: DeleteVPCAssociationAuthorizationInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DeleteVPCAssociationAuthorizationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteVPCAssociationAuthorizationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVPCAssociationAuthorizationInput, DeleteVPCAssociationAuthorizationOutputResponse, DeleteVPCAssociationAuthorizationOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: DeleteVPCAssociationAuthorizationInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Disables DNSSEC signing in a specific hosted zone. This action does not deactivate any key-signing keys (KSKs)
    /// 		that are active in the hosted zone.
    public func disableHostedZoneDNSSEC(input: DisableHostedZoneDNSSECInput, completion: @escaping (ClientRuntime.SdkResult<DisableHostedZoneDNSSECOutputResponse, DisableHostedZoneDNSSECOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disableHostedZoneDNSSEC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DisableHostedZoneDNSSECInput, DisableHostedZoneDNSSECOutputResponse, DisableHostedZoneDNSSECOutputError>(id: "disableHostedZoneDNSSEC")
        operation.initializeStep.intercept(position: .after, middleware: DisableHostedZoneDNSSECInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DisableHostedZoneDNSSECInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DisableHostedZoneDNSSECInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DisableHostedZoneDNSSECInput, DisableHostedZoneDNSSECOutputResponse, DisableHostedZoneDNSSECOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Disassociates an Amazon Virtual Private Cloud (Amazon VPC) from an Amazon Route 53 private hosted zone. Note the following:
    /// 		
    ///
    ///                You can't disassociate the last Amazon VPC from a private hosted zone.
    ///
    ///
    ///                You can't convert a private hosted zone into a public hosted zone.
    ///
    ///
    ///                You can submit a DisassociateVPCFromHostedZone request using either the account
    /// 				that created the hosted zone or the account that created the Amazon VPC.
    ///
    ///
    ///                Some services, such as Cloud Map and Amazon Elastic File System (Amazon EFS) automatically create hosted zones and associate
    /// 				VPCs with the hosted zones. A service can create a hosted zone using your account or using its own account.
    /// 				You can disassociate a VPC from a hosted zone only if the service created the hosted zone using your account.
    /// 				           When you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListHostedZonesByVPC.html">DisassociateVPCFromHostedZone,
    /// 					if the hosted zone has a value for OwningAccount, you can use DisassociateVPCFromHostedZone.
    /// 					If the hosted zone has a value for OwningService, you can't use DisassociateVPCFromHostedZone.
    /// 			
    ///
    public func disassociateVPCFromHostedZone(input: DisassociateVPCFromHostedZoneInput, completion: @escaping (ClientRuntime.SdkResult<DisassociateVPCFromHostedZoneOutputResponse, DisassociateVPCFromHostedZoneOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "disassociateVPCFromHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DisassociateVPCFromHostedZoneInput, DisassociateVPCFromHostedZoneOutputResponse, DisassociateVPCFromHostedZoneOutputError>(id: "disassociateVPCFromHostedZone")
        operation.initializeStep.intercept(position: .after, middleware: DisassociateVPCFromHostedZoneInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: DisassociateVPCFromHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DisassociateVPCFromHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DisassociateVPCFromHostedZoneInput, DisassociateVPCFromHostedZoneOutputResponse, DisassociateVPCFromHostedZoneOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: DisassociateVPCFromHostedZoneInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Enables DNSSEC signing in a specific hosted zone.
    public func enableHostedZoneDNSSEC(input: EnableHostedZoneDNSSECInput, completion: @escaping (ClientRuntime.SdkResult<EnableHostedZoneDNSSECOutputResponse, EnableHostedZoneDNSSECOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "enableHostedZoneDNSSEC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<EnableHostedZoneDNSSECInput, EnableHostedZoneDNSSECOutputResponse, EnableHostedZoneDNSSECOutputError>(id: "enableHostedZoneDNSSEC")
        operation.initializeStep.intercept(position: .after, middleware: EnableHostedZoneDNSSECInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: EnableHostedZoneDNSSECInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: EnableHostedZoneDNSSECInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<EnableHostedZoneDNSSECInput, EnableHostedZoneDNSSECOutputResponse, EnableHostedZoneDNSSECOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the specified limit for the current account, for example, the maximum number of health checks that you
    /// 			can create using the account.
    /// 		       For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits
    /// 			in the Amazon Route 53 Developer Guide. To request a higher limit,
    /// 			<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case.
    /// 		
    ///             You can also view account limits in Amazon Web Services Trusted Advisor. Sign in to the Amazon Web Services Management Console and open the Trusted Advisor console at
    /// 			<a href="https://console.aws.amazon.com/trustedadvisor">https://console.aws.amazon.com/trustedadvisor/. Then choose
    /// 			Service limits in the navigation pane.
    /// 		
    public func getAccountLimit(input: GetAccountLimitInput, completion: @escaping (ClientRuntime.SdkResult<GetAccountLimitOutputResponse, GetAccountLimitOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAccountLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetAccountLimitInput, GetAccountLimitOutputResponse, GetAccountLimitOutputError>(id: "getAccountLimit")
        operation.initializeStep.intercept(position: .after, middleware: GetAccountLimitInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetAccountLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetAccountLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetAccountLimitInput, GetAccountLimitOutputResponse, GetAccountLimitOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns the current status of a change batch request. The status is one of the
    /// 			following values:
    /// 		
    ///
    /// 				
    ///                   PENDING indicates that the changes in this request have not propagated to all Amazon Route 53 DNS servers.
    /// 					This is the initial status of all change batch requests.
    /// 			
    ///
    /// 				
    ///                   INSYNC indicates that the changes have propagated to all Route 53 DNS servers.
    /// 			
    ///
    public func getChange(input: GetChangeInput, completion: @escaping (ClientRuntime.SdkResult<GetChangeOutputResponse, GetChangeOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getChange")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetChangeInput, GetChangeOutputResponse, GetChangeOutputError>(id: "getChange")
        operation.initializeStep.intercept(position: .after, middleware: GetChangeInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetChangeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetChangeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetChangeInput, GetChangeOutputResponse, GetChangeOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.
    /// 	
    /// 			
    ///                GetCheckerIpRanges still works, but we recommend that you download
    /// 				ip-ranges.json, which includes IP address ranges for all Amazon Web Services services. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/route-53-ip-addresses.html">IP Address Ranges of Amazon Route 53 Servers
    /// 			in the Amazon Route 53 Developer Guide.
    /// 		
    public func getCheckerIpRanges(input: GetCheckerIpRangesInput, completion: @escaping (ClientRuntime.SdkResult<GetCheckerIpRangesOutputResponse, GetCheckerIpRangesOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCheckerIpRanges")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetCheckerIpRangesInput, GetCheckerIpRangesOutputResponse, GetCheckerIpRangesOutputError>(id: "getCheckerIpRanges")
        operation.initializeStep.intercept(position: .after, middleware: GetCheckerIpRangesInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetCheckerIpRangesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetCheckerIpRangesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetCheckerIpRangesInput, GetCheckerIpRangesOutputResponse, GetCheckerIpRangesOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Returns information about DNSSEC for a specific hosted zone, including the key-signing keys (KSKs) in the hosted zone.
    public func getDNSSEC(input: GetDNSSECInput, completion: @escaping (ClientRuntime.SdkResult<GetDNSSECOutputResponse, GetDNSSECOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDNSSEC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetDNSSECInput, GetDNSSECOutputResponse, GetDNSSECOutputError>(id: "getDNSSEC")
        operation.initializeStep.intercept(position: .after, middleware: GetDNSSECInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetDNSSECInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetDNSSECInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDNSSECInput, GetDNSSECOutputResponse, GetDNSSECOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about whether a specified geographic location is supported for Amazon Route 53 geolocation
    /// 			resource record sets.
    /// 	        Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.
    /// 		
    /// 		       Use the following syntax to determine whether a continent is supported for geolocation:
    /// 		
    ///             GET /2013-04-01/geolocation?continentcode=two-letter abbreviation for a continent
    ///
    ///
    /// 		
    /// 		       Use the following syntax to determine whether a country is supported for geolocation:
    /// 		
    ///             GET /2013-04-01/geolocation?countrycode=two-character country code
    ///
    ///
    /// 		
    /// 		       Use the following syntax to determine whether a subdivision of a country is supported for geolocation:
    /// 		
    ///             GET /2013-04-01/geolocation?countrycode=two-character country code&subdivisioncode=subdivision code
    ///
    ///
    public func getGeoLocation(input: GetGeoLocationInput, completion: @escaping (ClientRuntime.SdkResult<GetGeoLocationOutputResponse, GetGeoLocationOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGeoLocation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetGeoLocationInput, GetGeoLocationOutputResponse, GetGeoLocationOutputError>(id: "getGeoLocation")
        operation.initializeStep.intercept(position: .after, middleware: GetGeoLocationInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetGeoLocationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetGeoLocationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetGeoLocationInput, GetGeoLocationOutputResponse, GetGeoLocationOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a specified health check.
    public func getHealthCheck(input: GetHealthCheckInput, completion: @escaping (ClientRuntime.SdkResult<GetHealthCheckOutputResponse, GetHealthCheckOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHealthCheckInput, GetHealthCheckOutputResponse, GetHealthCheckOutputError>(id: "getHealthCheck")
        operation.initializeStep.intercept(position: .after, middleware: GetHealthCheckInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHealthCheckInput, GetHealthCheckOutputResponse, GetHealthCheckOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the number of health checks that are associated with the current Amazon Web Services account.
    public func getHealthCheckCount(input: GetHealthCheckCountInput, completion: @escaping (ClientRuntime.SdkResult<GetHealthCheckCountOutputResponse, GetHealthCheckCountOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheckCount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHealthCheckCountInput, GetHealthCheckCountOutputResponse, GetHealthCheckCountOutputError>(id: "getHealthCheckCount")
        operation.initializeStep.intercept(position: .after, middleware: GetHealthCheckCountInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckCountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckCountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHealthCheckCountInput, GetHealthCheckCountOutputResponse, GetHealthCheckCountOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the reason that a specified health check failed most recently.
    public func getHealthCheckLastFailureReason(input: GetHealthCheckLastFailureReasonInput, completion: @escaping (ClientRuntime.SdkResult<GetHealthCheckLastFailureReasonOutputResponse, GetHealthCheckLastFailureReasonOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheckLastFailureReason")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHealthCheckLastFailureReasonInput, GetHealthCheckLastFailureReasonOutputResponse, GetHealthCheckLastFailureReasonOutputError>(id: "getHealthCheckLastFailureReason")
        operation.initializeStep.intercept(position: .after, middleware: GetHealthCheckLastFailureReasonInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckLastFailureReasonInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckLastFailureReasonInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHealthCheckLastFailureReasonInput, GetHealthCheckLastFailureReasonOutputResponse, GetHealthCheckLastFailureReasonOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets status of a specified health check.
    /// 		
    ///             This API is intended for use during development to diagnose behavior. It doesn’t support production use-cases with high query rates that require immediate and actionable responses.
    ///
    public func getHealthCheckStatus(input: GetHealthCheckStatusInput, completion: @escaping (ClientRuntime.SdkResult<GetHealthCheckStatusOutputResponse, GetHealthCheckStatusOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHealthCheckStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHealthCheckStatusInput, GetHealthCheckStatusOutputResponse, GetHealthCheckStatusOutputError>(id: "getHealthCheckStatus")
        operation.initializeStep.intercept(position: .after, middleware: GetHealthCheckStatusInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHealthCheckStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHealthCheckStatusInput, GetHealthCheckStatusOutputResponse, GetHealthCheckStatusOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a specified hosted zone including the four name servers assigned to the hosted zone.
    public func getHostedZone(input: GetHostedZoneInput, completion: @escaping (ClientRuntime.SdkResult<GetHostedZoneOutputResponse, GetHostedZoneOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHostedZoneInput, GetHostedZoneOutputResponse, GetHostedZoneOutputError>(id: "getHostedZone")
        operation.initializeStep.intercept(position: .after, middleware: GetHostedZoneInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHostedZoneInput, GetHostedZoneOutputResponse, GetHostedZoneOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves the number of hosted zones that are associated with the current Amazon Web Services account.
    public func getHostedZoneCount(input: GetHostedZoneCountInput, completion: @escaping (ClientRuntime.SdkResult<GetHostedZoneCountOutputResponse, GetHostedZoneCountOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHostedZoneCount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHostedZoneCountInput, GetHostedZoneCountOutputResponse, GetHostedZoneCountOutputError>(id: "getHostedZoneCount")
        operation.initializeStep.intercept(position: .after, middleware: GetHostedZoneCountInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHostedZoneCountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHostedZoneCountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHostedZoneCountInput, GetHostedZoneCountOutputResponse, GetHostedZoneCountOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the specified limit for a specified hosted zone, for example, the maximum number of records that you
    /// 			can create in the hosted zone.
    /// 		       For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits
    /// 			in the Amazon Route 53 Developer Guide. To request a higher limit,
    /// 			<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case.
    public func getHostedZoneLimit(input: GetHostedZoneLimitInput, completion: @escaping (ClientRuntime.SdkResult<GetHostedZoneLimitOutputResponse, GetHostedZoneLimitOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getHostedZoneLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetHostedZoneLimitInput, GetHostedZoneLimitOutputResponse, GetHostedZoneLimitOutputError>(id: "getHostedZoneLimit")
        operation.initializeStep.intercept(position: .after, middleware: GetHostedZoneLimitInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetHostedZoneLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetHostedZoneLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetHostedZoneLimitInput, GetHostedZoneLimitOutputResponse, GetHostedZoneLimitOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a specified configuration for DNS query logging.
    /// 		
    /// 		       For more information about DNS query logs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig
    /// 			and
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries.
    public func getQueryLoggingConfig(input: GetQueryLoggingConfigInput, completion: @escaping (ClientRuntime.SdkResult<GetQueryLoggingConfigOutputResponse, GetQueryLoggingConfigOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getQueryLoggingConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetQueryLoggingConfigInput, GetQueryLoggingConfigOutputResponse, GetQueryLoggingConfigOutputError>(id: "getQueryLoggingConfig")
        operation.initializeStep.intercept(position: .after, middleware: GetQueryLoggingConfigInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetQueryLoggingConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetQueryLoggingConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetQueryLoggingConfigInput, GetQueryLoggingConfigOutputResponse, GetQueryLoggingConfigOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves information about a specified reusable delegation set, including the four name servers that are assigned
    /// 			to the delegation set.
    public func getReusableDelegationSet(input: GetReusableDelegationSetInput, completion: @escaping (ClientRuntime.SdkResult<GetReusableDelegationSetOutputResponse, GetReusableDelegationSetOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getReusableDelegationSet")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetReusableDelegationSetInput, GetReusableDelegationSetOutputResponse, GetReusableDelegationSetOutputError>(id: "getReusableDelegationSet")
        operation.initializeStep.intercept(position: .after, middleware: GetReusableDelegationSetInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetReusableDelegationSetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetReusableDelegationSetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetReusableDelegationSetInput, GetReusableDelegationSetOutputResponse, GetReusableDelegationSetOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the maximum number of hosted zones that you can associate with the specified reusable delegation set.
    /// 		       For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits
    /// 			in the Amazon Route 53 Developer Guide. To request a higher limit,
    /// 			<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53">open a case.
    public func getReusableDelegationSetLimit(input: GetReusableDelegationSetLimitInput, completion: @escaping (ClientRuntime.SdkResult<GetReusableDelegationSetLimitOutputResponse, GetReusableDelegationSetLimitOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getReusableDelegationSetLimit")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetReusableDelegationSetLimitInput, GetReusableDelegationSetLimitOutputResponse, GetReusableDelegationSetLimitOutputError>(id: "getReusableDelegationSetLimit")
        operation.initializeStep.intercept(position: .after, middleware: GetReusableDelegationSetLimitInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetReusableDelegationSetLimitInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetReusableDelegationSetLimitInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetReusableDelegationSetLimitInput, GetReusableDelegationSetLimitOutputResponse, GetReusableDelegationSetLimitOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a specific traffic policy version.
    /// 		       For information about how of deleting a traffic policy affects the response from GetTrafficPolicy, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy.
    /// 		
    public func getTrafficPolicy(input: GetTrafficPolicyInput, completion: @escaping (ClientRuntime.SdkResult<GetTrafficPolicyOutputResponse, GetTrafficPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTrafficPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetTrafficPolicyInput, GetTrafficPolicyOutputResponse, GetTrafficPolicyOutputError>(id: "getTrafficPolicy")
        operation.initializeStep.intercept(position: .after, middleware: GetTrafficPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetTrafficPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetTrafficPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetTrafficPolicyInput, GetTrafficPolicyOutputResponse, GetTrafficPolicyOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a specified traffic policy instance.
    /// 		
    /// 			         After you submit a CreateTrafficPolicyInstance or an UpdateTrafficPolicyInstance request,
    /// 				there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For
    /// 				more information, see the State response element.
    /// 		
    /// 		
    /// 			         In the Route 53 console, traffic policy instances are known as policy records.
    /// 		
    public func getTrafficPolicyInstance(input: GetTrafficPolicyInstanceInput, completion: @escaping (ClientRuntime.SdkResult<GetTrafficPolicyInstanceOutputResponse, GetTrafficPolicyInstanceOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetTrafficPolicyInstanceInput, GetTrafficPolicyInstanceOutputResponse, GetTrafficPolicyInstanceOutputError>(id: "getTrafficPolicyInstance")
        operation.initializeStep.intercept(position: .after, middleware: GetTrafficPolicyInstanceInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetTrafficPolicyInstanceInput, GetTrafficPolicyInstanceOutputResponse, GetTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the number of traffic policy instances that are associated with the current Amazon Web Services account.
    public func getTrafficPolicyInstanceCount(input: GetTrafficPolicyInstanceCountInput, completion: @escaping (ClientRuntime.SdkResult<GetTrafficPolicyInstanceCountOutputResponse, GetTrafficPolicyInstanceCountOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTrafficPolicyInstanceCount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetTrafficPolicyInstanceCountInput, GetTrafficPolicyInstanceCountOutputResponse, GetTrafficPolicyInstanceCountOutputError>(id: "getTrafficPolicyInstanceCount")
        operation.initializeStep.intercept(position: .after, middleware: GetTrafficPolicyInstanceCountInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: GetTrafficPolicyInstanceCountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetTrafficPolicyInstanceCountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetTrafficPolicyInstanceCountInput, GetTrafficPolicyInstanceCountOutputResponse, GetTrafficPolicyInstanceCountOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of supported geographic locations.
    /// 		       Countries are listed first, and continents are listed last. If Amazon Route 53 supports subdivisions for a country (for example, states or provinces),
    /// 			the subdivisions for that country are listed in alphabetical order immediately after the corresponding country.
    /// 	        Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.
    /// 	        For a list of supported geolocation codes, see the
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GeoLocation.html">GeoLocation data type.
    public func listGeoLocations(input: ListGeoLocationsInput, completion: @escaping (ClientRuntime.SdkResult<ListGeoLocationsOutputResponse, ListGeoLocationsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGeoLocations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListGeoLocationsInput, ListGeoLocationsOutputResponse, ListGeoLocationsOutputError>(id: "listGeoLocations")
        operation.initializeStep.intercept(position: .after, middleware: ListGeoLocationsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListGeoLocationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListGeoLocationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListGeoLocationsInput, ListGeoLocationsOutputResponse, ListGeoLocationsOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieve a list of the health checks that are associated with the current Amazon Web Services account.
    public func listHealthChecks(input: ListHealthChecksInput, completion: @escaping (ClientRuntime.SdkResult<ListHealthChecksOutputResponse, ListHealthChecksOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHealthChecks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListHealthChecksInput, ListHealthChecksOutputResponse, ListHealthChecksOutputError>(id: "listHealthChecks")
        operation.initializeStep.intercept(position: .after, middleware: ListHealthChecksInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListHealthChecksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListHealthChecksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListHealthChecksInput, ListHealthChecksOutputResponse, ListHealthChecksOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of the public and private hosted zones that are associated with the current Amazon Web Services account. The response
    /// 			includes a HostedZones child element for each hosted zone.
    /// 		       Amazon Route 53 returns a maximum of 100 items in each response. If you have a lot of hosted zones, you can use the
    /// 			maxitems parameter to list them in groups of up to 100.
    public func listHostedZones(input: ListHostedZonesInput, completion: @escaping (ClientRuntime.SdkResult<ListHostedZonesOutputResponse, ListHostedZonesOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHostedZones")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListHostedZonesInput, ListHostedZonesOutputResponse, ListHostedZonesOutputError>(id: "listHostedZones")
        operation.initializeStep.intercept(position: .after, middleware: ListHostedZonesInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListHostedZonesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListHostedZonesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListHostedZonesInput, ListHostedZonesOutputResponse, ListHostedZonesOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of your hosted zones in lexicographic order. The response includes a HostedZones child element
    /// 			for each hosted zone created by the current Amazon Web Services account.
    /// 		
    ///             ListHostedZonesByName sorts hosted zones by name with the labels reversed. For example:
    ///
    /// 		
    ///             com.example.www.
    ///
    ///
    /// 		       Note the trailing dot, which can change the sort order in some circumstances.
    /// 		       If the domain name includes escape characters or Punycode, ListHostedZonesByName alphabetizes the domain name
    /// 			using the escaped or Punycoded value, which is the format that Amazon Route 53 saves in its database. For example, to create a hosted zone
    /// 			for exämple.com, you specify ex\344mple.com for the domain name. ListHostedZonesByName alphabetizes it as:
    ///
    /// 		
    ///             com.ex\344mple.
    ///
    /// 		
    /// 		       The labels are reversed and alphabetized using the escaped value. For more information about valid domain name formats,
    /// 			including internationalized domain names, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html">DNS Domain Name Format in the
    /// 			Amazon Route 53 Developer Guide.
    /// 		       Route 53 returns up to 100 items in each response. If you have a lot of hosted zones, use the MaxItems parameter to list
    /// 			them in groups of up to 100. The response includes values that help navigate from one group of MaxItems hosted zones to the next:
    /// 		
    ///
    /// 				           The DNSName and HostedZoneId elements in the response contain the values, if any, specified for the
    /// 					dnsname and hostedzoneid parameters in the request that produced the current response.
    /// 			
    ///
    /// 				           The MaxItems element in the response contains the value, if any, that you specified for the maxitems
    /// 					parameter in the request that produced the current response.
    /// 			
    ///
    /// 				           If the value of IsTruncated in the response is true, there are more hosted zones associated with the
    /// 					current Amazon Web Services account.
    /// 				           If IsTruncated is false, this response includes the last hosted zone that is associated with the current account.
    /// 					The NextDNSName element and NextHostedZoneId elements are omitted from the response.
    /// 			
    ///
    /// 				           The NextDNSName and NextHostedZoneId elements in the response contain the domain name and the
    /// 					hosted zone ID of the next hosted zone that is associated with the current Amazon Web Services account. If you want to list more hosted zones,
    /// 					make another call to ListHostedZonesByName, and specify the value of NextDNSName and
    /// 					NextHostedZoneId in the dnsname and hostedzoneid parameters, respectively.
    /// 			
    ///
    public func listHostedZonesByName(input: ListHostedZonesByNameInput, completion: @escaping (ClientRuntime.SdkResult<ListHostedZonesByNameOutputResponse, ListHostedZonesByNameOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHostedZonesByName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListHostedZonesByNameInput, ListHostedZonesByNameOutputResponse, ListHostedZonesByNameOutputError>(id: "listHostedZonesByName")
        operation.initializeStep.intercept(position: .after, middleware: ListHostedZonesByNameInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListHostedZonesByNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListHostedZonesByNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListHostedZonesByNameInput, ListHostedZonesByNameOutputResponse, ListHostedZonesByNameOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists all the private hosted zones that a specified VPC is associated with, regardless of which Amazon Web Services account or Amazon Web Services service owns the
    /// 			hosted zones. The HostedZoneOwner structure in the response contains one of the following values:
    /// 		
    ///
    ///                An OwningAccount element, which contains the account number of either the current Amazon Web Services account or
    /// 				another Amazon Web Services account. Some services, such as Cloud Map, create hosted zones using the current account.
    /// 			
    ///
    ///                An OwningService element, which identifies the Amazon Web Services service that created and owns the hosted zone.
    /// 				For example, if a hosted zone was created by Amazon Elastic File System (Amazon EFS), the value of Owner is
    /// 				efs.amazonaws.com.
    /// 			
    ///
    public func listHostedZonesByVPC(input: ListHostedZonesByVPCInput, completion: @escaping (ClientRuntime.SdkResult<ListHostedZonesByVPCOutputResponse, ListHostedZonesByVPCOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listHostedZonesByVPC")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListHostedZonesByVPCInput, ListHostedZonesByVPCOutputResponse, ListHostedZonesByVPCOutputError>(id: "listHostedZonesByVPC")
        operation.initializeStep.intercept(position: .after, middleware: ListHostedZonesByVPCInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListHostedZonesByVPCInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListHostedZonesByVPCInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListHostedZonesByVPCInput, ListHostedZonesByVPCOutputResponse, ListHostedZonesByVPCOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the configurations for DNS query logging that are associated with the current Amazon Web Services account or the configuration
    /// 			that is associated with a specified hosted zone.
    ///
    /// 		       For more information about DNS query logs, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig.
    /// 			Additional information, including the format of DNS query logs, appears in
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries
    /// 			in the Amazon Route 53 Developer Guide.
    public func listQueryLoggingConfigs(input: ListQueryLoggingConfigsInput, completion: @escaping (ClientRuntime.SdkResult<ListQueryLoggingConfigsOutputResponse, ListQueryLoggingConfigsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listQueryLoggingConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutputResponse, ListQueryLoggingConfigsOutputError>(id: "listQueryLoggingConfigs")
        operation.initializeStep.intercept(position: .after, middleware: ListQueryLoggingConfigsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListQueryLoggingConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListQueryLoggingConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutputResponse, ListQueryLoggingConfigsOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the resource record sets in a specified hosted zone.
    /// 		
    ///             ListResourceRecordSets returns up to 300 resource record sets at a time in ASCII order,
    /// 			beginning at a position specified by the name and type elements.
    /// 		
    /// 		
    ///             Sort order
    ///
    /// 			
    ///             ListResourceRecordSets sorts results first by DNS name with the labels reversed, for example:
    /// 			
    ///             com.example.www.
    ///
    /// 			      Note the trailing dot, which can change the sort order when the record name contains characters that appear before
    /// 				. (decimal 46) in the ASCII table. These characters include the following: ! " # $ % & ' ( ) * + , -
    ///
    /// 			      When multiple records have the same DNS name, ListResourceRecordSets sorts results by the record type.
    /// 		
    /// 		
    ///             Specifying where to start listing records
    ///
    /// 			      You can use the name and type elements to specify the resource record set that the list begins with:
    /// 			
    ///             If you do not specify Name or Type
    ///
    ///                The results begin with the first resource record set that the hosted zone contains.
    ///
    ///             If you specify Name but not Type
    ///
    ///                The results begin with the first resource record set in the list whose name is greater than or equal to
    /// 						Name.
    ///
    ///             If you specify Type but not Name
    ///
    ///                Amazon Route 53 returns the InvalidInput error.
    ///
    ///             If you specify both Name and Type
    ///
    ///                The results begin with the first resource record set in the list whose name is greater than or equal to
    /// 						Name, and whose type is greater than or equal to Type.
    ///
    ///
    /// 		
    /// 		
    ///             Resource record sets that are PENDING
    ///
    /// 			      This action returns the most current version of the records. This includes records that are PENDING,
    /// 				and that are not yet available on all Route 53 DNS servers.
    /// 		
    /// 		
    ///             Changing resource record sets
    ///
    /// 			      To ensure that you get an accurate listing of the resource record sets for a hosted zone at a point in time,
    /// 				do not submit a ChangeResourceRecordSets request while you're paging through the results of a
    /// 				ListResourceRecordSets request. If you do, some pages may display results without the latest changes
    /// 				while other pages display results with the latest changes.
    /// 		
    /// 		
    ///             Displaying the next page of results
    ///
    /// 			      If a ListResourceRecordSets command returns more than one page of results, the value of IsTruncated
    /// 				is true. To display the next page of results, get the values of NextRecordName, NextRecordType,
    /// 				and NextRecordIdentifier (if any) from the response. Then submit another ListResourceRecordSets request, and
    /// 				specify those values for StartRecordName, StartRecordType, and StartRecordIdentifier.
    public func listResourceRecordSets(input: ListResourceRecordSetsInput, completion: @escaping (ClientRuntime.SdkResult<ListResourceRecordSetsOutputResponse, ListResourceRecordSetsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listResourceRecordSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListResourceRecordSetsInput, ListResourceRecordSetsOutputResponse, ListResourceRecordSetsOutputError>(id: "listResourceRecordSets")
        operation.initializeStep.intercept(position: .after, middleware: ListResourceRecordSetsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListResourceRecordSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListResourceRecordSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListResourceRecordSetsInput, ListResourceRecordSetsOutputResponse, ListResourceRecordSetsOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Retrieves a list of the reusable delegation sets that are associated with the current Amazon Web Services account.
    public func listReusableDelegationSets(input: ListReusableDelegationSetsInput, completion: @escaping (ClientRuntime.SdkResult<ListReusableDelegationSetsOutputResponse, ListReusableDelegationSetsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listReusableDelegationSets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListReusableDelegationSetsInput, ListReusableDelegationSetsOutputResponse, ListReusableDelegationSetsOutputError>(id: "listReusableDelegationSets")
        operation.initializeStep.intercept(position: .after, middleware: ListReusableDelegationSetsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListReusableDelegationSetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListReusableDelegationSetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListReusableDelegationSetsInput, ListReusableDelegationSetsOutputResponse, ListReusableDelegationSetsOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists tags for one health check or hosted zone.
    /// 		       For information about using tags for cost allocation, see
    /// 			<a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags
    /// 			in the Billing and Cost Management User Guide.
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (ClientRuntime.SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.initializeStep.intercept(position: .after, middleware: ListTagsForResourceInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists tags for up to 10 health checks or hosted zones.
    /// 		       For information about using tags for cost allocation, see
    /// 			<a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags
    /// 			in the Billing and Cost Management User Guide.
    public func listTagsForResources(input: ListTagsForResourcesInput, completion: @escaping (ClientRuntime.SdkResult<ListTagsForResourcesOutputResponse, ListTagsForResourcesOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTagsForResourcesInput, ListTagsForResourcesOutputResponse, ListTagsForResourcesOutputError>(id: "listTagsForResources")
        operation.initializeStep.intercept(position: .after, middleware: ListTagsForResourcesInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTagsForResourcesInput, ListTagsForResourcesOutputResponse, ListTagsForResourcesOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForResourcesInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the latest version for every traffic policy that is associated with the current Amazon Web Services account.
    /// 			Policies are listed in the order that they were created in.
    /// 		
    /// 		       For information about how of deleting a traffic policy affects the response from ListTrafficPolicies, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy.
    ///
    /// 		
    public func listTrafficPolicies(input: ListTrafficPoliciesInput, completion: @escaping (ClientRuntime.SdkResult<ListTrafficPoliciesOutputResponse, ListTrafficPoliciesOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTrafficPoliciesInput, ListTrafficPoliciesOutputResponse, ListTrafficPoliciesOutputError>(id: "listTrafficPolicies")
        operation.initializeStep.intercept(position: .after, middleware: ListTrafficPoliciesInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTrafficPoliciesInput, ListTrafficPoliciesOutputResponse, ListTrafficPoliciesOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the traffic policy instances that you created by using the current Amazon Web Services account.
    /// 		
    /// 			         After you submit an UpdateTrafficPolicyInstance request, there's a brief delay while Amazon Route 53 creates the
    /// 				resource record sets that are specified in the traffic policy definition. For more information, see the State response element.
    /// 		
    /// 		       Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
    /// 			MaxItems parameter to list them in groups of up to 100.
    public func listTrafficPolicyInstances(input: ListTrafficPolicyInstancesInput, completion: @escaping (ClientRuntime.SdkResult<ListTrafficPolicyInstancesOutputResponse, ListTrafficPolicyInstancesOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyInstances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTrafficPolicyInstancesInput, ListTrafficPolicyInstancesOutputResponse, ListTrafficPolicyInstancesOutputError>(id: "listTrafficPolicyInstances")
        operation.initializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTrafficPolicyInstancesInput, ListTrafficPolicyInstancesOutputResponse, ListTrafficPolicyInstancesOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the traffic policy instances that you created in a specified hosted zone.
    /// 		
    /// 			         After you submit a CreateTrafficPolicyInstance or an UpdateTrafficPolicyInstance request, there's a
    /// 				brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information,
    /// 				see the State response element.
    /// 		
    /// 		       Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
    /// 			MaxItems parameter to list them in groups of up to 100.
    public func listTrafficPolicyInstancesByHostedZone(input: ListTrafficPolicyInstancesByHostedZoneInput, completion: @escaping (ClientRuntime.SdkResult<ListTrafficPolicyInstancesByHostedZoneOutputResponse, ListTrafficPolicyInstancesByHostedZoneOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyInstancesByHostedZone")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTrafficPolicyInstancesByHostedZoneInput, ListTrafficPolicyInstancesByHostedZoneOutputResponse, ListTrafficPolicyInstancesByHostedZoneOutputError>(id: "listTrafficPolicyInstancesByHostedZone")
        operation.initializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesByHostedZoneInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesByHostedZoneInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesByHostedZoneInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTrafficPolicyInstancesByHostedZoneInput, ListTrafficPolicyInstancesByHostedZoneOutputResponse, ListTrafficPolicyInstancesByHostedZoneOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the traffic policy instances that you created by using a specify traffic policy version.
    /// 		
    /// 			         After you submit a CreateTrafficPolicyInstance or an UpdateTrafficPolicyInstance request,
    /// 				there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For
    /// 				more information, see the State response element.
    /// 		
    /// 		       Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the
    /// 			MaxItems parameter to list them in groups of up to 100.
    public func listTrafficPolicyInstancesByPolicy(input: ListTrafficPolicyInstancesByPolicyInput, completion: @escaping (ClientRuntime.SdkResult<ListTrafficPolicyInstancesByPolicyOutputResponse, ListTrafficPolicyInstancesByPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyInstancesByPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTrafficPolicyInstancesByPolicyInput, ListTrafficPolicyInstancesByPolicyOutputResponse, ListTrafficPolicyInstancesByPolicyOutputError>(id: "listTrafficPolicyInstancesByPolicy")
        operation.initializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesByPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesByPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyInstancesByPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTrafficPolicyInstancesByPolicyInput, ListTrafficPolicyInstancesByPolicyOutputResponse, ListTrafficPolicyInstancesByPolicyOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about all of the versions for a specified traffic policy.
    /// 		       Traffic policy versions are listed in numerical order by VersionNumber.
    public func listTrafficPolicyVersions(input: ListTrafficPolicyVersionsInput, completion: @escaping (ClientRuntime.SdkResult<ListTrafficPolicyVersionsOutputResponse, ListTrafficPolicyVersionsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTrafficPolicyVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTrafficPolicyVersionsInput, ListTrafficPolicyVersionsOutputResponse, ListTrafficPolicyVersionsOutputError>(id: "listTrafficPolicyVersions")
        operation.initializeStep.intercept(position: .after, middleware: ListTrafficPolicyVersionsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTrafficPolicyVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTrafficPolicyVersionsInput, ListTrafficPolicyVersionsOutputResponse, ListTrafficPolicyVersionsOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a list of the VPCs that were created by other accounts and that can be associated with a
    /// 			specified hosted zone because you've submitted one or more CreateVPCAssociationAuthorization requests.
    /// 		       The response includes a VPCs element with a VPC child element for each VPC
    /// 			that can be associated with the hosted zone.
    public func listVPCAssociationAuthorizations(input: ListVPCAssociationAuthorizationsInput, completion: @escaping (ClientRuntime.SdkResult<ListVPCAssociationAuthorizationsOutputResponse, ListVPCAssociationAuthorizationsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVPCAssociationAuthorizations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListVPCAssociationAuthorizationsInput, ListVPCAssociationAuthorizationsOutputResponse, ListVPCAssociationAuthorizationsOutputError>(id: "listVPCAssociationAuthorizations")
        operation.initializeStep.intercept(position: .after, middleware: ListVPCAssociationAuthorizationsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: ListVPCAssociationAuthorizationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListVPCAssociationAuthorizationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListVPCAssociationAuthorizationsInput, ListVPCAssociationAuthorizationsOutputResponse, ListVPCAssociationAuthorizationsOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the value that Amazon Route 53 returns in response to a DNS request for a specified record name and type. You can optionally specify
    /// 			the IP address of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask.
    /// 		       This call only supports querying public hosted zones.
    public func testDNSAnswer(input: TestDNSAnswerInput, completion: @escaping (ClientRuntime.SdkResult<TestDNSAnswerOutputResponse, TestDNSAnswerOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testDNSAnswer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<TestDNSAnswerInput, TestDNSAnswerOutputResponse, TestDNSAnswerOutputError>(id: "testDNSAnswer")
        operation.initializeStep.intercept(position: .after, middleware: TestDNSAnswerInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: TestDNSAnswerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: TestDNSAnswerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<TestDNSAnswerInput, TestDNSAnswerOutputResponse, TestDNSAnswerOutputError>(contentType: "application/xml"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing health check. Note that some values can't be updated.
    /// 		       For more information about updating health checks, see
    /// 			<a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html">Creating, Updating, and Deleting Health Checks
    /// 			in the Amazon Route 53 Developer Guide.
    public func updateHealthCheck(input: UpdateHealthCheckInput, completion: @escaping (ClientRuntime.SdkResult<UpdateHealthCheckOutputResponse, UpdateHealthCheckOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateHealthCheck")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UpdateHealthCheckInput, UpdateHealthCheckOutputResponse, UpdateHealthCheckOutputError>(id: "updateHealthCheck")
        operation.initializeStep.intercept(position: .after, middleware: UpdateHealthCheckInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: UpdateHealthCheckInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: UpdateHealthCheckInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateHealthCheckInput, UpdateHealthCheckOutputResponse, UpdateHealthCheckOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: UpdateHealthCheckInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the comment for a specified hosted zone.
    public func updateHostedZoneComment(input: UpdateHostedZoneCommentInput, completion: @escaping (ClientRuntime.SdkResult<UpdateHostedZoneCommentOutputResponse, UpdateHostedZoneCommentOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateHostedZoneComment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UpdateHostedZoneCommentInput, UpdateHostedZoneCommentOutputResponse, UpdateHostedZoneCommentOutputError>(id: "updateHostedZoneComment")
        operation.initializeStep.intercept(position: .after, middleware: UpdateHostedZoneCommentInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: UpdateHostedZoneCommentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: UpdateHostedZoneCommentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateHostedZoneCommentInput, UpdateHostedZoneCommentOutputResponse, UpdateHostedZoneCommentOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: UpdateHostedZoneCommentInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the comment for a specified traffic policy version.
    public func updateTrafficPolicyComment(input: UpdateTrafficPolicyCommentInput, completion: @escaping (ClientRuntime.SdkResult<UpdateTrafficPolicyCommentOutputResponse, UpdateTrafficPolicyCommentOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateTrafficPolicyComment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UpdateTrafficPolicyCommentInput, UpdateTrafficPolicyCommentOutputResponse, UpdateTrafficPolicyCommentOutputError>(id: "updateTrafficPolicyComment")
        operation.initializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyCommentInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyCommentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyCommentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateTrafficPolicyCommentInput, UpdateTrafficPolicyCommentOutputResponse, UpdateTrafficPolicyCommentOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyCommentInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates the resource record sets in a specified hosted zone that were created based on the settings in a specified traffic policy version.
    /// 		       When you update a traffic policy instance, Amazon Route 53 continues to respond to DNS queries for the root resource record set name
    /// 			(such as example.com) while it replaces one group of resource record sets with another. Route 53 performs the following operations:
    /// 		       <ol>
    ///
    /// 				           Route 53 creates a new group of resource record sets based on the specified traffic policy. This is true regardless of how significant
    /// 					the differences are between the existing resource record sets and the new resource record sets.
    /// 			
    ///
    /// 				           When all of the new resource record sets have been created, Route 53 starts to respond to DNS queries for the root resource record set name
    /// 					(such as example.com) by using the new resource record sets.
    /// 			
    ///
    /// 				           Route 53 deletes the old group of resource record sets that are associated with the root resource record set name.
    /// 			
    ///          </ol>
    public func updateTrafficPolicyInstance(input: UpdateTrafficPolicyInstanceInput, completion: @escaping (ClientRuntime.SdkResult<UpdateTrafficPolicyInstanceOutputResponse, UpdateTrafficPolicyInstanceOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateTrafficPolicyInstance")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "route53")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UpdateTrafficPolicyInstanceInput, UpdateTrafficPolicyInstanceOutputResponse, UpdateTrafficPolicyInstanceOutputError>(id: "updateTrafficPolicyInstance")
        operation.initializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyInstanceInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyInstanceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyInstanceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateTrafficPolicyInstanceInput, UpdateTrafficPolicyInstanceOutputResponse, UpdateTrafficPolicyInstanceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .after, middleware: UpdateTrafficPolicyInstanceInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
