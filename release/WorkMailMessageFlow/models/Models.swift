// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GetRawMessageContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRawMessageContentInput(messageId: \(Swift.String(describing: messageId)))"}
}

extension GetRawMessageContentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRawMessageContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRawMessageContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRawMessageContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRawMessageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRawMessageContentOutputError>
}

public struct GetRawMessageContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRawMessageContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRawMessageContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRawMessageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRawMessageContentOutputError>
}

public struct GetRawMessageContentInput: Swift.Equatable {
    /// <p>The identifier of the email message to retrieve.</p>
    public let messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct GetRawMessageContentInputBody: Swift.Equatable {
}

extension GetRawMessageContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRawMessageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRawMessageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRawMessageContentOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRawMessageContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRawMessageContentOutputResponse(messageContent: \(Swift.String(describing: messageContent)))"}
}

extension GetRawMessageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.messageContent = data
        } else {
            self.messageContent = nil
        }
    }
}

public struct GetRawMessageContentOutputResponse: Swift.Equatable {
    /// <p>The raw content of the email message, in MIME format.</p>
    public let messageContent: ClientRuntime.ByteStream?

    public init (
        messageContent: ClientRuntime.ByteStream? = nil
    )
    {
        self.messageContent = messageContent
    }
}

struct GetRawMessageContentOutputResponseBody: Swift.Equatable {
    public let messageContent: ClientRuntime.ByteStream?
}

extension GetRawMessageContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageContent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .messageContent)
        messageContent = messageContentDecoded
    }
}

extension InvalidContentLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidContentLocation(message: \(Swift.String(describing: message)))"}
}

extension InvalidContentLocation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidContentLocationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>WorkMail could not access the updated email content. Possible reasons:</p>
///          <ul>
///             <li>
///                <p>You made the request in a region other than your S3 bucket region.</p>
///             </li>
///             <li>
///                <p>The <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-owner-condition.html">S3 bucket owner</a> is not the
///         same as the calling AWS account.</p>
///             </li>
///             <li>
///                <p>You have an incomplete or missing S3 bucket policy. For more information about policies, see
///         <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/update-with-lambda.html">
///           Updating message content with AWS Lambda
///         </a> in the <i>WorkMail Administrator
///           Guide</i>.</p>
///             </li>
///          </ul>
public struct InvalidContentLocation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidContentLocationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidContentLocationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageFrozen: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageFrozen(message: \(Swift.String(describing: message)))"}
}

extension MessageFrozen: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MessageFrozenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested email is not eligible for update. This is usually the case for a redirected email.</p>
public struct MessageFrozen: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MessageFrozenBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MessageFrozenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageRejected: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageRejected(message: \(Swift.String(describing: message)))"}
}

extension MessageRejected: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MessageRejectedBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested email could not be updated due to an error in the MIME content. Check the error message for more information about
///       what caused the error.</p>
public struct MessageRejected: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MessageRejectedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MessageRejectedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRawMessageContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRawMessageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRawMessageContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRawMessageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRawMessageContentOutputError>
}

extension PutRawMessageContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRawMessageContentInput(content: \(Swift.String(describing: content)), messageId: \(Swift.String(describing: messageId)))"}
}

extension PutRawMessageContentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

public struct PutRawMessageContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRawMessageContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRawMessageContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRawMessageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRawMessageContentOutputError>
}

public struct PutRawMessageContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRawMessageContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRawMessageContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRawMessageContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRawMessageContentOutputError>
}

public struct PutRawMessageContentInput: Swift.Equatable {
    /// <p>Describes the raw message content of the updated email message.</p>
    public let content: WorkMailMessageFlowClientTypes.RawMessageContent?
    /// <p>The identifier of the email message being updated.</p>
    public let messageId: Swift.String?

    public init (
        content: WorkMailMessageFlowClientTypes.RawMessageContent? = nil,
        messageId: Swift.String? = nil
    )
    {
        self.content = content
        self.messageId = messageId
    }
}

struct PutRawMessageContentInputBody: Swift.Equatable {
    public let content: WorkMailMessageFlowClientTypes.RawMessageContent?
}

extension PutRawMessageContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WorkMailMessageFlowClientTypes.RawMessageContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension PutRawMessageContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRawMessageContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidContentLocation" : self = .invalidContentLocation(try InvalidContentLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageFrozen" : self = .messageFrozen(try MessageFrozen(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRawMessageContentOutputError: Swift.Error, Swift.Equatable {
    case invalidContentLocation(InvalidContentLocation)
    case messageFrozen(MessageFrozen)
    case messageRejected(MessageRejected)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRawMessageContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRawMessageContentOutputResponse()"}
}

extension PutRawMessageContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRawMessageContentOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutRawMessageContentOutputResponseBody: Swift.Equatable {
}

extension PutRawMessageContentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkMailMessageFlowClientTypes.RawMessageContent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Reference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Reference = s3Reference {
            try encodeContainer.encode(s3Reference, forKey: .s3Reference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ReferenceDecoded = try containerValues.decodeIfPresent(WorkMailMessageFlowClientTypes.S3Reference.self, forKey: .s3Reference)
        s3Reference = s3ReferenceDecoded
    }
}

extension WorkMailMessageFlowClientTypes.RawMessageContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RawMessageContent(s3Reference: \(Swift.String(describing: s3Reference)))"}
}

extension WorkMailMessageFlowClientTypes {
    /// <p>Provides the MIME content of the updated email message as an S3 object. All MIME content must meet the following criteria:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Each part of a multipart MIME message must be formatted properly.</p>
    ///             </li>
    ///             <li>
    ///                <p>Attachments must be of a content type that Amazon SES supports. For more information, see
    ///         <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mime-types-appendix.html">Unsupported Attachment Types</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>If any of the MIME parts in a message contain content that is outside of the 7-bit ASCII character range, we recommend
    ///         encoding that content.</p>
    ///             </li>
    ///             <li>
    ///                <p>Per <a href="https://tools.ietf.org/html/rfc5321#section-4.5.3.1.6">RFC 5321</a>, the maximum length of each line of
    ///         text, including the <CRLF>, must not exceed 1,000 characters.</p>
    ///             </li>
    ///             <li>
    ///                <p>The message must contain all the required header fields. Check the returned error message for more information.</p>
    ///             </li>
    ///             <li>
    ///                <p>The value of immutable headers must remain unchanged. Check the returned error message for more information.</p>
    ///             </li>
    ///             <li>
    ///                <p>Certain unique headers can only appear once. Check the returned error message for more information.</p>
    ///             </li>
    ///          </ul>
    public struct RawMessageContent: Swift.Equatable {
        /// <p>The S3 reference of an email message.</p>
        public let s3Reference: WorkMailMessageFlowClientTypes.S3Reference?

        public init (
            s3Reference: WorkMailMessageFlowClientTypes.S3Reference? = nil
        )
        {
            self.s3Reference = s3Reference
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested email message is not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailMessageFlowClientTypes.S3Reference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case objectVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let objectVersion = objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension WorkMailMessageFlowClientTypes.S3Reference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Reference(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)), objectVersion: \(Swift.String(describing: objectVersion)))"}
}

extension WorkMailMessageFlowClientTypes {
    /// <p>Amazon S3 object representing the updated message content, in MIME format.</p>
    ///          <note>
    ///             <p>The region for the S3 bucket containing the S3 object must match the region used for WorkMail operations. Also, for WorkMail to process
    ///       an S3 object, it must have permission to access that object. For more information, see
    ///       <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/update-with-lambda.html">
    ///         Updating message content with AWS Lambda</a>.</p>
    ///          </note>
    public struct S3Reference: Swift.Equatable {
        /// <p>The S3 bucket name.</p>
        public let bucket: Swift.String?
        /// <p>The S3 key object name.</p>
        public let key: Swift.String?
        /// <p>If you enable versioning for the bucket, you can specify the object version.</p>
        public let objectVersion: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.objectVersion = objectVersion
        }
    }

}
