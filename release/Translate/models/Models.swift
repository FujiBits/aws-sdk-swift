// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension TranslateClientTypes.AppliedTerminology: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case terms = "Terms"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let terms = terms {
            var termsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terms)
            for termlist0 in terms {
                try termsContainer.encode(termlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let termsContainer = try containerValues.decodeIfPresent([TranslateClientTypes.Term?].self, forKey: .terms)
        var termsDecoded0:[TranslateClientTypes.Term]? = nil
        if let termsContainer = termsContainer {
            termsDecoded0 = [TranslateClientTypes.Term]()
            for structure0 in termsContainer {
                if let structure0 = structure0 {
                    termsDecoded0?.append(structure0)
                }
            }
        }
        terms = termsDecoded0
    }
}

extension TranslateClientTypes.AppliedTerminology: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppliedTerminology(name: \(Swift.String(describing: name)), terms: \(Swift.String(describing: terms)))"}
}

extension TranslateClientTypes {
    /// <p>The custom terminology applied to the input text by Amazon Translate for the translated text
    ///       response. This is optional in the response and will only be present if you specified
    ///       terminology input in the request. Currently, only one terminology can be applied per
    ///       TranslateText request.</p>
    public struct AppliedTerminology: Swift.Equatable {
        /// <p>The name of the custom terminology applied to the input text by Amazon Translate for the translated
        ///       text response.</p>
        public let name: Swift.String?
        /// <p>The specific terms of the custom terminology applied to the input text by Amazon Translate for the
        ///       translated text response. A maximum of 250 terms will be returned, and the specific terms
        ///       applied will be the first 250 terms in the source text. </p>
        public let terms: [TranslateClientTypes.Term]?

        public init (
            name: Swift.String? = nil,
            terms: [TranslateClientTypes.Term]? = nil
        )
        {
            self.name = name
            self.terms = terms
        }
    }

}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another modification is being made. That modification must complete before you can make
///       your change.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict processing the request. Try your request again.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateParallelDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParallelDataOutputError>
}

extension CreateParallelDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParallelDataInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), parallelDataConfig: \(Swift.String(describing: parallelDataConfig)))"}
}

extension CreateParallelDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parallelDataConfig = parallelDataConfig {
            try encodeContainer.encode(parallelDataConfig, forKey: .parallelDataConfig)
        }
    }
}

public struct CreateParallelDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParallelDataOutputError>
}

public struct CreateParallelDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParallelDataOutputError>
}

public struct CreateParallelDataInput: Swift.Equatable {
    /// <p>A unique identifier for the request. This token is automatically generated when you use
    ///       Amazon Translate through an AWS SDK.</p>
    public var clientToken: Swift.String?
    /// <p>A custom description for the parallel data resource in Amazon Translate.</p>
    public let description: Swift.String?
    /// <p>The encryption key used to encrypt this object.</p>
    public let encryptionKey: TranslateClientTypes.EncryptionKey?
    /// <p>A custom name for the parallel data resource in Amazon Translate. You must assign a name
    ///       that is unique in the account and region.</p>
    public let name: Swift.String?
    /// <p>Specifies the format and S3 location of the parallel data input file.</p>
    public let parallelDataConfig: TranslateClientTypes.ParallelDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        encryptionKey: TranslateClientTypes.EncryptionKey? = nil,
        name: Swift.String? = nil,
        parallelDataConfig: TranslateClientTypes.ParallelDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.encryptionKey = encryptionKey
        self.name = name
        self.parallelDataConfig = parallelDataConfig
    }
}

struct CreateParallelDataInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let parallelDataConfig: TranslateClientTypes.ParallelDataConfig?
    public let encryptionKey: TranslateClientTypes.EncryptionKey?
    public let clientToken: Swift.String?
}

extension CreateParallelDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parallelDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataConfig.self, forKey: .parallelDataConfig)
        parallelDataConfig = parallelDataConfigDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateParallelDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParallelDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParallelDataOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParallelDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParallelDataOutputResponse(name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension CreateParallelDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.status = output.status
        } else {
            self.name = nil
            self.status = nil
        }
    }
}

public struct CreateParallelDataOutputResponse: Swift.Equatable {
    /// <p>The custom name that you assigned to the parallel data resource.</p>
    public let name: Swift.String?
    /// <p>The status of the parallel data resource. When the resource is ready for you to use, the
    ///       status is <code>ACTIVE</code>.</p>
    public let status: TranslateClientTypes.ParallelDataStatus?

    public init (
        name: Swift.String? = nil,
        status: TranslateClientTypes.ParallelDataStatus? = nil
    )
    {
        self.name = name
        self.status = status
    }
}

struct CreateParallelDataOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let status: TranslateClientTypes.ParallelDataStatus?
}

extension CreateParallelDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteParallelDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParallelDataOutputError>
}

extension DeleteParallelDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParallelDataInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteParallelDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteParallelDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParallelDataOutputError>
}

public struct DeleteParallelDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteParallelDataOutputError>
}

public struct DeleteParallelDataInput: Swift.Equatable {
    /// <p>The name of the parallel data resource that is being deleted.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteParallelDataInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteParallelDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteParallelDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParallelDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParallelDataOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParallelDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteParallelDataOutputResponse(name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension DeleteParallelDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.status = output.status
        } else {
            self.name = nil
            self.status = nil
        }
    }
}

public struct DeleteParallelDataOutputResponse: Swift.Equatable {
    /// <p>The name of the parallel data resource that is being deleted.</p>
    public let name: Swift.String?
    /// <p>The status of the parallel data deletion.</p>
    public let status: TranslateClientTypes.ParallelDataStatus?

    public init (
        name: Swift.String? = nil,
        status: TranslateClientTypes.ParallelDataStatus? = nil
    )
    {
        self.name = name
        self.status = status
    }
}

struct DeleteParallelDataOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let status: TranslateClientTypes.ParallelDataStatus?
}

extension DeleteParallelDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteTerminologyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTerminologyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTerminologyOutputError>
}

extension DeleteTerminologyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTerminologyInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteTerminologyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTerminologyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTerminologyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTerminologyOutputError>
}

public struct DeleteTerminologyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTerminologyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTerminologyOutputError>
}

public struct DeleteTerminologyInput: Swift.Equatable {
    /// <p>The name of the custom terminology being deleted. </p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTerminologyInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteTerminologyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTerminologyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTerminologyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTerminologyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTerminologyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTerminologyOutputResponse()"}
}

extension DeleteTerminologyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTerminologyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTerminologyOutputResponseBody: Swift.Equatable {
}

extension DeleteTerminologyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeTextTranslationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTextTranslationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTextTranslationJobOutputError>
}

extension DescribeTextTranslationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTextTranslationJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeTextTranslationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeTextTranslationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTextTranslationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTextTranslationJobOutputError>
}

public struct DescribeTextTranslationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTextTranslationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTextTranslationJobOutputError>
}

public struct DescribeTextTranslationJobInput: Swift.Equatable {
    /// <p>The identifier that Amazon Translate generated for the job. The <a>StartTextTranslationJob</a> operation returns this identifier in its
    ///       response.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeTextTranslationJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribeTextTranslationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeTextTranslationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTextTranslationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTextTranslationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTextTranslationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTextTranslationJobOutputResponse(textTranslationJobProperties: \(Swift.String(describing: textTranslationJobProperties)))"}
}

extension DescribeTextTranslationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTextTranslationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.textTranslationJobProperties = output.textTranslationJobProperties
        } else {
            self.textTranslationJobProperties = nil
        }
    }
}

public struct DescribeTextTranslationJobOutputResponse: Swift.Equatable {
    /// <p>An object that contains the properties associated with an asynchronous batch translation
    ///       job.</p>
    public let textTranslationJobProperties: TranslateClientTypes.TextTranslationJobProperties?

    public init (
        textTranslationJobProperties: TranslateClientTypes.TextTranslationJobProperties? = nil
    )
    {
        self.textTranslationJobProperties = textTranslationJobProperties
    }
}

struct DescribeTextTranslationJobOutputResponseBody: Swift.Equatable {
    public let textTranslationJobProperties: TranslateClientTypes.TextTranslationJobProperties?
}

extension DescribeTextTranslationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case textTranslationJobProperties = "TextTranslationJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textTranslationJobPropertiesDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TextTranslationJobProperties.self, forKey: .textTranslationJobProperties)
        textTranslationJobProperties = textTranslationJobPropertiesDecoded
    }
}

extension DetectedLanguageLowConfidenceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectedLanguageLowConfidenceException(detectedLanguageCode: \(Swift.String(describing: detectedLanguageCode)), message: \(Swift.String(describing: message)))"}
}

extension DetectedLanguageLowConfidenceException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DetectedLanguageLowConfidenceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.detectedLanguageCode = output.detectedLanguageCode
            self.message = output.message
        } else {
            self.detectedLanguageCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The confidence that Amazon Comprehend accurately detected the source language is low. If a
///       low confidence level is acceptable for your application, you can use the language in the
///       exception to call Amazon Translate again. For more information, see the <a href="https://docs.aws.amazon.com/comprehend/latest/dg/API_DetectDominantLanguage.html">DetectDominantLanguage</a> operation in the <i>Amazon Comprehend Developer
///         Guide</i>. </p>
public struct DetectedLanguageLowConfidenceException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The language code of the auto-detected language from Amazon Comprehend.</p>
    public var detectedLanguageCode: Swift.String?
    public var message: Swift.String?

    public init (
        detectedLanguageCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.detectedLanguageCode = detectedLanguageCode
        self.message = message
    }
}

struct DetectedLanguageLowConfidenceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let detectedLanguageCode: Swift.String?
}

extension DetectedLanguageLowConfidenceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectedLanguageCode = "DetectedLanguageCode"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let detectedLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectedLanguageCode)
        detectedLanguageCode = detectedLanguageCodeDecoded
    }
}

extension TranslateClientTypes.EncryptionKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.EncryptionKeyType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension TranslateClientTypes.EncryptionKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionKey(id: \(Swift.String(describing: id)), type: \(Swift.String(describing: type)))"}
}

extension TranslateClientTypes {
    /// <p>The encryption key used to encrypt this object.</p>
    public struct EncryptionKey: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the encryption key being used to encrypt the custom
        ///       terminology.</p>
        public let id: Swift.String?
        /// <p>The type of encryption key used by Amazon Translate to encrypt custom terminologies.</p>
        public let type: TranslateClientTypes.EncryptionKeyType?

        public init (
            id: Swift.String? = nil,
            type: TranslateClientTypes.EncryptionKeyType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension TranslateClientTypes {
    public enum EncryptionKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionKeyType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionKeyType(rawValue: rawValue) ?? EncryptionKeyType.sdkUnknown(rawValue)
        }
    }
}

public struct GetParallelDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParallelDataOutputError>
}

extension GetParallelDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParallelDataInput(name: \(Swift.String(describing: name)))"}
}

extension GetParallelDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetParallelDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParallelDataOutputError>
}

public struct GetParallelDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetParallelDataOutputError>
}

public struct GetParallelDataInput: Swift.Equatable {
    /// <p>The name of the parallel data resource that is being retrieved.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetParallelDataInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetParallelDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetParallelDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetParallelDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetParallelDataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetParallelDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetParallelDataOutputResponse(auxiliaryDataLocation: \(Swift.String(describing: auxiliaryDataLocation)), dataLocation: \(Swift.String(describing: dataLocation)), latestUpdateAttemptAuxiliaryDataLocation: \(Swift.String(describing: latestUpdateAttemptAuxiliaryDataLocation)), parallelDataProperties: \(Swift.String(describing: parallelDataProperties)))"}
}

extension GetParallelDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.auxiliaryDataLocation = output.auxiliaryDataLocation
            self.dataLocation = output.dataLocation
            self.latestUpdateAttemptAuxiliaryDataLocation = output.latestUpdateAttemptAuxiliaryDataLocation
            self.parallelDataProperties = output.parallelDataProperties
        } else {
            self.auxiliaryDataLocation = nil
            self.dataLocation = nil
            self.latestUpdateAttemptAuxiliaryDataLocation = nil
            self.parallelDataProperties = nil
        }
    }
}

public struct GetParallelDataOutputResponse: Swift.Equatable {
    /// <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
    ///       by your input file. This file was created when Amazon Translate attempted to create a parallel
    ///       data resource. The location is returned as a presigned URL to that has a 30 minute
    ///       expiration.</p>
    public let auxiliaryDataLocation: TranslateClientTypes.ParallelDataDataLocation?
    /// <p>The location of the most recent parallel data input file that was successfully imported
    ///       into Amazon Translate. The location is returned as a presigned URL that has a 30 minute
    ///       expiration.</p>
    public let dataLocation: TranslateClientTypes.ParallelDataDataLocation?
    /// <p>The Amazon S3 location of a file that provides any errors or warnings that were produced
    ///       by your input file. This file was created when Amazon Translate attempted to update a parallel
    ///       data resource. The location is returned as a presigned URL to that has a 30 minute
    ///       expiration.</p>
    public let latestUpdateAttemptAuxiliaryDataLocation: TranslateClientTypes.ParallelDataDataLocation?
    /// <p>The properties of the parallel data resource that is being retrieved.</p>
    public let parallelDataProperties: TranslateClientTypes.ParallelDataProperties?

    public init (
        auxiliaryDataLocation: TranslateClientTypes.ParallelDataDataLocation? = nil,
        dataLocation: TranslateClientTypes.ParallelDataDataLocation? = nil,
        latestUpdateAttemptAuxiliaryDataLocation: TranslateClientTypes.ParallelDataDataLocation? = nil,
        parallelDataProperties: TranslateClientTypes.ParallelDataProperties? = nil
    )
    {
        self.auxiliaryDataLocation = auxiliaryDataLocation
        self.dataLocation = dataLocation
        self.latestUpdateAttemptAuxiliaryDataLocation = latestUpdateAttemptAuxiliaryDataLocation
        self.parallelDataProperties = parallelDataProperties
    }
}

struct GetParallelDataOutputResponseBody: Swift.Equatable {
    public let parallelDataProperties: TranslateClientTypes.ParallelDataProperties?
    public let dataLocation: TranslateClientTypes.ParallelDataDataLocation?
    public let auxiliaryDataLocation: TranslateClientTypes.ParallelDataDataLocation?
    public let latestUpdateAttemptAuxiliaryDataLocation: TranslateClientTypes.ParallelDataDataLocation?
}

extension GetParallelDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auxiliaryDataLocation = "AuxiliaryDataLocation"
        case dataLocation = "DataLocation"
        case latestUpdateAttemptAuxiliaryDataLocation = "LatestUpdateAttemptAuxiliaryDataLocation"
        case parallelDataProperties = "ParallelDataProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parallelDataPropertiesDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataProperties.self, forKey: .parallelDataProperties)
        parallelDataProperties = parallelDataPropertiesDecoded
        let dataLocationDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataDataLocation.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let auxiliaryDataLocationDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataDataLocation.self, forKey: .auxiliaryDataLocation)
        auxiliaryDataLocation = auxiliaryDataLocationDecoded
        let latestUpdateAttemptAuxiliaryDataLocationDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataDataLocation.self, forKey: .latestUpdateAttemptAuxiliaryDataLocation)
        latestUpdateAttemptAuxiliaryDataLocation = latestUpdateAttemptAuxiliaryDataLocationDecoded
    }
}

public struct GetTerminologyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTerminologyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTerminologyOutputError>
}

extension GetTerminologyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTerminologyInput(name: \(Swift.String(describing: name)), terminologyDataFormat: \(Swift.String(describing: terminologyDataFormat)))"}
}

extension GetTerminologyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case terminologyDataFormat = "TerminologyDataFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let terminologyDataFormat = terminologyDataFormat {
            try encodeContainer.encode(terminologyDataFormat.rawValue, forKey: .terminologyDataFormat)
        }
    }
}

public struct GetTerminologyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTerminologyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTerminologyOutputError>
}

public struct GetTerminologyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTerminologyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTerminologyOutputError>
}

public struct GetTerminologyInput: Swift.Equatable {
    /// <p>The name of the custom terminology being retrieved.</p>
    public let name: Swift.String?
    /// <p>The data format of the custom terminology being retrieved, either CSV or TMX.</p>
    public let terminologyDataFormat: TranslateClientTypes.TerminologyDataFormat?

    public init (
        name: Swift.String? = nil,
        terminologyDataFormat: TranslateClientTypes.TerminologyDataFormat? = nil
    )
    {
        self.name = name
        self.terminologyDataFormat = terminologyDataFormat
    }
}

struct GetTerminologyInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let terminologyDataFormat: TranslateClientTypes.TerminologyDataFormat?
}

extension GetTerminologyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case terminologyDataFormat = "TerminologyDataFormat"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let terminologyDataFormatDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TerminologyDataFormat.self, forKey: .terminologyDataFormat)
        terminologyDataFormat = terminologyDataFormatDecoded
    }
}

extension GetTerminologyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTerminologyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTerminologyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTerminologyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTerminologyOutputResponse(terminologyDataLocation: \(Swift.String(describing: terminologyDataLocation)), terminologyProperties: \(Swift.String(describing: terminologyProperties)))"}
}

extension GetTerminologyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTerminologyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.terminologyDataLocation = output.terminologyDataLocation
            self.terminologyProperties = output.terminologyProperties
        } else {
            self.terminologyDataLocation = nil
            self.terminologyProperties = nil
        }
    }
}

public struct GetTerminologyOutputResponse: Swift.Equatable {
    /// <p>The data location of the custom terminology being retrieved. The custom terminology file
    ///       is returned in a presigned url that has a 30 minute expiration.</p>
    public let terminologyDataLocation: TranslateClientTypes.TerminologyDataLocation?
    /// <p>The properties of the custom terminology being retrieved.</p>
    public let terminologyProperties: TranslateClientTypes.TerminologyProperties?

    public init (
        terminologyDataLocation: TranslateClientTypes.TerminologyDataLocation? = nil,
        terminologyProperties: TranslateClientTypes.TerminologyProperties? = nil
    )
    {
        self.terminologyDataLocation = terminologyDataLocation
        self.terminologyProperties = terminologyProperties
    }
}

struct GetTerminologyOutputResponseBody: Swift.Equatable {
    public let terminologyProperties: TranslateClientTypes.TerminologyProperties?
    public let terminologyDataLocation: TranslateClientTypes.TerminologyDataLocation?
}

extension GetTerminologyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminologyDataLocation = "TerminologyDataLocation"
        case terminologyProperties = "TerminologyProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminologyPropertiesDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TerminologyProperties.self, forKey: .terminologyProperties)
        terminologyProperties = terminologyPropertiesDecoded
        let terminologyDataLocationDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TerminologyDataLocation.self, forKey: .terminologyDataLocation)
        terminologyDataLocation = terminologyDataLocationDecoded
    }
}

public struct ImportTerminologyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportTerminologyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportTerminologyOutputError>
}

extension ImportTerminologyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportTerminologyInput(description: \(Swift.String(describing: description)), encryptionKey: \(Swift.String(describing: encryptionKey)), mergeStrategy: \(Swift.String(describing: mergeStrategy)), name: \(Swift.String(describing: name)), terminologyData: \(Swift.String(describing: terminologyData)))"}
}

extension ImportTerminologyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case mergeStrategy = "MergeStrategy"
        case name = "Name"
        case terminologyData = "TerminologyData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let mergeStrategy = mergeStrategy {
            try encodeContainer.encode(mergeStrategy.rawValue, forKey: .mergeStrategy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let terminologyData = terminologyData {
            try encodeContainer.encode(terminologyData, forKey: .terminologyData)
        }
    }
}

public struct ImportTerminologyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportTerminologyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportTerminologyOutputError>
}

public struct ImportTerminologyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportTerminologyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportTerminologyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportTerminologyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportTerminologyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportTerminologyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportTerminologyOutputError>
}

public struct ImportTerminologyInput: Swift.Equatable {
    /// <p>The description of the custom terminology being imported.</p>
    public let description: Swift.String?
    /// <p>The encryption key for the custom terminology being imported.</p>
    public let encryptionKey: TranslateClientTypes.EncryptionKey?
    /// <p>The merge strategy of the custom terminology being imported. Currently, only the OVERWRITE
    ///       merge strategy is supported. In this case, the imported terminology will overwrite an existing
    ///       terminology of the same name.</p>
    public let mergeStrategy: TranslateClientTypes.MergeStrategy?
    /// <p>The name of the custom terminology being imported.</p>
    public let name: Swift.String?
    /// <p>The terminology data for the custom terminology being imported.</p>
    public let terminologyData: TranslateClientTypes.TerminologyData?

    public init (
        description: Swift.String? = nil,
        encryptionKey: TranslateClientTypes.EncryptionKey? = nil,
        mergeStrategy: TranslateClientTypes.MergeStrategy? = nil,
        name: Swift.String? = nil,
        terminologyData: TranslateClientTypes.TerminologyData? = nil
    )
    {
        self.description = description
        self.encryptionKey = encryptionKey
        self.mergeStrategy = mergeStrategy
        self.name = name
        self.terminologyData = terminologyData
    }
}

struct ImportTerminologyInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let mergeStrategy: TranslateClientTypes.MergeStrategy?
    public let description: Swift.String?
    public let terminologyData: TranslateClientTypes.TerminologyData?
    public let encryptionKey: TranslateClientTypes.EncryptionKey?
}

extension ImportTerminologyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case mergeStrategy = "MergeStrategy"
        case name = "Name"
        case terminologyData = "TerminologyData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mergeStrategyDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.MergeStrategy.self, forKey: .mergeStrategy)
        mergeStrategy = mergeStrategyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let terminologyDataDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TerminologyData.self, forKey: .terminologyData)
        terminologyData = terminologyDataDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension ImportTerminologyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportTerminologyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportTerminologyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportTerminologyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportTerminologyOutputResponse(terminologyProperties: \(Swift.String(describing: terminologyProperties)))"}
}

extension ImportTerminologyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportTerminologyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.terminologyProperties = output.terminologyProperties
        } else {
            self.terminologyProperties = nil
        }
    }
}

public struct ImportTerminologyOutputResponse: Swift.Equatable {
    /// <p>The properties of the custom terminology being imported.</p>
    public let terminologyProperties: TranslateClientTypes.TerminologyProperties?

    public init (
        terminologyProperties: TranslateClientTypes.TerminologyProperties? = nil
    )
    {
        self.terminologyProperties = terminologyProperties
    }
}

struct ImportTerminologyOutputResponseBody: Swift.Equatable {
    public let terminologyProperties: TranslateClientTypes.TerminologyProperties?
}

extension ImportTerminologyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminologyProperties = "TerminologyProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminologyPropertiesDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TerminologyProperties.self, forKey: .terminologyProperties)
        terminologyProperties = terminologyPropertiesDecoded
    }
}

extension TranslateClientTypes.InputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension TranslateClientTypes.InputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputDataConfig(contentType: \(Swift.String(describing: contentType)), s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension TranslateClientTypes {
    /// <p>The input configuration properties for requesting a batch translation job.</p>
    public struct InputDataConfig: Swift.Equatable {
        /// <p>Describes the format of the data that you submit to Amazon Translate as input. You can
        ///       specify one of the following multipurpose internet mail extension (MIME) types:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>text/html</code>: The input data consists of one or more HTML files. Amazon
        ///           Translate translates only the text that resides in the <code>html</code> element in each
        ///           file.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>text/plain</code>: The input data consists of one or more unformatted text
        ///           files. Amazon Translate translates every character in this type of input.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>application/vnd.openxmlformats-officedocument.wordprocessingml.document</code>:
        ///           The input data consists of one or more Word documents (.docx).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>application/vnd.openxmlformats-officedocument.presentationml.presentation</code>:
        ///           The input data consists of one or more PowerPoint Presentation files (.pptx).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code>: The
        ///           input data consists of one or more Excel Workbook files (.xlsx).</p>
        ///             </li>
        ///          </ul>
        ///          <important>
        ///             <p>If you structure your input data as HTML, ensure that you set this parameter to
        ///           <code>text/html</code>. By doing so, you cut costs by limiting the translation to the
        ///         contents of the <code>html</code> element in each file. Otherwise, if you set this parameter
        ///         to <code>text/plain</code>, your costs will cover the translation of every character.</p>
        ///          </important>
        public let contentType: Swift.String?
        /// <p>The URI of the AWS S3 folder that contains the input file. The folder must be in the
        ///       same Region as the API endpoint you are calling.</p>
        public let s3Uri: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.s3Uri = s3Uri
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error occurred. Retry your request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFilterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidFilterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidFilterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The filter specified for the operation is invalid. Specify a different filter.</p>
public struct InvalidFilterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFilterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of the parameter is invalid. Review the value of the parameter you are using to
///       correct it, and then retry your operation.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The request that you made is invalid. Check your request to determine why it's invalid
///       and then retry the request. </p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranslateClientTypes.JobDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentsWithErrorsCount = "DocumentsWithErrorsCount"
        case inputDocumentsCount = "InputDocumentsCount"
        case translatedDocumentsCount = "TranslatedDocumentsCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentsWithErrorsCount = documentsWithErrorsCount {
            try encodeContainer.encode(documentsWithErrorsCount, forKey: .documentsWithErrorsCount)
        }
        if let inputDocumentsCount = inputDocumentsCount {
            try encodeContainer.encode(inputDocumentsCount, forKey: .inputDocumentsCount)
        }
        if let translatedDocumentsCount = translatedDocumentsCount {
            try encodeContainer.encode(translatedDocumentsCount, forKey: .translatedDocumentsCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let translatedDocumentsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .translatedDocumentsCount)
        translatedDocumentsCount = translatedDocumentsCountDecoded
        let documentsWithErrorsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .documentsWithErrorsCount)
        documentsWithErrorsCount = documentsWithErrorsCountDecoded
        let inputDocumentsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputDocumentsCount)
        inputDocumentsCount = inputDocumentsCountDecoded
    }
}

extension TranslateClientTypes.JobDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobDetails(documentsWithErrorsCount: \(Swift.String(describing: documentsWithErrorsCount)), inputDocumentsCount: \(Swift.String(describing: inputDocumentsCount)), translatedDocumentsCount: \(Swift.String(describing: translatedDocumentsCount)))"}
}

extension TranslateClientTypes {
    /// <p>The number of documents successfully and unsuccessfully processed during a translation
    ///       job.</p>
    public struct JobDetails: Swift.Equatable {
        /// <p>The number of documents that could not be processed during a translation job.</p>
        public let documentsWithErrorsCount: Swift.Int?
        /// <p>The number of documents used as input in a translation job.</p>
        public let inputDocumentsCount: Swift.Int?
        /// <p>The number of documents successfully processed during a translation job.</p>
        public let translatedDocumentsCount: Swift.Int?

        public init (
            documentsWithErrorsCount: Swift.Int? = nil,
            inputDocumentsCount: Swift.Int? = nil,
            translatedDocumentsCount: Swift.Int? = nil
        )
        {
            self.documentsWithErrorsCount = documentsWithErrorsCount
            self.inputDocumentsCount = inputDocumentsCount
            self.translatedDocumentsCount = translatedDocumentsCount
        }
    }

}

extension TranslateClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithError
        case failed
        case inProgress
        case stopped
        case stopRequested
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .completedWithError,
                .failed,
                .inProgress,
                .stopped,
                .stopRequested,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithError: return "COMPLETED_WITH_ERROR"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopRequested: return "STOP_REQUESTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified limit has been exceeded. Review your request and retry it with a quantity
///       below the stated limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListParallelDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListParallelDataOutputError>
}

extension ListParallelDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListParallelDataInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListParallelDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListParallelDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListParallelDataOutputError>
}

public struct ListParallelDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListParallelDataOutputError>
}

public struct ListParallelDataInput: Swift.Equatable {
    /// <p>The maximum number of parallel data resources returned for each request.</p>
    public let maxResults: Swift.Int?
    /// <p>A string that specifies the next page of results to return in a paginated response.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListParallelDataInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListParallelDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListParallelDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListParallelDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListParallelDataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListParallelDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListParallelDataOutputResponse(nextToken: \(Swift.String(describing: nextToken)), parallelDataPropertiesList: \(Swift.String(describing: parallelDataPropertiesList)))"}
}

extension ListParallelDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parallelDataPropertiesList = output.parallelDataPropertiesList
        } else {
            self.nextToken = nil
            self.parallelDataPropertiesList = nil
        }
    }
}

public struct ListParallelDataOutputResponse: Swift.Equatable {
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated
    ///       response. This value is null if there are no additional pages.</p>
    public let nextToken: Swift.String?
    /// <p>The properties of the parallel data resources returned by this request.</p>
    public let parallelDataPropertiesList: [TranslateClientTypes.ParallelDataProperties]?

    public init (
        nextToken: Swift.String? = nil,
        parallelDataPropertiesList: [TranslateClientTypes.ParallelDataProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.parallelDataPropertiesList = parallelDataPropertiesList
    }
}

struct ListParallelDataOutputResponseBody: Swift.Equatable {
    public let parallelDataPropertiesList: [TranslateClientTypes.ParallelDataProperties]?
    public let nextToken: Swift.String?
}

extension ListParallelDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parallelDataPropertiesList = "ParallelDataPropertiesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parallelDataPropertiesListContainer = try containerValues.decodeIfPresent([TranslateClientTypes.ParallelDataProperties?].self, forKey: .parallelDataPropertiesList)
        var parallelDataPropertiesListDecoded0:[TranslateClientTypes.ParallelDataProperties]? = nil
        if let parallelDataPropertiesListContainer = parallelDataPropertiesListContainer {
            parallelDataPropertiesListDecoded0 = [TranslateClientTypes.ParallelDataProperties]()
            for structure0 in parallelDataPropertiesListContainer {
                if let structure0 = structure0 {
                    parallelDataPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        parallelDataPropertiesList = parallelDataPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTerminologiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTerminologiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTerminologiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTerminologiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTerminologiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTerminologiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTerminologiesOutputError>
}

extension ListTerminologiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTerminologiesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTerminologiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTerminologiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTerminologiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTerminologiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTerminologiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTerminologiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTerminologiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTerminologiesOutputError>
}

public struct ListTerminologiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTerminologiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTerminologiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTerminologiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTerminologiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTerminologiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTerminologiesOutputError>
}

public struct ListTerminologiesInput: Swift.Equatable {
    /// <p>The maximum number of custom terminologies returned per list request.</p>
    public let maxResults: Swift.Int?
    /// <p>If the result of the request to ListTerminologies was truncated, include the NextToken to
    ///       fetch the next group of custom terminologies. </p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTerminologiesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTerminologiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTerminologiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTerminologiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTerminologiesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTerminologiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTerminologiesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), terminologyPropertiesList: \(Swift.String(describing: terminologyPropertiesList)))"}
}

extension ListTerminologiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTerminologiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.terminologyPropertiesList = output.terminologyPropertiesList
        } else {
            self.nextToken = nil
            self.terminologyPropertiesList = nil
        }
    }
}

public struct ListTerminologiesOutputResponse: Swift.Equatable {
    /// <p> If the response to the ListTerminologies was truncated, the NextToken fetches the next
    ///       group of custom terminologies.</p>
    public let nextToken: Swift.String?
    /// <p>The properties list of the custom terminologies returned on the list request.</p>
    public let terminologyPropertiesList: [TranslateClientTypes.TerminologyProperties]?

    public init (
        nextToken: Swift.String? = nil,
        terminologyPropertiesList: [TranslateClientTypes.TerminologyProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.terminologyPropertiesList = terminologyPropertiesList
    }
}

struct ListTerminologiesOutputResponseBody: Swift.Equatable {
    public let terminologyPropertiesList: [TranslateClientTypes.TerminologyProperties]?
    public let nextToken: Swift.String?
}

extension ListTerminologiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case terminologyPropertiesList = "TerminologyPropertiesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminologyPropertiesListContainer = try containerValues.decodeIfPresent([TranslateClientTypes.TerminologyProperties?].self, forKey: .terminologyPropertiesList)
        var terminologyPropertiesListDecoded0:[TranslateClientTypes.TerminologyProperties]? = nil
        if let terminologyPropertiesListContainer = terminologyPropertiesListContainer {
            terminologyPropertiesListDecoded0 = [TranslateClientTypes.TerminologyProperties]()
            for structure0 in terminologyPropertiesListContainer {
                if let structure0 = structure0 {
                    terminologyPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        terminologyPropertiesList = terminologyPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTextTranslationJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTextTranslationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTextTranslationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTextTranslationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTextTranslationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTextTranslationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTextTranslationJobsOutputError>
}

extension ListTextTranslationJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTextTranslationJobsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTextTranslationJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTextTranslationJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTextTranslationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTextTranslationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTextTranslationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTextTranslationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTextTranslationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTextTranslationJobsOutputError>
}

public struct ListTextTranslationJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTextTranslationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTextTranslationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTextTranslationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTextTranslationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTextTranslationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTextTranslationJobsOutputError>
}

public struct ListTextTranslationJobsInput: Swift.Equatable {
    /// <p>The parameters that specify which batch translation jobs to retrieve. Filters include job
    ///       name, job status, and submission time. You can only set one filter at a time.</p>
    public let filter: TranslateClientTypes.TextTranslationJobFilter?
    /// <p>The maximum number of results to return in each page. The default value is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        filter: TranslateClientTypes.TextTranslationJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTextTranslationJobsInputBody: Swift.Equatable {
    public let filter: TranslateClientTypes.TextTranslationJobFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTextTranslationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TextTranslationJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTextTranslationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTextTranslationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilterException" : self = .invalidFilterException(try InvalidFilterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTextTranslationJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidFilterException(InvalidFilterException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTextTranslationJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTextTranslationJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), textTranslationJobPropertiesList: \(Swift.String(describing: textTranslationJobPropertiesList)))"}
}

extension ListTextTranslationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTextTranslationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.textTranslationJobPropertiesList = output.textTranslationJobPropertiesList
        } else {
            self.nextToken = nil
            self.textTranslationJobPropertiesList = nil
        }
    }
}

public struct ListTextTranslationJobsOutputResponse: Swift.Equatable {
    /// <p>The token to use to retreive the next page of results. This value is <code>null</code>
    ///       when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>A list containing the properties of each job that is returned.</p>
    public let textTranslationJobPropertiesList: [TranslateClientTypes.TextTranslationJobProperties]?

    public init (
        nextToken: Swift.String? = nil,
        textTranslationJobPropertiesList: [TranslateClientTypes.TextTranslationJobProperties]? = nil
    )
    {
        self.nextToken = nextToken
        self.textTranslationJobPropertiesList = textTranslationJobPropertiesList
    }
}

struct ListTextTranslationJobsOutputResponseBody: Swift.Equatable {
    public let textTranslationJobPropertiesList: [TranslateClientTypes.TextTranslationJobProperties]?
    public let nextToken: Swift.String?
}

extension ListTextTranslationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case textTranslationJobPropertiesList = "TextTranslationJobPropertiesList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textTranslationJobPropertiesListContainer = try containerValues.decodeIfPresent([TranslateClientTypes.TextTranslationJobProperties?].self, forKey: .textTranslationJobPropertiesList)
        var textTranslationJobPropertiesListDecoded0:[TranslateClientTypes.TextTranslationJobProperties]? = nil
        if let textTranslationJobPropertiesListContainer = textTranslationJobPropertiesListContainer {
            textTranslationJobPropertiesListDecoded0 = [TranslateClientTypes.TextTranslationJobProperties]()
            for structure0 in textTranslationJobPropertiesListContainer {
                if let structure0 = structure0 {
                    textTranslationJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        textTranslationJobPropertiesList = textTranslationJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension TranslateClientTypes {
    public enum MergeStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [MergeStrategy] {
            return [
                .overwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overwrite: return "OVERWRITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MergeStrategy(rawValue: rawValue) ?? MergeStrategy.sdkUnknown(rawValue)
        }
    }
}

extension TranslateClientTypes.OutputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension TranslateClientTypes.OutputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputDataConfig(s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension TranslateClientTypes {
    /// <p>The output configuration properties for a batch translation job.</p>
    public struct OutputDataConfig: Swift.Equatable {
        /// <p>The URI of the S3 folder that contains a translation job's output file. The folder must
        ///       be in the same Region as the API endpoint that you are calling.</p>
        public let s3Uri: Swift.String?

        public init (
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension TranslateClientTypes.ParallelDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let formatDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension TranslateClientTypes.ParallelDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParallelDataConfig(format: \(Swift.String(describing: format)), s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension TranslateClientTypes {
    /// <p>Specifies the format and S3 location of the parallel data input file.</p>
    public struct ParallelDataConfig: Swift.Equatable {
        /// <p>The format of the parallel data input file.</p>
        public let format: TranslateClientTypes.ParallelDataFormat?
        /// <p>The URI of the Amazon S3 folder that contains the parallel data input file. The folder
        ///       must be in the same Region as the API endpoint you are calling.</p>
        public let s3Uri: Swift.String?

        public init (
            format: TranslateClientTypes.ParallelDataFormat? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.format = format
            self.s3Uri = s3Uri
        }
    }

}

extension TranslateClientTypes.ParallelDataDataLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
        case repositoryType = "RepositoryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension TranslateClientTypes.ParallelDataDataLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParallelDataDataLocation(location: \(Swift.String(describing: location)), repositoryType: \(Swift.String(describing: repositoryType)))"}
}

extension TranslateClientTypes {
    /// <p>The location of the most recent parallel data input file that was successfully imported
    ///       into Amazon Translate.</p>
    public struct ParallelDataDataLocation: Swift.Equatable {
        /// <p>The Amazon S3 location of the parallel data input file. The location is returned as a
        ///       presigned URL to that has a 30 minute expiration.</p>
        public let location: Swift.String?
        /// <p>Describes the repository that contains the parallel data input file.</p>
        public let repositoryType: Swift.String?

        public init (
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil
        )
        {
            self.location = location
            self.repositoryType = repositoryType
        }
    }

}

extension TranslateClientTypes {
    public enum ParallelDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case tmx
        case tsv
        case sdkUnknown(Swift.String)

        public static var allCases: [ParallelDataFormat] {
            return [
                .csv,
                .tmx,
                .tsv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .tmx: return "TMX"
            case .tsv: return "TSV"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParallelDataFormat(rawValue: rawValue) ?? ParallelDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension TranslateClientTypes.ParallelDataProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case failedRecordCount = "FailedRecordCount"
        case importedDataSize = "ImportedDataSize"
        case importedRecordCount = "ImportedRecordCount"
        case lastUpdatedAt = "LastUpdatedAt"
        case latestUpdateAttemptAt = "LatestUpdateAttemptAt"
        case latestUpdateAttemptStatus = "LatestUpdateAttemptStatus"
        case message = "Message"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
        case skippedRecordCount = "SkippedRecordCount"
        case sourceLanguageCode = "SourceLanguageCode"
        case status = "Status"
        case targetLanguageCodes = "TargetLanguageCodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let failedRecordCount = failedRecordCount {
            try encodeContainer.encode(failedRecordCount, forKey: .failedRecordCount)
        }
        if let importedDataSize = importedDataSize {
            try encodeContainer.encode(importedDataSize, forKey: .importedDataSize)
        }
        if let importedRecordCount = importedRecordCount {
            try encodeContainer.encode(importedRecordCount, forKey: .importedRecordCount)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let latestUpdateAttemptAt = latestUpdateAttemptAt {
            try encodeContainer.encode(latestUpdateAttemptAt.timeIntervalSince1970, forKey: .latestUpdateAttemptAt)
        }
        if let latestUpdateAttemptStatus = latestUpdateAttemptStatus {
            try encodeContainer.encode(latestUpdateAttemptStatus.rawValue, forKey: .latestUpdateAttemptStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parallelDataConfig = parallelDataConfig {
            try encodeContainer.encode(parallelDataConfig, forKey: .parallelDataConfig)
        }
        if let skippedRecordCount = skippedRecordCount {
            try encodeContainer.encode(skippedRecordCount, forKey: .skippedRecordCount)
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for languagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(languagecodestringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[Swift.String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [Swift.String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let parallelDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataConfig.self, forKey: .parallelDataConfig)
        parallelDataConfig = parallelDataConfigDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let importedDataSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .importedDataSize)
        importedDataSize = importedDataSizeDecoded
        let importedRecordCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .importedRecordCount)
        importedRecordCount = importedRecordCountDecoded
        let failedRecordCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedRecordCount)
        failedRecordCount = failedRecordCountDecoded
        let skippedRecordCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .skippedRecordCount)
        skippedRecordCount = skippedRecordCountDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let latestUpdateAttemptStatusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataStatus.self, forKey: .latestUpdateAttemptStatus)
        latestUpdateAttemptStatus = latestUpdateAttemptStatusDecoded
        let latestUpdateAttemptAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestUpdateAttemptAt)
        latestUpdateAttemptAt = latestUpdateAttemptAtDecoded
    }
}

extension TranslateClientTypes.ParallelDataProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParallelDataProperties(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), encryptionKey: \(Swift.String(describing: encryptionKey)), failedRecordCount: \(Swift.String(describing: failedRecordCount)), importedDataSize: \(Swift.String(describing: importedDataSize)), importedRecordCount: \(Swift.String(describing: importedRecordCount)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), latestUpdateAttemptAt: \(Swift.String(describing: latestUpdateAttemptAt)), latestUpdateAttemptStatus: \(Swift.String(describing: latestUpdateAttemptStatus)), message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)), parallelDataConfig: \(Swift.String(describing: parallelDataConfig)), skippedRecordCount: \(Swift.String(describing: skippedRecordCount)), sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), status: \(Swift.String(describing: status)), targetLanguageCodes: \(Swift.String(describing: targetLanguageCodes)))"}
}

extension TranslateClientTypes {
    /// <p>The properties of a parallel data resource.</p>
    public struct ParallelDataProperties: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the parallel data resource.</p>
        public let arn: Swift.String?
        /// <p>The time at which the parallel data resource was created.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The description assigned to the parallel data resource.</p>
        public let description: Swift.String?
        /// <p>The encryption key used to encrypt this object.</p>
        public let encryptionKey: TranslateClientTypes.EncryptionKey?
        /// <p>The number of records unsuccessfully imported from the parallel data input file.</p>
        public let failedRecordCount: Swift.Int?
        /// <p>The number of UTF-8 characters that Amazon Translate imported from the parallel data input
        ///       file. This number includes only the characters in your translation examples. It does not
        ///       include characters that are used to format your file. For example, if you provided a
        ///       Translation Memory Exchange (.tmx) file, this number does not include the tags.</p>
        public let importedDataSize: Swift.Int?
        /// <p>The number of records successfully imported from the parallel data input file.</p>
        public let importedRecordCount: Swift.Int?
        /// <p>The time at which the parallel data resource was last updated.</p>
        public let lastUpdatedAt: ClientRuntime.Date?
        /// <p>The time that the most recent update was attempted.</p>
        public let latestUpdateAttemptAt: ClientRuntime.Date?
        /// <p>The status of the most recent update attempt for the parallel data resource.</p>
        public let latestUpdateAttemptStatus: TranslateClientTypes.ParallelDataStatus?
        /// <p>Additional information from Amazon Translate about the parallel data resource. </p>
        public let message: Swift.String?
        /// <p>The custom name assigned to the parallel data resource.</p>
        public let name: Swift.String?
        /// <p>Specifies the format and S3 location of the parallel data input file.</p>
        public let parallelDataConfig: TranslateClientTypes.ParallelDataConfig?
        /// <p>The number of items in the input file that Amazon Translate skipped when you created or
        ///       updated the parallel data resource. For example, Amazon Translate skips empty records, empty
        ///       target texts, and empty lines.</p>
        public let skippedRecordCount: Swift.Int?
        /// <p>The source language of the translations in the parallel data file.</p>
        public let sourceLanguageCode: Swift.String?
        /// <p>The status of the parallel data resource. When the parallel data is ready for you to use,
        ///       the status is <code>ACTIVE</code>.</p>
        public let status: TranslateClientTypes.ParallelDataStatus?
        /// <p>The language codes for the target languages available in the parallel data file. All
        ///       possible target languages are returned as an array.</p>
        public let targetLanguageCodes: [Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            encryptionKey: TranslateClientTypes.EncryptionKey? = nil,
            failedRecordCount: Swift.Int? = nil,
            importedDataSize: Swift.Int? = nil,
            importedRecordCount: Swift.Int? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            latestUpdateAttemptAt: ClientRuntime.Date? = nil,
            latestUpdateAttemptStatus: TranslateClientTypes.ParallelDataStatus? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            parallelDataConfig: TranslateClientTypes.ParallelDataConfig? = nil,
            skippedRecordCount: Swift.Int? = nil,
            sourceLanguageCode: Swift.String? = nil,
            status: TranslateClientTypes.ParallelDataStatus? = nil,
            targetLanguageCodes: [Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.encryptionKey = encryptionKey
            self.failedRecordCount = failedRecordCount
            self.importedDataSize = importedDataSize
            self.importedRecordCount = importedRecordCount
            self.lastUpdatedAt = lastUpdatedAt
            self.latestUpdateAttemptAt = latestUpdateAttemptAt
            self.latestUpdateAttemptStatus = latestUpdateAttemptStatus
            self.message = message
            self.name = name
            self.parallelDataConfig = parallelDataConfig
            self.skippedRecordCount = skippedRecordCount
            self.sourceLanguageCode = sourceLanguageCode
            self.status = status
            self.targetLanguageCodes = targetLanguageCodes
        }
    }

}

extension TranslateClientTypes {
    public enum ParallelDataStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ParallelDataStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParallelDataStatus(rawValue: rawValue) ?? ParallelDataStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are looking for has not been found. Review the resource you're looking
///       for and see if a different resource will accomplish your needs before retrying the revised
///       request.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Translate service is temporarily unavailable. Please wait a bit and then retry your
///       request.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartTextTranslationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartTextTranslationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartTextTranslationJobOutputError>
}

extension StartTextTranslationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTextTranslationJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), parallelDataNames: \(Swift.String(describing: parallelDataNames)), sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), targetLanguageCodes: \(Swift.String(describing: targetLanguageCodes)), terminologyNames: \(Swift.String(describing: terminologyNames)))"}
}

extension StartTextTranslationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case parallelDataNames = "ParallelDataNames"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCodes = "TargetLanguageCodes"
        case terminologyNames = "TerminologyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let parallelDataNames = parallelDataNames {
            var parallelDataNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parallelDataNames)
            for resourcenamelist0 in parallelDataNames {
                try parallelDataNamesContainer.encode(resourcenamelist0)
            }
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for targetlanguagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(targetlanguagecodestringlist0)
            }
        }
        if let terminologyNames = terminologyNames {
            var terminologyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminologyNames)
            for resourcenamelist0 in terminologyNames {
                try terminologyNamesContainer.encode(resourcenamelist0)
            }
        }
    }
}

public struct StartTextTranslationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartTextTranslationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartTextTranslationJobOutputError>
}

public struct StartTextTranslationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartTextTranslationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartTextTranslationJobOutputError>
}

public struct StartTextTranslationJobInput: Swift.Equatable {
    /// <p>A unique identifier for the request. This token is auto-generated when using the Amazon Translate
    ///       SDK.</p>
    public var clientToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity Access and Management (IAM) role
    ///       that grants Amazon Translate read access to your input data. For more nformation, see <a>identity-and-access-management</a>.</p>
    public let dataAccessRoleArn: Swift.String?
    /// <p>Specifies the format and S3 location of the input documents for the translation
    ///       job.</p>
    public let inputDataConfig: TranslateClientTypes.InputDataConfig?
    /// <p>The name of the batch translation job to be performed.</p>
    public let jobName: Swift.String?
    /// <p>Specifies the S3 folder to which your job output will be saved.
    ///       </p>
    public let outputDataConfig: TranslateClientTypes.OutputDataConfig?
    /// <p>The names of the parallel data resources to use in the batch translation job. For a list
    ///       of available parallel data resources, use the <a>ListParallelData</a>
    ///       operation.</p>
    public let parallelDataNames: [Swift.String]?
    /// <p>The language code of the input language. For a list of language codes, see <a>what-is-languages</a>.</p>
    ///          <p>Amazon Translate does not automatically detect a source language during batch translation
    ///       jobs.</p>
    public let sourceLanguageCode: Swift.String?
    /// <p>The language code of the output language.</p>
    public let targetLanguageCodes: [Swift.String]?
    /// <p>The name of the terminology to use in the batch translation job. For a list of available
    ///       terminologies, use the <a>ListTerminologies</a> operation.</p>
    public let terminologyNames: [Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: TranslateClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: TranslateClientTypes.OutputDataConfig? = nil,
        parallelDataNames: [Swift.String]? = nil,
        sourceLanguageCode: Swift.String? = nil,
        targetLanguageCodes: [Swift.String]? = nil,
        terminologyNames: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.parallelDataNames = parallelDataNames
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCodes = targetLanguageCodes
        self.terminologyNames = terminologyNames
    }
}

struct StartTextTranslationJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let inputDataConfig: TranslateClientTypes.InputDataConfig?
    public let outputDataConfig: TranslateClientTypes.OutputDataConfig?
    public let dataAccessRoleArn: Swift.String?
    public let sourceLanguageCode: Swift.String?
    public let targetLanguageCodes: [Swift.String]?
    public let terminologyNames: [Swift.String]?
    public let parallelDataNames: [Swift.String]?
    public let clientToken: Swift.String?
}

extension StartTextTranslationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case parallelDataNames = "ParallelDataNames"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCodes = "TargetLanguageCodes"
        case terminologyNames = "TerminologyNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[Swift.String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [Swift.String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let terminologyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .terminologyNames)
        var terminologyNamesDecoded0:[Swift.String]? = nil
        if let terminologyNamesContainer = terminologyNamesContainer {
            terminologyNamesDecoded0 = [Swift.String]()
            for string0 in terminologyNamesContainer {
                if let string0 = string0 {
                    terminologyNamesDecoded0?.append(string0)
                }
            }
        }
        terminologyNames = terminologyNamesDecoded0
        let parallelDataNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parallelDataNames)
        var parallelDataNamesDecoded0:[Swift.String]? = nil
        if let parallelDataNamesContainer = parallelDataNamesContainer {
            parallelDataNamesDecoded0 = [Swift.String]()
            for string0 in parallelDataNamesContainer {
                if let string0 = string0 {
                    parallelDataNamesDecoded0?.append(string0)
                }
            }
        }
        parallelDataNames = parallelDataNamesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartTextTranslationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTextTranslationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguagePairException" : self = .unsupportedLanguagePairException(try UnsupportedLanguagePairException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTextTranslationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedLanguagePairException(UnsupportedLanguagePairException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTextTranslationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTextTranslationJobOutputResponse(jobId: \(Swift.String(describing: jobId)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension StartTextTranslationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartTextTranslationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartTextTranslationJobOutputResponse: Swift.Equatable {
    /// <p>The identifier generated for the job. To get the status of a job, use this ID with the
    ///         <a>DescribeTextTranslationJob</a> operation.</p>
    public let jobId: Swift.String?
    /// <p>The status of the job. Possible values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUBMITTED</code> - The job has been received and is queued for
    ///           processing.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code> - Amazon Translate is processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETED</code> - The job was successfully completed and the output is
    ///           available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPLETED_WITH_ERROR</code> - The job was completed with errors. The errors can
    ///           be analyzed in the job's output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - The job did not complete. To get details, use the <a>DescribeTextTranslationJob</a> operation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOP_REQUESTED</code> - The user who started the job has requested that it be
    ///           stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>STOPPED</code> - The job has been stopped.</p>
    ///             </li>
    ///          </ul>
    public let jobStatus: TranslateClientTypes.JobStatus?

    public init (
        jobId: Swift.String? = nil,
        jobStatus: TranslateClientTypes.JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartTextTranslationJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobStatus: TranslateClientTypes.JobStatus?
}

extension StartTextTranslationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

public struct StopTextTranslationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopTextTranslationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopTextTranslationJobOutputError>
}

extension StopTextTranslationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopTextTranslationJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension StopTextTranslationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct StopTextTranslationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopTextTranslationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopTextTranslationJobOutputError>
}

public struct StopTextTranslationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopTextTranslationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopTextTranslationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopTextTranslationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopTextTranslationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopTextTranslationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopTextTranslationJobOutputError>
}

public struct StopTextTranslationJobInput: Swift.Equatable {
    /// <p>The job ID of the job to be stopped.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopTextTranslationJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StopTextTranslationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopTextTranslationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopTextTranslationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopTextTranslationJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopTextTranslationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopTextTranslationJobOutputResponse(jobId: \(Swift.String(describing: jobId)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension StopTextTranslationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopTextTranslationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StopTextTranslationJobOutputResponse: Swift.Equatable {
    /// <p>The job ID of the stopped batch translation job.</p>
    public let jobId: Swift.String?
    /// <p>The status of the designated job. Upon successful completion, the job's status will be
    ///         <code>STOPPED</code>.</p>
    public let jobStatus: TranslateClientTypes.JobStatus?

    public init (
        jobId: Swift.String? = nil,
        jobStatus: TranslateClientTypes.JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StopTextTranslationJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobStatus: TranslateClientTypes.JobStatus?
}

extension StopTextTranslationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension TranslateClientTypes.Term: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceText = "SourceText"
        case targetText = "TargetText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceText = sourceText {
            try encodeContainer.encode(sourceText, forKey: .sourceText)
        }
        if let targetText = targetText {
            try encodeContainer.encode(targetText, forKey: .targetText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceText)
        sourceText = sourceTextDecoded
        let targetTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetText)
        targetText = targetTextDecoded
    }
}

extension TranslateClientTypes.Term: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Term(sourceText: \(Swift.String(describing: sourceText)), targetText: \(Swift.String(describing: targetText)))"}
}

extension TranslateClientTypes {
    /// <p>The term being translated by the custom terminology.</p>
    public struct Term: Swift.Equatable {
        /// <p>The source text of the term being translated by the custom terminology.</p>
        public let sourceText: Swift.String?
        /// <p>The target text of the term being translated by the custom terminology.</p>
        public let targetText: Swift.String?

        public init (
            sourceText: Swift.String? = nil,
            targetText: Swift.String? = nil
        )
        {
            self.sourceText = sourceText
            self.targetText = targetText
        }
    }

}

extension TranslateClientTypes.TerminologyData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file = "File"
        case format = "Format"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = file {
            try encodeContainer.encode(file.base64EncodedString(), forKey: .file)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .file)
        file = fileDecoded
        let formatDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.TerminologyDataFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension TranslateClientTypes.TerminologyData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminologyData(file: \(Swift.String(describing: file)), format: \(Swift.String(describing: format)))"}
}

extension TranslateClientTypes {
    /// <p>The data associated with the custom terminology.</p>
    public struct TerminologyData: Swift.Equatable {
        /// <p>The file containing the custom terminology data. Your version of the AWS SDK performs a
        ///       Base64-encoding on this field before sending a request to the AWS service. Users of the SDK
        ///       should not perform Base64-encoding themselves.</p>
        public let file: ClientRuntime.Data?
        /// <p>The data format of the custom terminology. Either CSV or TMX.</p>
        public let format: TranslateClientTypes.TerminologyDataFormat?

        public init (
            file: ClientRuntime.Data? = nil,
            format: TranslateClientTypes.TerminologyDataFormat? = nil
        )
        {
            self.file = file
            self.format = format
        }
    }

}

extension TranslateClientTypes {
    public enum TerminologyDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case tmx
        case sdkUnknown(Swift.String)

        public static var allCases: [TerminologyDataFormat] {
            return [
                .csv,
                .tmx,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .tmx: return "TMX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TerminologyDataFormat(rawValue: rawValue) ?? TerminologyDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension TranslateClientTypes.TerminologyDataLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
        case repositoryType = "RepositoryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension TranslateClientTypes.TerminologyDataLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminologyDataLocation(location: \(Swift.String(describing: location)), repositoryType: \(Swift.String(describing: repositoryType)))"}
}

extension TranslateClientTypes {
    /// <p>The location of the custom terminology data.</p>
    public struct TerminologyDataLocation: Swift.Equatable {
        /// <p>The location of the custom terminology data.</p>
        public let location: Swift.String?
        /// <p>The repository type for the custom terminology data.</p>
        public let repositoryType: Swift.String?

        public init (
            location: Swift.String? = nil,
            repositoryType: Swift.String? = nil
        )
        {
            self.location = location
            self.repositoryType = repositoryType
        }
    }

}

extension TranslateClientTypes.TerminologyProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case encryptionKey = "EncryptionKey"
        case lastUpdatedAt = "LastUpdatedAt"
        case name = "Name"
        case sizeBytes = "SizeBytes"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCodes = "TargetLanguageCodes"
        case termCount = "TermCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sizeBytes = sizeBytes {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for languagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(languagecodestringlist0)
            }
        }
        if let termCount = termCount {
            try encodeContainer.encode(termCount, forKey: .termCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[Swift.String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [Swift.String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let sizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let termCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .termCount)
        termCount = termCountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension TranslateClientTypes.TerminologyProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminologyProperties(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), encryptionKey: \(Swift.String(describing: encryptionKey)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), name: \(Swift.String(describing: name)), sizeBytes: \(Swift.String(describing: sizeBytes)), sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), targetLanguageCodes: \(Swift.String(describing: targetLanguageCodes)), termCount: \(Swift.String(describing: termCount)))"}
}

extension TranslateClientTypes {
    /// <p>The properties of the custom terminology.</p>
    public struct TerminologyProperties: Swift.Equatable {
        /// <p> The Amazon Resource Name (ARN) of the custom terminology. </p>
        public let arn: Swift.String?
        /// <p>The time at which the custom terminology was created, based on the timestamp.</p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The description of the custom terminology properties.</p>
        public let description: Swift.String?
        /// <p>The encryption key for the custom terminology.</p>
        public let encryptionKey: TranslateClientTypes.EncryptionKey?
        /// <p>The time at which the custom terminology was last update, based on the timestamp.</p>
        public let lastUpdatedAt: ClientRuntime.Date?
        /// <p>The name of the custom terminology.</p>
        public let name: Swift.String?
        /// <p>The size of the file used when importing a custom terminology.</p>
        public let sizeBytes: Swift.Int?
        /// <p>The language code for the source text of the translation request for which the custom
        ///       terminology is being used.</p>
        public let sourceLanguageCode: Swift.String?
        /// <p>The language codes for the target languages available with the custom terminology file.
        ///       All possible target languages are returned in array.</p>
        public let targetLanguageCodes: [Swift.String]?
        /// <p>The number of terms included in the custom terminology.</p>
        public let termCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            encryptionKey: TranslateClientTypes.EncryptionKey? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            sizeBytes: Swift.Int? = nil,
            sourceLanguageCode: Swift.String? = nil,
            targetLanguageCodes: [Swift.String]? = nil,
            termCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.encryptionKey = encryptionKey
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.sizeBytes = sizeBytes
            self.sourceLanguageCode = sourceLanguageCode
            self.targetLanguageCodes = targetLanguageCodes
            self.termCount = termCount
        }
    }

}

extension TextSizeLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextSizeLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TextSizeLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The size of the text you submitted exceeds the size limit. Reduce the size of the text or
///       use a smaller document and then retry your request. </p>
public struct TextSizeLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TextSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TranslateClientTypes.TextTranslationJobFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submittedAfterTime = "SubmittedAfterTime"
        case submittedBeforeTime = "SubmittedBeforeTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submittedAfterTime = submittedAfterTime {
            try encodeContainer.encode(submittedAfterTime.timeIntervalSince1970, forKey: .submittedAfterTime)
        }
        if let submittedBeforeTime = submittedBeforeTime {
            try encodeContainer.encode(submittedBeforeTime.timeIntervalSince1970, forKey: .submittedBeforeTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedBeforeTime)
        submittedBeforeTime = submittedBeforeTimeDecoded
        let submittedAfterTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedAfterTime)
        submittedAfterTime = submittedAfterTimeDecoded
    }
}

extension TranslateClientTypes.TextTranslationJobFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextTranslationJobFilter(jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), submittedAfterTime: \(Swift.String(describing: submittedAfterTime)), submittedBeforeTime: \(Swift.String(describing: submittedBeforeTime)))"}
}

extension TranslateClientTypes {
    /// <p>Provides information for filtering a list of translation jobs. For more information, see
    ///         <a>ListTextTranslationJobs</a>.</p>
    public struct TextTranslationJobFilter: Swift.Equatable {
        /// <p>Filters the list of jobs by name.</p>
        public let jobName: Swift.String?
        /// <p>Filters the list of jobs based by job status.</p>
        public let jobStatus: TranslateClientTypes.JobStatus?
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing and
        ///       returns only the jobs submitted after the specified time. Jobs are returned in descending
        ///       order, newest to oldest.</p>
        public let submittedAfterTime: ClientRuntime.Date?
        /// <p>Filters the list of jobs based on the time that the job was submitted for processing and
        ///       returns only the jobs submitted before the specified time. Jobs are returned in ascending
        ///       order, oldest to newest.</p>
        public let submittedBeforeTime: ClientRuntime.Date?

        public init (
            jobName: Swift.String? = nil,
            jobStatus: TranslateClientTypes.JobStatus? = nil,
            submittedAfterTime: ClientRuntime.Date? = nil,
            submittedBeforeTime: ClientRuntime.Date? = nil
        )
        {
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.submittedAfterTime = submittedAfterTime
            self.submittedBeforeTime = submittedBeforeTime
        }
    }

}

extension TranslateClientTypes.TextTranslationJobProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobDetails = "JobDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case parallelDataNames = "ParallelDataNames"
        case sourceLanguageCode = "SourceLanguageCode"
        case submittedTime = "SubmittedTime"
        case targetLanguageCodes = "TargetLanguageCodes"
        case terminologyNames = "TerminologyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobDetails = jobDetails {
            try encodeContainer.encode(jobDetails, forKey: .jobDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let parallelDataNames = parallelDataNames {
            var parallelDataNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parallelDataNames)
            for resourcenamelist0 in parallelDataNames {
                try parallelDataNamesContainer.encode(resourcenamelist0)
            }
        }
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let submittedTime = submittedTime {
            try encodeContainer.encode(submittedTime.timeIntervalSince1970, forKey: .submittedTime)
        }
        if let targetLanguageCodes = targetLanguageCodes {
            var targetLanguageCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetLanguageCodes)
            for targetlanguagecodestringlist0 in targetLanguageCodes {
                try targetLanguageCodesContainer.encode(targetlanguagecodestringlist0)
            }
        }
        if let terminologyNames = terminologyNames {
            var terminologyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminologyNames)
            for resourcenamelist0 in terminologyNames {
                try terminologyNamesContainer.encode(resourcenamelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobDetailsDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetLanguageCodes)
        var targetLanguageCodesDecoded0:[Swift.String]? = nil
        if let targetLanguageCodesContainer = targetLanguageCodesContainer {
            targetLanguageCodesDecoded0 = [Swift.String]()
            for string0 in targetLanguageCodesContainer {
                if let string0 = string0 {
                    targetLanguageCodesDecoded0?.append(string0)
                }
            }
        }
        targetLanguageCodes = targetLanguageCodesDecoded0
        let terminologyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .terminologyNames)
        var terminologyNamesDecoded0:[Swift.String]? = nil
        if let terminologyNamesContainer = terminologyNamesContainer {
            terminologyNamesDecoded0 = [Swift.String]()
            for string0 in terminologyNamesContainer {
                if let string0 = string0 {
                    terminologyNamesDecoded0?.append(string0)
                }
            }
        }
        terminologyNames = terminologyNamesDecoded0
        let parallelDataNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parallelDataNames)
        var parallelDataNamesDecoded0:[Swift.String]? = nil
        if let parallelDataNamesContainer = parallelDataNamesContainer {
            parallelDataNamesDecoded0 = [Swift.String]()
            for string0 in parallelDataNamesContainer {
                if let string0 = string0 {
                    parallelDataNamesDecoded0?.append(string0)
                }
            }
        }
        parallelDataNames = parallelDataNamesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let submittedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedTime)
        submittedTime = submittedTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension TranslateClientTypes.TextTranslationJobProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextTranslationJobProperties(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobDetails: \(Swift.String(describing: jobDetails)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), message: \(Swift.String(describing: message)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), parallelDataNames: \(Swift.String(describing: parallelDataNames)), sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), submittedTime: \(Swift.String(describing: submittedTime)), targetLanguageCodes: \(Swift.String(describing: targetLanguageCodes)), terminologyNames: \(Swift.String(describing: terminologyNames)))"}
}

extension TranslateClientTypes {
    /// <p>Provides information about a translation job.</p>
    public struct TextTranslationJobProperties: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of an AWS Identity Access and Management (IAM) role
        ///       that granted Amazon Translate read access to the job's input data.</p>
        public let dataAccessRoleArn: Swift.String?
        /// <p>The time at which the translation job ended.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>The input configuration properties that were specified when the job was requested.</p>
        public let inputDataConfig: TranslateClientTypes.InputDataConfig?
        /// <p>The number of documents successfully and unsuccessfully processed during the translation
        ///       job.</p>
        public let jobDetails: TranslateClientTypes.JobDetails?
        /// <p>The ID of the translation job.</p>
        public let jobId: Swift.String?
        /// <p>The user-defined name of the translation job.</p>
        public let jobName: Swift.String?
        /// <p>The status of the translation job.</p>
        public let jobStatus: TranslateClientTypes.JobStatus?
        /// <p>An explanation of any errors that may have occured during the translation job.</p>
        public let message: Swift.String?
        /// <p>The output configuration properties that were specified when the job was requested.</p>
        public let outputDataConfig: TranslateClientTypes.OutputDataConfig?
        /// <p>A list containing the names of the parallel data resources applied to the translation
        ///       job.</p>
        public let parallelDataNames: [Swift.String]?
        /// <p>The language code of the language of the source text. The language must be a language
        ///       supported by Amazon Translate.</p>
        public let sourceLanguageCode: Swift.String?
        /// <p>The time at which the translation job was submitted.</p>
        public let submittedTime: ClientRuntime.Date?
        /// <p>The language code of the language of the target text. The language must be a language
        ///       supported by Amazon Translate.</p>
        public let targetLanguageCodes: [Swift.String]?
        /// <p>A list containing the names of the terminologies applied to a translation job. Only one
        ///       terminology can be applied per <a>StartTextTranslationJob</a> request at this
        ///       time.</p>
        public let terminologyNames: [Swift.String]?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            inputDataConfig: TranslateClientTypes.InputDataConfig? = nil,
            jobDetails: TranslateClientTypes.JobDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: TranslateClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: TranslateClientTypes.OutputDataConfig? = nil,
            parallelDataNames: [Swift.String]? = nil,
            sourceLanguageCode: Swift.String? = nil,
            submittedTime: ClientRuntime.Date? = nil,
            targetLanguageCodes: [Swift.String]? = nil,
            terminologyNames: [Swift.String]? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobDetails = jobDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.parallelDataNames = parallelDataNames
            self.sourceLanguageCode = sourceLanguageCode
            self.submittedTime = submittedTime
            self.targetLanguageCodes = targetLanguageCodes
            self.terminologyNames = terminologyNames
        }
    }

}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> You have made too many requests within a short period of time. Wait for a short time and
///       then try your request again.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TranslateTextInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TranslateTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TranslateTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TranslateTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TranslateTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TranslateTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TranslateTextOutputError>
}

extension TranslateTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslateTextInput(sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), targetLanguageCode: \(Swift.String(describing: targetLanguageCode)), terminologyNames: \(Swift.String(describing: terminologyNames)), text: \(Swift.String(describing: text)))"}
}

extension TranslateTextInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
        case terminologyNames = "TerminologyNames"
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceLanguageCode = sourceLanguageCode {
            try encodeContainer.encode(sourceLanguageCode, forKey: .sourceLanguageCode)
        }
        if let targetLanguageCode = targetLanguageCode {
            try encodeContainer.encode(targetLanguageCode, forKey: .targetLanguageCode)
        }
        if let terminologyNames = terminologyNames {
            var terminologyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .terminologyNames)
            for resourcenamelist0 in terminologyNames {
                try terminologyNamesContainer.encode(resourcenamelist0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct TranslateTextInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TranslateTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TranslateTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TranslateTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TranslateTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TranslateTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TranslateTextOutputError>
}

public struct TranslateTextInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TranslateTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TranslateTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TranslateTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TranslateTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TranslateTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TranslateTextOutputError>
}

public struct TranslateTextInput: Swift.Equatable {
    /// <p>The language code for the language of the source text. The language must be a language
    ///       supported by Amazon Translate. For a list of language codes, see <a>what-is-languages</a>.</p>
    ///          <p>To have Amazon Translate determine the source language of your text, you can specify
    ///         <code>auto</code> in the <code>SourceLanguageCode</code> field. If you specify
    ///         <code>auto</code>, Amazon Translate will call <a href="https://docs.aws.amazon.com/comprehend/latest/dg/comprehend-general.html">Amazon
    ///         Comprehend</a> to determine the source language.</p>
    public let sourceLanguageCode: Swift.String?
    /// <p>The language code requested for the language of the target text. The language must be a
    ///       language supported by Amazon Translate.</p>
    public let targetLanguageCode: Swift.String?
    /// <p>The name of the terminology list file to be used in the TranslateText request. You can use
    ///       1 terminology list at most in a <code>TranslateText</code> request. Terminology lists can
    ///       contain a maximum of 256 terms.</p>
    public let terminologyNames: [Swift.String]?
    /// <p>The text to translate. The text string can be a maximum of 5,000 bytes long. Depending on
    ///       your character set, this may be fewer than 5,000 characters.</p>
    public let text: Swift.String?

    public init (
        sourceLanguageCode: Swift.String? = nil,
        targetLanguageCode: Swift.String? = nil,
        terminologyNames: [Swift.String]? = nil,
        text: Swift.String? = nil
    )
    {
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCode = targetLanguageCode
        self.terminologyNames = terminologyNames
        self.text = text
    }
}

struct TranslateTextInputBody: Swift.Equatable {
    public let text: Swift.String?
    public let terminologyNames: [Swift.String]?
    public let sourceLanguageCode: Swift.String?
    public let targetLanguageCode: Swift.String?
}

extension TranslateTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
        case terminologyNames = "TerminologyNames"
        case text = "Text"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let terminologyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .terminologyNames)
        var terminologyNamesDecoded0:[Swift.String]? = nil
        if let terminologyNamesContainer = terminologyNamesContainer {
            terminologyNamesDecoded0 = [Swift.String]()
            for string0 in terminologyNamesContainer {
                if let string0 = string0 {
                    terminologyNamesDecoded0?.append(string0)
                }
            }
        }
        terminologyNames = terminologyNamesDecoded0
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLanguageCode)
        targetLanguageCode = targetLanguageCodeDecoded
    }
}

extension TranslateTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TranslateTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DetectedLanguageLowConfidenceException" : self = .detectedLanguageLowConfidenceException(try DetectedLanguageLowConfidenceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TextSizeLimitExceededException" : self = .textSizeLimitExceededException(try TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLanguagePairException" : self = .unsupportedLanguagePairException(try UnsupportedLanguagePairException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TranslateTextOutputError: Swift.Error, Swift.Equatable {
    case detectedLanguageLowConfidenceException(DetectedLanguageLowConfidenceException)
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case textSizeLimitExceededException(TextSizeLimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedLanguagePairException(UnsupportedLanguagePairException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TranslateTextOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranslateTextOutputResponse(appliedTerminologies: \(Swift.String(describing: appliedTerminologies)), sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), targetLanguageCode: \(Swift.String(describing: targetLanguageCode)), translatedText: \(Swift.String(describing: translatedText)))"}
}

extension TranslateTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TranslateTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appliedTerminologies = output.appliedTerminologies
            self.sourceLanguageCode = output.sourceLanguageCode
            self.targetLanguageCode = output.targetLanguageCode
            self.translatedText = output.translatedText
        } else {
            self.appliedTerminologies = nil
            self.sourceLanguageCode = nil
            self.targetLanguageCode = nil
            self.translatedText = nil
        }
    }
}

public struct TranslateTextOutputResponse: Swift.Equatable {
    /// <p>The names of the custom terminologies applied to the input text by Amazon Translate for the
    ///       translated text response.</p>
    public let appliedTerminologies: [TranslateClientTypes.AppliedTerminology]?
    /// <p>The language code for the language of the source text.</p>
    public let sourceLanguageCode: Swift.String?
    /// <p>The language code for the language of the target text. </p>
    public let targetLanguageCode: Swift.String?
    /// <p>The translated text.</p>
    public let translatedText: Swift.String?

    public init (
        appliedTerminologies: [TranslateClientTypes.AppliedTerminology]? = nil,
        sourceLanguageCode: Swift.String? = nil,
        targetLanguageCode: Swift.String? = nil,
        translatedText: Swift.String? = nil
    )
    {
        self.appliedTerminologies = appliedTerminologies
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCode = targetLanguageCode
        self.translatedText = translatedText
    }
}

struct TranslateTextOutputResponseBody: Swift.Equatable {
    public let translatedText: Swift.String?
    public let sourceLanguageCode: Swift.String?
    public let targetLanguageCode: Swift.String?
    public let appliedTerminologies: [TranslateClientTypes.AppliedTerminology]?
}

extension TranslateTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedTerminologies = "AppliedTerminologies"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
        case translatedText = "TranslatedText"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let translatedTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .translatedText)
        translatedText = translatedTextDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLanguageCode)
        targetLanguageCode = targetLanguageCodeDecoded
        let appliedTerminologiesContainer = try containerValues.decodeIfPresent([TranslateClientTypes.AppliedTerminology?].self, forKey: .appliedTerminologies)
        var appliedTerminologiesDecoded0:[TranslateClientTypes.AppliedTerminology]? = nil
        if let appliedTerminologiesContainer = appliedTerminologiesContainer {
            appliedTerminologiesDecoded0 = [TranslateClientTypes.AppliedTerminology]()
            for structure0 in appliedTerminologiesContainer {
                if let structure0 = structure0 {
                    appliedTerminologiesDecoded0?.append(structure0)
                }
            }
        }
        appliedTerminologies = appliedTerminologiesDecoded0
    }
}

extension UnsupportedLanguagePairException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedLanguagePairException(message: \(Swift.String(describing: message)), sourceLanguageCode: \(Swift.String(describing: sourceLanguageCode)), targetLanguageCode: \(Swift.String(describing: targetLanguageCode)))"}
}

extension UnsupportedLanguagePairException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedLanguagePairExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.sourceLanguageCode = output.sourceLanguageCode
            self.targetLanguageCode = output.targetLanguageCode
        } else {
            self.message = nil
            self.sourceLanguageCode = nil
            self.targetLanguageCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Translate does not support translation from the language of the source text into the requested
///       target language. For more information, see <a>how-to-error-msg</a>. </p>
public struct UnsupportedLanguagePairException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The language code for the language of the input text. </p>
    public var sourceLanguageCode: Swift.String?
    /// <p>The language code for the language of the translated text. </p>
    public var targetLanguageCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        sourceLanguageCode: Swift.String? = nil,
        targetLanguageCode: Swift.String? = nil
    )
    {
        self.message = message
        self.sourceLanguageCode = sourceLanguageCode
        self.targetLanguageCode = targetLanguageCode
    }
}

struct UnsupportedLanguagePairExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let sourceLanguageCode: Swift.String?
    public let targetLanguageCode: Swift.String?
}

extension UnsupportedLanguagePairExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case sourceLanguageCode = "SourceLanguageCode"
        case targetLanguageCode = "TargetLanguageCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let sourceLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLanguageCode)
        sourceLanguageCode = sourceLanguageCodeDecoded
        let targetLanguageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetLanguageCode)
        targetLanguageCode = targetLanguageCodeDecoded
    }
}

public struct UpdateParallelDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParallelDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParallelDataOutputError>
}

extension UpdateParallelDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateParallelDataInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), parallelDataConfig: \(Swift.String(describing: parallelDataConfig)))"}
}

extension UpdateParallelDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parallelDataConfig = parallelDataConfig {
            try encodeContainer.encode(parallelDataConfig, forKey: .parallelDataConfig)
        }
    }
}

public struct UpdateParallelDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParallelDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParallelDataOutputError>
}

public struct UpdateParallelDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateParallelDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateParallelDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateParallelDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateParallelDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateParallelDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateParallelDataOutputError>
}

public struct UpdateParallelDataInput: Swift.Equatable {
    /// <p>A unique identifier for the request. This token is automatically generated when you use
    ///       Amazon Translate through an AWS SDK.</p>
    public var clientToken: Swift.String?
    /// <p>A custom description for the parallel data resource in Amazon Translate.</p>
    public let description: Swift.String?
    /// <p>The name of the parallel data resource being updated.</p>
    public let name: Swift.String?
    /// <p>Specifies the format and S3 location of the parallel data input file.</p>
    public let parallelDataConfig: TranslateClientTypes.ParallelDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parallelDataConfig: TranslateClientTypes.ParallelDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.parallelDataConfig = parallelDataConfig
    }
}

struct UpdateParallelDataInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let parallelDataConfig: TranslateClientTypes.ParallelDataConfig?
    public let clientToken: Swift.String?
}

extension UpdateParallelDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case parallelDataConfig = "ParallelDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parallelDataConfigDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataConfig.self, forKey: .parallelDataConfig)
        parallelDataConfig = parallelDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateParallelDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateParallelDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateParallelDataOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateParallelDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateParallelDataOutputResponse(latestUpdateAttemptAt: \(Swift.String(describing: latestUpdateAttemptAt)), latestUpdateAttemptStatus: \(Swift.String(describing: latestUpdateAttemptStatus)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension UpdateParallelDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateParallelDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.latestUpdateAttemptAt = output.latestUpdateAttemptAt
            self.latestUpdateAttemptStatus = output.latestUpdateAttemptStatus
            self.name = output.name
            self.status = output.status
        } else {
            self.latestUpdateAttemptAt = nil
            self.latestUpdateAttemptStatus = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct UpdateParallelDataOutputResponse: Swift.Equatable {
    /// <p>The time that the most recent update was attempted.</p>
    public let latestUpdateAttemptAt: ClientRuntime.Date?
    /// <p>The status of the parallel data update attempt. When the updated parallel data resource is
    ///       ready for you to use, the status is <code>ACTIVE</code>.</p>
    public let latestUpdateAttemptStatus: TranslateClientTypes.ParallelDataStatus?
    /// <p>The name of the parallel data resource being updated.</p>
    public let name: Swift.String?
    /// <p>The status of the parallel data resource that you are attempting to update. Your update
    ///       request is accepted only if this status is either <code>ACTIVE</code> or
    ///       <code>FAILED</code>.</p>
    public let status: TranslateClientTypes.ParallelDataStatus?

    public init (
        latestUpdateAttemptAt: ClientRuntime.Date? = nil,
        latestUpdateAttemptStatus: TranslateClientTypes.ParallelDataStatus? = nil,
        name: Swift.String? = nil,
        status: TranslateClientTypes.ParallelDataStatus? = nil
    )
    {
        self.latestUpdateAttemptAt = latestUpdateAttemptAt
        self.latestUpdateAttemptStatus = latestUpdateAttemptStatus
        self.name = name
        self.status = status
    }
}

struct UpdateParallelDataOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let status: TranslateClientTypes.ParallelDataStatus?
    public let latestUpdateAttemptStatus: TranslateClientTypes.ParallelDataStatus?
    public let latestUpdateAttemptAt: ClientRuntime.Date?
}

extension UpdateParallelDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestUpdateAttemptAt = "LatestUpdateAttemptAt"
        case latestUpdateAttemptStatus = "LatestUpdateAttemptStatus"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataStatus.self, forKey: .status)
        status = statusDecoded
        let latestUpdateAttemptStatusDecoded = try containerValues.decodeIfPresent(TranslateClientTypes.ParallelDataStatus.self, forKey: .latestUpdateAttemptStatus)
        latestUpdateAttemptStatus = latestUpdateAttemptStatusDecoded
        let latestUpdateAttemptAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestUpdateAttemptAt)
        latestUpdateAttemptAt = latestUpdateAttemptAtDecoded
    }
}
