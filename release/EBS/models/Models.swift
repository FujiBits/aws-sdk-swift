// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The reason for the exception.</p>
    public var reason: EbsClientTypes.AccessDeniedExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: EbsClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: EbsClientTypes.AccessDeniedExceptionReason?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EbsClientTypes.AccessDeniedExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EbsClientTypes {
    public enum AccessDeniedExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyAccessDenied
        case unauthorizedAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .dependencyAccessDenied,
                .unauthorizedAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyAccessDenied: return "DEPENDENCY_ACCESS_DENIED"
            case .unauthorizedAccount: return "UNAUTHORIZED_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedExceptionReason(rawValue: rawValue) ?? AccessDeniedExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension EbsClientTypes.Block: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockIndex = "BlockIndex"
        case blockToken = "BlockToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockIndex = blockIndex {
            try encodeContainer.encode(blockIndex, forKey: .blockIndex)
        }
        if let blockToken = blockToken {
            try encodeContainer.encode(blockToken, forKey: .blockToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockIndex)
        blockIndex = blockIndexDecoded
        let blockTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockToken)
        blockToken = blockTokenDecoded
    }
}

extension EbsClientTypes.Block: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Block(blockIndex: \(Swift.String(describing: blockIndex)), blockToken: \(Swift.String(describing: blockToken)))"}
}

extension EbsClientTypes {
    /// <p>A block of data in an Amazon Elastic Block Store snapshot.</p>
    public struct Block: Swift.Equatable {
        /// <p>The block index.</p>
        public let blockIndex: Swift.Int?
        /// <p>The block token for the block index.</p>
        public let blockToken: Swift.String?

        public init (
            blockIndex: Swift.Int? = nil,
            blockToken: Swift.String? = nil
        )
        {
            self.blockIndex = blockIndex
            self.blockToken = blockToken
        }
    }

}

extension EbsClientTypes.ChangedBlock: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockIndex = "BlockIndex"
        case firstBlockToken = "FirstBlockToken"
        case secondBlockToken = "SecondBlockToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockIndex = blockIndex {
            try encodeContainer.encode(blockIndex, forKey: .blockIndex)
        }
        if let firstBlockToken = firstBlockToken {
            try encodeContainer.encode(firstBlockToken, forKey: .firstBlockToken)
        }
        if let secondBlockToken = secondBlockToken {
            try encodeContainer.encode(secondBlockToken, forKey: .secondBlockToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockIndex)
        blockIndex = blockIndexDecoded
        let firstBlockTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstBlockToken)
        firstBlockToken = firstBlockTokenDecoded
        let secondBlockTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondBlockToken)
        secondBlockToken = secondBlockTokenDecoded
    }
}

extension EbsClientTypes.ChangedBlock: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension EbsClientTypes {
    /// <p>A block of data in an Amazon Elastic Block Store snapshot that is different from another snapshot of
    ///             the same volume/snapshot lineage.</p>
    public struct ChangedBlock: Swift.Equatable {
        /// <p>The block index.</p>
        public let blockIndex: Swift.Int?
        /// <p>The block token for the block index of the <code>FirstSnapshotId</code> specified in
        ///             the <code>ListChangedBlocks</code> operation. This value is absent if the first snapshot
        ///             does not have the changed block that is on the second snapshot.</p>
        public let firstBlockToken: Swift.String?
        /// <p>The block token for the block index of the <code>SecondSnapshotId</code> specified in
        ///             the <code>ListChangedBlocks</code> operation.</p>
        public let secondBlockToken: Swift.String?

        public init (
            blockIndex: Swift.Int? = nil,
            firstBlockToken: Swift.String? = nil,
            secondBlockToken: Swift.String? = nil
        )
        {
            self.blockIndex = blockIndex
            self.firstBlockToken = firstBlockToken
            self.secondBlockToken = secondBlockToken
        }
    }

}

extension EbsClientTypes {
    public enum ChecksumAggregationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checksumAggregationLinear
        case sdkUnknown(Swift.String)

        public static var allCases: [ChecksumAggregationMethod] {
            return [
                .checksumAggregationLinear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checksumAggregationLinear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChecksumAggregationMethod(rawValue: rawValue) ?? ChecksumAggregationMethod.sdkUnknown(rawValue)
        }
    }
}

extension EbsClientTypes {
    public enum ChecksumAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case checksumAlgorithmSha256
        case sdkUnknown(Swift.String)

        public static var allCases: [ChecksumAlgorithm] {
            return [
                .checksumAlgorithmSha256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .checksumAlgorithmSha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChecksumAlgorithm(rawValue: rawValue) ?? ChecksumAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension CompleteSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteSnapshotInput(changedBlocksCount: \(Swift.String(describing: changedBlocksCount)), checksum: \(Swift.String(describing: checksum)), checksumAggregationMethod: \(Swift.String(describing: checksumAggregationMethod)), checksumAlgorithm: \(Swift.String(describing: checksumAlgorithm)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension CompleteSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CompleteSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let changedBlocksCount = input.operationInput.changedBlocksCount {
            input.builder.withHeader(name: "x-amz-ChangedBlocksCount", value: Swift.String(changedBlocksCount))
        }
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-Checksum", value: Swift.String(checksum))
        }
        if let checksumAggregationMethod = input.operationInput.checksumAggregationMethod {
            input.builder.withHeader(name: "x-amz-Checksum-Aggregation-Method", value: Swift.String(checksumAggregationMethod.rawValue))
        }
        if let checksumAlgorithm = input.operationInput.checksumAlgorithm {
            input.builder.withHeader(name: "x-amz-Checksum-Algorithm", value: Swift.String(checksumAlgorithm.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteSnapshotOutputError>
}

public struct CompleteSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteSnapshotOutputError>
}

public struct CompleteSnapshotInput: Swift.Equatable {
    /// <p>The number of blocks that were written to the snapshot.</p>
    public let changedBlocksCount: Swift.Int?
    /// <p>An aggregated Base-64 SHA256 checksum based on the checksums of each written
    ///             block.</p>
    ///         <p>To generate the aggregated checksum using the linear aggregation method, arrange the
    ///             checksums for each written block in ascending order of their block index, concatenate
    ///             them to form a single string, and then generate the checksum on the entire string using
    ///             the SHA256 algorithm.</p>
    public let checksum: Swift.String?
    /// <p>The aggregation method used to generate the checksum. Currently, the only supported
    ///             aggregation method is <code>LINEAR</code>.</p>
    public let checksumAggregationMethod: EbsClientTypes.ChecksumAggregationMethod?
    /// <p>The algorithm used to generate the checksum. Currently, the only supported algorithm
    ///             is <code>SHA256</code>.</p>
    public let checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm?
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: Swift.String?

    public init (
        changedBlocksCount: Swift.Int? = nil,
        checksum: Swift.String? = nil,
        checksumAggregationMethod: EbsClientTypes.ChecksumAggregationMethod? = nil,
        checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.changedBlocksCount = changedBlocksCount
        self.checksum = checksum
        self.checksumAggregationMethod = checksumAggregationMethod
        self.checksumAlgorithm = checksumAlgorithm
        self.snapshotId = snapshotId
    }
}

struct CompleteSnapshotInputBody: Swift.Equatable {
}

extension CompleteSnapshotInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CompleteSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteSnapshotOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension CompleteSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CompleteSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CompleteSnapshotOutputResponse: Swift.Equatable {
    /// <p>The status of the snapshot.</p>
    public let status: EbsClientTypes.Status?

    public init (
        status: EbsClientTypes.Status? = nil
    )
    {
        self.status = status
    }
}

struct CompleteSnapshotOutputResponseBody: Swift.Equatable {
    public let status: EbsClientTypes.Status?
}

extension CompleteSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EbsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConcurrentLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit for concurrent API requests. For more information, see
///                 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapi-performance">Optimizing performance of the EBS direct APIs</a> in the <i>Amazon Elastic Compute Cloud
///                 User Guide</i>.</p>
public struct ConcurrentLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request uses the same client token as a previous, but non-identical
///             request.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetSnapshotBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSnapshotBlockInput(blockIndex: \(Swift.String(describing: blockIndex)), blockToken: \(Swift.String(describing: blockToken)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension GetSnapshotBlockInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSnapshotBlockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSnapshotBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSnapshotBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSnapshotBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSnapshotBlockOutputError>
}

public struct GetSnapshotBlockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSnapshotBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSnapshotBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blockToken = input.operationInput.blockToken {
            let blockTokenQueryItem = ClientRuntime.URLQueryItem(name: "blockToken".urlPercentEncoding(), value: Swift.String(blockToken).urlPercentEncoding())
            input.builder.withQueryItem(blockTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSnapshotBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSnapshotBlockOutputError>
}

public struct GetSnapshotBlockInput: Swift.Equatable {
    /// <p>The block index of the block from which to get data.</p>
    ///
    ///
    ///         <p>Obtain the <code>BlockIndex</code> by running the <code>ListChangedBlocks</code> or
    ///                 <code>ListSnapshotBlocks</code> operations.</p>
    public let blockIndex: Swift.Int?
    /// <p>The block token of the block from which to get data.</p>
    ///
    ///
    ///         <p>Obtain the <code>BlockToken</code> by running the <code>ListChangedBlocks</code> or
    ///                 <code>ListSnapshotBlocks</code> operations.</p>
    public let blockToken: Swift.String?
    /// <p>The ID of the snapshot containing the block from which to get data.</p>
    public let snapshotId: Swift.String?

    public init (
        blockIndex: Swift.Int? = nil,
        blockToken: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.blockIndex = blockIndex
        self.blockToken = blockToken
        self.snapshotId = snapshotId
    }
}

struct GetSnapshotBlockInputBody: Swift.Equatable {
}

extension GetSnapshotBlockInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSnapshotBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnapshotBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSnapshotBlockOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnapshotBlockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSnapshotBlockOutputResponse(blockData: \(Swift.String(describing: blockData)), checksum: \(Swift.String(describing: checksum)), checksumAlgorithm: \(Swift.String(describing: checksumAlgorithm)), dataLength: \(Swift.String(describing: dataLength)))"}
}

extension GetSnapshotBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum-Algorithm") {
            self.checksumAlgorithm = EbsClientTypes.ChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
        if let dataLengthHeaderValue = httpResponse.headers.value(for: "x-amz-Data-Length") {
            self.dataLength = Swift.Int(dataLengthHeaderValue) ?? 0
        } else {
            self.dataLength = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.blockData = data
        } else {
            self.blockData = nil
        }
    }
}

public struct GetSnapshotBlockOutputResponse: Swift.Equatable {
    /// <p>The data content of the block.</p>
    public let blockData: ClientRuntime.ByteStream?
    /// <p>The checksum generated for the block, which is Base64 encoded.</p>
    public let checksum: Swift.String?
    /// <p>The algorithm used to generate the checksum for the block, such as SHA256.</p>
    public let checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm?
    /// <p>The size of the data in the block.</p>
    public let dataLength: Swift.Int?

    public init (
        blockData: ClientRuntime.ByteStream? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm? = nil,
        dataLength: Swift.Int? = nil
    )
    {
        self.blockData = blockData
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.dataLength = dataLength
    }
}

struct GetSnapshotBlockOutputResponseBody: Swift.Equatable {
    public let blockData: ClientRuntime.ByteStream?
}

extension GetSnapshotBlockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockData = "BlockData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .blockData)
        blockData = blockDataDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error has occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangedBlocksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChangedBlocksInput(firstSnapshotId: \(Swift.String(describing: firstSnapshotId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), secondSnapshotId: \(Swift.String(describing: secondSnapshotId)), startingBlockIndex: \(Swift.String(describing: startingBlockIndex)))"}
}

extension ListChangedBlocksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChangedBlocksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChangedBlocksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChangedBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChangedBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChangedBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChangedBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChangedBlocksOutputError>
}

public struct ListChangedBlocksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChangedBlocksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChangedBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChangedBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let firstSnapshotId = input.operationInput.firstSnapshotId {
            let firstSnapshotIdQueryItem = ClientRuntime.URLQueryItem(name: "firstSnapshotId".urlPercentEncoding(), value: Swift.String(firstSnapshotId).urlPercentEncoding())
            input.builder.withQueryItem(firstSnapshotIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "pageToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let startingBlockIndex = input.operationInput.startingBlockIndex {
            let startingBlockIndexQueryItem = ClientRuntime.URLQueryItem(name: "startingBlockIndex".urlPercentEncoding(), value: Swift.String(startingBlockIndex).urlPercentEncoding())
            input.builder.withQueryItem(startingBlockIndexQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChangedBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChangedBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChangedBlocksOutputError>
}

public struct ListChangedBlocksInput: Swift.Equatable {
    /// <p>The ID of the first snapshot to use for the comparison.</p>
    ///         <important>
    ///             <p>The <code>FirstSnapshotID</code> parameter must be specified with a
    ///                     <code>SecondSnapshotId</code> parameter; otherwise, an error occurs.</p>
    ///         </important>
    public let firstSnapshotId: Swift.String?
    /// <p>The number of results to return.</p>
    public let maxResults: Swift.Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The ID of the second snapshot to use for the comparison.</p>
    ///         <important>
    ///             <p>The <code>SecondSnapshotId</code> parameter must be specified with a
    ///                     <code>FirstSnapshotID</code> parameter; otherwise, an error occurs.</p>
    ///         </important>
    public let secondSnapshotId: Swift.String?
    /// <p>The block index from which the comparison should start.</p>
    ///         <p>The list in the response will start from this block index or the next valid block
    ///             index in the snapshots.</p>
    public let startingBlockIndex: Swift.Int?

    public init (
        firstSnapshotId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        secondSnapshotId: Swift.String? = nil,
        startingBlockIndex: Swift.Int? = nil
    )
    {
        self.firstSnapshotId = firstSnapshotId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secondSnapshotId = secondSnapshotId
        self.startingBlockIndex = startingBlockIndex
    }
}

struct ListChangedBlocksInputBody: Swift.Equatable {
}

extension ListChangedBlocksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChangedBlocksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChangedBlocksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChangedBlocksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangedBlocksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChangedBlocksOutputResponse(blockSize: \(Swift.String(describing: blockSize)), changedBlocks: \(Swift.String(describing: changedBlocks)), expiryTime: \(Swift.String(describing: expiryTime)), nextToken: \(Swift.String(describing: nextToken)), volumeSize: \(Swift.String(describing: volumeSize)))"}
}

extension ListChangedBlocksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChangedBlocksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blockSize = output.blockSize
            self.changedBlocks = output.changedBlocks
            self.expiryTime = output.expiryTime
            self.nextToken = output.nextToken
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.changedBlocks = nil
            self.expiryTime = nil
            self.nextToken = nil
            self.volumeSize = nil
        }
    }
}

public struct ListChangedBlocksOutputResponse: Swift.Equatable {
    /// <p>The size of the block.</p>
    public let blockSize: Swift.Int?
    /// <p>An array of objects containing information about the changed blocks.</p>
    public let changedBlocks: [EbsClientTypes.ChangedBlock]?
    /// <p>The time when the <code>BlockToken</code> expires.</p>
    public let expiryTime: ClientRuntime.Date?
    /// <p>The token to use to retrieve the next page of results. This value is null when there
    ///             are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>The size of the volume in GB.</p>
    public let volumeSize: Swift.Int?

    public init (
        blockSize: Swift.Int? = nil,
        changedBlocks: [EbsClientTypes.ChangedBlock]? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.blockSize = blockSize
        self.changedBlocks = changedBlocks
        self.expiryTime = expiryTime
        self.nextToken = nextToken
        self.volumeSize = volumeSize
    }
}

struct ListChangedBlocksOutputResponseBody: Swift.Equatable {
    public let changedBlocks: [EbsClientTypes.ChangedBlock]?
    public let expiryTime: ClientRuntime.Date?
    public let volumeSize: Swift.Int?
    public let blockSize: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListChangedBlocksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockSize = "BlockSize"
        case changedBlocks = "ChangedBlocks"
        case expiryTime = "ExpiryTime"
        case nextToken = "NextToken"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changedBlocksContainer = try containerValues.decodeIfPresent([EbsClientTypes.ChangedBlock?].self, forKey: .changedBlocks)
        var changedBlocksDecoded0:[EbsClientTypes.ChangedBlock]? = nil
        if let changedBlocksContainer = changedBlocksContainer {
            changedBlocksDecoded0 = [EbsClientTypes.ChangedBlock]()
            for structure0 in changedBlocksContainer {
                if let structure0 = structure0 {
                    changedBlocksDecoded0?.append(structure0)
                }
            }
        }
        changedBlocks = changedBlocksDecoded0
        let expiryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSnapshotBlocksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSnapshotBlocksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), snapshotId: \(Swift.String(describing: snapshotId)), startingBlockIndex: \(Swift.String(describing: startingBlockIndex)))"}
}

extension ListSnapshotBlocksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSnapshotBlocksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSnapshotBlocksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSnapshotBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSnapshotBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSnapshotBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSnapshotBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSnapshotBlocksOutputError>
}

public struct ListSnapshotBlocksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSnapshotBlocksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSnapshotBlocksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSnapshotBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "pageToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let startingBlockIndex = input.operationInput.startingBlockIndex {
            let startingBlockIndexQueryItem = ClientRuntime.URLQueryItem(name: "startingBlockIndex".urlPercentEncoding(), value: Swift.String(startingBlockIndex).urlPercentEncoding())
            input.builder.withQueryItem(startingBlockIndexQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSnapshotBlocksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSnapshotBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSnapshotBlocksOutputError>
}

public struct ListSnapshotBlocksInput: Swift.Equatable {
    /// <p>The number of results to return.</p>
    public let maxResults: Swift.Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The ID of the snapshot from which to get block indexes and block tokens.</p>
    public let snapshotId: Swift.String?
    /// <p>The block index from which the list should start. The list in the response will start
    ///             from this block index or the next valid block index in the snapshot.</p>
    public let startingBlockIndex: Swift.Int?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        startingBlockIndex: Swift.Int? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.snapshotId = snapshotId
        self.startingBlockIndex = startingBlockIndex
    }
}

struct ListSnapshotBlocksInputBody: Swift.Equatable {
}

extension ListSnapshotBlocksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSnapshotBlocksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSnapshotBlocksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSnapshotBlocksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSnapshotBlocksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSnapshotBlocksOutputResponse(blockSize: \(Swift.String(describing: blockSize)), blocks: \(Swift.String(describing: blocks)), expiryTime: \(Swift.String(describing: expiryTime)), nextToken: \(Swift.String(describing: nextToken)), volumeSize: \(Swift.String(describing: volumeSize)))"}
}

extension ListSnapshotBlocksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSnapshotBlocksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blockSize = output.blockSize
            self.blocks = output.blocks
            self.expiryTime = output.expiryTime
            self.nextToken = output.nextToken
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.blocks = nil
            self.expiryTime = nil
            self.nextToken = nil
            self.volumeSize = nil
        }
    }
}

public struct ListSnapshotBlocksOutputResponse: Swift.Equatable {
    /// <p>The size of the block.</p>
    public let blockSize: Swift.Int?
    /// <p>An array of objects containing information about the blocks.</p>
    public let blocks: [EbsClientTypes.Block]?
    /// <p>The time when the <code>BlockToken</code> expires.</p>
    public let expiryTime: ClientRuntime.Date?
    /// <p>The token to use to retrieve the next page of results. This value is null when there
    ///             are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>The size of the volume in GB.</p>
    public let volumeSize: Swift.Int?

    public init (
        blockSize: Swift.Int? = nil,
        blocks: [EbsClientTypes.Block]? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.blockSize = blockSize
        self.blocks = blocks
        self.expiryTime = expiryTime
        self.nextToken = nextToken
        self.volumeSize = volumeSize
    }
}

struct ListSnapshotBlocksOutputResponseBody: Swift.Equatable {
    public let blocks: [EbsClientTypes.Block]?
    public let expiryTime: ClientRuntime.Date?
    public let volumeSize: Swift.Int?
    public let blockSize: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListSnapshotBlocksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockSize = "BlockSize"
        case blocks = "Blocks"
        case expiryTime = "ExpiryTime"
        case nextToken = "NextToken"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blocksContainer = try containerValues.decodeIfPresent([EbsClientTypes.Block?].self, forKey: .blocks)
        var blocksDecoded0:[EbsClientTypes.Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [EbsClientTypes.Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let expiryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct PutSnapshotBlockInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSnapshotBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blockData = input.operationInput.blockData {
            let blockDatadata = blockData
            let blockDatabody = ClientRuntime.HttpBody.stream(blockDatadata)
            input.builder.withBody(blockDatabody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSnapshotBlockOutputError>
}

extension PutSnapshotBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSnapshotBlockInput(blockData: \(Swift.String(describing: blockData)), blockIndex: \(Swift.String(describing: blockIndex)), checksum: \(Swift.String(describing: checksum)), checksumAlgorithm: \(Swift.String(describing: checksumAlgorithm)), dataLength: \(Swift.String(describing: dataLength)), progress: \(Swift.String(describing: progress)), snapshotId: \(Swift.String(describing: snapshotId)))"}
}

extension PutSnapshotBlockInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockData = "BlockData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockData = blockData {
            try encodeContainer.encode(blockData.toBytes().toData(), forKey: .blockData)
        }
    }
}

public struct PutSnapshotBlockInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSnapshotBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-Checksum", value: Swift.String(checksum))
        }
        if let checksumAlgorithm = input.operationInput.checksumAlgorithm {
            input.builder.withHeader(name: "x-amz-Checksum-Algorithm", value: Swift.String(checksumAlgorithm.rawValue))
        }
        if let dataLength = input.operationInput.dataLength {
            input.builder.withHeader(name: "x-amz-Data-Length", value: Swift.String(dataLength))
        }
        if let progress = input.operationInput.progress {
            input.builder.withHeader(name: "x-amz-Progress", value: Swift.String(progress))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSnapshotBlockOutputError>
}

public struct PutSnapshotBlockInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSnapshotBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSnapshotBlockOutputError>
}

public struct PutSnapshotBlockInput: Swift.Equatable {
    /// <p>The data to write to the block.</p>
    ///         <p>The block data is not signed as part of the Signature Version 4 signing process. As a
    ///             result, you must generate and provide a Base64-encoded SHA256 checksum for the block
    ///             data using the <b>x-amz-Checksum</b> header. Also, you
    ///         	must specify the checksum algorithm using the <b>x-amz-Checksum-Algorithm</b>
    ///         	header. The checksum that you provide is part of the Signature Version 4 signing process.
    ///         	It is validated against a checksum generated by Amazon EBS to ensure the validity and authenticity
    ///         	of the data. If the checksums do not correspond, the request fails. For more information,
    ///         	see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapis-using-checksums">
    ///                 Using checksums with the EBS direct APIs</a> in the <i>Amazon Elastic Compute Cloud User
    ///                 Guide</i>.</p>
    public let blockData: ClientRuntime.ByteStream?
    /// <p>The block index of the block in which to write the data. A block index is a logical
    ///     	index in units of <code>512</code> KiB blocks. To identify the block index, divide
    ///         	the logical offset of the data in the logical volume by the block size (logical offset of
    ///         	data/<code>524288</code>). The logical offset of the data must be <code>512</code>
    ///         	KiB aligned.</p>
    public let blockIndex: Swift.Int?
    /// <p>A Base64-encoded SHA256 checksum of the data. Only SHA256 checksums are
    ///             supported.</p>
    public let checksum: Swift.String?
    /// <p>The algorithm used to generate the checksum. Currently, the only supported algorithm
    ///             is <code>SHA256</code>.</p>
    public let checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm?
    /// <p>The size of the data to write to the block, in bytes. Currently, the only supported
    ///             size is <code>524288</code>.</p>
    ///         <p>Valid values: <code>524288</code>
    ///          </p>
    public let dataLength: Swift.Int?
    /// <p>The progress of the write process, as a percentage.</p>
    public let progress: Swift.Int?
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: Swift.String?

    public init (
        blockData: ClientRuntime.ByteStream? = nil,
        blockIndex: Swift.Int? = nil,
        checksum: Swift.String? = nil,
        checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm? = nil,
        dataLength: Swift.Int? = nil,
        progress: Swift.Int? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.blockData = blockData
        self.blockIndex = blockIndex
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.dataLength = dataLength
        self.progress = progress
        self.snapshotId = snapshotId
    }
}

struct PutSnapshotBlockInputBody: Swift.Equatable {
    public let blockData: ClientRuntime.ByteStream?
}

extension PutSnapshotBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockData = "BlockData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDataDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .blockData)
        blockData = blockDataDecoded
    }
}

extension PutSnapshotBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSnapshotBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSnapshotBlockOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSnapshotBlockOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSnapshotBlockOutputResponse(checksum: \(Swift.String(describing: checksum)), checksumAlgorithm: \(Swift.String(describing: checksumAlgorithm)))"}
}

extension PutSnapshotBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum-Algorithm") {
            self.checksumAlgorithm = EbsClientTypes.ChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
    }
}

public struct PutSnapshotBlockOutputResponse: Swift.Equatable {
    /// <p>The SHA256 checksum generated for the block data by Amazon EBS.</p>
    public let checksum: Swift.String?
    /// <p>The algorithm used by Amazon EBS to generate the checksum.</p>
    public let checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm?

    public init (
        checksum: Swift.String? = nil,
        checksumAlgorithm: EbsClientTypes.ChecksumAlgorithm? = nil
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
    }
}

struct PutSnapshotBlockOutputResponseBody: Swift.Equatable {
}

extension PutSnapshotBlockOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RequestThrottledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestThrottledException(message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension RequestThrottledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of API requests has exceed the maximum allowed API request throttling
///             limit.</p>
public struct RequestThrottledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The reason for the exception.</p>
    public var reason: EbsClientTypes.RequestThrottledExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: EbsClientTypes.RequestThrottledExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct RequestThrottledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: EbsClientTypes.RequestThrottledExceptionReason?
}

extension RequestThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EbsClientTypes.RequestThrottledExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EbsClientTypes {
    public enum RequestThrottledExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountThrottled
        case dependencyRequestThrottled
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestThrottledExceptionReason] {
            return [
                .accountThrottled,
                .dependencyRequestThrottled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountThrottled: return "ACCOUNT_THROTTLED"
            case .dependencyRequestThrottled: return "DEPENDENCY_REQUEST_THROTTLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequestThrottledExceptionReason(rawValue: rawValue) ?? RequestThrottledExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The reason for the exception.</p>
    public var reason: EbsClientTypes.ResourceNotFoundExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: EbsClientTypes.ResourceNotFoundExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: EbsClientTypes.ResourceNotFoundExceptionReason?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EbsClientTypes.ResourceNotFoundExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EbsClientTypes {
    public enum ResourceNotFoundExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyResourceNotFound
        case snapshotNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .dependencyResourceNotFound,
                .snapshotNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyResourceNotFound: return "DEPENDENCY_RESOURCE_NOT_FOUND"
            case .snapshotNotFound: return "SNAPSHOT_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceNotFoundExceptionReason(rawValue: rawValue) ?? ResourceNotFoundExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your current service quotas do not allow you to perform this action.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The reason for the exception.</p>
    public var reason: EbsClientTypes.ServiceQuotaExceededExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: EbsClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: EbsClientTypes.ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EbsClientTypes.ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EbsClientTypes {
    public enum ServiceQuotaExceededExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dependencyServiceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .dependencyServiceQuotaExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dependencyServiceQuotaExceeded: return "DEPENDENCY_SERVICE_QUOTA_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
        }
    }
}

public struct StartSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSnapshotOutputError>
}

extension StartSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSnapshotInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), encrypted: \(Swift.String(describing: encrypted)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), parentSnapshotId: \(Swift.String(describing: parentSnapshotId)), tags: \(Swift.String(describing: tags)), timeout: \(Swift.String(describing: timeout)), volumeSize: \(Swift.String(describing: volumeSize)))"}
}

extension StartSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encrypted = "Encrypted"
        case kmsKeyArn = "KmsKeyArn"
        case parentSnapshotId = "ParentSnapshotId"
        case tags = "Tags"
        case timeout = "Timeout"
        case volumeSize = "VolumeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let parentSnapshotId = parentSnapshotId {
            try encodeContainer.encode(parentSnapshotId, forKey: .parentSnapshotId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
    }
}

public struct StartSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSnapshotOutputError>
}

public struct StartSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSnapshotOutputError>
}

public struct StartSnapshotInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///             request. Idempotency ensures that an API request completes only once. With an idempotent
    ///             request, if the original request completes successfully. The subsequent retries with the same
    ///             client token return the result from the original successful request and they have no additional
    ///             effect.</p>
    ///         <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-direct-api-idempotency.html">
    ///     		Idempotency for StartSnapshot API</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    public var clientToken: Swift.String?
    /// <p>A description for the snapshot.</p>
    public let description: Swift.String?
    /// <p>Indicates whether to encrypt the snapshot. To create an encrypted snapshot, specify
    ///                 <code>true</code>. To create an unencrypted snapshot, omit this parameter.</p>
    ///         <p>If you specify a value for <b>ParentSnapshotId</b>, omit
    ///             this parameter.</p>
    ///         <p>If you specify <code>true</code>, the snapshot is encrypted using the CMK specified
    ///             using the <b>KmsKeyArn</b> parameter. If no value is specified
    ///             for <b>KmsKeyArn</b>, the default CMK for your account is
    ///         	used. If no default CMK has been specified for your account, the AWS managed CMK is used.
    ///         	To set a default CMK for your account, use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyEbsDefaultKmsKeyId.html">
    ///         		ModifyEbsDefaultKmsKeyId</a>.</p>
    ///         <p>If your account is enabled for encryption by default, you cannot set this parameter to
    ///                 <code>false</code>. In this case, you can omit this parameter.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapis-using-encryption">
    ///                 Using encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    public let encrypted: Swift.Bool?
    /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS)
    ///         	customer master key (CMK) to be used to encrypt the snapshot. If you do not specify a
    ///         	CMK, the default AWS managed CMK is used.</p>
    ///         <p>If you specify a <b>ParentSnapshotId</b>, omit this
    ///             parameter; the snapshot will be encrypted using the same CMK that was used to encrypt
    ///             the parent snapshot.</p>
    ///         <p>If <b>Encrypted</b> is set to <code>true</code>,
    ///         	you must specify a CMK ARN. </p>
    public let kmsKeyArn: Swift.String?
    /// <p>The ID of the parent snapshot. If there is no parent snapshot, or if you are creating
    ///             the first snapshot for an on-premises volume, omit this parameter.</p>
    ///         <p>If your account is enabled for encryption by default, you cannot use an unencrypted
    ///             snapshot as a parent snapshot. You must first create an encrypted copy of the parent
    ///             snapshot using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CopySnapshot.html">CopySnapshot</a>.</p>
    public let parentSnapshotId: Swift.String?
    /// <p>The tags to apply to the snapshot.</p>
    public let tags: [EbsClientTypes.Tag]?
    /// <p>The amount of time (in minutes) after which the snapshot is automatically cancelled
    ///             if:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>No blocks are written to the snapshot.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The snapshot is not completed after writing the last block of data.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If no value is specified, the timeout defaults to <code>60</code> minutes.</p>
    public let timeout: Swift.Int?
    /// <p>The size of the volume, in GiB. The maximum size is <code>16384</code> GiB (16
    ///             TiB).</p>
    public let volumeSize: Swift.Int?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        kmsKeyArn: Swift.String? = nil,
        parentSnapshotId: Swift.String? = nil,
        tags: [EbsClientTypes.Tag]? = nil,
        timeout: Swift.Int? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyArn = kmsKeyArn
        self.parentSnapshotId = parentSnapshotId
        self.tags = tags
        self.timeout = timeout
        self.volumeSize = volumeSize
    }
}

struct StartSnapshotInputBody: Swift.Equatable {
    public let volumeSize: Swift.Int?
    public let parentSnapshotId: Swift.String?
    public let tags: [EbsClientTypes.Tag]?
    public let description: Swift.String?
    public let clientToken: Swift.String?
    public let encrypted: Swift.Bool?
    public let kmsKeyArn: Swift.String?
    public let timeout: Swift.Int?
}

extension StartSnapshotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encrypted = "Encrypted"
        case kmsKeyArn = "KmsKeyArn"
        case parentSnapshotId = "ParentSnapshotId"
        case tags = "Tags"
        case timeout = "Timeout"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let parentSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSnapshotId)
        parentSnapshotId = parentSnapshotIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EbsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EbsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EbsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension StartSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentLimitExceededException" : self = .concurrentLimitExceededException(try ConcurrentLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSnapshotOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentLimitExceededException(ConcurrentLimitExceededException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSnapshotOutputResponse(blockSize: \(Swift.String(describing: blockSize)), description: \(Swift.String(describing: description)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), ownerId: \(Swift.String(describing: ownerId)), parentSnapshotId: \(Swift.String(describing: parentSnapshotId)), snapshotId: \(Swift.String(describing: snapshotId)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), volumeSize: \(Swift.String(describing: volumeSize)))"}
}

extension StartSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.blockSize = output.blockSize
            self.description = output.description
            self.kmsKeyArn = output.kmsKeyArn
            self.ownerId = output.ownerId
            self.parentSnapshotId = output.parentSnapshotId
            self.snapshotId = output.snapshotId
            self.startTime = output.startTime
            self.status = output.status
            self.tags = output.tags
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.description = nil
            self.kmsKeyArn = nil
            self.ownerId = nil
            self.parentSnapshotId = nil
            self.snapshotId = nil
            self.startTime = nil
            self.status = nil
            self.tags = nil
            self.volumeSize = nil
        }
    }
}

public struct StartSnapshotOutputResponse: Swift.Equatable {
    /// <p>The size of the blocks in the snapshot, in bytes.</p>
    public let blockSize: Swift.Int?
    /// <p>The description of the snapshot.</p>
    public let description: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer
    ///             master key (CMK) used to encrypt the snapshot.</p>
    public let kmsKeyArn: Swift.String?
    /// <p>The AWS account ID of the snapshot owner.</p>
    public let ownerId: Swift.String?
    /// <p>The ID of the parent snapshot.</p>
    public let parentSnapshotId: Swift.String?
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: Swift.String?
    /// <p>The timestamp when the snapshot was created.</p>
    public let startTime: ClientRuntime.Date?
    /// <p>The status of the snapshot.</p>
    public let status: EbsClientTypes.Status?
    /// <p>The tags applied to the snapshot. You can specify up to 50 tags per snapshot. For more
    ///             information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html"> Tagging your Amazon EC2
    ///                 resources</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    public let tags: [EbsClientTypes.Tag]?
    /// <p>The size of the volume, in GiB.</p>
    public let volumeSize: Swift.Int?

    public init (
        blockSize: Swift.Int? = nil,
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        ownerId: Swift.String? = nil,
        parentSnapshotId: Swift.String? = nil,
        snapshotId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: EbsClientTypes.Status? = nil,
        tags: [EbsClientTypes.Tag]? = nil,
        volumeSize: Swift.Int? = nil
    )
    {
        self.blockSize = blockSize
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.ownerId = ownerId
        self.parentSnapshotId = parentSnapshotId
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.status = status
        self.tags = tags
        self.volumeSize = volumeSize
    }
}

struct StartSnapshotOutputResponseBody: Swift.Equatable {
    public let description: Swift.String?
    public let snapshotId: Swift.String?
    public let ownerId: Swift.String?
    public let status: EbsClientTypes.Status?
    public let startTime: ClientRuntime.Date?
    public let volumeSize: Swift.Int?
    public let blockSize: Swift.Int?
    public let tags: [EbsClientTypes.Tag]?
    public let parentSnapshotId: Swift.String?
    public let kmsKeyArn: Swift.String?
}

extension StartSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockSize = "BlockSize"
        case description = "Description"
        case kmsKeyArn = "KmsKeyArn"
        case ownerId = "OwnerId"
        case parentSnapshotId = "ParentSnapshotId"
        case snapshotId = "SnapshotId"
        case startTime = "StartTime"
        case status = "Status"
        case tags = "Tags"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EbsClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EbsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EbsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EbsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let parentSnapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentSnapshotId)
        parentSnapshotId = parentSnapshotIdDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension EbsClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case error
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .error,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .error: return "error"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension EbsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EbsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension EbsClientTypes {
    /// <p>Describes a tag.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key of the tag.</p>
        public let key: Swift.String?
        /// <p>The value of the tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints of the EBS direct APIs.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The reason for the validation exception.</p>
    public var reason: EbsClientTypes.ValidationExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: EbsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: EbsClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(EbsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension EbsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidBlock
        case invalidBlockToken
        case invalidContentEncoding
        case invalidCustomerKey
        case invalidDependencyRequest
        case invalidPageToken
        case invalidParameterValue
        case invalidSnapshotId
        case invalidTag
        case invalidVolumeSize
        case unrelatedSnapshots
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidBlock,
                .invalidBlockToken,
                .invalidContentEncoding,
                .invalidCustomerKey,
                .invalidDependencyRequest,
                .invalidPageToken,
                .invalidParameterValue,
                .invalidSnapshotId,
                .invalidTag,
                .invalidVolumeSize,
                .unrelatedSnapshots,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidBlock: return "INVALID_BLOCK"
            case .invalidBlockToken: return "INVALID_BLOCK_TOKEN"
            case .invalidContentEncoding: return "INVALID_CONTENT_ENCODING"
            case .invalidCustomerKey: return "INVALID_CUSTOMER_KEY"
            case .invalidDependencyRequest: return "INVALID_DEPENDENCY_REQUEST"
            case .invalidPageToken: return "INVALID_PAGE_TOKEN"
            case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
            case .invalidSnapshotId: return "INVALID_SNAPSHOT_ID"
            case .invalidTag: return "INVALID_TAG"
            case .invalidVolumeSize: return "INVALID_VOLUME_SIZE"
            case .unrelatedSnapshots: return "UNRELATED_SNAPSHOTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
