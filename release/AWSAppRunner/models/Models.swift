// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateCustomDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

extension AssociateCustomDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomDomainInput(domainName: \(Swift.String(describing: domainName)), enableWWWSubdomain: \(Swift.String(describing: enableWWWSubdomain)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension AssociateCustomDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct AssociateCustomDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateCustomDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCustomDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCustomDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateCustomDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCustomDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCustomDomainOutputError>
}

public struct AssociateCustomDomainInput: Swift.Equatable {
    /// A custom domain endpoint to associate. Specify a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
    /// This member is required.
    public var domainName: Swift.String?
    /// Set to true to associate the subdomain www.DomainName  with the App Runner service in addition to the base domain. Default: true
    public var enableWWWSubdomain: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        enableWWWSubdomain: Swift.Bool? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.enableWWWSubdomain = enableWWWSubdomain
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let domainName: Swift.String?
    public let enableWWWSubdomain: Swift.Bool?
}

extension AssociateCustomDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
    }
}

extension AssociateCustomDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCustomDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCustomDomainOutputResponse(customDomain: \(Swift.String(describing: customDomain)), dNSTarget: \(Swift.String(describing: dNSTarget)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension AssociateCustomDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomain = output.customDomain
            self.dNSTarget = output.dNSTarget
            self.serviceArn = output.serviceArn
        } else {
            self.customDomain = nil
            self.dNSTarget = nil
            self.serviceArn = nil
        }
    }
}

public struct AssociateCustomDomainOutputResponse: Swift.Equatable {
    /// A description of the domain name that's being associated.
    /// This member is required.
    public var customDomain: AppRunnerClientTypes.CustomDomain?
    /// The App Runner subdomain of the App Runner service. The custom domain name is mapped to this target name.
    /// This member is required.
    public var dNSTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service with which a custom domain name is associated.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dNSTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.customDomain = customDomain
        self.dNSTarget = dNSTarget
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainOutputResponseBody: Swift.Equatable {
    public let dNSTarget: Swift.String?
    public let serviceArn: Swift.String?
    public let customDomain: AppRunnerClientTypes.CustomDomain?
}

extension AssociateCustomDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomain = "CustomDomain"
        case dNSTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
    }
}

extension AppRunnerClientTypes.AuthenticationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRoleArn = "AccessRoleArn"
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRoleArn = accessRoleArn {
            try encodeContainer.encode(accessRoleArn, forKey: .accessRoleArn)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let accessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRoleArn)
        accessRoleArn = accessRoleArnDecoded
    }
}

extension AppRunnerClientTypes.AuthenticationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationConfiguration(accessRoleArn: \(Swift.String(describing: accessRoleArn)), connectionArn: \(Swift.String(describing: connectionArn)))"}
}

extension AppRunnerClientTypes {
    /// Describes resources needed to authenticate access to some source repositories. The specific resource depends on the repository provider.
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories (but not for ECR Public repositories).
        public var accessRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It's required for GitHub code repositories.
        public var connectionArn: Swift.String?

        public init (
            accessRoleArn: Swift.String? = nil,
            connectionArn: Swift.String? = nil
        )
        {
            self.accessRoleArn = accessRoleArn
            self.connectionArn = connectionArn
        }
    }

}

extension AppRunnerClientTypes.AutoScalingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case latest = "Latest"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if latest != false {
            try encodeContainer.encode(latest, forKey: .latest)
        }
        if maxConcurrency != 0 {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if maxSize != 0 {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if minSize != 0 {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
        let latestDecoded = try containerValues.decode(Swift.Bool.self, forKey: .latest)
        latest = latestDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let maxConcurrencyDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AppRunnerClientTypes.AutoScalingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoScalingConfiguration(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), autoScalingConfigurationRevision: \(Swift.String(describing: autoScalingConfigurationRevision)), createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), latest: \(Swift.String(describing: latest)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxSize: \(Swift.String(describing: maxSize)), minSize: \(Swift.String(describing: minSize)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// Describes an AWS App Runner automatic scaling configuration resource. Multiple revisions of a configuration have the same AutoScalingConfigurationName and different AutoScalingConfigurationRevision values. A higher MinSize increases the spread of your App Runner service over more Availability Zones in the AWS Region. The tradeoff is a higher minimal cost. A lower MaxSize controls your cost. The tradeoff is lower responsiveness during peak demand.
    public struct AutoScalingConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public var autoScalingConfigurationArn: Swift.String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public var autoScalingConfigurationName: Swift.String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same AutoScalingConfigurationName.
        public var autoScalingConfigurationRevision: Swift.Int
        /// The time when the auto scaling configuration was created. It's in Unix time stamp format.
        public var createdAt: ClientRuntime.Date?
        /// The time when the auto scaling configuration was deleted. It's in Unix time stamp format.
        public var deletedAt: ClientRuntime.Date?
        /// It's set to true for the configuration with the highest Revision among all configurations that share the same Name. It's set to false otherwise.
        public var latest: Swift.Bool
        /// The maximum number of concurrent requests that an instance processes. If the number of concurrent requests exceeds this limit, App Runner scales the service up.
        public var maxConcurrency: Swift.Int
        /// The maximum number of instances that a service scales up to. At most MaxSize instances actively serve traffic for your service.
        public var maxSize: Swift.Int
        /// The minimum number of instances that App Runner provisions for a service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.
        public var minSize: Swift.Int
        /// The current state of the auto scaling configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.AutoScalingConfigurationStatus?

        public init (
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            latest: Swift.Bool = false,
            maxConcurrency: Swift.Int = 0,
            maxSize: Swift.Int = 0,
            minSize: Swift.Int = 0,
            status: AppRunnerClientTypes.AutoScalingConfigurationStatus? = nil
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.latest = latest
            self.maxConcurrency = maxConcurrency
            self.maxSize = maxSize
            self.minSize = minSize
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum AutoScalingConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingConfigurationStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingConfigurationStatus(rawValue: rawValue) ?? AutoScalingConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.AutoScalingConfigurationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .autoScalingConfigurationRevision)
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
    }
}

extension AppRunnerClientTypes.AutoScalingConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoScalingConfigurationSummary(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), autoScalingConfigurationRevision: \(Swift.String(describing: autoScalingConfigurationRevision)))"}
}

extension AppRunnerClientTypes {
    /// Provides summary information about an AWS App Runner automatic scaling configuration resource. This type contains limited information about an auto scaling configuration. It includes only identification information, without configuration details. It's returned by the [ListAutoScalingConfigurations] action. Complete configuration information is returned by the [CreateAutoScalingConfiguration], [DescribeAutoScalingConfiguration], and [DeleteAutoScalingConfiguration] actions using the [AutoScalingConfiguration] type.
    public struct AutoScalingConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public var autoScalingConfigurationArn: Swift.String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public var autoScalingConfigurationName: Swift.String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") with the same AutoScalingConfigurationName.
        public var autoScalingConfigurationRevision: Swift.Int

        public init (
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
        }
    }

}

extension AppRunnerClientTypes.CertificateValidationRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CertificateValidationRecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes.CertificateValidationRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateValidationRecord(name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension AppRunnerClientTypes {
    /// Describes a certificate CNAME record to add to your DNS. For more information, see [AssociateCustomDomain](https://docs.aws.amazon.com/apprunner/latest/api/API_AssociateCustomDomain.html).
    public struct CertificateValidationRecord: Swift.Equatable {
        /// The certificate CNAME record name.
        public var name: Swift.String?
        /// The current state of the certificate CNAME record validation. It should change to SUCCESS after App Runner completes validation with your DNS.
        public var status: AppRunnerClientTypes.CertificateValidationRecordStatus?
        /// The record type, always CNAME.
        public var type: Swift.String?
        /// The certificate CNAME record value.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            status: AppRunnerClientTypes.CertificateValidationRecordStatus? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.type = type
            self.value = value
        }
    }

}

extension AppRunnerClientTypes {
    public enum CertificateValidationRecordStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pendingValidation
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateValidationRecordStatus] {
            return [
                .failed,
                .pendingValidation,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pendingValidation: return "PENDING_VALIDATION"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateValidationRecordStatus(rawValue: rawValue) ?? CertificateValidationRecordStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.CodeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeConfigurationValues = "CodeConfigurationValues"
        case configurationSource = "ConfigurationSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfigurationValues = codeConfigurationValues {
            try encodeContainer.encode(codeConfigurationValues, forKey: .codeConfigurationValues)
        }
        if let configurationSource = configurationSource {
            try encodeContainer.encode(configurationSource.rawValue, forKey: .configurationSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSourceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConfigurationSource.self, forKey: .configurationSource)
        configurationSource = configurationSourceDecoded
        let codeConfigurationValuesDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeConfigurationValues.self, forKey: .codeConfigurationValues)
        codeConfigurationValues = codeConfigurationValuesDecoded
    }
}

extension AppRunnerClientTypes.CodeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeConfiguration(codeConfigurationValues: \(Swift.String(describing: codeConfigurationValues)), configurationSource: \(Swift.String(describing: configurationSource)))"}
}

extension AppRunnerClientTypes {
    /// Describes the configuration that AWS App Runner uses to build and run an App Runner service from a source code repository.
    public struct CodeConfiguration: Swift.Equatable {
        /// The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a apprunner.yaml file in the source code repository (or ignoring the file if it exists).
        public var codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues?
        /// The source of the App Runner configuration. Values are interpreted as follows:
        ///
        /// * REPOSITORY – App Runner reads configuration values from the apprunner.yaml file in the source code repository and ignores CodeConfigurationValues.
        ///
        /// * API – App Runner uses configuration values provided in CodeConfigurationValues and ignores the apprunner.yaml file in the source code repository.
        /// This member is required.
        public var configurationSource: AppRunnerClientTypes.ConfigurationSource?

        public init (
            codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues? = nil,
            configurationSource: AppRunnerClientTypes.ConfigurationSource? = nil
        )
        {
            self.codeConfigurationValues = codeConfigurationValues
            self.configurationSource = configurationSource
        }
    }

}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildCommand = "BuildCommand"
        case port = "Port"
        case runtime = "Runtime"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buildCommand = buildCommand {
            try encodeContainer.encode(buildCommand, forKey: .buildCommand)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeenvironmentvariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeenvironmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startCommand = startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let buildCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildCommand)
        buildCommand = buildCommandDecoded
        let startCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
    }
}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeConfigurationValues(buildCommand: \(Swift.String(describing: buildCommand)), port: \(Swift.String(describing: port)), runtime: \(Swift.String(describing: runtime)), runtimeEnvironmentVariables: \(Swift.String(describing: runtimeEnvironmentVariables)), startCommand: \(Swift.String(describing: startCommand)))"}
}

extension AppRunnerClientTypes {
    /// Describes the basic configuration needed for building and running an AWS App Runner service. This type doesn't support the full set of possible configuration options. Fur full configuration capabilities, use a apprunner.yaml file in the source code repository.
    public struct CodeConfigurationValues: Swift.Equatable {
        /// The command App Runner runs to build your application.
        public var buildCommand: Swift.String?
        /// The port that your application listens to in the container. Default: 8080
        public var port: Swift.String?
        /// A runtime environment type for building and running an App Runner service. It represents a programming language runtime.
        /// This member is required.
        public var runtime: AppRunnerClientTypes.Runtime?
        /// The environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
        public var runtimeEnvironmentVariables: [Swift.String:Swift.String]?
        /// The command App Runner runs to start your application.
        public var startCommand: Swift.String?

        public init (
            buildCommand: Swift.String? = nil,
            port: Swift.String? = nil,
            runtime: AppRunnerClientTypes.Runtime? = nil,
            runtimeEnvironmentVariables: [Swift.String:Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.buildCommand = buildCommand
            self.port = port
            self.runtime = runtime
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }

}

extension AppRunnerClientTypes.CodeRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeConfiguration = "CodeConfiguration"
        case repositoryUrl = "RepositoryUrl"
        case sourceCodeVersion = "SourceCodeVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfiguration = codeConfiguration {
            try encodeContainer.encode(codeConfiguration, forKey: .codeConfiguration)
        }
        if let repositoryUrl = repositoryUrl {
            try encodeContainer.encode(repositoryUrl, forKey: .repositoryUrl)
        }
        if let sourceCodeVersion = sourceCodeVersion {
            try encodeContainer.encode(sourceCodeVersion, forKey: .sourceCodeVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUrl)
        repositoryUrl = repositoryUrlDecoded
        let sourceCodeVersionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceCodeVersion.self, forKey: .sourceCodeVersion)
        sourceCodeVersion = sourceCodeVersionDecoded
        let codeConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeConfiguration.self, forKey: .codeConfiguration)
        codeConfiguration = codeConfigurationDecoded
    }
}

extension AppRunnerClientTypes.CodeRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeRepository(codeConfiguration: \(Swift.String(describing: codeConfiguration)), repositoryUrl: \(Swift.String(describing: repositoryUrl)), sourceCodeVersion: \(Swift.String(describing: sourceCodeVersion)))"}
}

extension AppRunnerClientTypes {
    /// Describes a source code repository.
    public struct CodeRepository: Swift.Equatable {
        /// Configuration for building and running the service from a source code repository.
        public var codeConfiguration: AppRunnerClientTypes.CodeConfiguration?
        /// The location of the repository that contains the source code.
        /// This member is required.
        public var repositoryUrl: Swift.String?
        /// The version that should be used within the source code repository.
        /// This member is required.
        public var sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion?

        public init (
            codeConfiguration: AppRunnerClientTypes.CodeConfiguration? = nil,
            repositoryUrl: Swift.String? = nil,
            sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion? = nil
        )
        {
            self.codeConfiguration = codeConfiguration
            self.repositoryUrl = repositoryUrl
            self.sourceCodeVersion = sourceCodeVersion
        }
    }

}

extension AppRunnerClientTypes {
    public enum ConfigurationSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSource] {
            return [
                .api,
                .repository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .repository: return "REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSource(rawValue: rawValue) ?? ConfigurationSource.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.Connection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AppRunnerClientTypes.Connection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Connection(connectionArn: \(Swift.String(describing: connectionArn)), connectionName: \(Swift.String(describing: connectionName)), createdAt: \(Swift.String(describing: createdAt)), providerType: \(Swift.String(describing: providerType)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// Describes an AWS App Runner connection resource.
    public struct Connection: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this connection.
        public var connectionArn: Swift.String?
        /// The customer-provided connection name.
        public var connectionName: Swift.String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public var createdAt: ClientRuntime.Date?
        /// The source repository provider.
        public var providerType: AppRunnerClientTypes.ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public var status: AppRunnerClientTypes.ConnectionStatus?

        public init (
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case error
        case pendingHandshake
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .available,
                .deleted,
                .error,
                .pendingHandshake,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .pendingHandshake: return "PENDING_HANDSHAKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ConnectionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AppRunnerClientTypes.ConnectionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionSummary(connectionArn: \(Swift.String(describing: connectionArn)), connectionName: \(Swift.String(describing: connectionName)), createdAt: \(Swift.String(describing: createdAt)), providerType: \(Swift.String(describing: providerType)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// Provides summary information about an AWS App Runner connection resource.
    public struct ConnectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this connection.
        public var connectionArn: Swift.String?
        /// The customer-provided connection name.
        public var connectionName: Swift.String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public var createdAt: ClientRuntime.Date?
        /// The source repository provider.
        public var providerType: AppRunnerClientTypes.ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public var status: AppRunnerClientTypes.ConnectionStatus?

        public init (
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }

}

public struct CreateAutoScalingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

extension CreateAutoScalingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutoScalingConfigurationInput(autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxSize: \(Swift.String(describing: maxSize)), minSize: \(Swift.String(describing: minSize)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAutoScalingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if let maxConcurrency = maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxSize = maxSize {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if let minSize = minSize {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateAutoScalingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAutoScalingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAutoScalingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAutoScalingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAutoScalingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAutoScalingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAutoScalingConfigurationOutputError>
}

public struct CreateAutoScalingConfigurationInput: Swift.Equatable {
    /// A name for the auto scaling configuration. When you use it for the first time in an AWS Region, App Runner creates revision number 1 of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration.
    /// This member is required.
    public var autoScalingConfigurationName: Swift.String?
    /// The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales up your service. Default: 100
    public var maxConcurrency: Swift.Int?
    /// The maximum number of instances that your service scales up to. At most MaxSize instances actively serve traffic for your service. Default: 25
    public var maxSize: Swift.Int?
    /// The minimum number of instances that App Runner provisions for your service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code. Default: 1
    public var minSize: Swift.Int?
    /// A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        autoScalingConfigurationName: Swift.String? = nil,
        maxConcurrency: Swift.Int? = nil,
        maxSize: Swift.Int? = nil,
        minSize: Swift.Int? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.maxConcurrency = maxConcurrency
        self.maxSize = maxSize
        self.minSize = minSize
        self.tags = tags
    }
}

struct CreateAutoScalingConfigurationInputBody: Swift.Equatable {
    public let autoScalingConfigurationName: Swift.String?
    public let maxConcurrency: Swift.Int?
    public let minSize: Swift.Int?
    public let maxSize: Swift.Int?
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAutoScalingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(Swift.String(describing: autoScalingConfiguration)))"}
}

extension CreateAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct CreateAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// A description of the App Runner auto scaling configuration that's created by this request.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct CreateAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension CreateAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct CreateConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInput(connectionName: \(Swift.String(describing: connectionName)), providerType: \(Swift.String(describing: providerType)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Swift.Equatable {
    /// A name for the new connection. It must be unique across all App Runner connections for the AWS account in the AWS Region.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The source repository provider.
    /// This member is required.
    public var providerType: AppRunnerClientTypes.ProviderType?
    /// A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        connectionName: Swift.String? = nil,
        providerType: AppRunnerClientTypes.ProviderType? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.connectionName = connectionName
        self.providerType = providerType
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    public let connectionName: Swift.String?
    public let providerType: AppRunnerClientTypes.ProviderType?
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner connection that's created by this request.
    /// This member is required.
    public var connection: AppRunnerClientTypes.Connection?

    public init (
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    public let connection: AppRunnerClientTypes.Connection?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct CreateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

extension CreateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), healthCheckConfiguration: \(Swift.String(describing: healthCheckConfiguration)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), serviceName: \(Swift.String(describing: serviceName)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceOutputError>
}

public struct CreateServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration.
    public var autoScalingConfigurationArn: Swift.String?
    /// An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an AWS managed CMK.
    public var encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    /// The settings for the health check that AWS App Runner performs to monitor the health of your service.
    public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// The runtime configuration of instances (scaling units) of the App Runner service.
    public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// A name for the new service. It must be unique across all the running App Runner services in your AWS account in the AWS Region.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The source to deploy to the App Runner service. It can be a code or an image repository.
    /// This member is required.
    public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    /// An optional list of metadata items that you can associate with your service resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil,
        encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        serviceName: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.encryptionConfiguration = encryptionConfiguration
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceName = serviceName
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    public let serviceName: Swift.String?
    public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    public let tags: [AppRunnerClientTypes.Tag]?
    public let encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    public let autoScalingConfigurationArn: Swift.String?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations](https://docs.aws.amazon.com/apprunner/latest/api/API_ListOperations.html) call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service that's created by this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes.CustomDomain: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateValidationRecords = "CertificateValidationRecords"
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateValidationRecords = certificateValidationRecords {
            var certificateValidationRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateValidationRecords)
            for certificatevalidationrecordlist0 in certificateValidationRecords {
                try certificateValidationRecordsContainer.encode(certificatevalidationrecordlist0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
        let certificateValidationRecordsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.CertificateValidationRecord?].self, forKey: .certificateValidationRecords)
        var certificateValidationRecordsDecoded0:[AppRunnerClientTypes.CertificateValidationRecord]? = nil
        if let certificateValidationRecordsContainer = certificateValidationRecordsContainer {
            certificateValidationRecordsDecoded0 = [AppRunnerClientTypes.CertificateValidationRecord]()
            for structure0 in certificateValidationRecordsContainer {
                if let structure0 = structure0 {
                    certificateValidationRecordsDecoded0?.append(structure0)
                }
            }
        }
        certificateValidationRecords = certificateValidationRecordsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomainAssociationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes.CustomDomain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomDomain(certificateValidationRecords: \(Swift.String(describing: certificateValidationRecords)), domainName: \(Swift.String(describing: domainName)), enableWWWSubdomain: \(Swift.String(describing: enableWWWSubdomain)), status: \(Swift.String(describing: status)))"}
}

extension AppRunnerClientTypes {
    /// Describes a custom domain that's associated with an AWS App Runner service.
    public struct CustomDomain: Swift.Equatable {
        /// A list of certificate CNAME records that's used for this domain name.
        public var certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]?
        /// An associated custom domain endpoint. It can be a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
        /// This member is required.
        public var domainName: Swift.String?
        /// When true, the subdomain www.DomainName  is associated with the App Runner service in addition to the base domain.
        /// This member is required.
        public var enableWWWSubdomain: Swift.Bool?
        /// The current state of the domain name association.
        /// This member is required.
        public var status: AppRunnerClientTypes.CustomDomainAssociationStatus?

        public init (
            certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]? = nil,
            domainName: Swift.String? = nil,
            enableWWWSubdomain: Swift.Bool? = nil,
            status: AppRunnerClientTypes.CustomDomainAssociationStatus? = nil
        )
        {
            self.certificateValidationRecords = certificateValidationRecords
            self.domainName = domainName
            self.enableWWWSubdomain = enableWWWSubdomain
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum CustomDomainAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case bindingCertificate
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case pendingCertificateDnsValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomDomainAssociationStatus] {
            return [
                .active,
                .bindingCertificate,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .pendingCertificateDnsValidation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .bindingCertificate: return "BINDING_CERTIFICATE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .pendingCertificateDnsValidation: return "PENDING_CERTIFICATE_DNS_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomDomainAssociationStatus(rawValue: rawValue) ?? CustomDomainAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteAutoScalingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

extension DeleteAutoScalingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAutoScalingConfigurationInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)))"}
}

extension DeleteAutoScalingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

public struct DeleteAutoScalingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAutoScalingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAutoScalingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAutoScalingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAutoScalingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAutoScalingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAutoScalingConfigurationOutputError>
}

public struct DeleteAutoScalingConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is deleted.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DeleteAutoScalingConfigurationInputBody: Swift.Equatable {
    public let autoScalingConfigurationArn: Swift.String?
}

extension DeleteAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DeleteAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutoScalingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(Swift.String(describing: autoScalingConfiguration)))"}
}

extension DeleteAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DeleteAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// A description of the App Runner auto scaling configuration that this request just deleted.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DeleteAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension DeleteAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct DeleteConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionInput(connectionArn: \(Swift.String(describing: connectionArn)))"}
}

extension DeleteConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.
    /// This member is required.
    public var connectionArn: Swift.String?

    public init (
        connectionArn: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    public let connectionArn: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConnectionOutputResponse(connection: \(Swift.String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner connection that this request just deleted.
    public var connection: AppRunnerClientTypes.Connection?

    public init (
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    public let connection: AppRunnerClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct DeleteServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

extension DeleteServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DeleteServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DeleteServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceOutputError>
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to delete.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just deleted.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

public struct DescribeAutoScalingConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

extension DescribeAutoScalingConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutoScalingConfigurationInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)))"}
}

extension DescribeAutoScalingConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

public struct DescribeAutoScalingConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAutoScalingConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAutoScalingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAutoScalingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAutoScalingConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAutoScalingConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAutoScalingConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAutoScalingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAutoScalingConfigurationOutputError>
}

public struct DescribeAutoScalingConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is described.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DescribeAutoScalingConfigurationInputBody: Swift.Equatable {
    public let autoScalingConfigurationArn: Swift.String?
}

extension DescribeAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DescribeAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutoScalingConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAutoScalingConfigurationOutputResponse(autoScalingConfiguration: \(Swift.String(describing: autoScalingConfiguration)))"}
}

extension DescribeAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DescribeAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// A full description of the App Runner auto scaling configuration that you specified in this request.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DescribeAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    public let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension DescribeAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

public struct DescribeCustomDomainsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

extension DescribeCustomDomainsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomDomainsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DescribeCustomDomainsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DescribeCustomDomainsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeCustomDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCustomDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomDomainsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeCustomDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCustomDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomDomainsOutputError>
}

public struct DescribeCustomDomainsInput: Swift.Equatable {
    /// The maximum number of results that each response (result page) can include. It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeCustomDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCustomDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomDomainsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomDomainsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomDomainsOutputResponse(customDomains: \(Swift.String(describing: customDomains)), dNSTarget: \(Swift.String(describing: dNSTarget)), nextToken: \(Swift.String(describing: nextToken)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DescribeCustomDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomains = output.customDomains
            self.dNSTarget = output.dNSTarget
            self.nextToken = output.nextToken
            self.serviceArn = output.serviceArn
        } else {
            self.customDomains = nil
            self.dNSTarget = nil
            self.nextToken = nil
            self.serviceArn = nil
        }
    }
}

public struct DescribeCustomDomainsOutputResponse: Swift.Equatable {
    /// A list of descriptions of custom domain names that are associated with the service. In a paginated request, the request returns up to MaxResults records per call.
    /// This member is required.
    public var customDomains: [AppRunnerClientTypes.CustomDomain]?
    /// The App Runner subdomain of the App Runner service. The associated custom domain names are mapped to this target name.
    /// This member is required.
    public var dNSTarget: Swift.String?
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service whose associated custom domain names you want to describe.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        customDomains: [AppRunnerClientTypes.CustomDomain]? = nil,
        dNSTarget: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.customDomains = customDomains
        self.dNSTarget = dNSTarget
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsOutputResponseBody: Swift.Equatable {
    public let dNSTarget: Swift.String?
    public let serviceArn: Swift.String?
    public let customDomains: [AppRunnerClientTypes.CustomDomain]?
    public let nextToken: Swift.String?
}

extension DescribeCustomDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomains = "CustomDomains"
        case dNSTarget = "DNSTarget"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.CustomDomain?].self, forKey: .customDomains)
        var customDomainsDecoded0:[AppRunnerClientTypes.CustomDomain]? = nil
        if let customDomainsContainer = customDomainsContainer {
            customDomainsDecoded0 = [AppRunnerClientTypes.CustomDomain]()
            for structure0 in customDomainsContainer {
                if let structure0 = structure0 {
                    customDomainsDecoded0?.append(structure0)
                }
            }
        }
        customDomains = customDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

extension DescribeServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DescribeServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DescribeServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceOutputError>
}

public struct DescribeServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want a description for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DescribeServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension DescribeServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DescribeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceOutputResponse(service: \(Swift.String(describing: service)))"}
}

extension DescribeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct DescribeServiceOutputResponse: Swift.Equatable {
    /// A full description of the App Runner service that you specified in this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct DescribeServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
}

extension DescribeServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

public struct DisassociateCustomDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

extension DisassociateCustomDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomDomainInput(domainName: \(Swift.String(describing: domainName)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DisassociateCustomDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct DisassociateCustomDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCustomDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateCustomDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCustomDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCustomDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateCustomDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCustomDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCustomDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCustomDomainOutputError>
}

public struct DisassociateCustomDomainInput: Swift.Equatable {
    /// The domain name that you want to disassociate from the App Runner service.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let domainName: Swift.String?
}

extension DisassociateCustomDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateCustomDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCustomDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCustomDomainOutputResponse(customDomain: \(Swift.String(describing: customDomain)), dNSTarget: \(Swift.String(describing: dNSTarget)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension DisassociateCustomDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomain = output.customDomain
            self.dNSTarget = output.dNSTarget
            self.serviceArn = output.serviceArn
        } else {
            self.customDomain = nil
            self.dNSTarget = nil
            self.serviceArn = nil
        }
    }
}

public struct DisassociateCustomDomainOutputResponse: Swift.Equatable {
    /// A description of the domain name that's being disassociated.
    /// This member is required.
    public var customDomain: AppRunnerClientTypes.CustomDomain?
    /// The App Runner subdomain of the App Runner service. The disassociated custom domain name was mapped to this target name.
    /// This member is required.
    public var dNSTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that a custom domain name is disassociated from.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dNSTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.customDomain = customDomain
        self.dNSTarget = dNSTarget
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainOutputResponseBody: Swift.Equatable {
    public let dNSTarget: Swift.String?
    public let serviceArn: Swift.String?
    public let customDomain: AppRunnerClientTypes.CustomDomain?
}

extension DisassociateCustomDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomain = "CustomDomain"
        case dNSTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dNSTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSTarget)
        dNSTarget = dNSTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
    }
}

extension AppRunnerClientTypes.EncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AppRunnerClientTypes.EncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfiguration(kmsKey: \(Swift.String(describing: kmsKey)))"}
}

extension AppRunnerClientTypes {
    /// Describes a custom encryption key that AWS App Runner uses to encrypt copies of the source repository and service logs.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The ARN of the KMS key that's used for encryption.
        /// This member is required.
        public var kmsKey: Swift.String?

        public init (
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }

}

extension AppRunnerClientTypes.HealthCheckConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case path = "Path"
        case `protocol` = "Protocol"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthyThreshold = healthyThreshold {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let unhealthyThreshold = unhealthyThreshold {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension AppRunnerClientTypes.HealthCheckConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HealthCheckConfiguration(healthyThreshold: \(Swift.String(describing: healthyThreshold)), interval: \(Swift.String(describing: interval)), path: \(Swift.String(describing: path)), protocol: \(Swift.String(describing: `protocol`)), timeout: \(Swift.String(describing: timeout)), unhealthyThreshold: \(Swift.String(describing: unhealthyThreshold)))"}
}

extension AppRunnerClientTypes {
    /// Describes the settings for the health check that AWS App Runner performs to monitor the health of a service.
    public struct HealthCheckConfiguration: Swift.Equatable {
        /// The IP protocol that App Runner uses to perform health checks for your service. If you set Protocol to HTTP, App Runner sends health check requests to the HTTP path specified by Path. Default: TCP
        public var `protocol`: AppRunnerClientTypes.HealthCheckProtocol?
        /// The number of consecutive checks that must succeed before App Runner decides that the service is healthy. Default: 3
        public var healthyThreshold: Swift.Int?
        /// The time interval, in seconds, between health checks. Default: 5
        public var interval: Swift.Int?
        /// The URL that health check requests are sent to. Path is only applicable when you set Protocol to HTTP. Default: "/"
        public var path: Swift.String?
        /// The time, in seconds, to wait for a health check response before deciding it failed. Default: 2
        public var timeout: Swift.Int?
        /// The number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Default: 3
        public var unhealthyThreshold: Swift.Int?

        public init (
            `protocol`: AppRunnerClientTypes.HealthCheckProtocol? = nil,
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            path: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.`protocol` = `protocol`
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.path = path
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppRunnerClientTypes {
    public enum HealthCheckProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "Port"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeenvironmentvariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeenvironmentvariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startCommand = startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
        let startCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfiguration(port: \(Swift.String(describing: port)), runtimeEnvironmentVariables: \(Swift.String(describing: runtimeEnvironmentVariables)), startCommand: \(Swift.String(describing: startCommand)))"}
}

extension AppRunnerClientTypes {
    /// Describes the configuration that AWS App Runner uses to run an App Runner service using an image pulled from a source image repository.
    public struct ImageConfiguration: Swift.Equatable {
        /// The port that your application listens to in the container. Default: 8080
        public var port: Swift.String?
        /// Environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
        public var runtimeEnvironmentVariables: [Swift.String:Swift.String]?
        /// An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
        public var startCommand: Swift.String?

        public init (
            port: Swift.String? = nil,
            runtimeEnvironmentVariables: [Swift.String:Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.port = port
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }

}

extension AppRunnerClientTypes.ImageRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageConfiguration = "ImageConfiguration"
        case imageIdentifier = "ImageIdentifier"
        case imageRepositoryType = "ImageRepositoryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let imageIdentifier = imageIdentifier {
            try encodeContainer.encode(imageIdentifier, forKey: .imageIdentifier)
        }
        if let imageRepositoryType = imageRepositoryType {
            try encodeContainer.encode(imageRepositoryType.rawValue, forKey: .imageRepositoryType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageIdentifier)
        imageIdentifier = imageIdentifierDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let imageRepositoryTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageRepositoryType.self, forKey: .imageRepositoryType)
        imageRepositoryType = imageRepositoryTypeDecoded
    }
}

extension AppRunnerClientTypes.ImageRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageRepository(imageConfiguration: \(Swift.String(describing: imageConfiguration)), imageIdentifier: \(Swift.String(describing: imageIdentifier)), imageRepositoryType: \(Swift.String(describing: imageRepositoryType)))"}
}

extension AppRunnerClientTypes {
    /// Describes a source image repository.
    public struct ImageRepository: Swift.Equatable {
        /// Configuration for running the identified image.
        public var imageConfiguration: AppRunnerClientTypes.ImageConfiguration?
        /// The identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see [Pulling an image](https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html) in the Amazon ECR User Guide.
        /// This member is required.
        public var imageIdentifier: Swift.String?
        /// The type of the image repository. This reflects the repository provider and whether the repository is private or public.
        /// This member is required.
        public var imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType?

        public init (
            imageConfiguration: AppRunnerClientTypes.ImageConfiguration? = nil,
            imageIdentifier: Swift.String? = nil,
            imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
            self.imageIdentifier = imageIdentifier
            self.imageRepositoryType = imageRepositoryType
        }
    }

}

extension AppRunnerClientTypes {
    public enum ImageRepositoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecr
        case ecrPublic
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageRepositoryType] {
            return [
                .ecr,
                .ecrPublic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case .ecrPublic: return "ECR_PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageRepositoryType(rawValue: rawValue) ?? ImageRepositoryType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.InstanceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu = "Cpu"
        case instanceRoleArn = "InstanceRoleArn"
        case memory = "Memory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let instanceRoleArn = instanceRoleArn {
            try encodeContainer.encode(instanceRoleArn, forKey: .instanceRoleArn)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let instanceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceRoleArn)
        instanceRoleArn = instanceRoleArnDecoded
    }
}

extension AppRunnerClientTypes.InstanceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceConfiguration(cpu: \(Swift.String(describing: cpu)), instanceRoleArn: \(Swift.String(describing: instanceRoleArn)), memory: \(Swift.String(describing: memory)))"}
}

extension AppRunnerClientTypes {
    /// Describes the runtime configuration of an AWS App Runner service instance (scaling unit).
    public struct InstanceConfiguration: Swift.Equatable {
        /// The number of CPU units reserved for each instance of your App Runner service. Default: 1 vCPU
        public var cpu: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any AWS APIs.
        public var instanceRoleArn: Swift.String?
        /// The amount of memory, in MB or GB, reserved for each instance of your App Runner service. Default: 2 GB
        public var memory: Swift.String?

        public init (
            cpu: Swift.String? = nil,
            instanceRoleArn: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.instanceRoleArn = instanceRoleArn
            self.memory = memory
        }
    }

}

extension InternalServiceErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceErrorException(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected service exception occurred.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more input parameters aren't valid. Refer to the API action's document page, correct the input parameters, and try the action again.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform this action when the resource is in its current state.
public struct InvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAutoScalingConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

extension ListAutoScalingConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAutoScalingConfigurationsInput(autoScalingConfigurationName: \(Swift.String(describing: autoScalingConfigurationName)), latestOnly: \(Swift.String(describing: latestOnly)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAutoScalingConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if latestOnly != false {
            try encodeContainer.encode(latestOnly, forKey: .latestOnly)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAutoScalingConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAutoScalingConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAutoScalingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAutoScalingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAutoScalingConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAutoScalingConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAutoScalingConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAutoScalingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAutoScalingConfigurationsOutputError>
}

public struct ListAutoScalingConfigurationsInput: Swift.Equatable {
    /// The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner returns revisions of all configurations.
    public var autoScalingConfigurationName: Swift.String?
    /// Set to true to list only the latest revision for each requested configuration name. Keep as false to list all revisions for each requested configuration name. Default: false
    public var latestOnly: Swift.Bool
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        autoScalingConfigurationName: Swift.String? = nil,
        latestOnly: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsInputBody: Swift.Equatable {
    public let autoScalingConfigurationName: Swift.String?
    public let latestOnly: Swift.Bool
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListAutoScalingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let latestOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .latestOnly)
        latestOnly = latestOnlyDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAutoScalingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutoScalingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAutoScalingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutoScalingConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAutoScalingConfigurationsOutputResponse(autoScalingConfigurationSummaryList: \(Swift.String(describing: autoScalingConfigurationSummaryList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAutoScalingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAutoScalingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfigurationSummaryList = output.autoScalingConfigurationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.autoScalingConfigurationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAutoScalingConfigurationsOutputResponse: Swift.Equatable {
    /// A list of summary information records for auto scaling configurations. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?

    public init (
        autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryList
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsOutputResponseBody: Swift.Equatable {
    public let autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    public let nextToken: Swift.String?
}

extension ListAutoScalingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationSummaryList = "AutoScalingConfigurationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.AutoScalingConfigurationSummary?].self, forKey: .autoScalingConfigurationSummaryList)
        var autoScalingConfigurationSummaryListDecoded0:[AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil
        if let autoScalingConfigurationSummaryListContainer = autoScalingConfigurationSummaryListContainer {
            autoScalingConfigurationSummaryListDecoded0 = [AppRunnerClientTypes.AutoScalingConfigurationSummary]()
            for structure0 in autoScalingConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    autoScalingConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConnectionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

extension ListConnectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectionsInput(connectionName: \(Swift.String(describing: connectionName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListConnectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConnectionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConnectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConnectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInput: Swift.Equatable {
    /// If specified, only this connection is returned. If not specified, the result isn't filtered by name.
    public var connectionName: Swift.String?
    /// The maximum number of results to include in each response (result page). Used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        connectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionName = connectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Swift.Equatable {
    public let connectionName: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConnectionsOutputResponse(connectionSummaryList: \(Swift.String(describing: connectionSummaryList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionSummaryList = output.connectionSummaryList
            self.nextToken = output.nextToken
        } else {
            self.connectionSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Swift.Equatable {
    /// A list of summary information records for connections. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    /// The token that you can pass in a subsequent request to get the next result page. Returned in a paginated request.
    public var nextToken: Swift.String?

    public init (
        connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionSummaryList = connectionSummaryList
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Swift.Equatable {
    public let connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    public let nextToken: Swift.String?
}

extension ListConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionSummaryList = "ConnectionSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ConnectionSummary?].self, forKey: .connectionSummaryList)
        var connectionSummaryListDecoded0:[AppRunnerClientTypes.ConnectionSummary]? = nil
        if let connectionSummaryListContainer = connectionSummaryListContainer {
            connectionSummaryListDecoded0 = [AppRunnerClientTypes.ConnectionSummary]()
            for structure0 in connectionSummaryListContainer {
                if let structure0 = structure0 {
                    connectionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        connectionSummaryList = connectionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListOperationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

extension ListOperationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension ListOperationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct ListOperationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOperationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOperationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOperationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOperationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOperationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOperationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOperationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOperationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOperationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOperationsOutputError>
}

public struct ListOperationsInput: Swift.Equatable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOperationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), operationSummaryList: \(Swift.String(describing: operationSummaryList)))"}
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operationSummaryList = output.operationSummaryList
        } else {
            self.nextToken = nil
            self.operationSummaryList = nil
        }
    }
}

public struct ListOperationsOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of operation summary information records. In a paginated request, the request returns up to MaxResults records for each call.
    public var operationSummaryList: [AppRunnerClientTypes.OperationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        operationSummaryList: [AppRunnerClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operationSummaryList = operationSummaryList
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    public let operationSummaryList: [AppRunnerClientTypes.OperationSummary]?
    public let nextToken: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operationSummaryList = "OperationSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.OperationSummary?].self, forKey: .operationSummaryList)
        var operationSummaryListDecoded0:[AppRunnerClientTypes.OperationSummary]? = nil
        if let operationSummaryListContainer = operationSummaryListContainer {
            operationSummaryListDecoded0 = [AppRunnerClientTypes.OperationSummary]()
            for structure0 in operationSummaryListContainer {
                if let structure0 = structure0 {
                    operationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        operationSummaryList = operationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

extension ListServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServicesOutputError>
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServicesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serviceSummaryList: \(Swift.String(describing: serviceSummaryList)))"}
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceSummaryList = output.serviceSummaryList
        } else {
            self.nextToken = nil
            self.serviceSummaryList = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of service summary information records. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    public let serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?
    public let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceSummaryList = "ServiceSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ServiceSummary?].self, forKey: .serviceSummaryList)
        var serviceSummaryListDecoded0:[AppRunnerClientTypes.ServiceSummary]? = nil
        if let serviceSummaryListContainer = serviceSummaryListContainer {
            serviceSummaryListDecoded0 = [AppRunnerClientTypes.ServiceSummary]()
            for structure0 in serviceSummaryListContainer {
                if let structure0 = structure0 {
                    serviceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        serviceSummaryList = serviceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that a tag list is requested for. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of the tag key-value pairs that are associated with the resource.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppRunnerClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case rollbackFailed
        case rollbackInProgress
        case rollbackSucceeded
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .rollbackFailed,
                .rollbackInProgress,
                .rollbackSucceeded,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rollbackFailed: return "ROLLBACK_FAILED"
            case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
            case .rollbackSucceeded: return "ROLLBACK_SUCCEEDED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.OperationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt = "EndedAt"
        case id = "Id"
        case startedAt = "StartedAt"
        case status = "Status"
        case targetArn = "TargetArn"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AppRunnerClientTypes.OperationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationSummary(endedAt: \(Swift.String(describing: endedAt)), id: \(Swift.String(describing: id)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), targetArn: \(Swift.String(describing: targetArn)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AppRunnerClientTypes {
    /// Provides summary information for an operation that occurred on an AWS App Runner service.
    public struct OperationSummary: Swift.Equatable {
        /// The time when the operation ended. It's in the Unix time stamp format.
        public var endedAt: ClientRuntime.Date?
        /// A unique ID of this operation. It's unique in the scope of the App Runner service.
        public var id: Swift.String?
        /// The time when the operation started. It's in the Unix time stamp format.
        public var startedAt: ClientRuntime.Date?
        /// The current state of the operation.
        public var status: AppRunnerClientTypes.OperationStatus?
        /// The Amazon Resource Name (ARN) of the resource that the operation acted on (for example, an App Runner service).
        public var targetArn: Swift.String?
        /// The type of operation. It indicates a specific action that occured.
        public var type: AppRunnerClientTypes.OperationType?
        /// The time when the operation was last updated. It's in the Unix time stamp format.
        public var updatedAt: ClientRuntime.Date?

        public init (
            endedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: AppRunnerClientTypes.OperationStatus? = nil,
            targetArn: Swift.String? = nil,
            type: AppRunnerClientTypes.OperationType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.endedAt = endedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.targetArn = targetArn
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createService
        case deleteService
        case pauseService
        case resumeService
        case startDeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createService,
                .deleteService,
                .pauseService,
                .resumeService,
                .startDeployment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createService: return "CREATE_SERVICE"
            case .deleteService: return "DELETE_SERVICE"
            case .pauseService: return "PAUSE_SERVICE"
            case .resumeService: return "RESUME_SERVICE"
            case .startDeployment: return "START_DEPLOYMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

public struct PauseServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

extension PauseServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension PauseServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct PauseServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

public struct PauseServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PauseServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PauseServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

public struct PauseServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PauseServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PauseServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

public struct PauseServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PauseServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PauseServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PauseServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PauseServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<PauseServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PauseServiceOutputError>
}

public struct PauseServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to pause.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct PauseServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension PauseServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension PauseServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PauseServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PauseServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PauseServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PauseServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension PauseServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PauseServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct PauseServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just paused.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct PauseServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension PauseServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes {
    public enum ProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case github
        case sdkUnknown(Swift.String)

        public static var allCases: [ProviderType] {
            return [
                .github,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .github: return "GITHUB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource doesn't exist for the specified Amazon Resource Name (ARN) in your AWS account.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResumeServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

extension ResumeServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeServiceInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension ResumeServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct ResumeServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResumeServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResumeServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResumeServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResumeServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResumeServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResumeServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResumeServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResumeServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResumeServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResumeServiceOutputError>
}

public struct ResumeServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to resume.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct ResumeServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension ResumeServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension ResumeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResumeServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResumeServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension ResumeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResumeServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct ResumeServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just resumed.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct ResumeServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension ResumeServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nodejs12
        case python3
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .nodejs12,
                .python3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nodejs12: return "NODEJS_12"
            case .python3: return "PYTHON_3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationSummary = "AutoScalingConfigurationSummary"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case sourceConfiguration = "SourceConfiguration"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationSummary = autoScalingConfigurationSummary {
            try encodeContainer.encode(autoScalingConfigurationSummary, forKey: .autoScalingConfigurationSummary)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let deletedAt = deletedAt {
            try encodeContainer.encode(deletedAt.timeIntervalSince1970, forKey: .deletedAt)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let deletedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationSummaryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfigurationSummary.self, forKey: .autoScalingConfigurationSummary)
        autoScalingConfigurationSummary = autoScalingConfigurationSummaryDecoded
    }
}

extension AppRunnerClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(autoScalingConfigurationSummary: \(Swift.String(describing: autoScalingConfigurationSummary)), createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), healthCheckConfiguration: \(Swift.String(describing: healthCheckConfiguration)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), serviceArn: \(Swift.String(describing: serviceArn)), serviceId: \(Swift.String(describing: serviceId)), serviceName: \(Swift.String(describing: serviceName)), serviceUrl: \(Swift.String(describing: serviceUrl)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AppRunnerClientTypes {
    /// Describes an AWS App Runner service. It can describe a service in any state, including deleted services. This type contains the full information about a service, including configuration details. It's returned by the [CreateService](https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html), [DescribeService](https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html), and [DeleteService](https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html) actions. A subset of this information is returned by the [ListServices](https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html) action using the [ServiceSummary](https://docs.aws.amazon.com/apprunner/latest/api/API_ServiceSummary.html) type.
    public struct Service: Swift.Equatable {
        /// Summary information for the App Runner automatic scaling configuration resource that's associated with this service.
        /// This member is required.
        public var autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary?
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The time when the App Runner service was deleted. It's in the Unix time stamp format.
        public var deletedAt: ClientRuntime.Date?
        /// The encryption key that App Runner uses to encrypt the service logs and the copy of the source repository that App Runner maintains for the service. It can be either a customer-provided encryption key or an AWS managed CMK.
        public var encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
        /// The settings for the health check that App Runner performs to monitor the health of this service.
        public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
        /// The runtime configuration of instances (scaling units) of this service.
        /// This member is required.
        public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
        /// The Amazon Resource Name (ARN) of this service.
        /// This member is required.
        public var serviceArn: Swift.String?
        /// An ID that App Runner generated for this service. It's unique within the AWS Region.
        /// This member is required.
        public var serviceId: Swift.String?
        /// The customer-provided service name.
        /// This member is required.
        public var serviceName: Swift.String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        /// This member is required.
        public var serviceUrl: Swift.String?
        /// The source deployed to the App Runner service. It can be a code or an image repository.
        /// This member is required.
        public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
        /// The current state of the App Runner service. These particular values mean the following.
        ///
        /// * CREATE_FAILED – The service failed to create. To troubleshoot this failure, read the failure events and logs, change any parameters that need to be fixed, and retry the call to create the service. The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.
        ///
        /// * DELETE_FAILED – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        /// This member is required.
        public var status: AppRunnerClientTypes.ServiceStatus?
        /// The time when the App Runner service was last updated at. It's in the Unix time stamp format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
            healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
            instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.autoScalingConfigurationSummary = autoScalingConfigurationSummary
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.encryptionConfiguration = encryptionConfiguration
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// App Runner can't create this resource. You've reached your account quota for this resource type. For App Runner per-resource quotas, see [AWS App Runner endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/apprunner.html) in the AWS General Reference.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppRunnerClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case deleted
        case deleteFailed
        case operationInProgress
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .createFailed,
                .deleted,
                .deleteFailed,
                .operationInProgress,
                .paused,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .operationInProgress: return "OPERATION_IN_PROGRESS"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ServiceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes.ServiceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceSummary(createdAt: \(Swift.String(describing: createdAt)), serviceArn: \(Swift.String(describing: serviceArn)), serviceId: \(Swift.String(describing: serviceId)), serviceName: \(Swift.String(describing: serviceName)), serviceUrl: \(Swift.String(describing: serviceUrl)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension AppRunnerClientTypes {
    /// Provides summary information for an AWS App Runner service. This type contains limited information about a service. It doesn't include configuration details. It's returned by the [ListServices](https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html) action. Complete service information is returned by the [CreateService](https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html), [DescribeService](https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html), and [DeleteService](https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html) actions using the [Service](https://docs.aws.amazon.com/apprunner/latest/api/API_Service.html) type.
    public struct ServiceSummary: Swift.Equatable {
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of this service.
        public var serviceArn: Swift.String?
        /// An ID that App Runner generated for this service. It's unique within the AWS Region.
        public var serviceId: Swift.String?
        /// The customer-provided service name.
        public var serviceName: Swift.String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public var serviceUrl: Swift.String?
        /// The current state of the App Runner service. These particular values mean the following.
        ///
        /// * CREATE_FAILED – The service failed to create. Read the failure events and logs, change any parameters that need to be fixed, and retry the call to create the service. The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.
        ///
        /// * DELETE_FAILED – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        public var status: AppRunnerClientTypes.ServiceStatus?
        /// The time when the App Runner service was last updated. It's in theUnix time stamp format.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes.SourceCodeVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceCodeVersionType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppRunnerClientTypes.SourceCodeVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceCodeVersion(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension AppRunnerClientTypes {
    /// Identifies a version of code that AWS App Runner refers to within a source code repository.
    public struct SourceCodeVersion: Swift.Equatable {
        /// The type of version identifier. For a git-based repository, branches represent versions.
        /// This member is required.
        public var type: AppRunnerClientTypes.SourceCodeVersionType?
        /// A source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
        /// This member is required.
        public var value: Swift.String?

        public init (
            type: AppRunnerClientTypes.SourceCodeVersionType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension AppRunnerClientTypes {
    public enum SourceCodeVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case branch
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCodeVersionType] {
            return [
                .branch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .branch: return "BRANCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceCodeVersionType(rawValue: rawValue) ?? SourceCodeVersionType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.SourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfiguration = "AuthenticationConfiguration"
        case autoDeploymentsEnabled = "AutoDeploymentsEnabled"
        case codeRepository = "CodeRepository"
        case imageRepository = "ImageRepository"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfiguration = authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let autoDeploymentsEnabled = autoDeploymentsEnabled {
            try encodeContainer.encode(autoDeploymentsEnabled, forKey: .autoDeploymentsEnabled)
        }
        if let codeRepository = codeRepository {
            try encodeContainer.encode(codeRepository, forKey: .codeRepository)
        }
        if let imageRepository = imageRepository {
            try encodeContainer.encode(imageRepository, forKey: .imageRepository)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeRepositoryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeRepository.self, forKey: .codeRepository)
        codeRepository = codeRepositoryDecoded
        let imageRepositoryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageRepository.self, forKey: .imageRepository)
        imageRepository = imageRepositoryDecoded
        let autoDeploymentsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploymentsEnabled)
        autoDeploymentsEnabled = autoDeploymentsEnabledDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AuthenticationConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
    }
}

extension AppRunnerClientTypes.SourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceConfiguration(authenticationConfiguration: \(Swift.String(describing: authenticationConfiguration)), autoDeploymentsEnabled: \(Swift.String(describing: autoDeploymentsEnabled)), codeRepository: \(Swift.String(describing: codeRepository)), imageRepository: \(Swift.String(describing: imageRepository)))"}
}

extension AppRunnerClientTypes {
    /// Describes the source deployed to an AWS App Runner service. It can be a code or an image repository.
    public struct SourceConfiguration: Swift.Equatable {
        /// Describes the resources that are needed to authenticate access to some source repositories.
        public var authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration?
        /// If true, continuous integration from the source repository is enabled for the App Runner service. Each repository change (source code commit or new image version) starts a deployment. Default: true
        public var autoDeploymentsEnabled: Swift.Bool?
        /// The description of a source code repository. You must provide either this member or ImageRepository (but not both).
        public var codeRepository: AppRunnerClientTypes.CodeRepository?
        /// The description of a source image repository. You must provide either this member or CodeRepository (but not both).
        public var imageRepository: AppRunnerClientTypes.ImageRepository?

        public init (
            authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration? = nil,
            autoDeploymentsEnabled: Swift.Bool? = nil,
            codeRepository: AppRunnerClientTypes.CodeRepository? = nil,
            imageRepository: AppRunnerClientTypes.ImageRepository? = nil
        )
        {
            self.authenticationConfiguration = authenticationConfiguration
            self.autoDeploymentsEnabled = autoDeploymentsEnabled
            self.codeRepository = codeRepository
            self.imageRepository = imageRepository
        }
    }

}

public struct StartDeploymentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

extension StartDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeploymentInput(serviceArn: \(Swift.String(describing: serviceArn)))"}
}

extension StartDeploymentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

public struct StartDeploymentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDeploymentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartDeploymentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDeploymentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension StartDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDeploymentOutputResponse(operationId: \(Swift.String(describing: operationId)))"}
}

extension StartDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct StartDeploymentOutputResponseBody: Swift.Equatable {
    public let operationId: Swift.String?
}

extension StartDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppRunnerClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension AppRunnerClientTypes {
    /// Describes a tag that is applied to an AWS App Runner resource. A tag is a metadata item consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to update tags for. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already associated with the resource, the value of the tag is updated.
    /// This member is required.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [AppRunnerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateServiceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

extension UpdateServiceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceInput(autoScalingConfigurationArn: \(Swift.String(describing: autoScalingConfigurationArn)), healthCheckConfiguration: \(Swift.String(describing: healthCheckConfiguration)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), serviceArn: \(Swift.String(describing: serviceArn)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)))"}
}

extension UpdateServiceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let healthCheckConfiguration = healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let serviceArn = serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }
}

public struct UpdateServiceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateServiceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceOutputError>
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service.
    public var autoScalingConfigurationArn: Swift.String?
    /// The settings for the health check that AWS App Runner performs to monitor the health of your service.
    public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// The runtime configuration to apply to instances (scaling units) of the App Runner service.
    public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to update.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// The source configuration to apply to the App Runner service. You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way around. This means that you must provide the same structure member of SourceConfiguration that you originally included when you created the service. Specifically, you can include either CodeRepository or ImageRepository. To update the source configuration, set the values to members of the structure that you include.
    public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        serviceArn: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.serviceArn = serviceArn
        self.sourceConfiguration = sourceConfiguration
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    public let serviceArn: Swift.String?
    public let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    public let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    public let autoScalingConfigurationArn: Swift.String?
    public let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceOutputResponse(operationId: \(Swift.String(describing: operationId)), service: \(Swift.String(describing: service)))"}
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service updated by this request. All configuration values in the returned Service structure reflect configuration changes that are being applied by this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    public let service: AppRunnerClientTypes.Service?
    public let operationId: Swift.String?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}
