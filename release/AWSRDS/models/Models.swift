// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RdsClientTypes.AccountQuota: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotaName = "AccountQuotaName"
        case max = "Max"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountQuotaName = accountQuotaName {
            try container.encode(accountQuotaName, forKey: ClientRuntime.Key("AccountQuotaName"))
        }
        if max != 0 {
            try container.encode(max, forKey: ClientRuntime.Key("Max"))
        }
        if used != 0 {
            try container.encode(used, forKey: ClientRuntime.Key("Used"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountQuotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountQuotaName)
        accountQuotaName = accountQuotaNameDecoded
        let usedDecoded = try containerValues.decode(Swift.Int.self, forKey: .used)
        used = usedDecoded
        let maxDecoded = try containerValues.decode(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension RdsClientTypes.AccountQuota: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountQuota(accountQuotaName: \(Swift.String(describing: accountQuotaName)), max: \(Swift.String(describing: max)), used: \(Swift.String(describing: used)))"}
}

extension RdsClientTypes {
    /// Describes a quota for an Amazon Web Services account.
    ///          The following are account quotas:
    ///
    ///
    ///
    ///                   AllocatedStorage - The total allocated storage per account, in GiB.
    ///                     The used value is the total allocated storage in the account, in GiB.
    ///
    ///
    ///
    ///                   AuthorizationsPerDBSecurityGroup - The number of ingress rules per DB security group.
    ///                   The used value is the highest number of ingress rules in a DB security group in the account. Other
    ///                   DB security groups in the account might have a lower number of ingress rules.
    ///
    ///
    ///
    ///                   CustomEndpointsPerDBCluster - The number of custom endpoints per DB cluster.
    ///                   The used value is the highest number of custom endpoints in a DB clusters in the account. Other
    ///                   DB clusters in the account might have a lower number of custom endpoints.
    ///
    ///
    ///
    ///                   DBClusterParameterGroups - The number of DB cluster parameter groups
    ///                     per account, excluding default parameter groups. The used value is the count of
    ///                     nondefault DB cluster parameter groups in the account.
    ///
    ///
    ///
    ///                   DBClusterRoles - The number of associated Amazon Web Services Identity and Access Management (IAM) roles per DB cluster.
    ///                   The used value is the highest number of associated IAM roles for a DB cluster in the account. Other
    ///                   DB clusters in the account might have a lower number of associated IAM roles.
    ///
    ///
    ///
    ///                   DBClusters - The number of DB clusters per account.
    ///                   The used value is the count of DB clusters in the account.
    ///
    ///
    ///
    ///                   DBInstanceRoles - The number of associated IAM roles per DB instance.
    ///                   The used value is the highest number of associated IAM roles for a DB instance in the account. Other
    ///                   DB instances in the account might have a lower number of associated IAM roles.
    ///
    ///
    ///
    ///                   DBInstances - The number of DB instances per account.
    ///                   The used value is the count of the DB instances in the account.
    ///                   Amazon RDS DB instances, Amazon Aurora DB instances, Amazon Neptune instances, and Amazon DocumentDB
    ///                       instances apply to this quota.
    ///
    ///
    ///
    ///                   DBParameterGroups - The number of DB parameter groups per account,
    ///                     excluding default parameter groups. The used value is the count of nondefault DB
    ///                     parameter groups in the account.
    ///
    ///
    ///
    ///                   DBSecurityGroups - The number of DB security groups (not VPC
    ///                     security groups) per account, excluding the default security group. The used
    ///                     value is the count of nondefault DB security groups in the account.
    ///
    ///
    ///
    ///                   DBSubnetGroups - The number of DB subnet groups per account.
    ///                   The used value is the count of the DB subnet groups in the account.
    ///
    ///
    ///
    ///                   EventSubscriptions - The number of event subscriptions per account.
    ///                   The used value is the count of the event subscriptions in the account.
    ///
    ///
    ///
    ///                   ManualClusterSnapshots - The number of manual DB cluster snapshots per account.
    ///                   The used value is the count of the manual DB cluster snapshots in the account.
    ///
    ///
    ///
    ///                   ManualSnapshots - The number of manual DB instance snapshots per account.
    ///                   The used value is the count of the manual DB instance snapshots in the account.
    ///
    ///
    ///
    ///                   OptionGroups - The number of DB option groups per account, excluding
    ///                     default option groups. The used value is the count of nondefault DB option
    ///                     groups in the account.
    ///
    ///
    ///
    ///                   ReadReplicasPerMaster - The number of read replicas per DB
    ///                     instance. The used value is the highest number of read replicas for a DB
    ///                     instance in the account. Other DB instances in the account might have a lower
    ///                     number of read replicas.
    ///
    ///
    ///
    ///                   ReservedDBInstances - The number of reserved DB instances per account.
    ///                   The used value is the count of the active reserved DB instances in the account.
    ///
    ///
    ///
    ///                   SubnetsPerDBSubnetGroup - The number of subnets per DB subnet group.
    ///                   The used value is highest number of subnets for a DB subnet group in the account. Other
    ///                   DB subnet groups in the account might have a lower number of subnets.
    ///
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Limits.html">Quotas for Amazon RDS in the
    ///                 Amazon RDS User Guide and <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/CHAP_Limits.html">Quotas for Amazon Aurora in the
    ///                 Amazon Aurora User Guide.
    public struct AccountQuota: Swift.Equatable {
        /// The name of the Amazon RDS quota for this Amazon Web Services account.
        public var accountQuotaName: Swift.String?
        /// The maximum allowed value for the quota.
        public var max: Swift.Int
        /// The amount currently used toward the quota maximum.
        public var used: Swift.Int

        public init (
            accountQuotaName: Swift.String? = nil,
            max: Swift.Int = 0,
            used: Swift.Int = 0
        )
        {
            self.accountQuotaName = accountQuotaName
            self.max = max
            self.used = used
        }
    }

}

extension RdsClientTypes {
    public enum ActivityStreamMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case async
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityStreamMode] {
            return [
                .async,
                .sync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .async: return "async"
            case .sync: return "sync"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivityStreamMode(rawValue: rawValue) ?? ActivityStreamMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum ActivityStreamStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityStreamStatus] {
            return [
                .started,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "started"
            case .starting: return "starting"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivityStreamStatus(rawValue: rawValue) ?? ActivityStreamStatus.sdkUnknown(rawValue)
        }
    }
}

public struct AddRoleToDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

extension AddRoleToDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddRoleToDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension AddRoleToDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("AddRoleToDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddRoleToDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddRoleToDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddRoleToDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBClusterOutputError>
}

public struct AddRoleToDBClusterInput: Swift.Equatable {
    /// The name of the DB cluster to associate the IAM role with.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the feature for the DB cluster that the IAM role is to be associated with.
    ///             For the list of supported feature names, see DBEngineVersion.
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to associate with the Aurora DB
    ///             cluster, for example, arn:aws:iam::123456789012:role/AuroraAccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension AddRoleToDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleAlreadyExists" : self = .dBClusterRoleAlreadyExistsFault(try DBClusterRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleQuotaExceeded" : self = .dBClusterRoleQuotaExceededFault(try DBClusterRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleAlreadyExistsFault(DBClusterRoleAlreadyExistsFault)
    case dBClusterRoleQuotaExceededFault(DBClusterRoleQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddRoleToDBClusterOutputResponse()"}
}

extension AddRoleToDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddRoleToDBClusterOutputResponseBody: Swift.Equatable {
}

extension AddRoleToDBClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AddRoleToDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBInstanceOutputError>
}

extension AddRoleToDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddRoleToDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension AddRoleToDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("AddRoleToDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddRoleToDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBInstanceOutputError>
}

public struct AddRoleToDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddRoleToDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddRoleToDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBInstanceOutputError>
}

public struct AddRoleToDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddRoleToDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddRoleToDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddRoleToDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddRoleToDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddRoleToDBInstanceOutputError>
}

public struct AddRoleToDBInstanceInput: Swift.Equatable {
    /// The name of the DB instance to associate the IAM role with.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the feature for the DB instance that the IAM role is to be associated with.
    ///             For the list of supported feature names, see DBEngineVersion.
    ///
    /// This member is required.
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to associate with the DB instance, for
    ///             example arn:aws:iam::123456789012:role/AccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension AddRoleToDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddRoleToDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleAlreadyExists" : self = .dBInstanceRoleAlreadyExistsFault(try DBInstanceRoleAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleQuotaExceeded" : self = .dBInstanceRoleQuotaExceededFault(try DBInstanceRoleQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddRoleToDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBInstanceRoleAlreadyExistsFault(DBInstanceRoleAlreadyExistsFault)
    case dBInstanceRoleQuotaExceededFault(DBInstanceRoleQuotaExceededFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddRoleToDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddRoleToDBInstanceOutputResponse()"}
}

extension AddRoleToDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddRoleToDBInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddRoleToDBInstanceOutputResponseBody: Swift.Equatable {
}

extension AddRoleToDBInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AddSourceIdentifierToSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

extension AddSourceIdentifierToSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddSourceIdentifierToSubscriptionInput(sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension AddSourceIdentifierToSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("AddSourceIdentifierToSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddSourceIdentifierToSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddSourceIdentifierToSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

public struct AddSourceIdentifierToSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddSourceIdentifierToSubscriptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddSourceIdentifierToSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddSourceIdentifierToSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddSourceIdentifierToSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddSourceIdentifierToSubscriptionOutputError>
}

///
public struct AddSourceIdentifierToSubscriptionInput: Swift.Equatable {
    /// The identifier of the event source to be added.
    ///          Constraints:
    ///
    ///
    ///                If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.
    ///
    ///
    ///                If the source type is a DB security group, a DBSecurityGroupName value must be supplied.
    ///
    ///
    ///                If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.
    ///
    ///
    /// This member is required.
    public var sourceIdentifier: Swift.String?
    /// The name of the RDS event notification subscription you want to add a source identifier to.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        sourceIdentifier: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension AddSourceIdentifierToSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddSourceIdentifierToSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SourceNotFound" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddSourceIdentifierToSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddSourceIdentifierToSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddSourceIdentifierToSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension AddSourceIdentifierToSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddSourceIdentifierToSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct AddSourceIdentifierToSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct AddSourceIdentifierToSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RdsClientTypes.EventSubscription?
}

extension AddSourceIdentifierToSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AddSourceIdentifierToSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct AddTagsToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceInput(resourceName: \(Swift.String(describing: resourceName)), tags: \(Swift.String(describing: tags)))"}
}

extension AddTagsToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTagsToResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AddTagsToResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddTagsToResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

///
public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon RDS resource that the tags are added to. This value is an Amazon Resource Name (ARN). For information about
    ///             creating an ARN,
    ///         see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///             Constructing an RDS Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceName: Swift.String?
    /// The tags to be assigned to the Amazon RDS resource.
    /// This member is required.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        resourceName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceOutputResponse()"}
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RdsClientTypes {
    public enum ApplyMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immediate
        case pendingReboot
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplyMethod] {
            return [
                .immediate,
                .pendingReboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immediate: return "immediate"
            case .pendingReboot: return "pending-reboot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplyMethod(rawValue: rawValue) ?? ApplyMethod.sdkUnknown(rawValue)
        }
    }
}

public struct ApplyPendingMaintenanceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

extension ApplyPendingMaintenanceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyPendingMaintenanceActionInput(applyAction: \(Swift.String(describing: applyAction)), optInType: \(Swift.String(describing: optInType)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension ApplyPendingMaintenanceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyAction = applyAction {
            try container.encode(applyAction, forKey: ClientRuntime.Key("ApplyAction"))
        }
        if let optInType = optInType {
            try container.encode(optInType, forKey: ClientRuntime.Key("OptInType"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
        try container.encode("ApplyPendingMaintenanceAction", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ApplyPendingMaintenanceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ApplyPendingMaintenanceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

public struct ApplyPendingMaintenanceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ApplyPendingMaintenanceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ApplyPendingMaintenanceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ApplyPendingMaintenanceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ApplyPendingMaintenanceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ApplyPendingMaintenanceActionOutputError>
}

///
public struct ApplyPendingMaintenanceActionInput: Swift.Equatable {
    /// The pending maintenance action to apply to this resource.
    ///          Valid values: system-update, db-upgrade,
    ///           hardware-maintenance, ca-certificate-rotation
    ///
    /// This member is required.
    public var applyAction: Swift.String?
    /// A value that specifies the type of opt-in request, or undoes an opt-in request. An opt-in
    ///            request of type immediate can't be undone.
    ///          Valid values:
    ///
    ///
    ///
    ///                   immediate - Apply the maintenance action immediately.
    ///
    ///
    ///
    ///                   next-maintenance - Apply the maintenance action during
    ///             the next maintenance window for the resource.
    ///
    ///
    ///
    ///                   undo-opt-in - Cancel any existing next-maintenance
    ///             opt-in requests.
    ///
    ///
    /// This member is required.
    public var optInType: Swift.String?
    /// The RDS Amazon Resource Name (ARN) of the resource that the
    ///       pending maintenance action applies to. For information about
    ///       creating an ARN,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///         Constructing an RDS Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        applyAction: Swift.String? = nil,
        optInType: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.applyAction = applyAction
        self.optInType = optInType
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ApplyPendingMaintenanceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ApplyPendingMaintenanceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyPendingMaintenanceActionOutputError: Swift.Error, Swift.Equatable {
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyPendingMaintenanceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplyPendingMaintenanceActionOutputResponse(resourcePendingMaintenanceActions: \(Swift.String(describing: resourcePendingMaintenanceActions)))"}
}

extension ApplyPendingMaintenanceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApplyPendingMaintenanceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourcePendingMaintenanceActions = output.resourcePendingMaintenanceActions
        } else {
            self.resourcePendingMaintenanceActions = nil
        }
    }
}

public struct ApplyPendingMaintenanceActionOutputResponse: Swift.Equatable {
    /// Describes the pending maintenance actions for a resource.
    public var resourcePendingMaintenanceActions: RdsClientTypes.ResourcePendingMaintenanceActions?

    public init (
        resourcePendingMaintenanceActions: RdsClientTypes.ResourcePendingMaintenanceActions? = nil
    )
    {
        self.resourcePendingMaintenanceActions = resourcePendingMaintenanceActions
    }
}

struct ApplyPendingMaintenanceActionOutputResponseBody: Swift.Equatable {
    public let resourcePendingMaintenanceActions: RdsClientTypes.ResourcePendingMaintenanceActions?
}

extension ApplyPendingMaintenanceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcePendingMaintenanceActions = "ResourcePendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ApplyPendingMaintenanceActionResult"))
        let resourcePendingMaintenanceActionsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ResourcePendingMaintenanceActions.self, forKey: .resourcePendingMaintenanceActions)
        resourcePendingMaintenanceActions = resourcePendingMaintenanceActionsDecoded
    }
}

extension RdsClientTypes {
    public enum AuthScheme: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case secrets
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthScheme] {
            return [
                .secrets,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .secrets: return "SECRETS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthScheme(rawValue: rawValue) ?? AuthScheme.sdkUnknown(rawValue)
        }
    }
}

extension AuthorizationAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CIDR IP range or Amazon EC2 security group is already authorized for
///             the specified DB security group.
public struct AuthorizationAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified CIDR IP range or Amazon EC2 security group might not be authorized
///             for the specified DB security group.
///         Or, RDS might not be authorized to perform necessary actions using IAM on your
///             behalf.
public struct AuthorizationNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AuthorizationQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension AuthorizationQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<AuthorizationQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB security group authorization quota has been reached.
public struct AuthorizationQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AuthorizationQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AuthorizeDBSecurityGroupIngressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeDBSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

extension AuthorizeDBSecurityGroupIngressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeDBSecurityGroupIngressInput(cIDRIP: \(Swift.String(describing: cIDRIP)), dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), eC2SecurityGroupId: \(Swift.String(describing: eC2SecurityGroupId)), eC2SecurityGroupName: \(Swift.String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(Swift.String(describing: eC2SecurityGroupOwnerId)))"}
}

extension AuthorizeDBSecurityGroupIngressInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: ClientRuntime.Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("AuthorizeDBSecurityGroupIngress", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AuthorizeDBSecurityGroupIngressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeDBSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

public struct AuthorizeDBSecurityGroupIngressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeDBSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AuthorizeDBSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

public struct AuthorizeDBSecurityGroupIngressInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AuthorizeDBSecurityGroupIngressInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AuthorizeDBSecurityGroupIngressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AuthorizeDBSecurityGroupIngressInput
    public typealias MOutput = ClientRuntime.OperationOutput<AuthorizeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AuthorizeDBSecurityGroupIngressOutputError>
}

///
public struct AuthorizeDBSecurityGroupIngressInput: Swift.Equatable {
    /// The IP range to authorize.
    public var cIDRIP: Swift.String?
    /// The name of the DB security group to add authorization to.
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?
    ///
    ///         Id of the EC2 security group to authorize.
    ///         For VPC DB security groups, EC2SecurityGroupId must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    ///
    public var eC2SecurityGroupId: Swift.String?
    ///
    ///         Name of the EC2 security group to authorize.
    ///         For VPC DB security groups, EC2SecurityGroupId must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName
    ///       or EC2SecurityGroupId must be provided.
    ///
    public var eC2SecurityGroupName: Swift.String?
    ///
    ///         Amazon Web Services account number of the owner of the EC2 security group
    ///         specified in the EC2SecurityGroupName parameter.
    ///         The Amazon Web Services access key ID isn't an acceptable value.
    ///         For VPC DB security groups, EC2SecurityGroupId must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    ///
    public var eC2SecurityGroupOwnerId: Swift.String?

    public init (
        cIDRIP: Swift.String? = nil,
        dBSecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupId: Swift.String? = nil,
        eC2SecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupOwnerId: Swift.String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension AuthorizeDBSecurityGroupIngressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AuthorizeDBSecurityGroupIngressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationAlreadyExists" : self = .authorizationAlreadyExistsFault(try AuthorizationAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AuthorizationQuotaExceeded" : self = .authorizationQuotaExceededFault(try AuthorizationQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AuthorizeDBSecurityGroupIngressOutputError: Swift.Error, Swift.Equatable {
    case authorizationAlreadyExistsFault(AuthorizationAlreadyExistsFault)
    case authorizationQuotaExceededFault(AuthorizationQuotaExceededFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension AuthorizeDBSecurityGroupIngressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizeDBSecurityGroupIngressOutputResponse(dBSecurityGroup: \(Swift.String(describing: dBSecurityGroup)))"}
}

extension AuthorizeDBSecurityGroupIngressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AuthorizeDBSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct AuthorizeDBSecurityGroupIngressOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB security group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSecurityGroups action.
    ///
    public var dBSecurityGroup: RdsClientTypes.DBSecurityGroup?

    public init (
        dBSecurityGroup: RdsClientTypes.DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct AuthorizeDBSecurityGroupIngressOutputResponseBody: Swift.Equatable {
    public let dBSecurityGroup: RdsClientTypes.DBSecurityGroup?
}

extension AuthorizeDBSecurityGroupIngressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AuthorizeDBSecurityGroupIngressResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension RdsClientTypes.AvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RdsClientTypes.AvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZone(name: \(Swift.String(describing: name)))"}
}

extension RdsClientTypes {
    /// Contains Availability Zone information.
    ///          This data type is used as an element in the OrderableDBInstanceOption
    ///             data type.
    public struct AvailabilityZone: Swift.Equatable {
        /// The name of the Availability Zone.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension RdsClientTypes.AvailableProcessorFeature: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case defaultValue = "DefaultValue"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
    }
}

extension RdsClientTypes.AvailableProcessorFeature: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailableProcessorFeature(allowedValues: \(Swift.String(describing: allowedValues)), defaultValue: \(Swift.String(describing: defaultValue)), name: \(Swift.String(describing: name)))"}
}

extension RdsClientTypes {
    /// Contains the available processor feature information for the DB instance class of a DB instance.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor">Configuring the
    ///                 Processor of the DB Instance Class in the Amazon RDS User Guide.
    ///
    ///
    public struct AvailableProcessorFeature: Swift.Equatable {
        /// The allowed values for the processor feature of the DB instance class.
        public var allowedValues: Swift.String?
        /// The default value for the processor feature of the DB instance class.
        public var defaultValue: Swift.String?
        /// The name of the processor feature. Valid names are coreCount
        ///             and threadsPerCore.
        public var name: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.name = name
        }
    }

}

public struct BacktrackDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BacktrackDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BacktrackDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BacktrackDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BacktrackDBClusterOutputError>
}

extension BacktrackDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BacktrackDBClusterInput(backtrackTo: \(Swift.String(describing: backtrackTo)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), force: \(Swift.String(describing: force)), useEarliestTimeOnPointInTimeUnavailable: \(Swift.String(describing: useEarliestTimeOnPointInTimeUnavailable)))"}
}

extension BacktrackDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackTo = backtrackTo {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackTo, format: .dateTime), forKey: ClientRuntime.Key("backtrackTo"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let force = force {
            try container.encode(force, forKey: ClientRuntime.Key("Force"))
        }
        if let useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable {
            try container.encode(useEarliestTimeOnPointInTimeUnavailable, forKey: ClientRuntime.Key("UseEarliestTimeOnPointInTimeUnavailable"))
        }
        try container.encode("BacktrackDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct BacktrackDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BacktrackDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BacktrackDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BacktrackDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BacktrackDBClusterOutputError>
}

public struct BacktrackDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BacktrackDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BacktrackDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BacktrackDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BacktrackDBClusterOutputError>
}

public struct BacktrackDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BacktrackDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BacktrackDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BacktrackDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<BacktrackDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BacktrackDBClusterOutputError>
}

///
public struct BacktrackDBClusterInput: Swift.Equatable {
    /// The timestamp of the time to backtrack the DB cluster to, specified in ISO
    ///             8601 format. For more information about ISO 8601, see the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia
    ///             page.
    ///
    ///
    ///             If the specified time isn't a consistent time for the DB cluster,
    ///                 Aurora automatically chooses the nearest possible consistent time for the DB cluster.
    ///
    ///         Constraints:
    ///
    ///
    ///                 Must contain a valid ISO 8601 timestamp.
    ///
    ///
    ///                 Can't contain a timestamp set in the future.
    ///
    ///
    ///         Example: 2017-07-08T18:00Z
    ///
    /// This member is required.
    public var backtrackTo: ClientRuntime.Date?
    /// The DB cluster identifier of the DB cluster to be backtracked. This parameter is
    ///             stored as a lowercase string.
    ///         Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 alphanumeric characters or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///         Example: my-cluster1
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// A value that indicates whether to force the DB cluster to backtrack when binary logging is
    ///             enabled. Otherwise, an error occurs when binary logging is enabled.
    public var force: Swift.Bool?
    /// A value that indicates whether to backtrack the DB cluster to the earliest possible
    ///             backtrack time when BacktrackTo is set to a timestamp earlier than the earliest
    ///             backtrack time. When this parameter is disabled and BacktrackTo is set to a timestamp earlier than the earliest
    ///             backtrack time, an error occurs.
    public var useEarliestTimeOnPointInTimeUnavailable: Swift.Bool?

    public init (
        backtrackTo: ClientRuntime.Date? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        force: Swift.Bool? = nil,
        useEarliestTimeOnPointInTimeUnavailable: Swift.Bool? = nil
    )
    {
        self.backtrackTo = backtrackTo
        self.dBClusterIdentifier = dBClusterIdentifier
        self.force = force
        self.useEarliestTimeOnPointInTimeUnavailable = useEarliestTimeOnPointInTimeUnavailable
    }
}

extension BacktrackDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension BacktrackDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BacktrackDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension BacktrackDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BacktrackDBClusterOutputResponse(backtrackIdentifier: \(Swift.String(describing: backtrackIdentifier)), backtrackRequestCreationTime: \(Swift.String(describing: backtrackRequestCreationTime)), backtrackTo: \(Swift.String(describing: backtrackTo)), backtrackedFrom: \(Swift.String(describing: backtrackedFrom)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), status: \(Swift.String(describing: status)))"}
}

extension BacktrackDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BacktrackDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backtrackIdentifier = output.backtrackIdentifier
            self.backtrackRequestCreationTime = output.backtrackRequestCreationTime
            self.backtrackTo = output.backtrackTo
            self.backtrackedFrom = output.backtrackedFrom
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.status = output.status
        } else {
            self.backtrackIdentifier = nil
            self.backtrackRequestCreationTime = nil
            self.backtrackTo = nil
            self.backtrackedFrom = nil
            self.dBClusterIdentifier = nil
            self.status = nil
        }
    }
}

/// This data type is used as a response element in the DescribeDBClusterBacktracks action.
public struct BacktrackDBClusterOutputResponse: Swift.Equatable {
    /// Contains the backtrack identifier.
    public var backtrackIdentifier: Swift.String?
    /// The timestamp of the time at which the backtrack was requested.
    public var backtrackRequestCreationTime: ClientRuntime.Date?
    /// The timestamp of the time to which the DB cluster was backtracked.
    public var backtrackTo: ClientRuntime.Date?
    /// The timestamp of the time from which the DB cluster was backtracked.
    public var backtrackedFrom: ClientRuntime.Date?
    /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
    public var dBClusterIdentifier: Swift.String?
    /// The status of the backtrack. This property returns one of the following
    ///             values:
    ///
    ///
    ///
    ///                   applying - The backtrack is currently being applied to or rolled back from the DB cluster.
    ///
    ///
    ///
    ///                   completed - The backtrack has successfully been applied to or rolled back from the DB cluster.
    ///
    ///
    ///
    ///                   failed - An error occurred while the backtrack was applied to or rolled back from the DB cluster.
    ///
    ///
    ///
    ///                   pending - The backtrack is currently pending application to or rollback from the DB cluster.
    ///
    ///
    public var status: Swift.String?

    public init (
        backtrackIdentifier: Swift.String? = nil,
        backtrackRequestCreationTime: ClientRuntime.Date? = nil,
        backtrackTo: ClientRuntime.Date? = nil,
        backtrackedFrom: ClientRuntime.Date? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.backtrackRequestCreationTime = backtrackRequestCreationTime
        self.backtrackTo = backtrackTo
        self.backtrackedFrom = backtrackedFrom
        self.dBClusterIdentifier = dBClusterIdentifier
        self.status = status
    }
}

struct BacktrackDBClusterOutputResponseBody: Swift.Equatable {
    public let dBClusterIdentifier: Swift.String?
    public let backtrackIdentifier: Swift.String?
    public let backtrackTo: ClientRuntime.Date?
    public let backtrackedFrom: ClientRuntime.Date?
    public let backtrackRequestCreationTime: ClientRuntime.Date?
    public let status: Swift.String?
}

extension BacktrackDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
        case backtrackTo = "BacktrackTo"
        case backtrackedFrom = "BacktrackedFrom"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BacktrackDBClusterResult"))
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackTo)
        var backtrackToBuffer:ClientRuntime.Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let backtrackedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackedFrom)
        var backtrackedFromBuffer:ClientRuntime.Date? = nil
        if let backtrackedFromDecoded = backtrackedFromDecoded {
            backtrackedFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackedFromDecoded, format: .dateTime)
        }
        backtrackedFrom = backtrackedFromBuffer
        let backtrackRequestCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackRequestCreationTime)
        var backtrackRequestCreationTimeBuffer:ClientRuntime.Date? = nil
        if let backtrackRequestCreationTimeDecoded = backtrackRequestCreationTimeDecoded {
            backtrackRequestCreationTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackRequestCreationTimeDecoded, format: .dateTime)
        }
        backtrackRequestCreationTime = backtrackRequestCreationTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension BackupPolicyNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupPolicyNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension BackupPolicyNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<BackupPolicyNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

@available(*, deprecated, message: "Please avoid using this fault")
public struct BackupPolicyNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BackupPolicyNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BackupPolicyNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelExportTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelExportTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelExportTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelExportTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelExportTaskOutputError>
}

extension CancelExportTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelExportTaskInput(exportTaskIdentifier: \(Swift.String(describing: exportTaskIdentifier)))"}
}

extension CancelExportTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        try container.encode("CancelExportTask", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CancelExportTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelExportTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelExportTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelExportTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelExportTaskOutputError>
}

public struct CancelExportTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelExportTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelExportTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelExportTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelExportTaskOutputError>
}

public struct CancelExportTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelExportTaskInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CancelExportTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelExportTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelExportTaskOutputError>
}

public struct CancelExportTaskInput: Swift.Equatable {
    /// The identifier of the snapshot export task to cancel.
    /// This member is required.
    public var exportTaskIdentifier: Swift.String?

    public init (
        exportTaskIdentifier: Swift.String? = nil
    )
    {
        self.exportTaskIdentifier = exportTaskIdentifier
    }
}

extension CancelExportTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CancelExportTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExportTaskNotFound" : self = .exportTaskNotFoundFault(try ExportTaskNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportTaskStateFault" : self = .invalidExportTaskStateFault(try InvalidExportTaskStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelExportTaskOutputError: Swift.Error, Swift.Equatable {
    case exportTaskNotFoundFault(ExportTaskNotFoundFault)
    case invalidExportTaskStateFault(InvalidExportTaskStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelExportTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelExportTaskOutputResponse(exportOnly: \(Swift.String(describing: exportOnly)), exportTaskIdentifier: \(Swift.String(describing: exportTaskIdentifier)), failureCause: \(Swift.String(describing: failureCause)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), percentProgress: \(Swift.String(describing: percentProgress)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Prefix: \(Swift.String(describing: s3Prefix)), snapshotTime: \(Swift.String(describing: snapshotTime)), sourceArn: \(Swift.String(describing: sourceArn)), status: \(Swift.String(describing: status)), taskEndTime: \(Swift.String(describing: taskEndTime)), taskStartTime: \(Swift.String(describing: taskStartTime)), totalExtractedDataInGB: \(Swift.String(describing: totalExtractedDataInGB)), warningMessage: \(Swift.String(describing: warningMessage)))"}
}

extension CancelExportTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportOnly = output.exportOnly
            self.exportTaskIdentifier = output.exportTaskIdentifier
            self.failureCause = output.failureCause
            self.iamRoleArn = output.iamRoleArn
            self.kmsKeyId = output.kmsKeyId
            self.percentProgress = output.percentProgress
            self.s3Bucket = output.s3Bucket
            self.s3Prefix = output.s3Prefix
            self.snapshotTime = output.snapshotTime
            self.sourceArn = output.sourceArn
            self.status = output.status
            self.taskEndTime = output.taskEndTime
            self.taskStartTime = output.taskStartTime
            self.totalExtractedDataInGB = output.totalExtractedDataInGB
            self.warningMessage = output.warningMessage
        } else {
            self.exportOnly = nil
            self.exportTaskIdentifier = nil
            self.failureCause = nil
            self.iamRoleArn = nil
            self.kmsKeyId = nil
            self.percentProgress = 0
            self.s3Bucket = nil
            self.s3Prefix = nil
            self.snapshotTime = nil
            self.sourceArn = nil
            self.status = nil
            self.taskEndTime = nil
            self.taskStartTime = nil
            self.totalExtractedDataInGB = 0
            self.warningMessage = nil
        }
    }
}

/// Contains the details of a snapshot export to Amazon S3.
///
///         This data type is used as a response element in the DescribeExportTasks action.
///
public struct CancelExportTaskOutputResponse: Swift.Equatable {
    /// The data exported from the snapshot. Valid values are the following:
    ///
    ///
    ///
    ///                   database - Export all the data from a specified database.
    ///
    ///
    ///
    ///                   database.table
    ///                   table-name -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
    ///
    ///
    ///
    ///                   database.schema
    ///                   schema-name - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    ///
    ///
    ///                   database.schema.table
    ///                   table-name - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    ///
    public var exportOnly: [Swift.String]?
    /// A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is exported to.
    public var exportTaskIdentifier: Swift.String?
    /// The reason the export failed, if it failed.
    public var failureCause: Swift.String?
    /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot.
    public var iamRoleArn: Swift.String?
    /// The key identifier of the Amazon Web Services KMS customer master key (CMK) that is used to encrypt the snapshot when it's exported to
    ///             Amazon S3. The Amazon Web Services KMS CMK identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export
    ///             must have encryption and decryption permissions to use this Amazon Web Services KMS CMK.
    public var kmsKeyId: Swift.String?
    /// The progress of the snapshot export task as a percentage.
    public var percentProgress: Swift.Int
    /// The Amazon S3 bucket that the snapshot is exported to.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.
    public var s3Prefix: Swift.String?
    /// The time that the snapshot was created.
    public var snapshotTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
    public var sourceArn: Swift.String?
    /// The progress status of the export task.
    public var status: Swift.String?
    /// The time that the snapshot export task completed.
    public var taskEndTime: ClientRuntime.Date?
    /// The time that the snapshot export task started.
    public var taskStartTime: ClientRuntime.Date?
    /// The total amount of data exported, in gigabytes.
    public var totalExtractedDataInGB: Swift.Int
    /// A warning about the snapshot export task.
    public var warningMessage: Swift.String?

    public init (
        exportOnly: [Swift.String]? = nil,
        exportTaskIdentifier: Swift.String? = nil,
        failureCause: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        percentProgress: Swift.Int = 0,
        s3Bucket: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        snapshotTime: ClientRuntime.Date? = nil,
        sourceArn: Swift.String? = nil,
        status: Swift.String? = nil,
        taskEndTime: ClientRuntime.Date? = nil,
        taskStartTime: ClientRuntime.Date? = nil,
        totalExtractedDataInGB: Swift.Int = 0,
        warningMessage: Swift.String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

struct CancelExportTaskOutputResponseBody: Swift.Equatable {
    public let exportTaskIdentifier: Swift.String?
    public let sourceArn: Swift.String?
    public let exportOnly: [Swift.String]?
    public let snapshotTime: ClientRuntime.Date?
    public let taskStartTime: ClientRuntime.Date?
    public let taskEndTime: ClientRuntime.Date?
    public let s3Bucket: Swift.String?
    public let s3Prefix: Swift.String?
    public let iamRoleArn: Swift.String?
    public let kmsKeyId: Swift.String?
    public let status: Swift.String?
    public let percentProgress: Swift.Int
    public let totalExtractedDataInGB: Swift.Int
    public let failureCause: Swift.String?
    public let warningMessage: Swift.String?
}

extension CancelExportTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CancelExportTaskResult"))
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:ClientRuntime.Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:ClientRuntime.Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension RdsClientTypes.Certificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateIdentifier = "CertificateIdentifier"
        case certificateType = "CertificateType"
        case customerOverride = "CustomerOverride"
        case customerOverrideValidTill = "CustomerOverrideValidTill"
        case thumbprint = "Thumbprint"
        case validFrom = "ValidFrom"
        case validTill = "ValidTill"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateArn = certificateArn {
            try container.encode(certificateArn, forKey: ClientRuntime.Key("CertificateArn"))
        }
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: ClientRuntime.Key("CertificateIdentifier"))
        }
        if let certificateType = certificateType {
            try container.encode(certificateType, forKey: ClientRuntime.Key("CertificateType"))
        }
        if let customerOverride = customerOverride {
            try container.encode(customerOverride, forKey: ClientRuntime.Key("CustomerOverride"))
        }
        if let customerOverrideValidTill = customerOverrideValidTill {
            try container.encode(ClientRuntime.TimestampWrapper(customerOverrideValidTill, format: .dateTime), forKey: ClientRuntime.Key("customerOverrideValidTill"))
        }
        if let thumbprint = thumbprint {
            try container.encode(thumbprint, forKey: ClientRuntime.Key("Thumbprint"))
        }
        if let validFrom = validFrom {
            try container.encode(ClientRuntime.TimestampWrapper(validFrom, format: .dateTime), forKey: ClientRuntime.Key("validFrom"))
        }
        if let validTill = validTill {
            try container.encode(ClientRuntime.TimestampWrapper(validTill, format: .dateTime), forKey: ClientRuntime.Key("validTill"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateIdentifier)
        certificateIdentifier = certificateIdentifierDecoded
        let certificateTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateType)
        certificateType = certificateTypeDecoded
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let validFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validFrom)
        var validFromBuffer:ClientRuntime.Date? = nil
        if let validFromDecoded = validFromDecoded {
            validFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(validFromDecoded, format: .dateTime)
        }
        validFrom = validFromBuffer
        let validTillDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validTill)
        var validTillBuffer:ClientRuntime.Date? = nil
        if let validTillDecoded = validTillDecoded {
            validTillBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(validTillDecoded, format: .dateTime)
        }
        validTill = validTillBuffer
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let customerOverrideDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .customerOverride)
        customerOverride = customerOverrideDecoded
        let customerOverrideValidTillDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOverrideValidTill)
        var customerOverrideValidTillBuffer:ClientRuntime.Date? = nil
        if let customerOverrideValidTillDecoded = customerOverrideValidTillDecoded {
            customerOverrideValidTillBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(customerOverrideValidTillDecoded, format: .dateTime)
        }
        customerOverrideValidTill = customerOverrideValidTillBuffer
    }
}

extension RdsClientTypes.Certificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Certificate(certificateArn: \(Swift.String(describing: certificateArn)), certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), certificateType: \(Swift.String(describing: certificateType)), customerOverride: \(Swift.String(describing: customerOverride)), customerOverrideValidTill: \(Swift.String(describing: customerOverrideValidTill)), thumbprint: \(Swift.String(describing: thumbprint)), validFrom: \(Swift.String(describing: validFrom)), validTill: \(Swift.String(describing: validTill)))"}
}

extension RdsClientTypes {
    /// A CA certificate for an Amazon Web Services account.
    public struct Certificate: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the certificate.
        public var certificateArn: Swift.String?
        /// The unique key that identifies a certificate.
        public var certificateIdentifier: Swift.String?
        /// The type of the certificate.
        public var certificateType: Swift.String?
        /// Whether there is an override for the default certificate identifier.
        public var customerOverride: Swift.Bool?
        /// If there is an override for the default certificate identifier, when the override
        ///             expires.
        public var customerOverrideValidTill: ClientRuntime.Date?
        /// The thumbprint of the certificate.
        public var thumbprint: Swift.String?
        /// The starting date from which the certificate is valid.
        public var validFrom: ClientRuntime.Date?
        /// The final date that the certificate continues to be valid.
        public var validTill: ClientRuntime.Date?

        public init (
            certificateArn: Swift.String? = nil,
            certificateIdentifier: Swift.String? = nil,
            certificateType: Swift.String? = nil,
            customerOverride: Swift.Bool? = nil,
            customerOverrideValidTill: ClientRuntime.Date? = nil,
            thumbprint: Swift.String? = nil,
            validFrom: ClientRuntime.Date? = nil,
            validTill: ClientRuntime.Date? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateIdentifier = certificateIdentifier
            self.certificateType = certificateType
            self.customerOverride = customerOverride
            self.customerOverrideValidTill = customerOverrideValidTill
            self.thumbprint = thumbprint
            self.validFrom = validFrom
            self.validTill = validTill
        }
    }

}

extension CertificateNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension CertificateNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CertificateNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             CertificateIdentifier doesn't refer to an
///         existing certificate.
///
public struct CertificateNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CertificateNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.CharacterSet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characterSetDescription = "CharacterSetDescription"
        case characterSetName = "CharacterSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let characterSetDescription = characterSetDescription {
            try container.encode(characterSetDescription, forKey: ClientRuntime.Key("CharacterSetDescription"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let characterSetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetDescription)
        characterSetDescription = characterSetDescriptionDecoded
    }
}

extension RdsClientTypes.CharacterSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CharacterSet(characterSetDescription: \(Swift.String(describing: characterSetDescription)), characterSetName: \(Swift.String(describing: characterSetName)))"}
}

extension RdsClientTypes {
    ///
    ///             This data type is used as a response element in the action DescribeDBEngineVersions.
    ///
    public struct CharacterSet: Swift.Equatable {
        /// The description of the character set.
        public var characterSetDescription: Swift.String?
        /// The name of the character set.
        public var characterSetName: Swift.String?

        public init (
            characterSetDescription: Swift.String? = nil,
            characterSetName: Swift.String? = nil
        )
        {
            self.characterSetDescription = characterSetDescription
            self.characterSetName = characterSetName
        }
    }

}

extension RdsClientTypes.CloudwatchLogsExportConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableLogTypes = "DisableLogTypes"
        case enableLogTypes = "EnableLogTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let disableLogTypes = disableLogTypes {
            var disableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DisableLogTypes"))
            for (index0, string0) in disableLogTypes.enumerated() {
                try disableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableLogTypes = enableLogTypes {
            var enableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableLogTypes"))
            for (index0, string0) in enableLogTypes.enumerated() {
                try enableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.enableLogTypes) {
            struct KeyVal0{struct member{}}
            let enableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableLogTypes)
            if let enableLogTypesWrappedContainer = enableLogTypesWrappedContainer {
                let enableLogTypesContainer = try enableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableLogTypesBuffer:[Swift.String]? = nil
                if let enableLogTypesContainer = enableLogTypesContainer {
                    enableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in enableLogTypesContainer {
                        enableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                enableLogTypes = enableLogTypesBuffer
            } else {
                enableLogTypes = []
            }
        } else {
            enableLogTypes = nil
        }
        if containerValues.contains(.disableLogTypes) {
            struct KeyVal0{struct member{}}
            let disableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .disableLogTypes)
            if let disableLogTypesWrappedContainer = disableLogTypesWrappedContainer {
                let disableLogTypesContainer = try disableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var disableLogTypesBuffer:[Swift.String]? = nil
                if let disableLogTypesContainer = disableLogTypesContainer {
                    disableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in disableLogTypesContainer {
                        disableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                disableLogTypes = disableLogTypesBuffer
            } else {
                disableLogTypes = []
            }
        } else {
            disableLogTypes = nil
        }
    }
}

extension RdsClientTypes.CloudwatchLogsExportConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudwatchLogsExportConfiguration(disableLogTypes: \(Swift.String(describing: disableLogTypes)), enableLogTypes: \(Swift.String(describing: enableLogTypes)))"}
}

extension RdsClientTypes {
    /// The configuration setting for the log types to be enabled for export to CloudWatch
    ///             Logs for a specific DB instance or DB cluster.
    ///         The EnableLogTypes and DisableLogTypes arrays determine which logs will be exported
    ///             (or not exported) to CloudWatch Logs. The values within these arrays depend on the DB
    ///             engine being used.
    ///         For more information about exporting CloudWatch Logs for Amazon RDS DB instances, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs  in the Amazon RDS User Guide.
    ///         For more information about exporting CloudWatch Logs for Amazon Aurora DB clusters, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
    public struct CloudwatchLogsExportConfiguration: Swift.Equatable {
        /// The list of log types to disable.
        public var disableLogTypes: [Swift.String]?
        /// The list of log types to enable.
        public var enableLogTypes: [Swift.String]?

        public init (
            disableLogTypes: [Swift.String]? = nil,
            enableLogTypes: [Swift.String]? = nil
        )
        {
            self.disableLogTypes = disableLogTypes
            self.enableLogTypes = enableLogTypes
        }
    }

}

extension RdsClientTypes.ClusterPendingModifiedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case masterUserPassword = "MasterUserPassword"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: ClientRuntime.Key("PendingCloudwatchLogsExports"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension RdsClientTypes.ClusterPendingModifiedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterPendingModifiedValues(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), engineVersion: \(Swift.String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), pendingCloudwatchLogsExports: \(Swift.String(describing: pendingCloudwatchLogsExports)))"}
}

extension RdsClientTypes {
    /// This data type is used as a response element in the ModifyDBCluster operation and
    ///             contains changes that will be applied during the next maintenance window.
    public struct ClusterPendingModifiedValues: Swift.Equatable {
        /// The DBClusterIdentifier value for the DB cluster.
        public var dBClusterIdentifier: Swift.String?
        /// The database engine version.
        public var engineVersion: Swift.String?
        /// A value that indicates whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool?
        /// The master credentials for the DB cluster.
        public var masterUserPassword: Swift.String?
        /// A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.
        public var pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports?

        public init (
            dBClusterIdentifier: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            masterUserPassword: Swift.String? = nil,
            pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports? = nil
        )
        {
            self.dBClusterIdentifier = dBClusterIdentifier
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.masterUserPassword = masterUserPassword
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
        }
    }

}

extension RdsClientTypes.ConnectionPoolConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionBorrowTimeout = "ConnectionBorrowTimeout"
        case initQuery = "InitQuery"
        case maxConnectionsPercent = "MaxConnectionsPercent"
        case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
        case sessionPinningFilters = "SessionPinningFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let connectionBorrowTimeout = connectionBorrowTimeout {
            try container.encode(connectionBorrowTimeout, forKey: ClientRuntime.Key("ConnectionBorrowTimeout"))
        }
        if let initQuery = initQuery {
            try container.encode(initQuery, forKey: ClientRuntime.Key("InitQuery"))
        }
        if let maxConnectionsPercent = maxConnectionsPercent {
            try container.encode(maxConnectionsPercent, forKey: ClientRuntime.Key("MaxConnectionsPercent"))
        }
        if let maxIdleConnectionsPercent = maxIdleConnectionsPercent {
            try container.encode(maxIdleConnectionsPercent, forKey: ClientRuntime.Key("MaxIdleConnectionsPercent"))
        }
        if let sessionPinningFilters = sessionPinningFilters {
            var sessionPinningFiltersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SessionPinningFilters"))
            for (index0, string0) in sessionPinningFilters.enumerated() {
                try sessionPinningFiltersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnectionsPercent)
        maxConnectionsPercent = maxConnectionsPercentDecoded
        let maxIdleConnectionsPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIdleConnectionsPercent)
        maxIdleConnectionsPercent = maxIdleConnectionsPercentDecoded
        let connectionBorrowTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionBorrowTimeout)
        connectionBorrowTimeout = connectionBorrowTimeoutDecoded
        if containerValues.contains(.sessionPinningFilters) {
            struct KeyVal0{struct member{}}
            let sessionPinningFiltersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sessionPinningFilters)
            if let sessionPinningFiltersWrappedContainer = sessionPinningFiltersWrappedContainer {
                let sessionPinningFiltersContainer = try sessionPinningFiltersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sessionPinningFiltersBuffer:[Swift.String]? = nil
                if let sessionPinningFiltersContainer = sessionPinningFiltersContainer {
                    sessionPinningFiltersBuffer = [Swift.String]()
                    for stringContainer0 in sessionPinningFiltersContainer {
                        sessionPinningFiltersBuffer?.append(stringContainer0)
                    }
                }
                sessionPinningFilters = sessionPinningFiltersBuffer
            } else {
                sessionPinningFilters = []
            }
        } else {
            sessionPinningFilters = nil
        }
        let initQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initQuery)
        initQuery = initQueryDecoded
    }
}

extension RdsClientTypes.ConnectionPoolConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionPoolConfiguration(connectionBorrowTimeout: \(Swift.String(describing: connectionBorrowTimeout)), initQuery: \(Swift.String(describing: initQuery)), maxConnectionsPercent: \(Swift.String(describing: maxConnectionsPercent)), maxIdleConnectionsPercent: \(Swift.String(describing: maxIdleConnectionsPercent)), sessionPinningFilters: \(Swift.String(describing: sessionPinningFilters)))"}
}

extension RdsClientTypes {
    /// Specifies the settings that control the size and behavior of the connection pool associated with a DBProxyTargetGroup.
    public struct ConnectionPoolConfiguration: Swift.Equatable {
        /// The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the
        ///         proxy has opened its maximum number of connections and all connections are busy with client sessions.
        ///          Default: 120
        ///          Constraints: between 1 and 3600, or 0 representing unlimited
        public var connectionBorrowTimeout: Swift.Int?
        ///
        ///         One or more SQL statements for the proxy to run when opening each new database connection.
        ///         Typically used with SET statements to make sure that each connection has identical
        ///         settings such as time zone and character set. For multiple statements, use semicolons as the separator.
        ///         You can also include multiple variables in a single SET statement, such as
        ///         SET x=1, y=2.
        ///
        ///          Default: no initialization query
        public var initQuery: Swift.String?
        /// The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the
        ///         max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        ///          Default: 100
        ///          Constraints: between 1 and 100
        public var maxConnectionsPercent: Swift.Int?
        ///
        ///         Controls how actively the proxy closes idle database connections in the connection pool.
        ///         A high value enables the proxy to leave a high percentage of idle connections open.
        ///         A low value causes the proxy to close idle client connections and return the underlying
        ///         database connections to the connection pool. For Aurora MySQL, it is expressed as a percentage of the
        ///         max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        ///
        ///          Default: 50
        ///          Constraints: between 0 and MaxConnectionsPercent
        ///
        public var maxIdleConnectionsPercent: Swift.Int?
        /// Each item in the list represents a class of SQL operations that normally cause all later statements
        ///         in a session using a proxy to be pinned to the same underlying database connection. Including an item
        ///         in the list exempts that class of SQL operations from the pinning behavior.
        ///          Default: no session pinning filters
        public var sessionPinningFilters: [Swift.String]?

        public init (
            connectionBorrowTimeout: Swift.Int? = nil,
            initQuery: Swift.String? = nil,
            maxConnectionsPercent: Swift.Int? = nil,
            maxIdleConnectionsPercent: Swift.Int? = nil,
            sessionPinningFilters: [Swift.String]? = nil
        )
        {
            self.connectionBorrowTimeout = connectionBorrowTimeout
            self.initQuery = initQuery
            self.maxConnectionsPercent = maxConnectionsPercent
            self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
            self.sessionPinningFilters = sessionPinningFilters
        }
    }

}

extension RdsClientTypes.ConnectionPoolConfigurationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionBorrowTimeout = "ConnectionBorrowTimeout"
        case initQuery = "InitQuery"
        case maxConnectionsPercent = "MaxConnectionsPercent"
        case maxIdleConnectionsPercent = "MaxIdleConnectionsPercent"
        case sessionPinningFilters = "SessionPinningFilters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if connectionBorrowTimeout != 0 {
            try container.encode(connectionBorrowTimeout, forKey: ClientRuntime.Key("ConnectionBorrowTimeout"))
        }
        if let initQuery = initQuery {
            try container.encode(initQuery, forKey: ClientRuntime.Key("InitQuery"))
        }
        if maxConnectionsPercent != 0 {
            try container.encode(maxConnectionsPercent, forKey: ClientRuntime.Key("MaxConnectionsPercent"))
        }
        if maxIdleConnectionsPercent != 0 {
            try container.encode(maxIdleConnectionsPercent, forKey: ClientRuntime.Key("MaxIdleConnectionsPercent"))
        }
        if let sessionPinningFilters = sessionPinningFilters {
            var sessionPinningFiltersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SessionPinningFilters"))
            for (index0, string0) in sessionPinningFilters.enumerated() {
                try sessionPinningFiltersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxConnectionsPercent)
        maxConnectionsPercent = maxConnectionsPercentDecoded
        let maxIdleConnectionsPercentDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxIdleConnectionsPercent)
        maxIdleConnectionsPercent = maxIdleConnectionsPercentDecoded
        let connectionBorrowTimeoutDecoded = try containerValues.decode(Swift.Int.self, forKey: .connectionBorrowTimeout)
        connectionBorrowTimeout = connectionBorrowTimeoutDecoded
        if containerValues.contains(.sessionPinningFilters) {
            struct KeyVal0{struct member{}}
            let sessionPinningFiltersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sessionPinningFilters)
            if let sessionPinningFiltersWrappedContainer = sessionPinningFiltersWrappedContainer {
                let sessionPinningFiltersContainer = try sessionPinningFiltersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sessionPinningFiltersBuffer:[Swift.String]? = nil
                if let sessionPinningFiltersContainer = sessionPinningFiltersContainer {
                    sessionPinningFiltersBuffer = [Swift.String]()
                    for stringContainer0 in sessionPinningFiltersContainer {
                        sessionPinningFiltersBuffer?.append(stringContainer0)
                    }
                }
                sessionPinningFilters = sessionPinningFiltersBuffer
            } else {
                sessionPinningFilters = []
            }
        } else {
            sessionPinningFilters = nil
        }
        let initQueryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initQuery)
        initQuery = initQueryDecoded
    }
}

extension RdsClientTypes.ConnectionPoolConfigurationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionPoolConfigurationInfo(connectionBorrowTimeout: \(Swift.String(describing: connectionBorrowTimeout)), initQuery: \(Swift.String(describing: initQuery)), maxConnectionsPercent: \(Swift.String(describing: maxConnectionsPercent)), maxIdleConnectionsPercent: \(Swift.String(describing: maxIdleConnectionsPercent)), sessionPinningFilters: \(Swift.String(describing: sessionPinningFilters)))"}
}

extension RdsClientTypes {
    /// Displays the settings that control the size and behavior of the connection pool associated with a DBProxyTarget.
    public struct ConnectionPoolConfigurationInfo: Swift.Equatable {
        /// The number of seconds for a proxy to wait for a connection to become available in the connection pool. Only applies when the
        ///         proxy has opened its maximum number of connections and all connections are busy with client sessions.
        public var connectionBorrowTimeout: Swift.Int
        ///
        ///         One or more SQL statements for the proxy to run when opening each new database connection.
        ///         Typically used with SET statements to make sure that each connection has identical
        ///         settings such as time zone and character set. This setting is empty by default.
        ///         For multiple statements, use semicolons as the separator.
        ///         You can also include multiple variables in a single SET statement, such as
        ///         SET x=1, y=2.
        ///
        public var initQuery: Swift.String?
        /// The maximum size of the connection pool for each target in a target group. For Aurora MySQL, it is expressed as a percentage of the
        ///         max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        public var maxConnectionsPercent: Swift.Int
        ///
        ///         Controls how actively the proxy closes idle database connections in the connection pool.
        ///         A high value enables the proxy to leave a high percentage of idle connections open.
        ///         A low value causes the proxy to close idle client connections and return the underlying database connections to the connection pool.
        ///         For Aurora MySQL, it is expressed as a percentage of the max_connections setting for the RDS DB instance or Aurora DB cluster used by the target group.
        ///
        public var maxIdleConnectionsPercent: Swift.Int
        /// Each item in the list represents a class of SQL operations that normally cause all later statements
        ///         in a session using a proxy to be pinned to the same underlying database connection. Including an item
        ///         in the list exempts that class of SQL operations from the pinning behavior. Currently, the only
        ///         allowed value is EXCLUDE_VARIABLE_SETS.
        public var sessionPinningFilters: [Swift.String]?

        public init (
            connectionBorrowTimeout: Swift.Int = 0,
            initQuery: Swift.String? = nil,
            maxConnectionsPercent: Swift.Int = 0,
            maxIdleConnectionsPercent: Swift.Int = 0,
            sessionPinningFilters: [Swift.String]? = nil
        )
        {
            self.connectionBorrowTimeout = connectionBorrowTimeout
            self.initQuery = initQuery
            self.maxConnectionsPercent = maxConnectionsPercent
            self.maxIdleConnectionsPercent = maxIdleConnectionsPercent
            self.sessionPinningFilters = sessionPinningFilters
        }
    }

}

public struct CopyDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

extension CopyDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterParameterGroupInput(sourceDBClusterParameterGroupIdentifier: \(Swift.String(describing: sourceDBClusterParameterGroupIdentifier)), tags: \(Swift.String(describing: tags)), targetDBClusterParameterGroupDescription: \(Swift.String(describing: targetDBClusterParameterGroupDescription)), targetDBClusterParameterGroupIdentifier: \(Swift.String(describing: targetDBClusterParameterGroupIdentifier)))"}
}

extension CopyDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier {
            try container.encode(sourceDBClusterParameterGroupIdentifier, forKey: ClientRuntime.Key("SourceDBClusterParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription {
            try container.encode(targetDBClusterParameterGroupDescription, forKey: ClientRuntime.Key("TargetDBClusterParameterGroupDescription"))
        }
        if let targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier {
            try container.encode(targetDBClusterParameterGroupIdentifier, forKey: ClientRuntime.Key("TargetDBClusterParameterGroupIdentifier"))
        }
        try container.encode("CopyDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyDBClusterParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyDBClusterParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterParameterGroupOutputError>
}

public struct CopyDBClusterParameterGroupInput: Swift.Equatable {
    /// The identifier or Amazon Resource Name (ARN) for the source DB cluster parameter group.
    ///             For information about
    ///             creating an ARN,
    ///             see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///                 Constructing an ARN for Amazon RDS in the Amazon Aurora User Guide.
    ///
    ///         Constraints:
    ///
    ///
    ///                Must specify a valid DB cluster parameter group.
    ///
    ///
    /// This member is required.
    public var sourceDBClusterParameterGroupIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A description for the copied DB cluster parameter group.
    /// This member is required.
    public var targetDBClusterParameterGroupDescription: Swift.String?
    /// The identifier for the copied DB cluster parameter group.
    ///         Constraints:
    ///
    ///
    ///                Can't be null, empty, or blank
    ///
    ///
    ///                Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///         Example: my-cluster-param-group1
    ///
    /// This member is required.
    public var targetDBClusterParameterGroupIdentifier: Swift.String?

    public init (
        sourceDBClusterParameterGroupIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBClusterParameterGroupDescription: Swift.String? = nil,
        targetDBClusterParameterGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceDBClusterParameterGroupIdentifier = sourceDBClusterParameterGroupIdentifier
        self.tags = tags
        self.targetDBClusterParameterGroupDescription = targetDBClusterParameterGroupDescription
        self.targetDBClusterParameterGroupIdentifier = targetDBClusterParameterGroupIdentifier
    }
}

extension CopyDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(Swift.String(describing: dBClusterParameterGroup)))"}
}

extension CopyDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CopyDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB cluster parameter group.
    ///
    ///          This data type is used as a response element in the DescribeDBClusterParameterGroups action.
    ///
    public var dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CopyDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?
}

extension CopyDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CopyDBClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

extension CopyDBClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterSnapshotInput(copyTags: \(Swift.String(describing: copyTags)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), sourceDBClusterSnapshotIdentifier: \(Swift.String(describing: sourceDBClusterSnapshotIdentifier)), tags: \(Swift.String(describing: tags)), targetDBClusterSnapshotIdentifier: \(Swift.String(describing: targetDBClusterSnapshotIdentifier)))"}
}

extension CopyDBClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: ClientRuntime.Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier {
            try container.encode(sourceDBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier {
            try container.encode(targetDBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("TargetDBClusterSnapshotIdentifier"))
        }
        try container.encode("CopyDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

public struct CopyDBClusterSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBClusterSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyDBClusterSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyDBClusterSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBClusterSnapshotOutputError>
}

///
public struct CopyDBClusterSnapshotInput: Swift.Equatable {
    /// A value that indicates whether to copy all tags from the source DB cluster snapshot to the target DB cluster snapshot.
    ///             By default, tags are not copied.
    public var copyTags: Swift.Bool?
    /// The Amazon Web Services KMS key identifier for an encrypted DB cluster snapshot.
    ///             The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///
    ///         If you copy an encrypted DB cluster snapshot from your Amazon Web Services account, you can specify a value for KmsKeyId to encrypt the copy with a new Amazon Web Services KMS CMK.
    ///             If you don't specify a value for KmsKeyId, then the copy of the DB cluster snapshot is encrypted with the same Amazon Web Services KMS key as the source DB cluster snapshot.
    ///
    ///
    ///         If you copy an encrypted DB cluster snapshot that is shared from another Amazon Web Services account, then you must specify a value for KmsKeyId.
    ///
    ///         To copy an encrypted DB cluster snapshot to another Amazon Web Services Region, you must set KmsKeyId to the Amazon Web Services KMS key identifier you want to use to encrypt the copy of the DB cluster snapshot
    ///             in the destination Amazon Web Services Region. Amazon Web Services KMS CMKs are specific to the Amazon Web Services Region that they are created in, and you can't use CMKs from one Amazon Web Services Region
    ///             in another Amazon Web Services Region.
    ///
    ///         If you copy an unencrypted DB cluster snapshot and specify a value for the KmsKeyId parameter,
    ///             an error is returned.
    public var kmsKeyId: Swift.String?
    /// The URL that contains a Signature Version 4 signed request for the CopyDBClusterSnapshot API action in the Amazon Web Services Region that contains the
    ///             source DB cluster snapshot to copy. The PreSignedUrl parameter must be used when copying an encrypted DB cluster snapshot from another Amazon Web Services Region.
    ///             Don't specify PreSignedUrl when you are copying an encrypted DB cluster snapshot in the same Amazon Web Services Region.
    ///         The pre-signed URL must be a valid request for the CopyDBClusterSnapshot API action that can be
    ///             executed in the source Amazon Web Services Region that contains the encrypted DB cluster snapshot to be copied.
    ///             The pre-signed URL request must contain the following parameter values:
    ///
    ///
    ///
    ///
    ///                   KmsKeyId - The Amazon Web Services KMS key identifier for the customer master key (CMK) to use to encrypt the copy of the DB
    ///                 cluster snapshot in the destination Amazon Web Services Region. This is the same identifier for both the CopyDBClusterSnapshot
    ///                 action that is called in the destination Amazon Web Services Region, and the action contained in the pre-signed URL.
    ///
    ///
    ///
    ///                   DestinationRegion - The name of the Amazon Web Services Region that the DB cluster snapshot is to be created in.
    ///
    ///
    ///
    ///                   SourceDBClusterSnapshotIdentifier - The DB cluster snapshot identifier for the encrypted DB cluster
    ///                 snapshot to be copied. This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example,
    ///                 if you are copying an encrypted DB cluster snapshot from the us-west-2 Amazon Web Services Region, then your SourceDBClusterSnapshotIdentifier
    ///                 looks like the following example: arn:aws:rds:us-west-2:123456789012:cluster-snapshot:aurora-cluster1-snapshot-20161115.
    ///
    ///
    ///
    ///         To learn how to generate a Signature Version 4 signed request, see
    ///
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">
    ///                 Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and
    ///             <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">
    ///                 Signature Version 4 Signing Process.
    ///
    ///
    ///             If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI)
    ///                 instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a pre-signed URL that is a valid
    ///                 request for the operation that can be executed in the source Amazon Web Services Region.
    ///
    public var preSignedUrl: Swift.String?
    /// The identifier of the DB cluster snapshot to copy. This parameter isn't case-sensitive.
    ///          You can't copy an encrypted, shared DB cluster snapshot from one Amazon Web Services Region to another.
    ///          Constraints:
    ///
    ///
    ///                Must specify a valid system snapshot in the "available" state.
    ///
    ///
    ///                If the source snapshot is in the same Amazon Web Services Region as the copy, specify a valid DB snapshot identifier.
    ///
    ///
    ///                If the source snapshot is in a different Amazon Web Services Region than the copy,
    ///               specify a valid DB cluster snapshot ARN. For more information, go to
    ///               <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_CopySnapshot.html#USER_CopySnapshot.AcrossRegions">
    ///                   Copying Snapshots Across Amazon Web Services Regions in the Amazon Aurora User Guide.
    ///
    ///
    ///
    ///          Example: my-cluster-snapshot1
    ///
    /// This member is required.
    public var sourceDBClusterSnapshotIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// The identifier of the new DB cluster snapshot to create from the source DB cluster snapshot. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///          Example: my-cluster-snapshot2
    ///
    /// This member is required.
    public var targetDBClusterSnapshotIdentifier: Swift.String?

    public init (
        copyTags: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBClusterSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBClusterSnapshotIdentifier = sourceDBClusterSnapshotIdentifier
        self.tags = tags
        self.targetDBClusterSnapshotIdentifier = targetDBClusterSnapshotIdentifier
    }
}

extension CopyDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(Swift.String(describing: dBClusterSnapshot)))"}
}

extension CopyDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CopyDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB cluster snapshot
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBClusterSnapshots action.
    ///
    public var dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CopyDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?
}

extension CopyDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CopyDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

extension CopyDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBParameterGroupInput(sourceDBParameterGroupIdentifier: \(Swift.String(describing: sourceDBParameterGroupIdentifier)), tags: \(Swift.String(describing: tags)), targetDBParameterGroupDescription: \(Swift.String(describing: targetDBParameterGroupDescription)), targetDBParameterGroupIdentifier: \(Swift.String(describing: targetDBParameterGroupIdentifier)))"}
}

extension CopyDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier {
            try container.encode(sourceDBParameterGroupIdentifier, forKey: ClientRuntime.Key("SourceDBParameterGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBParameterGroupDescription = targetDBParameterGroupDescription {
            try container.encode(targetDBParameterGroupDescription, forKey: ClientRuntime.Key("TargetDBParameterGroupDescription"))
        }
        if let targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier {
            try container.encode(targetDBParameterGroupIdentifier, forKey: ClientRuntime.Key("TargetDBParameterGroupIdentifier"))
        }
        try container.encode("CopyDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

public struct CopyDBParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyDBParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyDBParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBParameterGroupOutputError>
}

///
public struct CopyDBParameterGroupInput: Swift.Equatable {
    ///
    ///         The identifier or ARN for the source DB parameter group.
    ///         For information about
    ///         creating an ARN,
    ///         see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///             Constructing an ARN for Amazon RDS in the Amazon RDS User Guide.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must specify a valid DB parameter group.
    ///
    ///
    /// This member is required.
    public var sourceDBParameterGroupIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A description for the copied DB parameter group.
    /// This member is required.
    public var targetDBParameterGroupDescription: Swift.String?
    /// The identifier for the copied DB parameter group.
    ///          Constraints:
    ///
    ///
    ///                Can't be null, empty, or blank
    ///
    ///
    ///                Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-db-parameter-group
    ///
    /// This member is required.
    public var targetDBParameterGroupIdentifier: Swift.String?

    public init (
        sourceDBParameterGroupIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBParameterGroupDescription: Swift.String? = nil,
        targetDBParameterGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceDBParameterGroupIdentifier = sourceDBParameterGroupIdentifier
        self.tags = tags
        self.targetDBParameterGroupDescription = targetDBParameterGroupDescription
        self.targetDBParameterGroupIdentifier = targetDBParameterGroupIdentifier
    }
}

extension CopyDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBParameterGroupOutputResponse(dBParameterGroup: \(Swift.String(describing: dBParameterGroup)))"}
}

extension CopyDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CopyDBParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB parameter group.
    ///
    ///          This data type is used as a response element in the DescribeDBParameterGroups action.
    ///
    public var dBParameterGroup: RdsClientTypes.DBParameterGroup?

    public init (
        dBParameterGroup: RdsClientTypes.DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CopyDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroup: RdsClientTypes.DBParameterGroup?
}

extension CopyDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CopyDBSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBSnapshotOutputError>
}

extension CopyDBSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBSnapshotInput(copyTags: \(Swift.String(describing: copyTags)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), optionGroupName: \(Swift.String(describing: optionGroupName)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), sourceDBSnapshotIdentifier: \(Swift.String(describing: sourceDBSnapshotIdentifier)), tags: \(Swift.String(describing: tags)), targetCustomAvailabilityZone: \(Swift.String(describing: targetCustomAvailabilityZone)), targetDBSnapshotIdentifier: \(Swift.String(describing: targetDBSnapshotIdentifier)))"}
}

extension CopyDBSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let copyTags = copyTags {
            try container.encode(copyTags, forKey: ClientRuntime.Key("CopyTags"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier {
            try container.encode(sourceDBSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetCustomAvailabilityZone = targetCustomAvailabilityZone {
            try container.encode(targetCustomAvailabilityZone, forKey: ClientRuntime.Key("TargetCustomAvailabilityZone"))
        }
        if let targetDBSnapshotIdentifier = targetDBSnapshotIdentifier {
            try container.encode(targetDBSnapshotIdentifier, forKey: ClientRuntime.Key("TargetDBSnapshotIdentifier"))
        }
        try container.encode("CopyDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyDBSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBSnapshotOutputError>
}

public struct CopyDBSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBSnapshotOutputError>
}

public struct CopyDBSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyDBSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyDBSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyDBSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyDBSnapshotOutputError>
}

///
public struct CopyDBSnapshotInput: Swift.Equatable {
    /// A value that indicates whether to copy all tags from the source DB snapshot to the target DB snapshot. By default, tags are not copied.
    public var copyTags: Swift.Bool?
    /// The Amazon Web Services KMS key identifier for an encrypted DB snapshot.
    ///             The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///
    ///
    ///         If you copy an encrypted DB snapshot from your Amazon Web Services account,
    ///             you can specify a value for this parameter to encrypt the copy with a new Amazon Web Services KMS CMK.
    ///             If you don't specify a value for this parameter,
    ///             then the copy of the DB snapshot is encrypted with the same Amazon Web Services KMS key as the source DB snapshot.
    ///
    ///
    ///         If you copy an encrypted DB snapshot that is shared from another Amazon Web Services account,
    ///             then you must specify a value for this parameter.
    ///
    ///
    ///         If you specify this parameter when you copy an unencrypted snapshot,
    ///             the copy is encrypted.
    ///
    ///
    ///         If you copy an encrypted snapshot to a different Amazon Web Services Region, then you must specify
    ///             a Amazon Web Services KMS key identifier for the destination Amazon Web Services Region. Amazon Web Services KMS CMKs are specific to the Amazon Web Services Region
    ///             that they are created in, and you can't use CMKs from one Amazon Web Services Region in another
    ///             Amazon Web Services Region.
    ///
    public var kmsKeyId: Swift.String?
    /// The name of an option group to associate with the copy of the snapshot.
    ///
    ///         Specify this option if you are copying a snapshot from one Amazon Web Services Region to another,
    ///             and your DB instance uses a nondefault option group.
    ///             If your source DB instance uses Transparent Data Encryption for Oracle or Microsoft SQL Server,
    ///             you must specify this option when copying across Amazon Web Services Regions.
    ///             For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CopySnapshot.html#USER_CopySnapshot.Options">Option group considerations in the Amazon RDS User Guide.
    ///
    public var optionGroupName: Swift.String?
    /// The URL that contains a Signature Version 4 signed request for the
    ///                 CopyDBSnapshot API action in the source Amazon Web Services Region that contains the
    ///             source DB snapshot to copy.
    ///
    ///         You must specify this parameter when you copy an encrypted DB snapshot from another
    ///             Amazon Web Services Region by using the Amazon RDS API. Don't specify PreSignedUrl when you are
    ///             copying an encrypted DB snapshot in the same Amazon Web Services Region.
    ///
    ///         The presigned URL must be a valid request for the CopyDBSnapshot API action
    ///             that can be executed in the source Amazon Web Services Region that contains the encrypted DB snapshot to be copied.
    ///             The presigned URL request must contain the following parameter values:
    ///
    ///
    ///
    ///
    ///
    ///                   DestinationRegion - The Amazon Web Services Region that the encrypted DB snapshot is copied to.
    ///                     This Amazon Web Services Region is the same one where the CopyDBSnapshot action is called that contains this presigned URL.
    ///
    ///
    ///                 For example, if you copy an encrypted DB snapshot from the us-west-2 Amazon Web Services Region
    ///                     to the us-east-1 Amazon Web Services Region, then you call the CopyDBSnapshot action in
    ///                     the us-east-1 Amazon Web Services Region and provide a presigned URL that contains a call to the
    ///                         CopyDBSnapshot action in the us-west-2 Amazon Web Services Region. For this
    ///                     example, the DestinationRegion in the presigned URL must be set to
    ///                     the us-east-1 Amazon Web Services Region.
    ///
    ///
    ///
    ///                   KmsKeyId - The Amazon Web Services KMS key identifier for the customer master key (CMK) to use to encrypt the copy of the DB snapshot in the destination Amazon Web Services Region.
    ///                     This is the same identifier for both the CopyDBSnapshot action that is called in the destination Amazon Web Services Region,
    ///                     and the action contained in the presigned URL.
    ///
    ///
    ///
    ///
    ///                   SourceDBSnapshotIdentifier - The DB snapshot identifier for the encrypted snapshot to be copied.
    ///                     This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region.
    ///                     For example, if you are copying an encrypted DB snapshot from the us-west-2 Amazon Web Services Region, then your SourceDBSnapshotIdentifier looks like
    ///                     the following example: arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20161115.
    ///
    ///
    ///
    ///
    /// 	        To learn how to generate a Signature Version 4 signed request, see
    /// 		<a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and
    /// 		<a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature Version 4 Signing Process.
    /// 	
    ///
    ///
    ///            If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI)
    ///                instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a pre-signed URL that is a valid
    ///                request for the operation that can be executed in the source Amazon Web Services Region.
    ///
    public var preSignedUrl: Swift.String?
    /// The identifier for the source DB snapshot.
    ///
    ///          If the source snapshot is in the same Amazon Web Services Region as the copy, specify a valid DB
    ///             snapshot identifier. For example, you might specify
    ///                 rds:mysql-instance1-snapshot-20130805.
    ///
    ///          If the source snapshot is in a different Amazon Web Services Region than the copy, specify a valid DB
    ///             snapshot ARN. For example, you might specify
    ///                 arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805.
    ///
    ///          If you are copying from a shared manual DB snapshot,
    ///           this parameter must be the Amazon Resource Name (ARN) of the shared DB snapshot.
    ///
    ///
    ///          If you are copying an encrypted snapshot
    ///             this parameter must be in the ARN format for the source Amazon Web Services Region,
    ///             and must match the SourceDBSnapshotIdentifier in the PreSignedUrl parameter.
    ///
    ///
    ///          Constraints:
    ///
    ///
    ///                Must specify a valid system snapshot in the "available" state.
    ///
    ///
    ///
    ///          Example: rds:mydb-2012-04-02-00-01
    ///
    ///
    ///          Example: arn:aws:rds:us-west-2:123456789012:snapshot:mysql-instance1-snapshot-20130805
    ///
    /// This member is required.
    public var sourceDBSnapshotIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// The external custom Availability Zone (CAZ) identifier for the target CAZ.
    ///         Example: rds-caz-aiqhTgQv.
    public var targetCustomAvailabilityZone: Swift.String?
    /// The identifier for the copy of the snapshot.
    ///
    ///
    ///         Constraints:
    ///
    ///
    ///
    ///                Can't be null, empty, or blank
    ///
    ///
    ///                Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///
    ///         Example: my-db-snapshot
    ///
    /// This member is required.
    public var targetDBSnapshotIdentifier: Swift.String?

    public init (
        copyTags: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetCustomAvailabilityZone: Swift.String? = nil,
        targetDBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.preSignedUrl = preSignedUrl
        self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
        self.tags = tags
        self.targetCustomAvailabilityZone = targetCustomAvailabilityZone
        self.targetDBSnapshotIdentifier = targetDBSnapshotIdentifier
    }
}

extension CopyDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyDBSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyDBSnapshotOutputResponse(dBSnapshot: \(Swift.String(describing: dBSnapshot)))"}
}

extension CopyDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct CopyDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSnapshots action.
    ///
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct CopyDBSnapshotOutputResponseBody: Swift.Equatable {
    public let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension CopyDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct CopyOptionGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyOptionGroupOutputError>
}

extension CopyOptionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyOptionGroupInput(sourceOptionGroupIdentifier: \(Swift.String(describing: sourceOptionGroupIdentifier)), tags: \(Swift.String(describing: tags)), targetOptionGroupDescription: \(Swift.String(describing: targetOptionGroupDescription)), targetOptionGroupIdentifier: \(Swift.String(describing: targetOptionGroupIdentifier)))"}
}

extension CopyOptionGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceOptionGroupIdentifier = sourceOptionGroupIdentifier {
            try container.encode(sourceOptionGroupIdentifier, forKey: ClientRuntime.Key("SourceOptionGroupIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetOptionGroupDescription = targetOptionGroupDescription {
            try container.encode(targetOptionGroupDescription, forKey: ClientRuntime.Key("TargetOptionGroupDescription"))
        }
        if let targetOptionGroupIdentifier = targetOptionGroupIdentifier {
            try container.encode(targetOptionGroupIdentifier, forKey: ClientRuntime.Key("TargetOptionGroupIdentifier"))
        }
        try container.encode("CopyOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CopyOptionGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyOptionGroupOutputError>
}

public struct CopyOptionGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyOptionGroupOutputError>
}

public struct CopyOptionGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyOptionGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyOptionGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyOptionGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyOptionGroupOutputError>
}

///
public struct CopyOptionGroupInput: Swift.Equatable {
    /// The identifier for the source option group.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must specify a valid option group.
    ///
    ///
    /// This member is required.
    public var sourceOptionGroupIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// The description for the copied option group.
    /// This member is required.
    public var targetOptionGroupDescription: Swift.String?
    /// The identifier for the copied option group.
    ///          Constraints:
    ///
    ///
    ///                Can't be null, empty, or blank
    ///
    ///
    ///                Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-option-group
    ///
    /// This member is required.
    public var targetOptionGroupIdentifier: Swift.String?

    public init (
        sourceOptionGroupIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetOptionGroupDescription: Swift.String? = nil,
        targetOptionGroupIdentifier: Swift.String? = nil
    )
    {
        self.sourceOptionGroupIdentifier = sourceOptionGroupIdentifier
        self.tags = tags
        self.targetOptionGroupDescription = targetOptionGroupDescription
        self.targetOptionGroupIdentifier = targetOptionGroupIdentifier
    }
}

extension CopyOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CopyOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OptionGroupAlreadyExistsFault" : self = .optionGroupAlreadyExistsFault(try OptionGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupQuotaExceededFault" : self = .optionGroupQuotaExceededFault(try OptionGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case optionGroupAlreadyExistsFault(OptionGroupAlreadyExistsFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case optionGroupQuotaExceededFault(OptionGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyOptionGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyOptionGroupOutputResponse(optionGroup: \(Swift.String(describing: optionGroup)))"}
}

extension CopyOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct CopyOptionGroupOutputResponse: Swift.Equatable {
    ///
    public var optionGroup: RdsClientTypes.OptionGroup?

    public init (
        optionGroup: RdsClientTypes.OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct CopyOptionGroupOutputResponseBody: Swift.Equatable {
    public let optionGroup: RdsClientTypes.OptionGroup?
}

extension CopyOptionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CopyOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

public struct CreateCustomAvailabilityZoneInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomAvailabilityZoneInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomAvailabilityZoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomAvailabilityZoneOutputError>
}

extension CreateCustomAvailabilityZoneInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomAvailabilityZoneInput(customAvailabilityZoneName: \(Swift.String(describing: customAvailabilityZoneName)), existingVpnId: \(Swift.String(describing: existingVpnId)), newVpnTunnelName: \(Swift.String(describing: newVpnTunnelName)), vpnTunnelOriginatorIP: \(Swift.String(describing: vpnTunnelOriginatorIP)))"}
}

extension CreateCustomAvailabilityZoneInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneName = customAvailabilityZoneName {
            try container.encode(customAvailabilityZoneName, forKey: ClientRuntime.Key("CustomAvailabilityZoneName"))
        }
        if let existingVpnId = existingVpnId {
            try container.encode(existingVpnId, forKey: ClientRuntime.Key("ExistingVpnId"))
        }
        if let newVpnTunnelName = newVpnTunnelName {
            try container.encode(newVpnTunnelName, forKey: ClientRuntime.Key("NewVpnTunnelName"))
        }
        if let vpnTunnelOriginatorIP = vpnTunnelOriginatorIP {
            try container.encode(vpnTunnelOriginatorIP, forKey: ClientRuntime.Key("VpnTunnelOriginatorIP"))
        }
        try container.encode("CreateCustomAvailabilityZone", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateCustomAvailabilityZoneInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomAvailabilityZoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomAvailabilityZoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomAvailabilityZoneOutputError>
}

public struct CreateCustomAvailabilityZoneInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomAvailabilityZoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomAvailabilityZoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomAvailabilityZoneOutputError>
}

public struct CreateCustomAvailabilityZoneInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomAvailabilityZoneInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateCustomAvailabilityZoneInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCustomAvailabilityZoneInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomAvailabilityZoneOutputError>
}

///
public struct CreateCustomAvailabilityZoneInput: Swift.Equatable {
    /// The name of the custom Availability Zone (AZ).
    /// This member is required.
    public var customAvailabilityZoneName: Swift.String?
    /// The ID of an existing virtual private network (VPN) between the Amazon RDS website and
    ///             the VMware vSphere cluster.
    public var existingVpnId: Swift.String?
    /// The name of a new VPN tunnel between the Amazon RDS website and the VMware vSphere cluster.
    ///         Specify this parameter only if ExistingVpnId isn't specified.
    public var newVpnTunnelName: Swift.String?
    /// The IP address of network traffic from your on-premises data center. A custom AZ receives the network traffic.
    ///         Specify this parameter only if ExistingVpnId isn't specified.
    public var vpnTunnelOriginatorIP: Swift.String?

    public init (
        customAvailabilityZoneName: Swift.String? = nil,
        existingVpnId: Swift.String? = nil,
        newVpnTunnelName: Swift.String? = nil,
        vpnTunnelOriginatorIP: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneName = customAvailabilityZoneName
        self.existingVpnId = existingVpnId
        self.newVpnTunnelName = newVpnTunnelName
        self.vpnTunnelOriginatorIP = vpnTunnelOriginatorIP
    }
}

extension CreateCustomAvailabilityZoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCustomAvailabilityZoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneAlreadyExists" : self = .customAvailabilityZoneAlreadyExistsFault(try CustomAvailabilityZoneAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CustomAvailabilityZoneQuotaExceeded" : self = .customAvailabilityZoneQuotaExceededFault(try CustomAvailabilityZoneQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomAvailabilityZoneOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneAlreadyExistsFault(CustomAvailabilityZoneAlreadyExistsFault)
    case customAvailabilityZoneQuotaExceededFault(CustomAvailabilityZoneQuotaExceededFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomAvailabilityZoneOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomAvailabilityZoneOutputResponse(customAvailabilityZone: \(Swift.String(describing: customAvailabilityZone)))"}
}

extension CreateCustomAvailabilityZoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomAvailabilityZoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZone = output.customAvailabilityZone
        } else {
            self.customAvailabilityZone = nil
        }
    }
}

public struct CreateCustomAvailabilityZoneOutputResponse: Swift.Equatable {
    /// A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster.
    ///         For more information about RDS on VMware, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                 RDS on VMware User Guide.
    ///
    public var customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?

    public init (
        customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone? = nil
    )
    {
        self.customAvailabilityZone = customAvailabilityZone
    }
}

struct CreateCustomAvailabilityZoneOutputResponseBody: Swift.Equatable {
    public let customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?
}

extension CreateCustomAvailabilityZoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZone = "CustomAvailabilityZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateCustomAvailabilityZoneResult"))
        let customAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CustomAvailabilityZone.self, forKey: .customAvailabilityZone)
        customAvailabilityZone = customAvailabilityZoneDecoded
    }
}

public struct CreateDBClusterEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

extension CreateDBClusterEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterEndpointInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBClusterEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBClusterEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBClusterEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterEndpointOutputError>
}

public struct CreateDBClusterEndpointInput: Swift.Equatable {
    /// The identifier to use for the new endpoint. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, ANY.
    /// This member is required.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The tags to be assigned to the Amazon RDS resource.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.tags = tags
    }
}

extension CreateDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointAlreadyExistsFault" : self = .dBClusterEndpointAlreadyExistsFault(try DBClusterEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterEndpointQuotaExceededFault" : self = .dBClusterEndpointQuotaExceededFault(try DBClusterEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointAlreadyExistsFault(DBClusterEndpointAlreadyExistsFault)
    case dBClusterEndpointQuotaExceededFault(DBClusterEndpointQuotaExceededFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterEndpointOutputResponse(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension CreateDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:
///
///
///
///                   CreateDBClusterEndpoint
///
///
///
///
///                   DescribeDBClusterEndpoints
///
///
///
///
///                   ModifyDBClusterEndpoint
///
///
///
///
///                   DeleteDBClusterEndpoint
///
///
///
///          For the data structure that represents Amazon RDS DB instance endpoints,
///         see Endpoint.
public struct CreateDBClusterEndpointOutputResponse: Swift.Equatable {
    /// The type associated with a custom endpoint. One of: READER,
    ///        WRITER, ANY.
    public var customEndpointType: Swift.String?
    /// The Amazon Resource Name (ARN) for the endpoint.
    public var dBClusterEndpointArn: Swift.String?
    /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
    public var dBClusterEndpointResourceIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// The DNS address of the endpoint.
    public var endpoint: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a writer endpoint for a read-only secondary cluster in a global database.
    public var status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct CreateDBClusterEndpointOutputResponseBody: Swift.Equatable {
    public let dBClusterEndpointIdentifier: Swift.String?
    public let dBClusterIdentifier: Swift.String?
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    public let endpoint: Swift.String?
    public let status: Swift.String?
    public let endpointType: Swift.String?
    public let customEndpointType: Swift.String?
    public let staticMembers: [Swift.String]?
    public let excludedMembers: [Swift.String]?
    public let dBClusterEndpointArn: Swift.String?
}

extension CreateDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct CreateDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

extension CreateDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterInput(availabilityZones: \(Swift.String(describing: availabilityZones)), backtrackWindow: \(Swift.String(describing: backtrackWindow)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableGlobalWriteForwarding: \(Swift.String(describing: enableGlobalWriteForwarding)), enableHttpEndpoint: \(Swift.String(describing: enableHttpEndpoint)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), engineMode: \(Swift.String(describing: engineMode)), engineVersion: \(Swift.String(describing: engineVersion)), globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), replicationSourceIdentifier: \(Swift.String(describing: replicationSourceIdentifier)), scalingConfiguration: \(Swift.String(describing: scalingConfiguration)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableGlobalWriteForwarding = enableGlobalWriteForwarding {
            try container.encode(enableGlobalWriteForwarding, forKey: ClientRuntime.Key("EnableGlobalWriteForwarding"))
        }
        if let enableHttpEndpoint = enableHttpEndpoint {
            try container.encode(enableHttpEndpoint, forKey: ClientRuntime.Key("EnableHttpEndpoint"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

public struct CreateDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterOutputError>
}

///
public struct CreateDBClusterInput: Swift.Equatable {
    /// A list of Availability Zones (AZs) where instances in the DB cluster can be created. For information on
    ///             Amazon Web Services Regions and Availability Zones, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Concepts.RegionsAndAvailabilityZones.html">Choosing the Regions and
    ///                 Availability Zones in the Amazon Aurora User Guide.
    ///
    public var availabilityZones: [Swift.String]?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.
    ///
    ///             Currently, Backtrack is only supported for Aurora MySQL DB clusters.
    ///
    ///          Default: 0
    ///          Constraints:
    ///
    ///
    ///                If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    public var backtrackWindow: Swift.Int?
    /// The number of days for which automated backups are retained.
    ///          Default: 1
    ///          Constraints:
    ///
    ///
    ///                Must be a value from 1 to 35
    ///
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// A value that indicates that the DB cluster should be associated with the specified CharacterSet.
    public var characterSetName: Swift.String?
    /// A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.
    ///             The default is not to copy them.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The DB cluster identifier. This parameter is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///          Example: my-cluster1
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    ///
    ///             The name of the DB cluster parameter group to associate
    ///             with this DB cluster. If you do not specify a value, then
    ///           the default DB cluster parameter group for the specified DB engine and version is used.
    ///
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DB cluster parameter group.
    ///
    ///
    public var dBClusterParameterGroupName: Swift.String?
    /// A DB subnet group to associate with this DB cluster.
    ///          Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.
    ///          Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// The name for your database of up to 64 alphanumeric characters. If you do not
    ///             provide a name, Amazon RDS doesn't create a database in the DB cluster you are
    ///             creating.
    public var databaseName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to create the DB cluster in.
    ///
    ///          For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication
    ///          in the Amazon Aurora User Guide.
    ///
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of log types that need to be enabled for exporting to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
    ///
    ///             Aurora MySQL
    ///
    ///         Possible values are audit, error, general, and slowquery.
    ///
    ///
    ///             Aurora PostgreSQL
    ///
    ///         Possible value is postgresql.
    ///
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable this DB cluster to forward write operations to the primary cluster of an
    ///       Aurora global database (GlobalCluster). By default, write operations are not allowed on Aurora DB clusters that
    ///       are secondary clusters in an Aurora global database.
    ///          You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter
    ///       enabled, a secondary cluster can forward writes to the current primary cluster and the resulting changes are replicated back to
    ///       this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the
    ///         primary is demoted by the FailoverGlobalCluster API operation, but it does nothing until then.
    ///
    public var enableGlobalWriteForwarding: Swift.Bool?
    /// A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint
    ///             is disabled.
    ///         When enabled, the HTTP endpoint provides a connectionless web service API for running
    ///             SQL queries on the Aurora Serverless DB cluster. You can also query your database
    ///             from inside the RDS console with the query editor.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API for Aurora Serverless in the
    ///             Amazon Aurora User Guide.
    public var enableHttpEndpoint: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication in the Amazon Aurora User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The name of the database engine to be used for this DB cluster.
    ///          Valid Values: aurora (for MySQL 5.6-compatible Aurora), aurora-mysql (for MySQL 5.7-compatible Aurora), and aurora-postgresql
    ///
    /// This member is required.
    public var engine: Swift.String?
    /// The DB engine mode of the DB cluster, either provisioned, serverless,
    ///             parallelquery, global, or multimaster.
    ///         The parallelquery engine mode isn't required for Aurora MySQL version 1.23 and higher 1.x versions,
    ///             and version 2.09 and higher 2.x versions.
    ///         The global engine mode isn't required for Aurora MySQL version 1.22 and higher 1.x versions,
    ///             and global engine mode isn't required for any 2.x versions.
    ///         The multimaster engine mode only applies for DB clusters created with Aurora MySQL version 5.6.10a.
    ///         For Aurora PostgreSQL, the global engine mode isn't required, and both the parallelquery
    ///             and the multimaster engine modes currently aren't supported.
    ///         Limitations and requirements apply to some DB engine modes. For more information, see the
    ///             following sections in the Amazon Aurora User Guide:
    ///
    ///
    ///
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html#aurora-serverless.limitations">
    ///                         Limitations of Aurora Serverless
    ///
    ///
    ///
    ///
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html#aurora-mysql-parallel-query-limitations">
    ///                         Limitations of Parallel Query
    ///
    ///
    ///
    ///
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-global-database.html#aurora-global-database.limitations">
    ///                         Limitations of Aurora Global Databases
    ///
    ///
    ///
    ///
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-multi-master.html#aurora-multi-master-limitations">
    ///                         Limitations of Multi-Master Clusters
    ///
    ///
    ///
    public var engineMode: Swift.String?
    /// The version number of the database engine to use.
    ///          To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"
    ///
    ///          To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"
    ///
    ///          To list all of the available engine versions for aurora-postgresql, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"
    ///
    ///
    ///             Aurora MySQL
    ///
    ///          Example: 5.6.10a, 5.6.mysql_aurora.1.19.2, 5.7.12, 5.7.mysql_aurora.2.04.5
    ///
    ///
    ///             Aurora PostgreSQL
    ///
    ///          Example: 9.6.3, 10.7
    ///
    public var engineVersion: Swift.String?
    ///
    ///         The global cluster ID of an Aurora cluster that becomes the primary cluster
    ///         in the new global database cluster.
    ///
    public var globalClusterIdentifier: Swift.String?
    /// The Amazon Web Services KMS key identifier for an encrypted DB cluster.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///                  To use a CMK in a different Amazon Web Services account, specify the key ARN or alias ARN.
    ///         When a CMK isn't specified in KmsKeyId:
    ///
    ///
    ///                 If ReplicationSourceIdentifier identifies an encrypted
    ///                     source, then Amazon RDS will use the CMK used to encrypt the
    ///                     source. Otherwise, Amazon RDS will use your default CMK.
    ///
    ///
    ///                 If the StorageEncrypted parameter is enabled and
    ///                         ReplicationSourceIdentifier isn't specified, then Amazon RDS
    ///                     will use your default CMK.
    ///
    ///
    ///         There is a default CMK for your Amazon Web Services account. Your Amazon Web Services account
    ///             has a different default CMK for each Amazon Web Services Region.
    ///         If you create a read replica of an encrypted DB cluster in another Amazon Web Services Region, you
    ///             must set KmsKeyId to a Amazon Web Services KMS key identifier that is valid in the destination Amazon Web Services
    ///             Region. This CMK is used to encrypt the read replica in that Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
    ///          Constraints: Must contain from 8 to 41 characters.
    public var masterUserPassword: Swift.String?
    /// The name of the master user for the DB cluster.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 16 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    public var masterUsername: Swift.String?
    /// A value that indicates that the DB cluster should be associated with the specified option group.
    ///          Permanent options can't be removed from an option group. The option group can't be removed from a DB cluster once it is associated with a DB cluster.
    public var optionGroupName: Swift.String?
    /// The port number on which the instances in the DB cluster accept connections.
    ///
    ///             Default: 3306 if engine is set as aurora or 5432 if set to aurora-postgresql.
    ///
    public var port: Swift.Int?
    /// A URL that contains a Signature Version 4 signed request for
    ///             the CreateDBCluster action to be called in the source Amazon Web Services Region where the DB cluster is replicated from.
    ///             You only need to specify PreSignedUrl when you are performing cross-region replication from an encrypted DB cluster.
    ///
    ///         The pre-signed URL must be a valid request for the CreateDBCluster API action
    ///             that can be executed in the source Amazon Web Services Region that contains the encrypted DB cluster to be copied.
    ///         The pre-signed URL request must contain the following parameter values:
    ///
    ///
    ///
    ///                   KmsKeyId - The Amazon Web Services KMS key identifier for the key to use to encrypt the copy of
    ///                 the DB cluster in the destination Amazon Web Services Region. This should refer to the same Amazon Web Services KMS CMK for both the CreateDBCluster
    ///                 action that is called in the destination Amazon Web Services Region, and the action contained in the pre-signed URL.
    ///
    ///
    ///
    ///                   DestinationRegion - The name of the Amazon Web Services Region that Aurora read replica will
    ///                     be created in.
    ///
    ///
    ///
    ///                   ReplicationSourceIdentifier - The DB cluster identifier for the encrypted DB cluster to be copied.
    ///                 This identifier must be in the Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you are copying an
    ///                 encrypted DB cluster from the us-west-2 Amazon Web Services Region, then your ReplicationSourceIdentifier would look like
    ///                 Example: arn:aws:rds:us-west-2:123456789012:cluster:aurora-cluster1.
    ///
    ///
    ///
    ///         To learn how to generate a Signature Version 4 signed request, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">
    ///                 Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and
    ///             <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">
    ///                 Signature Version 4 Signing Process.
    ///
    ///             If you are using an Amazon Web Services SDK tool or the CLI, you can specify SourceRegion (or --source-region for the CLI)
    ///                 instead of specifying PreSignedUrl manually. Specifying SourceRegion autogenerates a pre-signed URL that is a valid
    ///                 request for the operation that can be executed in the source Amazon Web Services Region.
    ///
    public var preSignedUrl: Swift.String?
    /// The daily time range during which automated backups are created
    ///         if automated backups are enabled
    ///         using the BackupRetentionPeriod parameter.
    ///
    ///          The default is a 30-minute window selected at random from an
    ///         8-hour block of time for each Amazon Web Services Region.
    ///         To view the time blocks available, see
    ///         <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow">
    ///             Backup window in the Amazon Aurora User Guide.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred maintenance window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
    ///          Format: ddd:hh24:mi-ddd:hh24:mi
    ///
    ///          The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region, occurring on a random day of the
    ///             week. To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora">
    ///                 Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide.
    ///
    ///          Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
    ///          Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB
    ///             cluster is created as a read replica.
    public var replicationSourceIdentifier: Swift.String?
    /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster.
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// A value that indicates whether the DB cluster is encrypted.
    public var storageEncrypted: Swift.Bool?
    /// Tags to assign to the DB cluster.
    public var tags: [RdsClientTypes.Tag]?
    /// A list of EC2 VPC security groups to associate with this DB cluster.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        backtrackWindow: Swift.Int? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableGlobalWriteForwarding: Swift.Bool? = nil,
        enableHttpEndpoint: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineMode: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        preSignedUrl: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        replicationSourceIdentifier: Swift.String? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        storageEncrypted: Swift.Bool? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
        self.enableHttpEndpoint = enableHttpEndpoint
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationSourceIdentifier = replicationSourceIdentifier
        self.scalingConfiguration = scalingConfiguration
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension CreateDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct CreateDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct CreateDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension CreateDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct CreateDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

extension CreateDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

public struct CreateDBClusterParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBClusterParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBClusterParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterParameterGroupOutputError>
}

///
public struct CreateDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must match the name of an existing DB cluster parameter group.
    ///
    ///
    ///
    ///             This value is stored as a lowercase string.
    ///
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// The DB cluster parameter group family name. A DB cluster parameter group can be associated with one and only one DB cluster
    ///           parameter group family, and can be applied only to a DB cluster running a database engine and engine version compatible with that DB cluster parameter group family.
    ///
    ///             Aurora MySQL
    ///
    ///          Example: aurora5.6, aurora-mysql5.7
    ///
    ///
    ///             Aurora PostgreSQL
    ///
    ///          Example: aurora-postgresql9.6
    ///
    ///          To list all of the available parameter group families for a DB engine, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine <engine>
    ///
    ///          For example, to list all of the available parameter group families for the Aurora PostgreSQL DB engine, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine aurora-postgresql
    ///
    ///
    ///             The output contains duplicates.
    ///
    ///          The following are the valid DB engine values:
    ///
    ///
    ///
    ///                   aurora (for MySQL 5.6-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-postgresql
    ///
    ///
    ///
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// The description for the DB cluster parameter group.
    /// This member is required.
    public var description: Swift.String?
    /// Tags to assign to the DB cluster parameter group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        dBParameterGroupFamily: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.description = description
        self.tags = tags
    }
}

extension CreateDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterParameterGroupOutputResponse(dBClusterParameterGroup: \(Swift.String(describing: dBClusterParameterGroup)))"}
}

extension CreateDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroup = output.dBClusterParameterGroup
        } else {
            self.dBClusterParameterGroup = nil
        }
    }
}

public struct CreateDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB cluster parameter group.
    ///
    ///          This data type is used as a response element in the DescribeDBClusterParameterGroups action.
    ///
    public var dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?

    public init (
        dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup? = nil
    )
    {
        self.dBClusterParameterGroup = dBClusterParameterGroup
    }
}

struct CreateDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroup: RdsClientTypes.DBClusterParameterGroup?
}

extension CreateDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroup = "DBClusterParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterParameterGroupResult"))
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterParameterGroup.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
    }
}

public struct CreateDBClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

extension CreateDBClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterSnapshotInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

public struct CreateDBClusterSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBClusterSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBClusterSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBClusterSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBClusterSnapshotOutputError>
}

///
public struct CreateDBClusterSnapshotInput: Swift.Equatable {
    /// The identifier of the DB cluster to create a snapshot for. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBCluster.
    ///
    ///
    ///          Example: my-cluster1
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The identifier of the DB cluster snapshot. This parameter is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///          Example: my-cluster1-snapshot1
    ///
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?
    /// The tags to be assigned to the DB cluster snapshot.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.tags = tags
    }
}

extension CreateDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(Swift.String(describing: dBClusterSnapshot)))"}
}

extension CreateDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct CreateDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB cluster snapshot
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBClusterSnapshots action.
    ///
    public var dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct CreateDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?
}

extension CreateDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct CreateDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

extension CreateDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBName: \(Swift.String(describing: dBName)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableCustomerOwnedIp: \(Swift.String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(Swift.String(describing: enablePerformanceInsights)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), ncharCharacterSetName: \(Swift.String(describing: ncharCharacterSetName)), optionGroupName: \(Swift.String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(Swift.String(describing: performanceInsightsRetentionPeriod)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), processorFeatures: \(Swift.String(describing: processorFeatures)), promotionTier: \(Swift.String(describing: promotionTier)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), storageType: \(Swift.String(describing: storageType)), tags: \(Swift.String(describing: tags)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), tdeCredentialPassword: \(Swift.String(describing: tdeCredentialPassword)), timezone: \(Swift.String(describing: timezone)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let ncharCharacterSetName = ncharCharacterSetName {
            try container.encode(ncharCharacterSetName, forKey: ClientRuntime.Key("NcharCharacterSetName"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

public struct CreateDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceOutputError>
}

///
public struct CreateDBInstanceInput: Swift.Equatable {
    /// The amount of storage in gibibytes (GiB) to allocate for the DB instance.
    ///          Type: Integer
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. Aurora cluster volumes automatically grow as the amount of data in your
    ///           database increases, though you are only charged for the space that you use in an Aurora cluster volume.
    ///
    ///
    ///             MySQL
    ///
    ///          Constraints to the amount of storage for each storage type are the following:
    ///
    ///
    ///
    ///                General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    ///
    ///                Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    ///
    ///                Magnetic storage (standard): Must be an integer from 5 to 3072.
    ///
    ///
    ///
    ///
    ///             MariaDB
    ///
    ///          Constraints to the amount of storage for each storage type are the following:
    ///
    ///
    ///
    ///                General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    ///
    ///                Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    ///
    ///                Magnetic storage (standard): Must be an integer from 5 to 3072.
    ///
    ///
    ///
    ///
    ///             PostgreSQL
    ///
    ///          Constraints to the amount of storage for each storage type are the following:
    ///
    ///
    ///
    ///                General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    ///
    ///                Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    ///
    ///                Magnetic storage (standard): Must be an integer from 5 to 3072.
    ///
    ///
    ///
    ///
    ///             Oracle
    ///
    ///          Constraints to the amount of storage for each storage type are the following:
    ///
    ///
    ///
    ///                General Purpose (SSD) storage (gp2): Must be an integer from 20 to 65536.
    ///
    ///
    ///                Provisioned IOPS storage (io1): Must be an integer from 100 to 65536.
    ///
    ///
    ///                Magnetic storage (standard): Must be an integer from 10 to 3072.
    ///
    ///
    ///
    ///
    ///             SQL Server
    ///
    ///          Constraints to the amount of storage for each storage type are the following:
    ///
    ///
    ///
    ///                General Purpose (SSD) storage (gp2):
    ///
    ///
    ///                      Enterprise and Standard editions: Must be an integer from 200 to 16384.
    ///
    ///
    ///                      Web and Express editions: Must be an integer from 20 to 16384.
    ///
    ///
    ///
    ///
    ///                Provisioned IOPS storage (io1):
    ///
    ///
    ///                      Enterprise and Standard editions: Must be an integer from 200 to 16384.
    ///
    ///
    ///                      Web and Express editions: Must be an integer from 100 to 16384.
    ///
    ///
    ///
    ///
    ///                Magnetic storage (standard):
    ///
    ///
    ///                      Enterprise and Standard editions: Must be an integer from 200 to 1024.
    ///
    ///
    ///                      Web and Express editions: Must be an integer from 20 to 1024.
    ///
    ///
    ///
    ///
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically to the DB instance during the maintenance window.
    ///           By default, minor engine upgrades are applied automatically.
    public var autoMinorVersionUpgrade: Swift.Bool?
    ///
    ///         The Availability Zone (AZ) where the database will be created. For information on
    ///         Amazon Web Services Regions and Availability Zones, see
    ///         <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">Regions
    ///         and Availability Zones.
    ///
    ///          Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region.
    ///
    ///             Example: us-east-1d
    ///
    ///
    ///           Constraint: The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment.
    ///             The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint.
    ///
    ///
    ///             If you're creating a DB instance in an RDS on VMware environment,
    ///                 specify the identifier of the custom Availability Zone to create the DB instance
    ///                 in.
    ///             For more information about RDS on VMware, see the
    ///               <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                   RDS on VMware User Guide.
    ///
    ///
    public var availabilityZone: Swift.String?
    /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The retention period for automated backups is managed by the DB
    ///           cluster.
    ///          Default: 1
    ///          Constraints:
    ///
    ///
    ///                Must be a value from 0 to 35
    ///
    ///
    ///                Can't be set to 0 if the DB instance is a source to read replicas
    ///
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// For supported engines, indicates that the DB instance should be associated with the specified CharacterSet.
    ///
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The character set is managed by
    ///           the DB cluster. For more information, see CreateDBCluster.
    public var characterSetName: Swift.String?
    /// A value that indicates whether to copy tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this
    ///           value for an Aurora DB instance has no effect on the DB cluster setting.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The identifier of the DB cluster that the instance will belong to.
    public var dBClusterIdentifier: Swift.String?
    /// The compute and memory capacity of the DB instance, for example, db.m4.large.
    ///           Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class in the Amazon RDS User Guide.
    ///
    /// This member is required.
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier. This parameter is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///          Example: mydbinstance
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The meaning of this parameter differs according to the database engine you use.
    ///
    ///             MySQL
    ///
    ///          The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance.
    ///          Constraints:
    ///
    ///
    ///                Must contain 1 to 64 letters or numbers.
    ///
    ///
    ///                Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
    ///
    ///
    ///                Can't be a word reserved by the specified database engine
    ///
    ///
    ///
    ///             MariaDB
    ///
    ///          The name of the database to create when the DB instance is created. If this parameter isn't specified, no database is created in the DB instance.
    ///          Constraints:
    ///
    ///
    ///                Must contain 1 to 64 letters or numbers.
    ///
    ///
    ///                Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
    ///
    ///
    ///                Can't be a word reserved by the specified database engine
    ///
    ///
    ///
    ///             PostgreSQL
    ///
    ///          The name of the database to create when the DB instance is created. If this parameter isn't specified, a database named postgres
    ///           is created in the DB instance.
    ///          Constraints:
    ///
    ///
    ///                Must contain 1 to 63 letters, numbers, or underscores.
    ///
    ///
    ///                Must begin with a letter. Subsequent characters can be letters, underscores, or digits (0-9).
    ///
    ///
    ///                Can't be a word reserved by the specified database engine
    ///
    ///
    ///
    ///             Oracle
    ///
    ///          The Oracle System ID (SID) of the created DB instance.
    ///           If you specify null, the default value ORCL is used.
    ///           You can't specify the string NULL, or any other reserved word, for DBName.
    ///
    ///          Default: ORCL
    ///
    ///          Constraints:
    ///
    ///
    ///                Can't be longer than 8 characters
    ///
    ///
    ///
    ///             SQL Server
    ///
    ///          Not applicable. Must be null.
    ///
    ///             Amazon Aurora MySQL
    ///
    ///          The name of the database to create when the primary DB instance of the Aurora MySQL DB cluster is
    ///           created. If this parameter isn't specified for an Aurora MySQL DB cluster, no database is created
    ///           in the DB cluster.
    ///          Constraints:
    ///
    ///
    ///               It must contain 1 to 64 alphanumeric characters.
    ///
    ///
    ///               It can't be a word reserved by the database engine.
    ///
    ///
    ///
    ///             Amazon Aurora PostgreSQL
    ///
    ///          The name of the database to create when the primary DB instance of the Aurora PostgreSQL DB cluster is
    ///           created. If this parameter isn't specified for an Aurora PostgreSQL DB cluster,
    ///           a database named postgres is created in the DB cluster.
    ///          Constraints:
    ///
    ///
    ///               It must contain 1 to 63 alphanumeric characters.
    ///
    ///
    ///               It must begin with a letter or an underscore.
    ///                   Subsequent characters can be letters, underscores, or digits
    ///                   (0 to 9).
    ///
    ///
    ///               It can't be a word reserved by the
    ///                   database engine.
    ///
    ///
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance. If you do not specify a value, then
    ///           the default DB parameter group for the specified DB engine and version is used.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    public var dBParameterGroupName: Swift.String?
    /// A list of DB security groups to associate with this DB instance.
    ///          Default: The default DB security group for the database engine.
    public var dBSecurityGroups: [Swift.String]?
    /// A DB subnet group to associate with this DB instance.
    ///          If there is no DB subnet group, then it is a non-VPC DB instance.
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance.
    ///
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. You can enable or disable deletion protection for the DB cluster.
    ///             For more information, see CreateDBCluster. DB instances in a DB
    ///             cluster can be deleted even when deletion protection is enabled for the DB cluster.
    ///
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL
    ///             Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///            Kerberos Authentication in the Amazon RDS User Guide.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of log types that need to be enabled for exporting to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs  in the Amazon Relational Database
    ///                     Service User Guide.
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. CloudWatch Logs exports are managed by the DB cluster.
    ///
    ///
    ///             MariaDB
    ///
    ///         Possible values are audit, error, general, and slowquery.
    ///
    ///
    ///             Microsoft SQL Server
    ///
    ///         Possible values are agent and error.
    ///
    ///
    ///             MySQL
    ///
    ///         Possible values are audit, error, general, and slowquery.
    ///
    ///
    ///             Oracle
    ///
    ///         Possible values are alert, audit, listener, trace, and
    ///             oemagent.
    ///
    ///
    ///             PostgreSQL
    ///
    ///         Possible values are postgresql and upgrade.
    ///
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS
    ///             on Outposts DB instance.
    ///         A CoIP provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.
    ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on Amazon Web Services Outposts
    ///             in the Amazon RDS User Guide.
    ///         For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses
    ///             in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///          This setting doesn't apply to Amazon Aurora. Mapping Amazon Web Services IAM accounts to database accounts is managed by the DB
    ///         cluster.
    ///
    ///          For more information, see
    ///        <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///            IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the DB instance.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using Amazon Performance Insights in the Amazon Relational Database Service
    ///                     User Guide.
    ///
    public var enablePerformanceInsights: Swift.Bool?
    /// The name of the database engine to be used for this instance.
    ///
    ///
    ///          Not every database engine is available for every Amazon Web Services Region.
    ///
    ///
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   aurora (for MySQL 5.6-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-postgresql
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    /// This member is required.
    public var engine: Swift.String?
    /// The version number of the database engine to use.
    ///          For a list of valid engine versions, use the  DescribeDBEngineVersions action.
    ///          The following are the database engines and links to information about the major and minor versions that are available with
    ///           Amazon RDS. Not every database engine is available for every Amazon Web Services Region.
    ///
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. The version number of the database engine to be used by the DB
    ///             instance is managed by the DB cluster.
    ///
    ///
    ///             MariaDB
    ///
    ///
    ///          See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MariaDB.html#MariaDB.Concepts.VersionMgmt">MariaDB on Amazon RDS Versions in the
    ///           Amazon RDS User Guide.
    ///
    ///
    ///
    ///             Microsoft SQL Server
    ///
    ///
    ///          See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport">Microsoft SQL Server Versions on Amazon RDS in the
    ///           Amazon RDS User Guide.
    ///
    ///
    ///
    ///             MySQL
    ///
    ///
    ///          See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_MySQL.html#MySQL.Concepts.VersionMgmt">MySQL on Amazon RDS Versions in the
    ///           Amazon RDS User Guide.
    ///
    ///
    ///
    ///             Oracle
    ///
    ///
    ///          See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Appendix.Oracle.PatchComposition.html">Oracle Database Engine Release Notes in the
    ///           Amazon RDS User Guide.
    ///
    ///
    ///
    ///             PostgreSQL
    ///
    ///
    ///          See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html#PostgreSQL.Concepts">Amazon RDS for PostgreSQL versions and extensions in the
    ///           Amazon RDS User Guide.
    ///
    public var engineVersion: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.
    ///           For information about valid Iops values, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS">Amazon RDS Provisioned IOPS Storage to Improve Performance in the Amazon RDS User Guide.
    ///
    ///          Constraints: For MariaDB, MySQL, Oracle, and PostgreSQL DB instances, must be a multiple between .5 and 50 of the storage amount for the DB instance.
    ///           For SQL Server DB instances, must be a multiple between 1 and 50 of the storage amount for the DB instance.
    ///
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted DB instance.
    ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///           To use a CMK in a different Amazon Web Services account, specify the key ARN or alias ARN.
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The Amazon Web Services KMS key identifier is managed by
    ///           the DB cluster. For more information, see CreateDBCluster.
    ///          If StorageEncrypted is enabled, and you do
    ///         not specify a value for the KmsKeyId parameter, then
    ///         Amazon RDS uses your default CMK. There is a
    ///         default CMK for your Amazon Web Services account. Your Amazon Web Services account has a different
    ///         default CMK for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// License model information for this DB instance.
    ///
    ///             Valid values:  license-included | bring-your-own-license | general-public-license
    ///
    public var licenseModel: Swift.String?
    /// The password for the master user. The password can include any printable ASCII character except "/", """, or "@".
    ///
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. The password for the master user is managed by the DB
    ///             cluster.
    ///
    ///
    ///             MariaDB
    ///
    ///          Constraints: Must contain from 8 to 41 characters.
    ///
    ///
    ///             Microsoft SQL Server
    ///
    ///          Constraints: Must contain from 8 to 128 characters.
    ///
    ///
    ///             MySQL
    ///
    ///          Constraints: Must contain from 8 to 41 characters.
    ///
    ///
    ///             Oracle
    ///
    ///          Constraints: Must contain from 8 to 30 characters.
    ///
    ///
    ///             PostgreSQL
    ///
    ///          Constraints: Must contain from 8 to 128 characters.
    public var masterUserPassword: Swift.String?
    /// The name for the master user.
    ///
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. The name for the master user is managed by the DB cluster.
    ///
    ///
    ///
    ///             MariaDB
    ///
    ///          Constraints:
    ///
    ///
    ///               Required for MariaDB.
    ///
    ///
    ///               Must be 1 to 16 letters or numbers.
    ///
    ///
    ///               Can't be a reserved word for the chosen database engine.
    ///
    ///
    ///
    ///
    ///             Microsoft SQL Server
    ///
    ///          Constraints:
    ///
    ///
    ///               Required for SQL Server.
    ///
    ///
    ///                Must be 1 to 128 letters or numbers.
    ///
    ///
    ///                The first character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    ///
    ///
    ///             MySQL
    ///
    ///          Constraints:
    ///
    ///
    ///               Required for MySQL.
    ///
    ///
    ///                Must be 1 to 16 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    ///
    ///
    ///             Oracle
    ///
    ///          Constraints:
    ///
    ///
    ///               Required for Oracle.
    ///
    ///
    ///                Must be 1 to 30 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    ///
    ///
    ///             PostgreSQL
    ///
    ///          Constraints:
    ///
    ///
    ///               Required for PostgreSQL.
    ///
    ///
    ///                Must be 1 to 63 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    public var masterUsername: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
    ///         For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling
    ///             in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0.
    ///          If MonitoringRoleArn is specified, then you must also set MonitoringInterval
    ///       to a value other than 0.
    ///          Valid Values: 0, 1, 5, 10, 15, 30, 60
    ///
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For
    ///       example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role,
    ///       go to <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling">Setting Up and Enabling Enhanced Monitoring
    ///           in the Amazon RDS User Guide.
    ///          If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment. You can't set
    ///           the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    public var multiAZ: Swift.Bool?
    /// The name of the NCHAR character set for the Oracle DB instance.
    public var ncharCharacterSetName: Swift.String?
    /// A value that indicates that the DB instance should be associated with the specified option group.
    ///          Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group. Also, that option group can't be removed from a DB instance once it is associated with a DB instance
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///         If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your Amazon Web Services account.
    ///             Your Amazon Web Services account has a different default CMK for each Amazon Web Services Region.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number on which the database accepts connections.
    ///
    ///             MySQL
    ///
    ///
    ///             Default: 3306
    ///
    ///           Valid values: 1150-65535
    ///
    ///          Type: Integer
    ///
    ///             MariaDB
    ///
    ///
    ///       Default: 3306
    ///
    ///           Valid values: 1150-65535
    ///
    ///          Type: Integer
    ///
    ///             PostgreSQL
    ///
    ///
    ///             Default: 5432
    ///
    ///           Valid values: 1150-65535
    ///
    ///          Type: Integer
    ///
    ///             Oracle
    ///
    ///
    ///             Default: 1521
    ///
    ///           Valid values: 1150-65535
    ///
    ///
    ///             SQL Server
    ///
    ///
    ///             Default: 1433
    ///
    ///           Valid values: 1150-65535 except 1234, 1434,
    ///                 3260, 3343, 3389, 47001, and
    ///                 49152-49156.
    ///
    ///             Amazon Aurora
    ///
    ///
    ///       Default: 3306
    ///
    ///           Valid values: 1150-65535
    ///
    ///          Type: Integer
    public var port: Swift.Int?
    ///
    ///         The daily time range during which automated backups are created
    ///         if automated backups are enabled,
    ///         using the BackupRetentionPeriod parameter.
    ///           The default is a 30-minute window selected at random from an
    ///           8-hour block of time for each Amazon Web Services Region. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Backup window in the Amazon RDS User Guide.
    ///
    ///
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The daily time range for creating automated backups is managed by
    ///           the DB cluster.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred maintenance window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredBackupWindow: Swift.String?
    /// The time range each week during which system maintenance can occur,
    ///           in Universal Coordinated Time (UTC).
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance">Amazon RDS Maintenance Window.
    ///
    ///
    ///             Format: ddd:hh24:mi-ddd:hh24:mi
    ///
    ///          The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region, occurring on a random day of the
    ///             week.
    ///
    ///          Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
    ///          Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance
    ///       after a failure of the existing primary instance. For more information,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
    ///           Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide.
    ///
    ///          Default: 1
    ///          Valid Values: 0 - 15
    public var promotionTier: Swift.Int?
    /// A value that indicates whether the DB instance is publicly accessible.
    ///          When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
    ///          When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
    ///          Default: The default behavior varies depending on whether DBSubnetGroupName is specified.
    ///          If DBSubnetGroupName isn't specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    ///
    ///               If the default VPC in the target region doesn’t have an Internet gateway attached to it, the DB instance is private.
    ///
    ///
    ///               If the default VPC in the target region has an Internet gateway attached to it, the DB instance is public.
    ///
    ///
    ///          If DBSubnetGroupName is specified, and PubliclyAccessible isn't specified, the following applies:
    ///
    ///
    ///               If the subnets are part of a VPC that doesn’t have an Internet gateway attached to it, the DB instance is private.
    ///
    ///
    ///               If the subnets are part of a VPC that has an Internet gateway attached to it, the DB instance is public.
    ///
    ///
    public var publiclyAccessible: Swift.Bool?
    /// A value that indicates whether the DB instance is encrypted. By default, it isn't encrypted.
    ///
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The encryption for DB instances is managed by
    ///           the DB cluster.
    public var storageEncrypted: Swift.Bool?
    /// Specifies the storage type to be associated with the DB instance.
    ///
    ///             Valid values: standard | gp2 | io1
    ///
    ///
    ///             If you specify io1, you must also include a value for the
    ///             Iops parameter.
    ///
    ///
    ///             Default: io1 if the Iops parameter
    ///             is specified, otherwise gp2
    ///
    public var storageType: Swift.String?
    /// Tags to assign to the DB instance.
    public var tags: [RdsClientTypes.Tag]?
    /// The ARN from the key store with which to associate the instance for TDE encryption.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device.
    public var tdeCredentialPassword: Swift.String?
    /// The time zone of the DB instance.
    ///             The time zone parameter is currently supported only by
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.TimeZone">Microsoft SQL Server.
    ///
    public var timezone: Swift.String?
    /// A list of Amazon EC2 VPC security groups to associate with this DB instance.
    ///
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The associated list of EC2 VPC security groups is managed by
    ///           the DB cluster.
    ///
    ///          Default: The default EC2 VPC security group for the DB subnet group's VPC.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        ncharCharacterSetName: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        promotionTier: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        storageEncrypted: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        timezone: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.ncharCharacterSetName = ncharCharacterSetName
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.timezone = timezone
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension CreateDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension CreateDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct CreateDBInstanceReadReplicaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceReadReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceReadReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceReadReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceReadReplicaOutputError>
}

extension CreateDBInstanceReadReplicaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBInstanceReadReplicaInput(autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(Swift.String(describing: enablePerformanceInsights)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), optionGroupName: \(Swift.String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(Swift.String(describing: performanceInsightsRetentionPeriod)), port: \(Swift.String(describing: port)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), processorFeatures: \(Swift.String(describing: processorFeatures)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), replicaMode: \(Swift.String(describing: replicaMode)), sourceDBInstanceIdentifier: \(Swift.String(describing: sourceDBInstanceIdentifier)), storageType: \(Swift.String(describing: storageType)), tags: \(Swift.String(describing: tags)), useDefaultProcessorFeatures: \(Swift.String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension CreateDBInstanceReadReplicaInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: ClientRuntime.Key("ReplicaMode"))
        }
        if let sourceDBInstanceIdentifier = sourceDBInstanceIdentifier {
            try container.encode(sourceDBInstanceIdentifier, forKey: ClientRuntime.Key("SourceDBInstanceIdentifier"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBInstanceReadReplica", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBInstanceReadReplicaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceReadReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceReadReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceReadReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceReadReplicaOutputError>
}

public struct CreateDBInstanceReadReplicaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceReadReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBInstanceReadReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBInstanceReadReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceReadReplicaOutputError>
}

public struct CreateDBInstanceReadReplicaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBInstanceReadReplicaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBInstanceReadReplicaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBInstanceReadReplicaInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBInstanceReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBInstanceReadReplicaOutputError>
}

public struct CreateDBInstanceReadReplicaInput: Swift.Equatable {
    /// A value that indicates whether minor engine upgrades are applied automatically to the
    ///             read replica during the maintenance window.
    ///          Default: Inherits from the source DB instance
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the read replica will be created.
    ///          Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region.
    ///
    ///            Example: us-east-1d
    ///
    public var availabilityZone: Swift.String?
    /// A value that indicates whether to copy all tags from the read replica to snapshots of
    ///             the read replica. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The compute and memory capacity of the read replica, for example,
    ///                 db.m4.large. Not all DB instance classes are available in all Amazon Web Services
    ///             Regions, or for all database engines. For the full list of DB instance classes, and
    ///             availability for your engine, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance
    ///                 Class in the Amazon RDS User Guide.
    ///
    ///          Default: Inherits from the source DB instance.
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier of the read replica. This identifier is the unique key
    ///             that identifies a DB instance. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance.
    ///         If you do not specify a value for DBParameterGroupName, then Amazon RDS
    ///             uses the DBParameterGroup of source DB instance for a same region read
    ///             replica, or the default DBParameterGroup for the specified DB engine for a
    ///             cross region read replica.
    ///
    ///             Currently, specifying a parameter group for this operation is only supported for Oracle DB instances.
    ///
    ///         Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    public var dBParameterGroupName: Swift.String?
    /// Specifies a DB subnet group for the DB instance. The new DB instance is created in the VPC associated with the DB subnet group. If no DB subnet group is specified, then the new DB instance isn't created in a VPC.
    ///          Constraints:
    ///
    ///
    ///                Can only be specified if the source DB instance identifier specifies a DB instance in another Amazon Web Services Region.
    ///
    ///
    ///                If supplied, must match the name of an existing DBSubnetGroup.
    ///
    ///
    ///                The specified DB subnet group must be in the same Amazon Web Services Region in which the operation is running.
    ///
    ///
    ///               All read replicas in one Amazon Web Services Region that are created from the same source DB
    ///                     instance must either:>
    ///
    ///
    ///                      Specify DB subnet groups from the same VPC. All these read replicas are created in the same
    ///                             VPC.
    ///
    ///
    ///                      Not specify a DB subnet group. All these read replicas are created outside of any
    ///                             VPC.
    ///
    ///
    ///
    ///
    ///          Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance.
    ///
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to create the DB instance in. Currently, only MySQL, Microsoft SQL
    ///             Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///             Kerberos Authentication in the Amazon RDS User Guide.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the new DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing
    ///                 Database Logs to Amazon CloudWatch Logs  in the Amazon RDS User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///          For more information about IAM database authentication, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///               IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the read replica.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using
    ///             Amazon Performance Insights in the Amazon RDS User Guide.
    ///
    public var enablePerformanceInsights: Swift.Bool?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted read replica.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS CMK.
    ///         If you create an encrypted read replica in the same Amazon Web Services Region as the source DB
    ///             instance, then do not specify a value for this parameter. A read replica in the same Region
    ///             is always encrypted with the same Amazon Web Services KMS CMK as the source DB instance.
    ///         If you create an encrypted read replica in a different Amazon Web Services Region, then you must
    ///             specify a Amazon Web Services KMS key identifier for the destination Amazon Web Services Region. Amazon Web Services KMS CMKs are specific to
    ///             the Amazon Web Services Region that they are created in, and you can't use CMKs from one
    ///             Amazon Web Services Region in another Amazon Web Services Region.
    ///         You can't create an encrypted read replica from an unencrypted DB instance.
    public var kmsKeyId: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
    ///         For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling
    ///             in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are
    ///             collected for the read replica. To disable collecting Enhanced Monitoring metrics,
    ///             specify 0. The default is 0.
    ///          If MonitoringRoleArn is specified, then you must also set MonitoringInterval
    ///       to a value other than 0.
    ///          Valid Values: 0, 1, 5, 10, 15, 30, 60
    ///
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For
    ///       example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role,
    ///       go to <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole">To
    ///           create an IAM role for Amazon RDS Enhanced Monitoring in the Amazon RDS User Guide.
    ///          If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the read replica is in a Multi-AZ deployment.
    ///
    ///         You can create a read replica as a Multi-AZ DB instance. RDS creates a standby of
    ///             your replica in another Availability Zone for failover support for the replica. Creating
    ///             your read replica as a Multi-AZ DB instance is independent of whether the source
    ///             database is a Multi-AZ DB instance.
    public var multiAZ: Swift.Bool?
    /// The option group the DB instance is associated with. If omitted, the option group associated with the source instance is used.
    ///
    ///             For SQL Server, you must use the option group associated with the source
    ///                 instance.
    ///
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///         If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your Amazon Web Services account.
    ///             Your Amazon Web Services account has a different default CMK for each Amazon Web Services Region.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number that the DB instance uses for connections.
    ///          Default: Inherits from the source DB instance
    ///          Valid Values: 1150-65535
    ///
    public var port: Swift.Int?
    /// The URL that contains a Signature Version 4 signed request for the CreateDBInstanceReadReplica API action
    ///             in the source Amazon Web Services Region that contains the source DB instance.
    ///
    ///
    ///         You must specify this parameter when you create an encrypted read replica from
    ///             another Amazon Web Services Region by using the Amazon RDS API. Don't specify
    ///                 PreSignedUrl when you are creating an encrypted read replica in the
    ///             same Amazon Web Services Region.
    ///
    ///         The presigned URL must be a valid request for the CreateDBInstanceReadReplica API action
    ///             that can be executed in the source Amazon Web Services Region that contains the encrypted source DB instance.
    ///             The presigned URL request must contain the following parameter values:
    ///
    ///
    ///
    ///
    ///
    ///                   DestinationRegion - The Amazon Web Services Region that the encrypted read
    ///                     replica is created in. This Amazon Web Services Region is the same one where the
    ///                         CreateDBInstanceReadReplica action is called that contains this presigned URL.
    ///
    ///                 For example, if you create an encrypted DB instance in the us-west-1 Amazon Web Services Region,
    ///                     from a source DB instance in the us-east-2 Amazon Web Services Region,
    ///                     then you call the CreateDBInstanceReadReplica action in
    ///                     the us-east-1 Amazon Web Services Region and provide a presigned URL that contains a call to the
    ///                     CreateDBInstanceReadReplica action in the us-west-2 Amazon Web Services Region. For this
    ///                     example, the DestinationRegion in the presigned URL must be set to
    ///                     the us-east-1 Amazon Web Services Region.
    ///
    ///
    ///
    ///
    ///                   KmsKeyId - The Amazon Web Services KMS key identifier for the key to use to
    ///                     encrypt the read replica in the destination Amazon Web Services Region. This is the same
    ///                     identifier for both the CreateDBInstanceReadReplica action that is
    ///                     called in the destination Amazon Web Services Region, and the action contained in the presigned
    ///                     URL.
    ///
    ///
    ///
    ///                   SourceDBInstanceIdentifier - The DB instance identifier for
    ///                     the encrypted DB instance to be replicated. This identifier must be in the
    ///                     Amazon Resource Name (ARN) format for the source Amazon Web Services Region. For example, if you
    ///                     are creating an encrypted read replica from a DB instance in the us-west-2 Amazon Web Services
    ///                     Region, then your SourceDBInstanceIdentifier looks like the
    ///                     following example:
    ///                         arn:aws:rds:us-west-2:123456789012:instance:mysql-instance1-20161115.
    ///
    ///
    ///
    ///         To learn how to generate a Signature Version 4 signed request, see
    ///             <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests: Using Query Parameters (Amazon Web Services Signature Version 4) and
    ///             <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature Version 4 Signing Process.
    ///
    ///
    ///
    ///             If you are using an Amazon Web Services SDK tool or the CLI, you can specify
    ///                     SourceRegion (or --source-region for the CLI)
    ///                 instead of specifying PreSignedUrl manually. Specifying
    ///                     SourceRegion autogenerates a presigned URL that is a valid request
    ///                 for the operation that can be executed in the source Amazon Web Services Region.
    ///
    ///                SourceRegion isn't supported for SQL Server, because SQL Server on Amazon RDS
    ///                 doesn't support cross-region read replicas.
    ///
    public var preSignedUrl: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible.
    ///          When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///               and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///               and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
    ///          When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
    ///          For more information, see CreateDBInstance.
    public var publiclyAccessible: Swift.Bool?
    /// The open mode of the replica database: mounted or read-only.
    ///
    ///             This parameter is only supported for Oracle DB instances.
    ///
    ///         Mounted DB replicas are included in Oracle Enterprise Edition. The main use case for
    ///             mounted replicas is cross-Region disaster recovery. The primary database doesn't use Active
    ///             Data Guard to transmit information to the mounted replica. Because it doesn't accept
    ///             user connections, a mounted replica can't serve a read-only workload.
    ///         You can create a combination of mounted and read-only DB replicas for the same primary DB instance.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Working with Oracle Read Replicas for Amazon RDS
    ///             in the Amazon RDS User Guide.
    public var replicaMode: RdsClientTypes.ReplicaMode?
    /// The identifier of the DB instance that will act as the source for the read replica.
    ///             Each DB instance can have up to five read replicas.
    ///          Constraints:
    ///
    ///
    ///                Must be the identifier of an existing MySQL, MariaDB, Oracle, PostgreSQL, or SQL Server DB
    ///                     instance.
    ///
    ///
    ///                Can specify a DB instance that is a MySQL read replica only if the source is running MySQL
    ///                     5.6 or later.
    ///
    ///
    ///               For the limitations of Oracle read replicas, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Read Replica Limitations with Oracle in the
    ///                   Amazon RDS User Guide.
    ///
    ///
    ///                 For the limitations of SQL Server read replicas, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/SQLServer.ReadReplicas.Limitations.html">Read Replica
    ///                         Limitations with Microsoft SQL Server in the Amazon RDS User Guide.
    ///
    ///
    ///                Can specify a PostgreSQL DB instance only if the source is running PostgreSQL 9.3.5 or
    ///                     later (9.4.7 and higher for cross-region replication).
    ///
    ///
    ///                The specified DB instance must have automatic backups enabled, that is, its backup
    ///                     retention period must be greater than 0.
    ///
    ///
    ///                If the source DB instance is in the same Amazon Web Services Region as the read replica, specify a valid DB
    ///                     instance identifier.
    ///
    ///
    ///                If the source DB instance is in a different Amazon Web Services Region from the read replica, specify a valid DB instance ARN.
    ///              For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">Constructing an ARN for Amazon RDS
    ///              in the Amazon RDS User Guide. This doesn't apply to SQL Server, which doesn't support cross-region replicas.
    ///
    ///
    /// This member is required.
    public var sourceDBInstanceIdentifier: Swift.String?
    /// Specifies the storage type to be associated with the read replica.
    ///
    ///             Valid values: standard | gp2 | io1
    ///
    ///
    ///             If you specify io1, you must also include a value for the
    ///             Iops parameter.
    ///
    ///
    ///             Default: io1 if the Iops parameter
    ///             is specified, otherwise gp2
    ///
    public var storageType: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.
    public var useDefaultProcessorFeatures: Swift.Bool?
    ///  A list of EC2 VPC security groups to associate with the read replica.
    ///
    ///             Default: The default EC2 VPC security group for the DB subnet group's VPC.
    ///
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preSignedUrl: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicaMode: RdsClientTypes.ReplicaMode? = nil,
        sourceDBInstanceIdentifier: Swift.String? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preSignedUrl = preSignedUrl
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.replicaMode = replicaMode
        self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
        self.storageType = storageType
        self.tags = tags
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension CreateDBInstanceReadReplicaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBInstanceReadReplicaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotAllowedFault" : self = .dBSubnetGroupNotAllowedFault(try DBSubnetGroupNotAllowedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupFault" : self = .invalidDBSubnetGroupFault(try InvalidDBSubnetGroupFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBInstanceReadReplicaOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotAllowedFault(DBSubnetGroupNotAllowedFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSubnetGroupFault(InvalidDBSubnetGroupFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBInstanceReadReplicaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBInstanceReadReplicaOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension CreateDBInstanceReadReplicaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBInstanceReadReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct CreateDBInstanceReadReplicaOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct CreateDBInstanceReadReplicaOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension CreateDBInstanceReadReplicaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBInstanceReadReplicaResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct CreateDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

extension CreateDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBParameterGroupInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), description: \(Swift.String(describing: description)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

public struct CreateDBParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBParameterGroupOutputError>
}

///
public struct CreateDBParameterGroupInput: Swift.Equatable {
    /// The DB parameter group family name. A DB parameter group can be associated with one and only one DB parameter group family, and can be applied only to a DB instance running a database engine and engine version compatible with that DB parameter group family.
    ///          To list all of the available parameter group families for a DB engine, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine <engine>
    ///
    ///          For example, to list all of the available parameter group families for the MySQL DB engine, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --query "DBEngineVersions[].DBParameterGroupFamily" --engine mysql
    ///
    ///
    ///             The output contains duplicates.
    ///
    ///          The following are the valid DB engine values:
    ///
    ///
    ///
    ///                   aurora (for MySQL 5.6-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-postgresql
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// The name of the DB parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///
    ///             This value is stored as a lowercase string.
    ///
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// The description for the DB parameter group.
    /// This member is required.
    public var description: Swift.String?
    /// Tags to assign to the DB parameter group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        description: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.dBParameterGroupName = dBParameterGroupName
        self.description = description
        self.tags = tags
    }
}

extension CreateDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupAlreadyExists" : self = .dBParameterGroupAlreadyExistsFault(try DBParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupQuotaExceeded" : self = .dBParameterGroupQuotaExceededFault(try DBParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupAlreadyExistsFault(DBParameterGroupAlreadyExistsFault)
    case dBParameterGroupQuotaExceededFault(DBParameterGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBParameterGroupOutputResponse(dBParameterGroup: \(Swift.String(describing: dBParameterGroup)))"}
}

extension CreateDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroup = output.dBParameterGroup
        } else {
            self.dBParameterGroup = nil
        }
    }
}

public struct CreateDBParameterGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB parameter group.
    ///
    ///          This data type is used as a response element in the DescribeDBParameterGroups action.
    ///
    public var dBParameterGroup: RdsClientTypes.DBParameterGroup?

    public init (
        dBParameterGroup: RdsClientTypes.DBParameterGroup? = nil
    )
    {
        self.dBParameterGroup = dBParameterGroup
    }
}

struct CreateDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroup: RdsClientTypes.DBParameterGroup?
}

extension CreateDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroup = "DBParameterGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBParameterGroupResult"))
        let dBParameterGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBParameterGroup.self, forKey: .dBParameterGroup)
        dBParameterGroup = dBParameterGroupDecoded
    }
}

public struct CreateDBProxyEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyEndpointOutputError>
}

extension CreateDBProxyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBProxyEndpointInput(dBProxyEndpointName: \(Swift.String(describing: dBProxyEndpointName)), dBProxyName: \(Swift.String(describing: dBProxyName)), tags: \(Swift.String(describing: tags)), targetRole: \(Swift.String(describing: targetRole)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(Swift.String(describing: vpcSubnetIds)))"}
}

extension CreateDBProxyEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetRole = targetRole {
            try container.encode(targetRole, forKey: ClientRuntime.Key("TargetRole"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBProxyEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBProxyEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyEndpointOutputError>
}

public struct CreateDBProxyEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyEndpointOutputError>
}

public struct CreateDBProxyEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBProxyEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBProxyEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyEndpointOutputError>
}

public struct CreateDBProxyEndpointInput: Swift.Equatable {
    /// The name of the DB proxy endpoint to create.
    /// This member is required.
    public var dBProxyEndpointName: Swift.String?
    /// The name of the DB proxy associated with the DB proxy endpoint that you create.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether the DB proxy endpoint can be used for read/write
    ///         or read-only operations. The default is READ_WRITE.
    public var targetRole: RdsClientTypes.DBProxyEndpointTargetRole?
    /// The VPC security group IDs for the DB proxy endpoint that you create. You can
    ///         specify a different set of security group IDs than for the original DB proxy.
    ///         The default is the default security group for the VPC.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// The VPC subnet IDs for the DB proxy endpoint that you create. You can specify a
    ///         different set of subnet IDs than for the original DB proxy.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init (
        dBProxyEndpointName: Swift.String? = nil,
        dBProxyName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetRole: RdsClientTypes.DBProxyEndpointTargetRole? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.tags = tags
        self.targetRole = targetRole
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

extension CreateDBProxyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBProxyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointAlreadyExistsFault" : self = .dBProxyEndpointAlreadyExistsFault(try DBProxyEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyEndpointQuotaExceededFault" : self = .dBProxyEndpointQuotaExceededFault(try DBProxyEndpointQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBProxyEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointAlreadyExistsFault(DBProxyEndpointAlreadyExistsFault)
    case dBProxyEndpointQuotaExceededFault(DBProxyEndpointQuotaExceededFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBProxyEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBProxyEndpointOutputResponse(dBProxyEndpoint: \(Swift.String(describing: dBProxyEndpoint)))"}
}

extension CreateDBProxyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct CreateDBProxyEndpointOutputResponse: Swift.Equatable {
    /// The DBProxyEndpoint object that is created by the API operation.
    ///         The DB proxy endpoint that you create might provide capabilities such as read/write
    ///         or read-only operations, or using a different VPC than the proxy's default VPC.
    public var dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?

    public init (
        dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct CreateDBProxyEndpointOutputResponseBody: Swift.Equatable {
    public let dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?
}

extension CreateDBProxyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

public struct CreateDBProxyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyOutputError>
}

extension CreateDBProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBProxyInput(auth: \(Swift.String(describing: auth)), dBProxyName: \(Swift.String(describing: dBProxyName)), debugLogging: \(Swift.String(describing: debugLogging)), engineFamily: \(Swift.String(describing: engineFamily)), idleClientTimeout: \(Swift.String(describing: idleClientTimeout)), requireTLS: \(Swift.String(describing: requireTLS)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(Swift.String(describing: vpcSubnetIds)))"}
}

extension CreateDBProxyInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Auth"))
            for (index0, userauthconfig0) in auth.enumerated() {
                try authContainer.encode(userauthconfig0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: ClientRuntime.Key("DebugLogging"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: ClientRuntime.Key("EngineFamily"))
        }
        if let idleClientTimeout = idleClientTimeout {
            try container.encode(idleClientTimeout, forKey: ClientRuntime.Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: ClientRuntime.Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBProxy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBProxyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyOutputError>
}

public struct CreateDBProxyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyOutputError>
}

public struct CreateDBProxyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBProxyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBProxyOutputError>
}

public struct CreateDBProxyInput: Swift.Equatable {
    /// The authorization mechanism that the proxy uses.
    /// This member is required.
    public var auth: [RdsClientTypes.UserAuthConfig]?
    /// The identifier for the proxy. This name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// Whether the proxy includes detailed information about SQL statements in its logs.
    ///         This information helps you to debug issues involving SQL behavior or the performance
    ///         and scalability of the proxy connections. The debug information includes the text of
    ///         SQL statements that you submit through the proxy. Thus, only enable this setting
    ///         when needed for debugging, and only when you have security measures in place to
    ///         safeguard any sensitive information that appears in the logs.
    public var debugLogging: Swift.Bool
    /// The kinds of databases that the proxy can connect to.
    ///           This value determines which database network protocol the proxy recognizes when it interprets
    ///         network traffic to and from the database.
    ///         The engine family applies to MySQL and PostgreSQL for both RDS and Aurora.
    /// This member is required.
    public var engineFamily: RdsClientTypes.EngineFamily?
    /// The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this
    ///         value higher or lower than the connection timeout limit for the associated database.
    public var idleClientTimeout: Swift.Int?
    /// A Boolean parameter that specifies whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
    ///         By enabling this setting, you can enforce encrypted TLS connections to the proxy.
    public var requireTLS: Swift.Bool
    /// The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in Amazon Web Services Secrets Manager.
    /// This member is required.
    public var roleArn: Swift.String?
    /// An optional set of key-value pairs to associate arbitrary data of your choosing with the proxy.
    public var tags: [RdsClientTypes.Tag]?
    /// One or more VPC security group IDs to associate with the new proxy.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// One or more VPC subnet IDs to associate with the new proxy.
    /// This member is required.
    public var vpcSubnetIds: [Swift.String]?

    public init (
        auth: [RdsClientTypes.UserAuthConfig]? = nil,
        dBProxyName: Swift.String? = nil,
        debugLogging: Swift.Bool = false,
        engineFamily: RdsClientTypes.EngineFamily? = nil,
        idleClientTimeout: Swift.Int? = nil,
        requireTLS: Swift.Bool = false,
        roleArn: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        vpcSubnetIds: [Swift.String]? = nil
    )
    {
        self.auth = auth
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.engineFamily = engineFamily
        self.idleClientTimeout = idleClientTimeout
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.vpcSubnetIds = vpcSubnetIds
    }
}

extension CreateDBProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyAlreadyExistsFault" : self = .dBProxyAlreadyExistsFault(try DBProxyAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyQuotaExceededFault" : self = .dBProxyQuotaExceededFault(try DBProxyQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBProxyOutputError: Swift.Error, Swift.Equatable {
    case dBProxyAlreadyExistsFault(DBProxyAlreadyExistsFault)
    case dBProxyQuotaExceededFault(DBProxyQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBProxyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBProxyOutputResponse(dBProxy: \(Swift.String(describing: dBProxy)))"}
}

extension CreateDBProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct CreateDBProxyOutputResponse: Swift.Equatable {
    /// The DBProxy structure corresponding to the new proxy.
    public var dBProxy: RdsClientTypes.DBProxy?

    public init (
        dBProxy: RdsClientTypes.DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct CreateDBProxyOutputResponseBody: Swift.Equatable {
    public let dBProxy: RdsClientTypes.DBProxy?
}

extension CreateDBProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

public struct CreateDBSecurityGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSecurityGroupOutputError>
}

extension CreateDBSecurityGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSecurityGroupInput(dBSecurityGroupDescription: \(Swift.String(describing: dBSecurityGroupDescription)), dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBSecurityGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupDescription = dBSecurityGroupDescription {
            try container.encode(dBSecurityGroupDescription, forKey: ClientRuntime.Key("DBSecurityGroupDescription"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSecurityGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBSecurityGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSecurityGroupOutputError>
}

public struct CreateDBSecurityGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSecurityGroupOutputError>
}

public struct CreateDBSecurityGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSecurityGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBSecurityGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBSecurityGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSecurityGroupOutputError>
}

///
public struct CreateDBSecurityGroupInput: Swift.Equatable {
    /// The description for the DB security group.
    /// This member is required.
    public var dBSecurityGroupDescription: Swift.String?
    /// The name for the DB security group. This value is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///                Must not be "Default"
    ///
    ///
    ///          Example: mysecuritygroup
    ///
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?
    /// Tags to assign to the DB security group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBSecurityGroupDescription: Swift.String? = nil,
        dBSecurityGroupName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBSecurityGroupDescription = dBSecurityGroupDescription
        self.dBSecurityGroupName = dBSecurityGroupName
        self.tags = tags
    }
}

extension CreateDBSecurityGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSecurityGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupAlreadyExists" : self = .dBSecurityGroupAlreadyExistsFault(try DBSecurityGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotSupported" : self = .dBSecurityGroupNotSupportedFault(try DBSecurityGroupNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QuotaExceeded.DBSecurityGroup" : self = .dBSecurityGroupQuotaExceededFault(try DBSecurityGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSecurityGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSecurityGroupAlreadyExistsFault(DBSecurityGroupAlreadyExistsFault)
    case dBSecurityGroupNotSupportedFault(DBSecurityGroupNotSupportedFault)
    case dBSecurityGroupQuotaExceededFault(DBSecurityGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSecurityGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSecurityGroupOutputResponse(dBSecurityGroup: \(Swift.String(describing: dBSecurityGroup)))"}
}

extension CreateDBSecurityGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSecurityGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct CreateDBSecurityGroupOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB security group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSecurityGroups action.
    ///
    public var dBSecurityGroup: RdsClientTypes.DBSecurityGroup?

    public init (
        dBSecurityGroup: RdsClientTypes.DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct CreateDBSecurityGroupOutputResponseBody: Swift.Equatable {
    public let dBSecurityGroup: RdsClientTypes.DBSecurityGroup?
}

extension CreateDBSecurityGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSecurityGroupResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

public struct CreateDBSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSnapshotOutputError>
}

extension CreateDBSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSnapshotInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSnapshotOutputError>
}

public struct CreateDBSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSnapshotOutputError>
}

public struct CreateDBSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSnapshotOutputError>
}

///
public struct CreateDBSnapshotInput: Swift.Equatable {
    /// The identifier of the DB instance that you want to create the snapshot of.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBInstance.
    ///
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The identifier for the DB snapshot.
    ///          Constraints:
    ///
    ///
    ///                Can't be null, empty, or blank
    ///
    ///
    ///                Must contain from 1 to 255 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-snapshot-id
    ///
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.tags = tags
    }
}

extension CreateDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSnapshotOutputResponse(dBSnapshot: \(Swift.String(describing: dBSnapshot)))"}
}

extension CreateDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct CreateDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSnapshots action.
    ///
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct CreateDBSnapshotOutputResponseBody: Swift.Equatable {
    public let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension CreateDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct CreateDBSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

extension CreateDBSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSubnetGroupInput(dBSubnetGroupDescription: \(Swift.String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDBSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateDBSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

public struct CreateDBSubnetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDBSubnetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDBSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDBSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDBSubnetGroupOutputError>
}

///
public struct CreateDBSubnetGroupInput: Swift.Equatable {
    /// The description for the DB subnet group.
    /// This member is required.
    public var dBSubnetGroupDescription: Swift.String?
    /// The name for the DB subnet group. This value is stored as a lowercase string.
    ///          Constraints: Must contain no more than 255 letters, numbers, periods, underscores, spaces, or hyphens. Must not be default.
    ///          Example: mySubnetgroup
    ///
    /// This member is required.
    public var dBSubnetGroupName: Swift.String?
    /// The EC2 Subnet IDs for the DB subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Tags to assign to the DB subnet group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBSubnetGroupDescription: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

extension CreateDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupAlreadyExists" : self = .dBSubnetGroupAlreadyExistsFault(try DBSubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupQuotaExceeded" : self = .dBSubnetGroupQuotaExceededFault(try DBSubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupAlreadyExistsFault(DBSubnetGroupAlreadyExistsFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupQuotaExceededFault(DBSubnetGroupQuotaExceededFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDBSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDBSubnetGroupOutputResponse(dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)))"}
}

extension CreateDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct CreateDBSubnetGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB subnet group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSubnetGroups action.
    ///
    public var dBSubnetGroup: RdsClientTypes.DBSubnetGroup?

    public init (
        dBSubnetGroup: RdsClientTypes.DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct CreateDBSubnetGroupOutputResponseBody: Swift.Equatable {
    public let dBSubnetGroup: RdsClientTypes.DBSubnetGroup?
}

extension CreateDBSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct CreateEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

extension CreateEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIds: \(Swift.String(describing: sourceIds)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIds = sourceIds {
            var sourceIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIds"))
            for (index0, string0) in sourceIds.enumerated() {
                try sourceIdsContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

public struct CreateEventSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventSubscriptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateEventSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEventSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventSubscriptionOutputError>
}

///
public struct CreateEventSubscriptionInput: Swift.Equatable {
    ///
    ///           A value that indicates whether to activate the subscription. If the event notification subscription isn't activated, the subscription is created but not active.
    ///
    public var enabled: Swift.Bool?
    ///  A list of event categories for a particular source type (SourceType)
    ///             that you want to subscribe to. You can see a list of the categories for a given source
    ///             type in <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html">Events in the
    ///                 Amazon RDS User Guide or by using the DescribeEventCategories operation.
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    /// This member is required.
    public var snsTopicArn: Swift.String?
    /// The list of identifiers of the event sources for which events are returned. If not specified, then all sources are included in the response.
    ///           An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens. It can't end with a hyphen or contain two consecutive hyphens.
    ///          Constraints:
    ///
    ///
    ///                If SourceIds are supplied, SourceType must also be provided.
    ///
    ///
    ///                If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.
    ///
    ///
    ///                If the source type is a DB security group, a DBSecurityGroupName value must be supplied.
    ///
    ///
    ///                If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.
    ///
    ///
    public var sourceIds: [Swift.String]?
    /// The type of source that is generating the events. For example, if you want to be
    ///             notified of events generated by a DB instance, you set this parameter to
    ///                 db-instance. If this value isn't specified, all events are
    ///             returned.
    ///          Valid values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot
    ///
    public var sourceType: Swift.String?
    /// The name of the subscription.
    ///          Constraints: The name must be less than 255 characters.
    /// This member is required.
    public var subscriptionName: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceIds: [Swift.String]? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceIds = sourceIds
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
        self.tags = tags
    }
}

extension CreateEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceeded" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopic" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorization" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFound" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceNotFound" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionAlreadyExist" : self = .subscriptionAlreadyExistFault(try SubscriptionAlreadyExistFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFound" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionAlreadyExistFault(SubscriptionAlreadyExistFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension CreateEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct CreateEventSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct CreateEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RdsClientTypes.EventSubscription?
}

extension CreateEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct CreateGlobalClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalClusterOutputError>
}

extension CreateGlobalClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlobalClusterInput(databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)), sourceDBClusterIdentifier: \(Swift.String(describing: sourceDBClusterIdentifier)), storageEncrypted: \(Swift.String(describing: storageEncrypted)))"}
}

extension CreateGlobalClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: ClientRuntime.Key("SourceDBClusterIdentifier"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        try container.encode("CreateGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateGlobalClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalClusterOutputError>
}

public struct CreateGlobalClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalClusterOutputError>
}

public struct CreateGlobalClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGlobalClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateGlobalClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGlobalClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGlobalClusterOutputError>
}

public struct CreateGlobalClusterInput: Swift.Equatable {
    ///
    ///         The name for your database of up to 64 alpha-numeric characters. If you do not provide a name, Amazon
    ///         Aurora will not create a database in the global database cluster you are creating.
    ///
    public var databaseName: Swift.String?
    ///
    ///         The deletion protection setting for the new global database.
    ///         The global database can't be deleted when deletion protection is enabled.
    ///
    public var deletionProtection: Swift.Bool?
    /// The name of the database engine to be used for this DB cluster.
    public var engine: Swift.String?
    /// The engine version of the Aurora global database.
    public var engineVersion: Swift.String?
    /// The cluster identifier of the new global database cluster.
    public var globalClusterIdentifier: Swift.String?
    ///
    ///         The Amazon Resource Name (ARN) to use as the primary cluster of the global database.
    ///         This parameter is optional.
    ///
    public var sourceDBClusterIdentifier: Swift.String?
    ///
    ///         The storage encryption setting for the new global database cluster.
    ///
    public var storageEncrypted: Swift.Bool?

    public init (
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        sourceDBClusterIdentifier: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil
    )
    {
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.engine = engine
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.storageEncrypted = storageEncrypted
    }
}

extension CreateGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterAlreadyExistsFault" : self = .globalClusterAlreadyExistsFault(try GlobalClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterQuotaExceededFault" : self = .globalClusterQuotaExceededFault(try GlobalClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterAlreadyExistsFault(GlobalClusterAlreadyExistsFault)
    case globalClusterQuotaExceededFault(GlobalClusterQuotaExceededFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGlobalClusterOutputResponse(globalCluster: \(Swift.String(describing: globalCluster)))"}
}

extension CreateGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct CreateGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct CreateGlobalClusterOutputResponseBody: Swift.Equatable {
    public let globalCluster: RdsClientTypes.GlobalCluster?
}

extension CreateGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct CreateOptionGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOptionGroupOutputError>
}

extension CreateOptionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOptionGroupInput(engineName: \(Swift.String(describing: engineName)), majorEngineVersion: \(Swift.String(describing: majorEngineVersion)), optionGroupDescription: \(Swift.String(describing: optionGroupDescription)), optionGroupName: \(Swift.String(describing: optionGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateOptionGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let optionGroupDescription = optionGroupDescription {
            try container.encode(optionGroupDescription, forKey: ClientRuntime.Key("OptionGroupDescription"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct CreateOptionGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOptionGroupOutputError>
}

public struct CreateOptionGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOptionGroupOutputError>
}

public struct CreateOptionGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOptionGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateOptionGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOptionGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOptionGroupOutputError>
}

///
public struct CreateOptionGroupInput: Swift.Equatable {
    /// Specifies the name of the engine that this option group should be associated with.
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    /// This member is required.
    public var engineName: Swift.String?
    /// Specifies the major version of the engine that this option group should be associated with.
    /// This member is required.
    public var majorEngineVersion: Swift.String?
    /// The description of the option group.
    /// This member is required.
    public var optionGroupDescription: Swift.String?
    /// Specifies the name of the option group to be created.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: myoptiongroup
    ///
    /// This member is required.
    public var optionGroupName: Swift.String?
    /// Tags to assign to the option group.
    public var tags: [RdsClientTypes.Tag]?

    public init (
        engineName: Swift.String? = nil,
        majorEngineVersion: Swift.String? = nil,
        optionGroupDescription: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.engineName = engineName
        self.majorEngineVersion = majorEngineVersion
        self.optionGroupDescription = optionGroupDescription
        self.optionGroupName = optionGroupName
        self.tags = tags
    }
}

extension CreateOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OptionGroupAlreadyExistsFault" : self = .optionGroupAlreadyExistsFault(try OptionGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupQuotaExceededFault" : self = .optionGroupQuotaExceededFault(try OptionGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case optionGroupAlreadyExistsFault(OptionGroupAlreadyExistsFault)
    case optionGroupQuotaExceededFault(OptionGroupQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOptionGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOptionGroupOutputResponse(optionGroup: \(Swift.String(describing: optionGroup)))"}
}

extension CreateOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct CreateOptionGroupOutputResponse: Swift.Equatable {
    ///
    public var optionGroup: RdsClientTypes.OptionGroup?

    public init (
        optionGroup: RdsClientTypes.OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct CreateOptionGroupOutputResponseBody: Swift.Equatable {
    public let optionGroup: RdsClientTypes.OptionGroup?
}

extension CreateOptionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension RdsClientTypes.CustomAvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case customAvailabilityZoneName = "CustomAvailabilityZoneName"
        case customAvailabilityZoneStatus = "CustomAvailabilityZoneStatus"
        case vpnDetails = "VpnDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let customAvailabilityZoneName = customAvailabilityZoneName {
            try container.encode(customAvailabilityZoneName, forKey: ClientRuntime.Key("CustomAvailabilityZoneName"))
        }
        if let customAvailabilityZoneStatus = customAvailabilityZoneStatus {
            try container.encode(customAvailabilityZoneStatus, forKey: ClientRuntime.Key("CustomAvailabilityZoneStatus"))
        }
        if let vpnDetails = vpnDetails {
            try container.encode(vpnDetails, forKey: ClientRuntime.Key("VpnDetails"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let customAvailabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneName)
        customAvailabilityZoneName = customAvailabilityZoneNameDecoded
        let customAvailabilityZoneStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneStatus)
        customAvailabilityZoneStatus = customAvailabilityZoneStatusDecoded
        let vpnDetailsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.VpnDetails.self, forKey: .vpnDetails)
        vpnDetails = vpnDetailsDecoded
    }
}

extension RdsClientTypes.CustomAvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomAvailabilityZone(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)), customAvailabilityZoneName: \(Swift.String(describing: customAvailabilityZoneName)), customAvailabilityZoneStatus: \(Swift.String(describing: customAvailabilityZoneStatus)), vpnDetails: \(Swift.String(describing: vpnDetails)))"}
}

extension RdsClientTypes {
    /// A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster.
    ///         For more information about RDS on VMware, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                 RDS on VMware User Guide.
    ///
    public struct CustomAvailabilityZone: Swift.Equatable {
        /// The identifier of the custom AZ.
        ///         Amazon RDS generates a unique identifier when a custom AZ is created.
        public var customAvailabilityZoneId: Swift.String?
        /// The name of the custom AZ.
        public var customAvailabilityZoneName: Swift.String?
        /// The status of the custom AZ.
        public var customAvailabilityZoneStatus: Swift.String?
        /// Information about the virtual private network (VPN) between the VMware vSphere cluster
        ///             and the Amazon Web Services website.
        public var vpnDetails: RdsClientTypes.VpnDetails?

        public init (
            customAvailabilityZoneId: Swift.String? = nil,
            customAvailabilityZoneName: Swift.String? = nil,
            customAvailabilityZoneStatus: Swift.String? = nil,
            vpnDetails: RdsClientTypes.VpnDetails? = nil
        )
        {
            self.customAvailabilityZoneId = customAvailabilityZoneId
            self.customAvailabilityZoneName = customAvailabilityZoneName
            self.customAvailabilityZoneStatus = customAvailabilityZoneStatus
            self.vpnDetails = vpnDetails
        }
    }

}

extension CustomAvailabilityZoneAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomAvailabilityZoneAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension CustomAvailabilityZoneAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomAvailabilityZoneAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             CustomAvailabilityZoneName is already used by an existing custom
///             Availability Zone.
public struct CustomAvailabilityZoneAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CustomAvailabilityZoneAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomAvailabilityZoneNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomAvailabilityZoneNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension CustomAvailabilityZoneNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomAvailabilityZoneNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             CustomAvailabilityZoneId doesn't refer to an existing custom
///             Availability Zone identifier.
public struct CustomAvailabilityZoneNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CustomAvailabilityZoneNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CustomAvailabilityZoneQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomAvailabilityZoneQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension CustomAvailabilityZoneQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<CustomAvailabilityZoneQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of custom Availability Zones.
public struct CustomAvailabilityZoneQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomAvailabilityZoneQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CustomAvailabilityZoneQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBCluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case automaticRestartTime = "AutomaticRestartTime"
        case availabilityZones = "AvailabilityZones"
        case backtrackConsumedChangeRecords = "BacktrackConsumedChangeRecords"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case capacity = "Capacity"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case earliestBacktrackTime = "EarliestBacktrackTime"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case globalWriteForwardingRequested = "GlobalWriteForwardingRequested"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case multiAZ = "MultiAZ"
        case pendingModifiedValues = "PendingModifiedValues"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case scalingConfigurationInfo = "ScalingConfigurationInfo"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case tagList = "TagList"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: ClientRuntime.Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: ClientRuntime.Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: ClientRuntime.Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: ClientRuntime.Key("ActivityStreamStatus"))
        }
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: ClientRuntime.Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(ClientRuntime.TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: ClientRuntime.Key("automaticRestartTime"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackConsumedChangeRecords = backtrackConsumedChangeRecords {
            try container.encode(backtrackConsumedChangeRecords, forKey: ClientRuntime.Key("BacktrackConsumedChangeRecords"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let capacity = capacity {
            try container.encode(capacity, forKey: ClientRuntime.Key("Capacity"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: ClientRuntime.Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: ClientRuntime.Key("CrossAccountClone"))
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CustomEndpoints"))
            for (index0, string0) in customEndpoints.enumerated() {
                try customEndpointsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: ClientRuntime.Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: ClientRuntime.Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: ClientRuntime.Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: ClientRuntime.Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: ClientRuntime.Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: ClientRuntime.Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let earliestBacktrackTime = earliestBacktrackTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestBacktrackTime, format: .dateTime), forKey: ClientRuntime.Key("earliestBacktrackTime"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalWriteForwardingRequested = globalWriteForwardingRequested {
            try container.encode(globalWriteForwardingRequested, forKey: ClientRuntime.Key("GlobalWriteForwardingRequested"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: ClientRuntime.Key("GlobalWriteForwardingStatus"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if let httpEndpointEnabled = httpEndpointEnabled {
            try container.encode(httpEndpointEnabled, forKey: ClientRuntime.Key("HttpEndpointEnabled"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: ClientRuntime.Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfigurationInfo = scalingConfigurationInfo {
            try container.encode(scalingConfigurationInfo, forKey: ClientRuntime.Key("ScalingConfigurationInfo"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:ClientRuntime.Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
        let percentProgressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        if containerValues.contains(.customEndpoints) {
            struct KeyVal0{struct member{}}
            let customEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customEndpoints)
            if let customEndpointsWrappedContainer = customEndpointsWrappedContainer {
                let customEndpointsContainer = try customEndpointsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var customEndpointsBuffer:[Swift.String]? = nil
                if let customEndpointsContainer = customEndpointsContainer {
                    customEndpointsBuffer = [Swift.String]()
                    for stringContainer0 in customEndpointsContainer {
                        customEndpointsBuffer?.append(stringContainer0)
                    }
                }
                customEndpoints = customEndpointsBuffer
            } else {
                customEndpoints = []
            }
        } else {
            customEndpoints = nil
        }
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[RdsClientTypes.DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [RdsClientTypes.DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[RdsClientTypes.DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [RdsClientTypes.DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[RdsClientTypes.DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [RdsClientTypes.DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let earliestBacktrackTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestBacktrackTime)
        var earliestBacktrackTimeBuffer:ClientRuntime.Date? = nil
        if let earliestBacktrackTimeDecoded = earliestBacktrackTimeDecoded {
            earliestBacktrackTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestBacktrackTimeDecoded, format: .dateTime)
        }
        earliestBacktrackTime = earliestBacktrackTimeBuffer
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        let backtrackConsumedChangeRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackConsumedChangeRecords)
        backtrackConsumedChangeRecords = backtrackConsumedChangeRecordsDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationInfoDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfigurationInfo.self, forKey: .scalingConfigurationInfo)
        scalingConfigurationInfo = scalingConfigurationInfoDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .httpEndpointEnabled)
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[RdsClientTypes.DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [RdsClientTypes.DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
        let globalWriteForwardingRequestedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalWriteForwardingRequested)
        globalWriteForwardingRequested = globalWriteForwardingRequestedDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
    }
}

extension RdsClientTypes.DBCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBCluster(activityStreamKinesisStreamName: \(Swift.String(describing: activityStreamKinesisStreamName)), activityStreamKmsKeyId: \(Swift.String(describing: activityStreamKmsKeyId)), activityStreamMode: \(Swift.String(describing: activityStreamMode)), activityStreamStatus: \(Swift.String(describing: activityStreamStatus)), allocatedStorage: \(Swift.String(describing: allocatedStorage)), associatedRoles: \(Swift.String(describing: associatedRoles)), automaticRestartTime: \(Swift.String(describing: automaticRestartTime)), availabilityZones: \(Swift.String(describing: availabilityZones)), backtrackConsumedChangeRecords: \(Swift.String(describing: backtrackConsumedChangeRecords)), backtrackWindow: \(Swift.String(describing: backtrackWindow)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), capacity: \(Swift.String(describing: capacity)), characterSetName: \(Swift.String(describing: characterSetName)), cloneGroupId: \(Swift.String(describing: cloneGroupId)), clusterCreateTime: \(Swift.String(describing: clusterCreateTime)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), crossAccountClone: \(Swift.String(describing: crossAccountClone)), customEndpoints: \(Swift.String(describing: customEndpoints)), dBClusterArn: \(Swift.String(describing: dBClusterArn)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterMembers: \(Swift.String(describing: dBClusterMembers)), dBClusterOptionGroupMemberships: \(Swift.String(describing: dBClusterOptionGroupMemberships)), dBClusterParameterGroup: \(Swift.String(describing: dBClusterParameterGroup)), dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)), databaseName: \(Swift.String(describing: databaseName)), dbClusterResourceId: \(Swift.String(describing: dbClusterResourceId)), deletionProtection: \(Swift.String(describing: deletionProtection)), domainMemberships: \(Swift.String(describing: domainMemberships)), earliestBacktrackTime: \(Swift.String(describing: earliestBacktrackTime)), earliestRestorableTime: \(Swift.String(describing: earliestRestorableTime)), enabledCloudwatchLogsExports: \(Swift.String(describing: enabledCloudwatchLogsExports)), endpoint: \(Swift.String(describing: endpoint)), engine: \(Swift.String(describing: engine)), engineMode: \(Swift.String(describing: engineMode)), engineVersion: \(Swift.String(describing: engineVersion)), globalWriteForwardingRequested: \(Swift.String(describing: globalWriteForwardingRequested)), globalWriteForwardingStatus: \(Swift.String(describing: globalWriteForwardingStatus)), hostedZoneId: \(Swift.String(describing: hostedZoneId)), httpEndpointEnabled: \(Swift.String(describing: httpEndpointEnabled)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), latestRestorableTime: \(Swift.String(describing: latestRestorableTime)), masterUsername: \(Swift.String(describing: masterUsername)), multiAZ: \(Swift.String(describing: multiAZ)), pendingModifiedValues: \(Swift.String(describing: pendingModifiedValues)), percentProgress: \(Swift.String(describing: percentProgress)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), readReplicaIdentifiers: \(Swift.String(describing: readReplicaIdentifiers)), readerEndpoint: \(Swift.String(describing: readerEndpoint)), replicationSourceIdentifier: \(Swift.String(describing: replicationSourceIdentifier)), scalingConfigurationInfo: \(Swift.String(describing: scalingConfigurationInfo)), status: \(Swift.String(describing: status)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), tagList: \(Swift.String(describing: tagList)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension RdsClientTypes {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public struct DBCluster: Swift.Equatable {
        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public var activityStreamKinesisStreamName: Swift.String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream.
        ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var activityStreamKmsKeyId: Swift.String?
        /// The mode of the database activity stream.
        ///            Database events such as a change or access generate an activity stream event.
        ///            The database session can handle these events either synchronously or asynchronously.
        ///
        public var activityStreamMode: RdsClientTypes.ActivityStreamMode?
        /// The status of the database activity stream.
        public var activityStreamStatus: RdsClientTypes.ActivityStreamStatus?
        /// For all database engines except Amazon Aurora, AllocatedStorage specifies the allocated storage size in gibibytes (GiB).
        ///           For Aurora, AllocatedStorage always returns 1, because Aurora DB cluster storage size isn't fixed, but instead automatically
        ///       adjusts as needed.
        public var allocatedStorage: Swift.Int?
        /// Provides a list of the Amazon Web Services Identity and Access Management (IAM) roles that are associated with the DB cluster.
        ///           IAM roles that are associated with a DB cluster grant permission for the DB cluster to access other Amazon Web Services
        ///           on your behalf.
        public var associatedRoles: [RdsClientTypes.DBClusterRole]?
        /// The time when a stopped DB cluster is restarted automatically.
        public var automaticRestartTime: ClientRuntime.Date?
        /// Provides the list of Availability Zones (AZs) where instances in the DB cluster can be created.
        public var availabilityZones: [Swift.String]?
        /// The number of change records stored for Backtrack.
        public var backtrackConsumedChangeRecords: Swift.Int?
        /// The target backtrack window, in seconds. If this value is set to 0, backtracking is
        ///             disabled for the DB cluster. Otherwise, backtracking is enabled.
        public var backtrackWindow: Swift.Int?
        /// Specifies the number of days for which automatic DB snapshots are retained.
        public var backupRetentionPeriod: Swift.Int?
        /// The current capacity of an Aurora Serverless DB cluster. The capacity is 0 (zero)
        ///           when the cluster is paused.
        ///          For more information about Aurora Serverless, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless in the
        ///           Amazon Aurora User Guide.
        public var capacity: Swift.Int?
        /// If present, specifies the name of the character set that this cluster is associated with.
        public var characterSetName: Swift.String?
        /// Identifies the clone group to which the DB cluster is associated.
        public var cloneGroupId: Swift.String?
        /// Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public var clusterCreateTime: ClientRuntime.Date?
        /// Specifies whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public var copyTagsToSnapshot: Swift.Bool?
        /// Specifies whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public var crossAccountClone: Swift.Bool?
        /// Identifies all custom endpoints associated with the cluster.
        public var customEndpoints: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the DB cluster.
        public var dBClusterArn: Swift.String?
        /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
        public var dBClusterIdentifier: Swift.String?
        /// Provides the list of instances that make up the DB cluster.
        public var dBClusterMembers: [RdsClientTypes.DBClusterMember]?
        /// Provides the list of option group memberships for this DB cluster.
        public var dBClusterOptionGroupMemberships: [RdsClientTypes.DBClusterOptionGroupStatus]?
        /// Specifies the name of the DB cluster parameter group for the DB cluster.
        public var dBClusterParameterGroup: Swift.String?
        /// Specifies information on the subnet group associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public var dBSubnetGroup: Swift.String?
        /// Contains the name of the initial database of this DB cluster that was provided at create time, if one was specified when the DB cluster was created. This same name is returned for the life of the DB cluster.
        public var databaseName: Swift.String?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB cluster. This identifier is found in Amazon Web Services CloudTrail log entries whenever
        ///           the Amazon Web Services KMS CMK for the DB cluster is accessed.
        public var dbClusterResourceId: Swift.String?
        /// Indicates if the DB cluster has deletion protection enabled.
        ///             The database can't be deleted when deletion protection is enabled.
        ///
        public var deletionProtection: Swift.Bool?
        /// The Active Directory Domain membership records associated with the DB cluster.
        public var domainMemberships: [RdsClientTypes.DomainMembership]?
        /// The earliest time to which a DB cluster can be backtracked.
        public var earliestBacktrackTime: ClientRuntime.Date?
        /// The earliest time to which a database can be restored with point-in-time
        ///             restore.
        public var earliestRestorableTime: ClientRuntime.Date?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs.
        ///         Log types vary by DB engine. For information about the log types for each DB engine, see
        ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html">Amazon RDS Database Log Files in the Amazon Aurora User Guide.
        ///
        public var enabledCloudwatchLogsExports: [Swift.String]?
        /// Specifies the connection endpoint for the primary instance of the DB cluster.
        public var endpoint: Swift.String?
        /// The name of the database engine to be used for this DB cluster.
        public var engine: Swift.String?
        /// The DB engine mode of the DB cluster, either provisioned, serverless,
        ///             parallelquery, global, or multimaster.
        ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html">
        ///             CreateDBCluster.
        public var engineMode: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// Specifies whether you have requested to enable write forwarding for a secondary cluster
        ///       in an Aurora global database. Because write forwarding takes time to enable, check the
        ///       value of GlobalWriteForwardingStatus to confirm that the request has completed
        ///       before using the write forwarding feature for this cluster.
        public var globalWriteForwardingRequested: Swift.Bool?
        /// Specifies whether a secondary cluster in an Aurora global database has
        ///         write forwarding enabled, not enabled, or is in the process of enabling it.
        public var globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// A value that indicates whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.
        ///          When enabled, the HTTP endpoint provides a connectionless web service API for running
        ///           SQL queries on the Aurora Serverless DB cluster. You can also query your database
        ///           from inside the RDS console with the query editor.
        ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API for Aurora Serverless in the
        ///           Amazon Aurora User Guide.
        public var httpEndpointEnabled: Swift.Bool?
        /// A value that indicates whether the mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool?
        /// If StorageEncrypted is enabled, the Amazon Web Services KMS key identifier for the encrypted DB cluster.
        ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var kmsKeyId: Swift.String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore.
        public var latestRestorableTime: ClientRuntime.Date?
        /// Contains the master username for the DB cluster.
        public var masterUsername: Swift.String?
        /// Specifies whether the DB cluster has instances in multiple Availability Zones.
        public var multiAZ: Swift.Bool?
        /// A value that specifies that changes to the DB cluster are pending. This element is only included when changes are pending.
        ///           Specific changes are identified by subelements.
        public var pendingModifiedValues: RdsClientTypes.ClusterPendingModifiedValues?
        /// Specifies the progress of the operation as a percentage.
        public var percentProgress: Swift.String?
        /// Specifies the port that the database engine is listening on.
        public var port: Swift.Int?
        /// Specifies the daily time range during which automated backups are
        ///             created if automated backups are enabled, as determined
        ///             by the BackupRetentionPeriod.
        ///
        public var preferredBackupWindow: Swift.String?
        /// Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
        public var preferredMaintenanceWindow: Swift.String?
        /// Contains one or more identifiers of the read replicas associated with this DB
        ///             cluster.
        public var readReplicaIdentifiers: [Swift.String]?
        /// The reader endpoint for the DB cluster. The reader endpoint for a DB cluster load-balances
        ///             connections across the Aurora Replicas that are available in a DB cluster. As clients request new connections
        ///             to the reader endpoint, Aurora distributes the connection requests among the Aurora Replicas in the DB cluster.
        ///             This functionality can help balance your read workload across multiple Aurora Replicas in your DB cluster.
        ///         If a failover occurs, and the Aurora Replica that you are connected to is promoted
        ///             to be the primary instance, your connection is dropped. To
        ///             continue sending your read workload to other Aurora Replicas in the cluster,
        ///             you can then reconnect to the reader endpoint.
        public var readerEndpoint: Swift.String?
        /// Contains the identifier of the source DB cluster if this DB cluster is a read
        ///             replica.
        public var replicationSourceIdentifier: Swift.String?
        /// Shows the scaling configuration for an Aurora DB cluster in serverless DB engine mode.
        ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless in the
        ///             Amazon Aurora User Guide.
        public var scalingConfigurationInfo: RdsClientTypes.ScalingConfigurationInfo?
        /// Specifies the current state of this DB cluster.
        public var status: Swift.String?
        /// Specifies whether the DB cluster is encrypted.
        public var storageEncrypted: Swift.Bool
        /// A list of tags.
        ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
        ///
        public var tagList: [RdsClientTypes.Tag]?
        /// Provides a list of VPC security groups that the DB cluster belongs to.
        public var vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]?

        public init (
            activityStreamKinesisStreamName: Swift.String? = nil,
            activityStreamKmsKeyId: Swift.String? = nil,
            activityStreamMode: RdsClientTypes.ActivityStreamMode? = nil,
            activityStreamStatus: RdsClientTypes.ActivityStreamStatus? = nil,
            allocatedStorage: Swift.Int? = nil,
            associatedRoles: [RdsClientTypes.DBClusterRole]? = nil,
            automaticRestartTime: ClientRuntime.Date? = nil,
            availabilityZones: [Swift.String]? = nil,
            backtrackConsumedChangeRecords: Swift.Int? = nil,
            backtrackWindow: Swift.Int? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            capacity: Swift.Int? = nil,
            characterSetName: Swift.String? = nil,
            cloneGroupId: Swift.String? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            copyTagsToSnapshot: Swift.Bool? = nil,
            crossAccountClone: Swift.Bool? = nil,
            customEndpoints: [Swift.String]? = nil,
            dBClusterArn: Swift.String? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBClusterMembers: [RdsClientTypes.DBClusterMember]? = nil,
            dBClusterOptionGroupMemberships: [RdsClientTypes.DBClusterOptionGroupStatus]? = nil,
            dBClusterParameterGroup: Swift.String? = nil,
            dBSubnetGroup: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            dbClusterResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            domainMemberships: [RdsClientTypes.DomainMembership]? = nil,
            earliestBacktrackTime: ClientRuntime.Date? = nil,
            earliestRestorableTime: ClientRuntime.Date? = nil,
            enabledCloudwatchLogsExports: [Swift.String]? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineMode: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            globalWriteForwardingRequested: Swift.Bool? = nil,
            globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus? = nil,
            hostedZoneId: Swift.String? = nil,
            httpEndpointEnabled: Swift.Bool? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: ClientRuntime.Date? = nil,
            masterUsername: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            pendingModifiedValues: RdsClientTypes.ClusterPendingModifiedValues? = nil,
            percentProgress: Swift.String? = nil,
            port: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            readReplicaIdentifiers: [Swift.String]? = nil,
            readerEndpoint: Swift.String? = nil,
            replicationSourceIdentifier: Swift.String? = nil,
            scalingConfigurationInfo: RdsClientTypes.ScalingConfigurationInfo? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            tagList: [RdsClientTypes.Tag]? = nil,
            vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
            self.activityStreamKmsKeyId = activityStreamKmsKeyId
            self.activityStreamMode = activityStreamMode
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.automaticRestartTime = automaticRestartTime
            self.availabilityZones = availabilityZones
            self.backtrackConsumedChangeRecords = backtrackConsumedChangeRecords
            self.backtrackWindow = backtrackWindow
            self.backupRetentionPeriod = backupRetentionPeriod
            self.capacity = capacity
            self.characterSetName = characterSetName
            self.cloneGroupId = cloneGroupId
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.dBClusterArn = dBClusterArn
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBClusterMembers = dBClusterMembers
            self.dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships
            self.dBClusterParameterGroup = dBClusterParameterGroup
            self.dBSubnetGroup = dBSubnetGroup
            self.databaseName = databaseName
            self.dbClusterResourceId = dbClusterResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.earliestBacktrackTime = earliestBacktrackTime
            self.earliestRestorableTime = earliestRestorableTime
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.globalWriteForwardingRequested = globalWriteForwardingRequested
            self.globalWriteForwardingStatus = globalWriteForwardingStatus
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.masterUsername = masterUsername
            self.multiAZ = multiAZ
            self.pendingModifiedValues = pendingModifiedValues
            self.percentProgress = percentProgress
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.readerEndpoint = readerEndpoint
            self.replicationSourceIdentifier = replicationSourceIdentifier
            self.scalingConfigurationInfo = scalingConfigurationInfo
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.tagList = tagList
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DBClusterAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user already has a DB cluster with the given identifier.
public struct DBClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterBacktrack: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backtrackIdentifier = "BacktrackIdentifier"
        case backtrackRequestCreationTime = "BacktrackRequestCreationTime"
        case backtrackTo = "BacktrackTo"
        case backtrackedFrom = "BacktrackedFrom"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackIdentifier = backtrackIdentifier {
            try container.encode(backtrackIdentifier, forKey: ClientRuntime.Key("BacktrackIdentifier"))
        }
        if let backtrackRequestCreationTime = backtrackRequestCreationTime {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackRequestCreationTime, format: .dateTime), forKey: ClientRuntime.Key("backtrackRequestCreationTime"))
        }
        if let backtrackTo = backtrackTo {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackTo, format: .dateTime), forKey: ClientRuntime.Key("backtrackTo"))
        }
        if let backtrackedFrom = backtrackedFrom {
            try container.encode(ClientRuntime.TimestampWrapper(backtrackedFrom, format: .dateTime), forKey: ClientRuntime.Key("backtrackedFrom"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let backtrackIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackIdentifier)
        backtrackIdentifier = backtrackIdentifierDecoded
        let backtrackToDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackTo)
        var backtrackToBuffer:ClientRuntime.Date? = nil
        if let backtrackToDecoded = backtrackToDecoded {
            backtrackToBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackToDecoded, format: .dateTime)
        }
        backtrackTo = backtrackToBuffer
        let backtrackedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackedFrom)
        var backtrackedFromBuffer:ClientRuntime.Date? = nil
        if let backtrackedFromDecoded = backtrackedFromDecoded {
            backtrackedFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackedFromDecoded, format: .dateTime)
        }
        backtrackedFrom = backtrackedFromBuffer
        let backtrackRequestCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backtrackRequestCreationTime)
        var backtrackRequestCreationTimeBuffer:ClientRuntime.Date? = nil
        if let backtrackRequestCreationTimeDecoded = backtrackRequestCreationTimeDecoded {
            backtrackRequestCreationTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(backtrackRequestCreationTimeDecoded, format: .dateTime)
        }
        backtrackRequestCreationTime = backtrackRequestCreationTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes.DBClusterBacktrack: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterBacktrack(backtrackIdentifier: \(Swift.String(describing: backtrackIdentifier)), backtrackRequestCreationTime: \(Swift.String(describing: backtrackRequestCreationTime)), backtrackTo: \(Swift.String(describing: backtrackTo)), backtrackedFrom: \(Swift.String(describing: backtrackedFrom)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// This data type is used as a response element in the DescribeDBClusterBacktracks action.
    public struct DBClusterBacktrack: Swift.Equatable {
        /// Contains the backtrack identifier.
        public var backtrackIdentifier: Swift.String?
        /// The timestamp of the time at which the backtrack was requested.
        public var backtrackRequestCreationTime: ClientRuntime.Date?
        /// The timestamp of the time to which the DB cluster was backtracked.
        public var backtrackTo: ClientRuntime.Date?
        /// The timestamp of the time from which the DB cluster was backtracked.
        public var backtrackedFrom: ClientRuntime.Date?
        /// Contains a user-supplied DB cluster identifier. This identifier is the unique key that identifies a DB cluster.
        public var dBClusterIdentifier: Swift.String?
        /// The status of the backtrack. This property returns one of the following
        ///             values:
        ///
        ///
        ///
        ///                   applying - The backtrack is currently being applied to or rolled back from the DB cluster.
        ///
        ///
        ///
        ///                   completed - The backtrack has successfully been applied to or rolled back from the DB cluster.
        ///
        ///
        ///
        ///                   failed - An error occurred while the backtrack was applied to or rolled back from the DB cluster.
        ///
        ///
        ///
        ///                   pending - The backtrack is currently pending application to or rollback from the DB cluster.
        ///
        ///
        public var status: Swift.String?

        public init (
            backtrackIdentifier: Swift.String? = nil,
            backtrackRequestCreationTime: ClientRuntime.Date? = nil,
            backtrackTo: ClientRuntime.Date? = nil,
            backtrackedFrom: ClientRuntime.Date? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.backtrackIdentifier = backtrackIdentifier
            self.backtrackRequestCreationTime = backtrackRequestCreationTime
            self.backtrackTo = backtrackTo
            self.backtrackedFrom = backtrackedFrom
            self.dBClusterIdentifier = dBClusterIdentifier
            self.status = status
        }
    }

}

extension DBClusterBacktrackNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterBacktrackNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterBacktrackNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterBacktrackNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             BacktrackIdentifier doesn't refer to an existing backtrack.
public struct DBClusterBacktrackNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterBacktrackNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterBacktrackNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customEndpointType = customEndpointType {
            try container.encode(customEndpointType, forKey: ClientRuntime.Key("CustomEndpointType"))
        }
        if let dBClusterEndpointArn = dBClusterEndpointArn {
            try container.encode(dBClusterEndpointArn, forKey: ClientRuntime.Key("DBClusterEndpointArn"))
        }
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier {
            try container.encode(dBClusterEndpointResourceIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointResourceIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

extension RdsClientTypes.DBClusterEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpoint(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// This data type represents the information you need to connect to an Amazon Aurora DB cluster.
    ///       This data type is used as a response element in the following actions:
    ///
    ///
    ///
    ///                   CreateDBClusterEndpoint
    ///
    ///
    ///
    ///
    ///                   DescribeDBClusterEndpoints
    ///
    ///
    ///
    ///
    ///                   ModifyDBClusterEndpoint
    ///
    ///
    ///
    ///
    ///                   DeleteDBClusterEndpoint
    ///
    ///
    ///
    ///          For the data structure that represents Amazon RDS DB instance endpoints,
    ///         see Endpoint.
    public struct DBClusterEndpoint: Swift.Equatable {
        /// The type associated with a custom endpoint. One of: READER,
        ///        WRITER, ANY.
        public var customEndpointType: Swift.String?
        /// The Amazon Resource Name (ARN) for the endpoint.
        public var dBClusterEndpointArn: Swift.String?
        /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
        public var dBClusterEndpointIdentifier: Swift.String?
        /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
        public var dBClusterEndpointResourceIdentifier: Swift.String?
        /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
        ///             stored as a lowercase string.
        public var dBClusterIdentifier: Swift.String?
        /// The DNS address of the endpoint.
        public var endpoint: Swift.String?
        /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
        public var endpointType: Swift.String?
        /// List of DB instance identifiers that aren't part of the custom endpoint group.
        ///        All other eligible instances are reachable through the custom endpoint.
        ///        Only relevant if the list of static members is empty.
        public var excludedMembers: [Swift.String]?
        /// List of DB instance identifiers that are part of the custom endpoint group.
        public var staticMembers: [Swift.String]?
        /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster,
        ///      such as a writer endpoint for a read-only secondary cluster in a global database.
        public var status: Swift.String?

        public init (
            customEndpointType: Swift.String? = nil,
            dBClusterEndpointArn: Swift.String? = nil,
            dBClusterEndpointIdentifier: Swift.String? = nil,
            dBClusterEndpointResourceIdentifier: Swift.String? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            endpointType: Swift.String? = nil,
            excludedMembers: [Swift.String]? = nil,
            staticMembers: [Swift.String]? = nil,
            status: Swift.String? = nil
        )
        {
            self.customEndpointType = customEndpointType
            self.dBClusterEndpointArn = dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = dBClusterIdentifier
            self.endpoint = endpoint
            self.endpointType = endpointType
            self.excludedMembers = excludedMembers
            self.staticMembers = staticMembers
            self.status = status
        }
    }

}

extension DBClusterEndpointAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpointAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterEndpointAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified custom endpoint can't be created because it already exists.
public struct DBClusterEndpointAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterEndpointAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpointNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterEndpointNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified custom endpoint doesn't exist.
public struct DBClusterEndpointNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterEndpointNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterEndpointQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterEndpointQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterEndpointQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cluster already has the maximum number of custom endpoints.
public struct DBClusterEndpointQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterEndpointQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterEndpointQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupStatus = "DBClusterParameterGroupStatus"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupStatus = dBClusterParameterGroupStatus {
            try container.encode(dBClusterParameterGroupStatus, forKey: ClientRuntime.Key("DBClusterParameterGroupStatus"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if isClusterWriter != false {
            try container.encode(isClusterWriter, forKey: ClientRuntime.Key("IsClusterWriter"))
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let isClusterWriterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isClusterWriter)
        isClusterWriter = isClusterWriterDecoded
        let dBClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupStatus)
        dBClusterParameterGroupStatus = dBClusterParameterGroupStatusDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
    }
}

extension RdsClientTypes.DBClusterMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterMember(dBClusterParameterGroupStatus: \(Swift.String(describing: dBClusterParameterGroupStatus)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), isClusterWriter: \(Swift.String(describing: isClusterWriter)), promotionTier: \(Swift.String(describing: promotionTier)))"}
}

extension RdsClientTypes {
    /// Contains information about an instance that is part of a DB cluster.
    public struct DBClusterMember: Swift.Equatable {
        /// Specifies the status of the DB cluster parameter group for this member of the DB cluster.
        public var dBClusterParameterGroupStatus: Swift.String?
        /// Specifies the instance identifier for this member of the DB cluster.
        public var dBInstanceIdentifier: Swift.String?
        /// Value that is true if the cluster member is the primary instance for the DB cluster and false otherwise.
        public var isClusterWriter: Swift.Bool
        /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance
        ///       after a failure of the existing primary instance. For more information,
        ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
        ///           Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide.
        ///
        public var promotionTier: Swift.Int?

        public init (
            dBClusterParameterGroupStatus: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            isClusterWriter: Swift.Bool = false,
            promotionTier: Swift.Int? = nil
        )
        {
            self.dBClusterParameterGroupStatus = dBClusterParameterGroupStatus
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }
    }

}

extension DBClusterNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBClusterIdentifier doesn't refer to an existing DB cluster.
///
public struct DBClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterOptionGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterOptionGroupName = "DBClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterOptionGroupName = dBClusterOptionGroupName {
            try container.encode(dBClusterOptionGroupName, forKey: ClientRuntime.Key("DBClusterOptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterOptionGroupName)
        dBClusterOptionGroupName = dBClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes.DBClusterOptionGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterOptionGroupStatus(dBClusterOptionGroupName: \(Swift.String(describing: dBClusterOptionGroupName)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// Contains status information for a DB cluster option group.
    public struct DBClusterOptionGroupStatus: Swift.Equatable {
        /// Specifies the name of the DB cluster option group.
        public var dBClusterOptionGroupName: Swift.String?
        /// Specifies the status of the DB cluster option group.
        public var status: Swift.String?

        public init (
            dBClusterOptionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dBClusterOptionGroupName = dBClusterOptionGroupName
            self.status = status
        }
    }

}

extension RdsClientTypes.DBClusterParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupArn = "DBClusterParameterGroupArn"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupArn = dBClusterParameterGroupArn {
            try container.encode(dBClusterParameterGroupArn, forKey: ClientRuntime.Key("DBClusterParameterGroupArn"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dBClusterParameterGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupArn)
        dBClusterParameterGroupArn = dBClusterParameterGroupArnDecoded
    }
}

extension RdsClientTypes.DBClusterParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterParameterGroup(dBClusterParameterGroupArn: \(Swift.String(describing: dBClusterParameterGroupArn)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), description: \(Swift.String(describing: description)))"}
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB cluster parameter group.
    ///
    ///          This data type is used as a response element in the DescribeDBClusterParameterGroups action.
    ///
    public struct DBClusterParameterGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB cluster parameter group.
        public var dBClusterParameterGroupArn: Swift.String?
        /// The name of the DB cluster parameter group.
        public var dBClusterParameterGroupName: Swift.String?
        /// The name of the DB parameter group family that this DB cluster parameter group is compatible with.
        public var dBParameterGroupFamily: Swift.String?
        /// Provides the customer-specified description for this DB cluster parameter group.
        public var description: Swift.String?

        public init (
            dBClusterParameterGroupArn: Swift.String? = nil,
            dBClusterParameterGroupName: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.dBClusterParameterGroupArn = dBClusterParameterGroupArn
            self.dBClusterParameterGroupName = dBClusterParameterGroupName
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.description = description
        }
    }

}

extension DBClusterParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterParameterGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBClusterParameterGroupName doesn't refer to an existing DB
///             cluster parameter group.
public struct DBClusterParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user attempted to create a new DB cluster and the user has already reached the
///             maximum allowed DB cluster quota.
public struct DBClusterQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterRole: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
    }
}

extension RdsClientTypes.DBClusterRole: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRole(featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// Describes an Amazon Web Services Identity and Access Management (IAM) role that is associated with a DB cluster.
    public struct DBClusterRole: Swift.Equatable {
        /// The name of the feature associated with the Amazon Web Services Identity and Access Management (IAM) role.
        ///             For the list of supported feature names, see DBEngineVersion.
        ///
        public var featureName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
        public var roleArn: Swift.String?
        /// Describes the state of association between the IAM role and the DB cluster. The Status property returns one of the following
        ///         values:
        ///
        ///
        ///
        ///                   ACTIVE - the IAM role ARN is associated with the DB cluster and can be used to
        ///             access other Amazon Web Services on your behalf.
        ///
        ///
        ///
        ///                   PENDING - the IAM role ARN is being associated with the DB cluster.
        ///
        ///
        ///
        ///                   INVALID - the IAM role ARN is associated with the DB cluster, but the DB cluster is unable
        ///                 to assume the IAM role in order to access other Amazon Web Services on your behalf.
        ///
        ///
        public var status: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension DBClusterRoleAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRoleAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterRoleAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified IAM role Amazon Resource Name (ARN) is already associated with the specified DB cluster.
public struct DBClusterRoleAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterRoleAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRoleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified IAM role Amazon Resource Name (ARN) isn't associated with the specified DB cluster.
public struct DBClusterRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBClusterRoleQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterRoleQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterRoleQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of IAM roles that can be associated with the specified DB cluster.
public struct DBClusterRoleQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterRoleQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterRoleQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterSnapshot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterSnapshotArn = "DBClusterSnapshotArn"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBClusterSnapshotArn = "SourceDBClusterSnapshotArn"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case tagList = "TagList"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotArn = dBClusterSnapshotArn {
            try container.encode(dBClusterSnapshotArn, forKey: ClientRuntime.Key("DBClusterSnapshotArn"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn {
            try container.encode(sourceDBClusterSnapshotArn, forKey: ClientRuntime.Key("SourceDBClusterSnapshotArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotArn)
        dBClusterSnapshotArn = dBClusterSnapshotArnDecoded
        let sourceDBClusterSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterSnapshotArn)
        sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArnDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension RdsClientTypes.DBClusterSnapshot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshot(allocatedStorage: \(Swift.String(describing: allocatedStorage)), availabilityZones: \(Swift.String(describing: availabilityZones)), clusterCreateTime: \(Swift.String(describing: clusterCreateTime)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterSnapshotArn: \(Swift.String(describing: dBClusterSnapshotArn)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), engine: \(Swift.String(describing: engine)), engineMode: \(Swift.String(describing: engineMode)), engineVersion: \(Swift.String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUsername: \(Swift.String(describing: masterUsername)), percentProgress: \(Swift.String(describing: percentProgress)), port: \(Swift.String(describing: port)), snapshotCreateTime: \(Swift.String(describing: snapshotCreateTime)), snapshotType: \(Swift.String(describing: snapshotType)), sourceDBClusterSnapshotArn: \(Swift.String(describing: sourceDBClusterSnapshotArn)), status: \(Swift.String(describing: status)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), tagList: \(Swift.String(describing: tagList)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RdsClientTypes {
    /// Contains the details for an Amazon RDS DB cluster snapshot
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBClusterSnapshots action.
    ///
    public struct DBClusterSnapshot: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// Provides the list of Availability Zones (AZs) where instances in the DB cluster snapshot can be restored.
        public var availabilityZones: [Swift.String]?
        /// Specifies the time when the DB cluster was created, in Universal Coordinated Time (UTC).
        public var clusterCreateTime: ClientRuntime.Date?
        /// Specifies the DB cluster identifier of the DB cluster that this DB cluster snapshot was created from.
        public var dBClusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) for the DB cluster snapshot.
        public var dBClusterSnapshotArn: Swift.String?
        /// Specifies the identifier for the DB cluster snapshot.
        public var dBClusterSnapshotIdentifier: Swift.String?
        /// Specifies the name of the database engine for this DB cluster snapshot.
        public var engine: Swift.String?
        /// Provides the engine mode of the database engine for this DB cluster snapshot.
        public var engineMode: Swift.String?
        /// Provides the version of the database engine for this DB cluster snapshot.
        public var engineVersion: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// If StorageEncrypted is true, the Amazon Web Services KMS key identifier for the encrypted DB cluster snapshot.
        ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var kmsKeyId: Swift.String?
        /// Provides the license model information for this DB cluster snapshot.
        public var licenseModel: Swift.String?
        /// Provides the master username for this DB cluster snapshot.
        public var masterUsername: Swift.String?
        /// Specifies the percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int
        /// Specifies the port that the DB cluster was listening on at the time of the snapshot.
        public var port: Swift.Int
        /// Provides the time when the snapshot was taken, in Universal Coordinated Time (UTC).
        public var snapshotCreateTime: ClientRuntime.Date?
        /// Provides the type of the DB cluster snapshot.
        public var snapshotType: Swift.String?
        /// If the DB cluster snapshot was copied from a source DB cluster snapshot, the Amazon
        ///             Resource Name (ARN) for the source DB cluster snapshot, otherwise, a null value.
        public var sourceDBClusterSnapshotArn: Swift.String?
        /// Specifies the status of this DB cluster snapshot.
        public var status: Swift.String?
        /// Specifies whether the DB cluster snapshot is encrypted.
        public var storageEncrypted: Swift.Bool
        /// A list of tags.
        ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
        ///
        public var tagList: [RdsClientTypes.Tag]?
        /// Provides the VPC ID associated with the DB cluster snapshot.
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZones: [Swift.String]? = nil,
            clusterCreateTime: ClientRuntime.Date? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBClusterSnapshotArn: Swift.String? = nil,
            dBClusterSnapshotIdentifier: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineMode: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotType: Swift.String? = nil,
            sourceDBClusterSnapshotArn: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            tagList: [RdsClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBClusterSnapshotArn = dBClusterSnapshotArn
            self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDBClusterSnapshotArn = sourceDBClusterSnapshotArn
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.tagList = tagList
            self.vpcId = vpcId
        }
    }

}

extension DBClusterSnapshotAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterSnapshotAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user already has a DB cluster snapshot with the given identifier.
public struct DBClusterSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBClusterSnapshotAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var attributeValuesBuffer:[Swift.String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [Swift.String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension RdsClientTypes.DBClusterSnapshotAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotAttribute(attributeName: \(Swift.String(describing: attributeName)), attributeValues: \(Swift.String(describing: attributeValues)))"}
}

extension RdsClientTypes {
    /// Contains the name and values of a manual DB cluster snapshot attribute.
    ///         Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts
    ///             to restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute
    ///             API action.
    public struct DBClusterSnapshotAttribute: Swift.Equatable {
        /// The name of the manual DB cluster snapshot attribute.
        ///         The attribute named restore refers to the list of Amazon Web Services accounts that
        ///             have permission to copy or restore the manual DB cluster snapshot. For more information,
        ///             see the ModifyDBClusterSnapshotAttribute
        ///             API action.
        public var attributeName: Swift.String?
        /// The value(s) for the manual DB cluster snapshot attribute.
        ///         If the AttributeName field is set to restore, then this element
        ///             returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual
        ///             DB cluster snapshot. If a value of all is in the list, then the manual DB cluster snapshot
        ///             is public and available for any Amazon Web Services account to copy or restore.
        public var attributeValues: [Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            attributeValues: [Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension RdsClientTypes.DBClusterSnapshotAttributesResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributes = "DBClusterSnapshotAttributes"
        case dBClusterSnapshotIdentifier = "DBClusterSnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotAttributes = dBClusterSnapshotAttributes {
            var dBClusterSnapshotAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterSnapshotAttributes"))
            for (index0, dbclustersnapshotattribute0) in dBClusterSnapshotAttributes.enumerated() {
                try dBClusterSnapshotAttributesContainer.encode(dbclustersnapshotattribute0, forKey: ClientRuntime.Key("DBClusterSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterSnapshotIdentifier)
        dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifierDecoded
        if containerValues.contains(.dBClusterSnapshotAttributes) {
            struct KeyVal0{struct DBClusterSnapshotAttribute{}}
            let dBClusterSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshotAttribute>.CodingKeys.self, forKey: .dBClusterSnapshotAttributes)
            if let dBClusterSnapshotAttributesWrappedContainer = dBClusterSnapshotAttributesWrappedContainer {
                let dBClusterSnapshotAttributesContainer = try dBClusterSnapshotAttributesWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterSnapshotAttribute].self, forKey: .member)
                var dBClusterSnapshotAttributesBuffer:[RdsClientTypes.DBClusterSnapshotAttribute]? = nil
                if let dBClusterSnapshotAttributesContainer = dBClusterSnapshotAttributesContainer {
                    dBClusterSnapshotAttributesBuffer = [RdsClientTypes.DBClusterSnapshotAttribute]()
                    for structureContainer0 in dBClusterSnapshotAttributesContainer {
                        dBClusterSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshotAttributes = dBClusterSnapshotAttributesBuffer
            } else {
                dBClusterSnapshotAttributes = []
            }
        } else {
            dBClusterSnapshotAttributes = nil
        }
    }
}

extension RdsClientTypes.DBClusterSnapshotAttributesResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotAttributesResult(dBClusterSnapshotAttributes: \(Swift.String(describing: dBClusterSnapshotAttributes)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)))"}
}

extension RdsClientTypes {
    /// Contains the results of a successful call to the DescribeDBClusterSnapshotAttributes
    ///             API action.
    ///         Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts
    ///             to copy or restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute
    ///             API action.
    public struct DBClusterSnapshotAttributesResult: Swift.Equatable {
        /// The list of attributes and values for the manual DB cluster snapshot.
        public var dBClusterSnapshotAttributes: [RdsClientTypes.DBClusterSnapshotAttribute]?
        /// The identifier of the manual DB cluster snapshot that the attributes apply to.
        public var dBClusterSnapshotIdentifier: Swift.String?

        public init (
            dBClusterSnapshotAttributes: [RdsClientTypes.DBClusterSnapshotAttribute]? = nil,
            dBClusterSnapshotIdentifier: Swift.String? = nil
        )
        {
            self.dBClusterSnapshotAttributes = dBClusterSnapshotAttributes
            self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        }
    }

}

extension DBClusterSnapshotNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBClusterSnapshotNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBClusterSnapshotNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBClusterSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBClusterSnapshotIdentifier doesn't refer to an existing DB cluster snapshot.
///
public struct DBClusterSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBClusterSnapshotNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBClusterSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBEngineVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: ClientRuntime.Key("DBEngineDescription"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: ClientRuntime.Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: ClientRuntime.Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedFeatureNames = supportedFeatureNames {
            var supportedFeatureNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedFeatureNames"))
            for (index0, string0) in supportedFeatureNames.enumerated() {
                try supportedFeatureNamesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedNcharCharacterSets = supportedNcharCharacterSets {
            var supportedNcharCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedNcharCharacterSets"))
            for (index0, characterset0) in supportedNcharCharacterSets.enumerated() {
                try supportedNcharCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: ClientRuntime.Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: ClientRuntime.Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsParallelQuery != false {
            try container.encode(supportsParallelQuery, forKey: ClientRuntime.Key("SupportsParallelQuery"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: ClientRuntime.Key("SupportsReadReplica"))
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: ClientRuntime.Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension RdsClientTypes.DBEngineVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBEngineVersion(dBEngineDescription: \(Swift.String(describing: dBEngineDescription)), dBEngineVersionDescription: \(Swift.String(describing: dBEngineVersionDescription)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), defaultCharacterSet: \(Swift.String(describing: defaultCharacterSet)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), exportableLogTypes: \(Swift.String(describing: exportableLogTypes)), status: \(Swift.String(describing: status)), supportedCharacterSets: \(Swift.String(describing: supportedCharacterSets)), supportedEngineModes: \(Swift.String(describing: supportedEngineModes)), supportedFeatureNames: \(Swift.String(describing: supportedFeatureNames)), supportedNcharCharacterSets: \(Swift.String(describing: supportedNcharCharacterSets)), supportedTimezones: \(Swift.String(describing: supportedTimezones)), supportsGlobalDatabases: \(Swift.String(describing: supportsGlobalDatabases)), supportsLogExportsToCloudwatchLogs: \(Swift.String(describing: supportsLogExportsToCloudwatchLogs)), supportsParallelQuery: \(Swift.String(describing: supportsParallelQuery)), supportsReadReplica: \(Swift.String(describing: supportsReadReplica)), validUpgradeTarget: \(Swift.String(describing: validUpgradeTarget)))"}
}

extension RdsClientTypes {
    ///
    ///             This data type is used as a response element in the action DescribeDBEngineVersions.
    ///
    public struct DBEngineVersion: Swift.Equatable {
        /// The description of the database engine.
        public var dBEngineDescription: Swift.String?
        /// The description of the database engine version.
        public var dBEngineVersionDescription: Swift.String?
        /// The name of the DB parameter group family for the database engine.
        public var dBParameterGroupFamily: Swift.String?
        ///
        ///             The default character set for new instances of this engine version,
        ///             if the CharacterSetName parameter of the CreateDBInstance API
        ///             isn't specified.
        ///
        public var defaultCharacterSet: RdsClientTypes.CharacterSet?
        /// The name of the database engine.
        public var engine: Swift.String?
        /// The version number of the database engine.
        public var engineVersion: Swift.String?
        /// The types of logs that the database engine has available for export to CloudWatch Logs.
        public var exportableLogTypes: [Swift.String]?
        /// The status of the DB engine version, either available or deprecated.
        public var status: Swift.String?
        /// A list of the character sets supported by this engine for the CharacterSetName parameter of the CreateDBInstance operation.
        ///
        public var supportedCharacterSets: [RdsClientTypes.CharacterSet]?
        /// A list of the supported DB engine modes.
        public var supportedEngineModes: [Swift.String]?
        ///
        ///         A list of features supported by the DB engine. Supported feature names include the following.
        ///
        ///
        ///
        ///                s3Import
        ///
        ///
        public var supportedFeatureNames: [Swift.String]?
        /// A list of the character sets supported by the Oracle DB engine for the NcharCharacterSetName parameter of the CreateDBInstance operation.
        ///
        public var supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
        /// A list of the time zones supported by this engine for the
        ///             Timezone parameter of the CreateDBInstance action.
        ///
        public var supportedTimezones: [RdsClientTypes.Timezone]?
        /// A value that indicates whether you can use Aurora global databases with a specific DB engine version.
        public var supportsGlobalDatabases: Swift.Bool
        /// A value that indicates whether the engine version supports exporting the log types specified by ExportableLogTypes to CloudWatch Logs.
        public var supportsLogExportsToCloudwatchLogs: Swift.Bool
        /// A value that indicates whether you can use Aurora parallel query with a specific DB engine version.
        public var supportsParallelQuery: Swift.Bool
        /// Indicates whether the database engine version supports read replicas.
        public var supportsReadReplica: Swift.Bool
        /// A list of engine versions that this database engine version can be upgraded to.
        public var validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?

        public init (
            dBEngineDescription: Swift.String? = nil,
            dBEngineVersionDescription: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            defaultCharacterSet: RdsClientTypes.CharacterSet? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            exportableLogTypes: [Swift.String]? = nil,
            status: Swift.String? = nil,
            supportedCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
            supportedEngineModes: [Swift.String]? = nil,
            supportedFeatureNames: [Swift.String]? = nil,
            supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]? = nil,
            supportedTimezones: [RdsClientTypes.Timezone]? = nil,
            supportsGlobalDatabases: Swift.Bool = false,
            supportsLogExportsToCloudwatchLogs: Swift.Bool = false,
            supportsParallelQuery: Swift.Bool = false,
            supportsReadReplica: Swift.Bool = false,
            validUpgradeTarget: [RdsClientTypes.UpgradeTarget]? = nil
        )
        {
            self.dBEngineDescription = dBEngineDescription
            self.dBEngineVersionDescription = dBEngineVersionDescription
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.defaultCharacterSet = defaultCharacterSet
            self.engine = engine
            self.engineVersion = engineVersion
            self.exportableLogTypes = exportableLogTypes
            self.status = status
            self.supportedCharacterSets = supportedCharacterSets
            self.supportedEngineModes = supportedEngineModes
            self.supportedFeatureNames = supportedFeatureNames
            self.supportedNcharCharacterSets = supportedNcharCharacterSets
            self.supportedTimezones = supportedTimezones
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogs
            self.supportsParallelQuery = supportsParallelQuery
            self.supportsReadReplica = supportsReadReplica
            self.validUpgradeTarget = validUpgradeTarget
        }
    }

}

extension RdsClientTypes.DBInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityStreamEngineNativeAuditFieldsIncluded = "ActivityStreamEngineNativeAuditFieldsIncluded"
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticRestartTime = "AutomaticRestartTime"
        case availabilityZone = "AvailabilityZone"
        case awsBackupRecoveryPointArn = "AwsBackupRecoveryPointArn"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case customerOwnedIpEnabled = "CustomerOwnedIpEnabled"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBInstanceStatus = "DBInstanceStatus"
        case dBName = "DBName"
        case dBParameterGroups = "DBParameterGroups"
        case dBSecurityGroups = "DBSecurityGroups"
        case dBSubnetGroup = "DBSubnetGroup"
        case dbInstancePort = "DbInstancePort"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case listenerEndpoint = "ListenerEndpoint"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case ncharCharacterSetName = "NcharCharacterSetName"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case replicaMode = "ReplicaMode"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tagList = "TagList"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncluded {
            try container.encode(activityStreamEngineNativeAuditFieldsIncluded, forKey: ClientRuntime.Key("ActivityStreamEngineNativeAuditFieldsIncluded"))
        }
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: ClientRuntime.Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: ClientRuntime.Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: ClientRuntime.Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: ClientRuntime.Key("ActivityStreamStatus"))
        }
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedRoles"))
            for (index0, dbinstancerole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbinstancerole0, forKey: ClientRuntime.Key("DBInstanceRole.\(index0.advanced(by: 1))"))
            }
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(ClientRuntime.TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: ClientRuntime.Key("automaticRestartTime"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let awsBackupRecoveryPointArn = awsBackupRecoveryPointArn {
            try container.encode(awsBackupRecoveryPointArn, forKey: ClientRuntime.Key("AwsBackupRecoveryPointArn"))
        }
        if backupRetentionPeriod != 0 {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if copyTagsToSnapshot != false {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let customerOwnedIpEnabled = customerOwnedIpEnabled {
            try container.encode(customerOwnedIpEnabled, forKey: ClientRuntime.Key("CustomerOwnedIpEnabled"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: ClientRuntime.Key("DBInstanceArn"))
        }
        if let dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications {
            var dBInstanceAutomatedBackupsReplicationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplications"))
            for (index0, dbinstanceautomatedbackupsreplication0) in dBInstanceAutomatedBackupsReplications.enumerated() {
                try dBInstanceAutomatedBackupsReplicationsContainer.encode(dbinstanceautomatedbackupsreplication0, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplication.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBInstanceStatus = dBInstanceStatus {
            try container.encode(dBInstanceStatus, forKey: ClientRuntime.Key("DBInstanceStatus"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroups = dBParameterGroups {
            var dBParameterGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBParameterGroups"))
            for (index0, dbparametergroupstatus0) in dBParameterGroups.enumerated() {
                try dBParameterGroupsContainer.encode(dbparametergroupstatus0, forKey: ClientRuntime.Key("DBParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(dbsecuritygroupmembership0, forKey: ClientRuntime.Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if dbInstancePort != 0 {
            try container.encode(dbInstancePort, forKey: ClientRuntime.Key("DbInstancePort"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if deletionProtection != false {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: ClientRuntime.Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let enhancedMonitoringResourceArn = enhancedMonitoringResourceArn {
            try container.encode(enhancedMonitoringResourceArn, forKey: ClientRuntime.Key("EnhancedMonitoringResourceArn"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let listenerEndpoint = listenerEndpoint {
            try container.encode(listenerEndpoint, forKey: ClientRuntime.Key("ListenerEndpoint"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let ncharCharacterSetName = ncharCharacterSetName {
            try container.encode(ncharCharacterSetName, forKey: ClientRuntime.Key("NcharCharacterSetName"))
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupMemberships"))
            for (index0, optiongroupmembership0) in optionGroupMemberships.enumerated() {
                try optionGroupMembershipsContainer.encode(optiongroupmembership0, forKey: ClientRuntime.Key("OptionGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: ClientRuntime.Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaDBClusterIdentifiers"))
            for (index0, string0) in readReplicaDBClusterIdentifiers.enumerated() {
                try readReplicaDBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaDBClusterIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaDBInstanceIdentifiers"))
            for (index0, string0) in readReplicaDBInstanceIdentifiers.enumerated() {
                try readReplicaDBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaDBInstanceIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier {
            try container.encode(readReplicaSourceDBInstanceIdentifier, forKey: ClientRuntime.Key("ReadReplicaSourceDBInstanceIdentifier"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: ClientRuntime.Key("ReplicaMode"))
        }
        if let secondaryAvailabilityZone = secondaryAvailabilityZone {
            try container.encode(secondaryAvailabilityZone, forKey: ClientRuntime.Key("SecondaryAvailabilityZone"))
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StatusInfos"))
            for (index0, dbinstancestatusinfo0) in statusInfos.enumerated() {
                try statusInfosContainer.encode(dbinstancestatusinfo0, forKey: ClientRuntime.Key("DBInstanceStatusInfo.\(index0.advanced(by: 1))"))
            }
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let dBInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceStatus)
        dBInstanceStatus = dBInstanceStatusDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:ClientRuntime.Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupsBuffer:[RdsClientTypes.DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [RdsClientTypes.DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBParameterGroupStatus].self, forKey: .member)
                var dBParameterGroupsBuffer:[RdsClientTypes.DBParameterGroupStatus]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [RdsClientTypes.DBParameterGroupStatus]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RdsClientTypes.PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        if containerValues.contains(.readReplicaDBInstanceIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBInstanceIdentifier{}}
            let readReplicaDBInstanceIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBInstanceIdentifier>.CodingKeys.self, forKey: .readReplicaDBInstanceIdentifiers)
            if let readReplicaDBInstanceIdentifiersWrappedContainer = readReplicaDBInstanceIdentifiersWrappedContainer {
                let readReplicaDBInstanceIdentifiersContainer = try readReplicaDBInstanceIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaDBInstanceIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
                    readReplicaDBInstanceIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaDBInstanceIdentifiersContainer {
                        readReplicaDBInstanceIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersBuffer
            } else {
                readReplicaDBInstanceIdentifiers = []
            }
        } else {
            readReplicaDBInstanceIdentifiers = nil
        }
        if containerValues.contains(.readReplicaDBClusterIdentifiers) {
            struct KeyVal0{struct ReadReplicaDBClusterIdentifier{}}
            let readReplicaDBClusterIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaDBClusterIdentifier>.CodingKeys.self, forKey: .readReplicaDBClusterIdentifiers)
            if let readReplicaDBClusterIdentifiersWrappedContainer = readReplicaDBClusterIdentifiersWrappedContainer {
                let readReplicaDBClusterIdentifiersContainer = try readReplicaDBClusterIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaDBClusterIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
                    readReplicaDBClusterIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaDBClusterIdentifiersContainer {
                        readReplicaDBClusterIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersBuffer
            } else {
                readReplicaDBClusterIdentifiers = []
            }
        } else {
            readReplicaDBClusterIdentifiers = nil
        }
        let replicaModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ReplicaMode.self, forKey: .replicaMode)
        replicaMode = replicaModeDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        if containerValues.contains(.optionGroupMemberships) {
            struct KeyVal0{struct OptionGroupMembership{}}
            let optionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupMembership>.CodingKeys.self, forKey: .optionGroupMemberships)
            if let optionGroupMembershipsWrappedContainer = optionGroupMembershipsWrappedContainer {
                let optionGroupMembershipsContainer = try optionGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroupMembership].self, forKey: .member)
                var optionGroupMembershipsBuffer:[RdsClientTypes.OptionGroupMembership]? = nil
                if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
                    optionGroupMembershipsBuffer = [RdsClientTypes.OptionGroupMembership]()
                    for structureContainer0 in optionGroupMembershipsContainer {
                        optionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupMemberships = optionGroupMembershipsBuffer
            } else {
                optionGroupMemberships = []
            }
        } else {
            optionGroupMemberships = nil
        }
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let ncharCharacterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ncharCharacterSetName)
        ncharCharacterSetName = ncharCharacterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        if containerValues.contains(.statusInfos) {
            struct KeyVal0{struct DBInstanceStatusInfo{}}
            let statusInfosWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceStatusInfo>.CodingKeys.self, forKey: .statusInfos)
            if let statusInfosWrappedContainer = statusInfosWrappedContainer {
                let statusInfosContainer = try statusInfosWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceStatusInfo].self, forKey: .member)
                var statusInfosBuffer:[RdsClientTypes.DBInstanceStatusInfo]? = nil
                if let statusInfosContainer = statusInfosContainer {
                    statusInfosBuffer = [RdsClientTypes.DBInstanceStatusInfo]()
                    for structureContainer0 in statusInfosContainer {
                        statusInfosBuffer?.append(structureContainer0)
                    }
                }
                statusInfos = statusInfosBuffer
            } else {
                statusInfos = []
            }
        } else {
            statusInfos = nil
        }
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let dbInstancePortDecoded = try containerValues.decode(Swift.Int.self, forKey: .dbInstancePort)
        dbInstancePort = dbInstancePortDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[RdsClientTypes.DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [RdsClientTypes.DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        let copyTagsToSnapshotDecoded = try containerValues.decode(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier)
        promotionTier = promotionTierDecoded
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let deletionProtectionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBInstanceRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceRole].self, forKey: .member)
                var associatedRolesBuffer:[RdsClientTypes.DBInstanceRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [RdsClientTypes.DBInstanceRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let listenerEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Endpoint.self, forKey: .listenerEndpoint)
        listenerEndpoint = listenerEndpointDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage)
        maxAllocatedStorage = maxAllocatedStorageDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        if containerValues.contains(.dBInstanceAutomatedBackupsReplications) {
            struct KeyVal0{struct DBInstanceAutomatedBackupsReplication{}}
            let dBInstanceAutomatedBackupsReplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackupsReplication>.CodingKeys.self, forKey: .dBInstanceAutomatedBackupsReplications)
            if let dBInstanceAutomatedBackupsReplicationsWrappedContainer = dBInstanceAutomatedBackupsReplicationsWrappedContainer {
                let dBInstanceAutomatedBackupsReplicationsContainer = try dBInstanceAutomatedBackupsReplicationsWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceAutomatedBackupsReplication].self, forKey: .member)
                var dBInstanceAutomatedBackupsReplicationsBuffer:[RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil
                if let dBInstanceAutomatedBackupsReplicationsContainer = dBInstanceAutomatedBackupsReplicationsContainer {
                    dBInstanceAutomatedBackupsReplicationsBuffer = [RdsClientTypes.DBInstanceAutomatedBackupsReplication]()
                    for structureContainer0 in dBInstanceAutomatedBackupsReplicationsContainer {
                        dBInstanceAutomatedBackupsReplicationsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplicationsBuffer
            } else {
                dBInstanceAutomatedBackupsReplications = []
            }
        } else {
            dBInstanceAutomatedBackupsReplications = nil
        }
        let customerOwnedIpEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .customerOwnedIpEnabled)
        customerOwnedIpEnabled = customerOwnedIpEnabledDecoded
        let awsBackupRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsBackupRecoveryPointArn)
        awsBackupRecoveryPointArn = awsBackupRecoveryPointArnDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamEngineNativeAuditFieldsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activityStreamEngineNativeAuditFieldsIncluded)
        activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncludedDecoded
    }
}

extension RdsClientTypes.DBInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstance(activityStreamEngineNativeAuditFieldsIncluded: \(Swift.String(describing: activityStreamEngineNativeAuditFieldsIncluded)), activityStreamKinesisStreamName: \(Swift.String(describing: activityStreamKinesisStreamName)), activityStreamKmsKeyId: \(Swift.String(describing: activityStreamKmsKeyId)), activityStreamMode: \(Swift.String(describing: activityStreamMode)), activityStreamStatus: \(Swift.String(describing: activityStreamStatus)), allocatedStorage: \(Swift.String(describing: allocatedStorage)), associatedRoles: \(Swift.String(describing: associatedRoles)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), automaticRestartTime: \(Swift.String(describing: automaticRestartTime)), availabilityZone: \(Swift.String(describing: availabilityZone)), awsBackupRecoveryPointArn: \(Swift.String(describing: awsBackupRecoveryPointArn)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(Swift.String(describing: cACertificateIdentifier)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), customerOwnedIpEnabled: \(Swift.String(describing: customerOwnedIpEnabled)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBInstanceArn: \(Swift.String(describing: dBInstanceArn)), dBInstanceAutomatedBackupsReplications: \(Swift.String(describing: dBInstanceAutomatedBackupsReplications)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBInstanceStatus: \(Swift.String(describing: dBInstanceStatus)), dBName: \(Swift.String(describing: dBName)), dBParameterGroups: \(Swift.String(describing: dBParameterGroups)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)), dbInstancePort: \(Swift.String(describing: dbInstancePort)), dbiResourceId: \(Swift.String(describing: dbiResourceId)), deletionProtection: \(Swift.String(describing: deletionProtection)), domainMemberships: \(Swift.String(describing: domainMemberships)), enabledCloudwatchLogsExports: \(Swift.String(describing: enabledCloudwatchLogsExports)), endpoint: \(Swift.String(describing: endpoint)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), enhancedMonitoringResourceArn: \(Swift.String(describing: enhancedMonitoringResourceArn)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(Swift.String(describing: instanceCreateTime)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), latestRestorableTime: \(Swift.String(describing: latestRestorableTime)), licenseModel: \(Swift.String(describing: licenseModel)), listenerEndpoint: \(Swift.String(describing: listenerEndpoint)), masterUsername: \(Swift.String(describing: masterUsername)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), ncharCharacterSetName: \(Swift.String(describing: ncharCharacterSetName)), optionGroupMemberships: \(Swift.String(describing: optionGroupMemberships)), pendingModifiedValues: \(Swift.String(describing: pendingModifiedValues)), performanceInsightsEnabled: \(Swift.String(describing: performanceInsightsEnabled)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(Swift.String(describing: performanceInsightsRetentionPeriod)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), processorFeatures: \(Swift.String(describing: processorFeatures)), promotionTier: \(Swift.String(describing: promotionTier)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), readReplicaDBClusterIdentifiers: \(Swift.String(describing: readReplicaDBClusterIdentifiers)), readReplicaDBInstanceIdentifiers: \(Swift.String(describing: readReplicaDBInstanceIdentifiers)), readReplicaSourceDBInstanceIdentifier: \(Swift.String(describing: readReplicaSourceDBInstanceIdentifier)), replicaMode: \(Swift.String(describing: replicaMode)), secondaryAvailabilityZone: \(Swift.String(describing: secondaryAvailabilityZone)), statusInfos: \(Swift.String(describing: statusInfos)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), storageType: \(Swift.String(describing: storageType)), tagList: \(Swift.String(describing: tagList)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), timezone: \(Swift.String(describing: timezone)), vpcSecurityGroups: \(Swift.String(describing: vpcSecurityGroups)))"}
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public struct DBInstance: Swift.Equatable {
        /// Indicates whether engine-native audit fields are included in the database activity stream.
        public var activityStreamEngineNativeAuditFieldsIncluded: Swift.Bool?
        /// The name of the Amazon Kinesis data stream used for the database activity stream.
        public var activityStreamKinesisStreamName: Swift.String?
        /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream.
        ///             The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS
        ///             customer master key (CMK).
        public var activityStreamKmsKeyId: Swift.String?
        /// The mode of the database activity stream. Database events such as a change or access generate
        ///             an activity stream event. RDS for Oracle always handles these events asynchronously.
        public var activityStreamMode: RdsClientTypes.ActivityStreamMode?
        /// The status of the database activity stream.
        public var activityStreamStatus: RdsClientTypes.ActivityStreamStatus?
        /// Specifies the allocated storage size specified in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        ///
        ///             The Amazon Web Services Identity and Access Management (IAM) roles associated with the DB instance.
        ///
        public var associatedRoles: [RdsClientTypes.DBInstanceRole]?
        /// A value that indicates that minor version patches are applied automatically.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The time when a stopped DB instance is restarted automatically.
        public var automaticRestartTime: ClientRuntime.Date?
        /// Specifies the name of the Availability Zone the DB instance is located in.
        public var availabilityZone: Swift.String?
        /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
        public var awsBackupRecoveryPointArn: Swift.String?
        /// Specifies the number of days for which automatic DB snapshots are retained.
        public var backupRetentionPeriod: Swift.Int
        /// The identifier of the CA certificate for this DB instance.
        public var cACertificateIdentifier: Swift.String?
        /// If present, specifies the name of the character set that this instance is associated with.
        public var characterSetName: Swift.String?
        /// Specifies whether tags are copied from the DB instance to snapshots of the DB instance.
        ///
        ///             Amazon Aurora
        ///
        ///          Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this
        ///             value for an Aurora DB instance has no effect on the DB cluster setting. For more
        ///             information, see DBCluster.
        public var copyTagsToSnapshot: Swift.Bool
        /// Specifies whether a customer-owned IP address (CoIP) is enabled for an RDS on Outposts DB instance.
        ///         A CoIP provides local or external connectivity to resources in
        ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
        ///             provide lower latency for connections to the DB instance from outside of its virtual
        ///             private cloud (VPC) on your local network.
        ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on Amazon Web Services Outposts
        ///             in the Amazon RDS User Guide.
        ///         For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses
        ///             in the Amazon Web Services Outposts User Guide.
        public var customerOwnedIpEnabled: Swift.Bool?
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public var dBClusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) for the DB instance.
        public var dBInstanceArn: Swift.String?
        /// The list of replicated automated backups associated with the DB instance.
        public var dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public var dBInstanceClass: Swift.String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public var dBInstanceIdentifier: Swift.String?
        /// Specifies the current state of this database.
        ///          For information about DB instance statuses, see
        ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/accessing-monitoring.html#Overview.DBInstance.Status">Viewing DB instance status
        ///           in the Amazon RDS User Guide.
        ///
        public var dBInstanceStatus: Swift.String?
        /// The meaning of this parameter differs according to the database engine you use.
        ///
        ///             MySQL, MariaDB, SQL Server, PostgreSQL
        ///
        ///          Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance.
        ///          Type: String
        ///
        ///             Oracle
        ///
        ///          Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance.
        public var dBName: Swift.String?
        /// Provides the list of DB parameter groups applied to this DB instance.
        public var dBParameterGroups: [RdsClientTypes.DBParameterGroupStatus]?
        ///
        ///         A list of DB security group elements containing
        ///         DBSecurityGroup.Name and DBSecurityGroup.Status subelements.
        ///
        public var dBSecurityGroups: [RdsClientTypes.DBSecurityGroupMembership]?
        /// Specifies information on the subnet group associated with the DB instance, including the name, description, and subnets in the subnet group.
        public var dBSubnetGroup: RdsClientTypes.DBSubnetGroup?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public var dbInstancePort: Swift.Int
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in Amazon Web Services CloudTrail log
        ///           entries whenever the Amazon Web Services KMS customer master key (CMK) for the DB instance is accessed.
        public var dbiResourceId: Swift.String?
        /// Indicates if the DB instance has deletion protection enabled.
        ///             The database can't be deleted when deletion protection is enabled.
        ///             For more information, see
        ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
        ///                 Deleting a DB Instance.
        ///
        public var deletionProtection: Swift.Bool
        /// The Active Directory Domain membership records associated with the DB instance.
        public var domainMemberships: [RdsClientTypes.DomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs.
        ///         Log types vary by DB engine. For information about the log types for each DB engine, see
        ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html">Amazon RDS Database Log Files in the Amazon RDS User Guide.
        ///
        public var enabledCloudwatchLogsExports: [Swift.String]?
        /// Specifies the connection endpoint.
        ///
        ///             The endpoint might not be shown for instances whose status is creating.
        ///
        public var endpoint: RdsClientTypes.Endpoint?
        /// The name of the database engine to be used for this DB instance.
        public var engine: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log stream that receives the Enhanced Monitoring metrics data for the DB instance.
        public var enhancedMonitoringResourceArn: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.
        ///
        ///          IAM database authentication can be enabled for the following database engines
        ///
        ///
        ///                For MySQL 5.6, minor version 5.6.34 or higher
        ///
        ///
        ///                For MySQL 5.7, minor version 5.7.16 or higher
        ///
        ///
        ///                Aurora 5.6 or higher. To enable IAM database authentication for Aurora, see DBCluster Type.
        ///
        ///
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// Provides the date and time the DB instance was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// Specifies the Provisioned IOPS (I/O operations per second) value.
        public var iops: Swift.Int?
        ///
        ///             If StorageEncrypted is true, the Amazon Web Services KMS key identifier
        ///             for the encrypted DB instance.
        ///
        ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var kmsKeyId: Swift.String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore.
        public var latestRestorableTime: ClientRuntime.Date?
        /// License model information for this DB instance.
        public var licenseModel: Swift.String?
        /// Specifies the listener connection endpoint for SQL Server Always On.
        public var listenerEndpoint: RdsClientTypes.Endpoint?
        /// Contains the master username for the DB instance.
        public var masterUsername: Swift.String?
        /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
        public var maxAllocatedStorage: Swift.Int?
        /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.
        public var monitoringInterval: Swift.Int?
        /// The ARN for the IAM role that permits RDS to send Enhanced Monitoring metrics to Amazon CloudWatch Logs.
        public var monitoringRoleArn: Swift.String?
        /// Specifies if the DB instance is a Multi-AZ deployment.
        public var multiAZ: Swift.Bool
        /// The name of the NCHAR character set for the Oracle DB instance. This character set specifies the
        ///             Unicode encoding for data stored in table columns of type NCHAR, NCLOB, or NVARCHAR2.
        ///
        public var ncharCharacterSetName: Swift.String?
        /// Provides the list of option group memberships for this DB instance.
        public var optionGroupMemberships: [RdsClientTypes.OptionGroupMembership]?
        /// A value that specifies that changes to the DB instance are pending. This element is only included when changes are pending. Specific changes are identified by subelements.
        public var pendingModifiedValues: RdsClientTypes.PendingModifiedValues?
        /// True if Performance Insights is enabled for the DB instance, and otherwise false.
        public var performanceInsightsEnabled: Swift.Bool?
        /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
        ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var performanceInsightsKMSKeyId: Swift.String?
        /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
        public var performanceInsightsRetentionPeriod: Swift.Int?
        ///
        ///         Specifies the daily time range during which automated backups are
        ///         created if automated backups are enabled, as determined
        ///         by the BackupRetentionPeriod.
        ///
        public var preferredBackupWindow: Swift.String?
        /// Specifies the weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
        public var preferredMaintenanceWindow: Swift.String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
        /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance
        ///       after a failure of the existing primary instance. For more information,
        ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
        ///           Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide.
        ///
        public var promotionTier: Swift.Int?
        /// Specifies the accessibility options for the DB instance.
        ///          When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
        ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
        ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
        ///          When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
        ///          For more information, see CreateDBInstance.
        public var publiclyAccessible: Swift.Bool
        /// Contains one or more identifiers of Aurora DB clusters to which the RDS DB instance
        ///             is replicated as a read replica. For example, when you create an Aurora read replica of
        ///             an RDS MySQL DB instance, the Aurora MySQL DB cluster for the Aurora read replica is
        ///             shown. This output does not contain information about cross region Aurora read
        ///             replicas.
        ///
        ///             Currently, each RDS DB instance can have only one Aurora read replica.
        ///
        public var readReplicaDBClusterIdentifiers: [Swift.String]?
        /// Contains one or more identifiers of the read replicas associated with this DB
        ///             instance.
        public var readReplicaDBInstanceIdentifiers: [Swift.String]?
        /// Contains the identifier of the source DB instance if this DB instance is a read
        ///             replica.
        public var readReplicaSourceDBInstanceIdentifier: Swift.String?
        /// The open mode of an Oracle read replica. The default is open-read-only.
        ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Working with Oracle Read Replicas for Amazon RDS
        ///             in the Amazon RDS User Guide.
        ///
        ///             This attribute is only supported in RDS for Oracle.
        ///
        public var replicaMode: RdsClientTypes.ReplicaMode?
        /// If present, specifies the name of the secondary Availability Zone for a DB instance with multi-AZ support.
        public var secondaryAvailabilityZone: Swift.String?
        /// The status of a read replica. If the instance isn't a read replica, this is
        ///             blank.
        public var statusInfos: [RdsClientTypes.DBInstanceStatusInfo]?
        /// Specifies whether the DB instance is encrypted.
        public var storageEncrypted: Swift.Bool
        /// Specifies the storage type associated with DB instance.
        public var storageType: Swift.String?
        /// A list of tags.
        ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
        ///
        public var tagList: [RdsClientTypes.Tag]?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB instance.
        ///             In most cases, the Timezone element is empty.
        ///             Timezone content appears only for
        ///             Microsoft SQL Server DB instances
        ///             that were created with a time zone specified.
        ///
        public var timezone: Swift.String?
        /// Provides a list of VPC security group elements that the DB instance belongs to.
        public var vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]?

        public init (
            activityStreamEngineNativeAuditFieldsIncluded: Swift.Bool? = nil,
            activityStreamKinesisStreamName: Swift.String? = nil,
            activityStreamKmsKeyId: Swift.String? = nil,
            activityStreamMode: RdsClientTypes.ActivityStreamMode? = nil,
            activityStreamStatus: RdsClientTypes.ActivityStreamStatus? = nil,
            allocatedStorage: Swift.Int = 0,
            associatedRoles: [RdsClientTypes.DBInstanceRole]? = nil,
            autoMinorVersionUpgrade: Swift.Bool = false,
            automaticRestartTime: ClientRuntime.Date? = nil,
            availabilityZone: Swift.String? = nil,
            awsBackupRecoveryPointArn: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int = 0,
            cACertificateIdentifier: Swift.String? = nil,
            characterSetName: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool = false,
            customerOwnedIpEnabled: Swift.Bool? = nil,
            dBClusterIdentifier: Swift.String? = nil,
            dBInstanceArn: Swift.String? = nil,
            dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBInstanceStatus: Swift.String? = nil,
            dBName: Swift.String? = nil,
            dBParameterGroups: [RdsClientTypes.DBParameterGroupStatus]? = nil,
            dBSecurityGroups: [RdsClientTypes.DBSecurityGroupMembership]? = nil,
            dBSubnetGroup: RdsClientTypes.DBSubnetGroup? = nil,
            dbInstancePort: Swift.Int = 0,
            dbiResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool = false,
            domainMemberships: [RdsClientTypes.DomainMembership]? = nil,
            enabledCloudwatchLogsExports: [Swift.String]? = nil,
            endpoint: RdsClientTypes.Endpoint? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            enhancedMonitoringResourceArn: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: ClientRuntime.Date? = nil,
            licenseModel: Swift.String? = nil,
            listenerEndpoint: RdsClientTypes.Endpoint? = nil,
            masterUsername: Swift.String? = nil,
            maxAllocatedStorage: Swift.Int? = nil,
            monitoringInterval: Swift.Int? = nil,
            monitoringRoleArn: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            ncharCharacterSetName: Swift.String? = nil,
            optionGroupMemberships: [RdsClientTypes.OptionGroupMembership]? = nil,
            pendingModifiedValues: RdsClientTypes.PendingModifiedValues? = nil,
            performanceInsightsEnabled: Swift.Bool? = nil,
            performanceInsightsKMSKeyId: Swift.String? = nil,
            performanceInsightsRetentionPeriod: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
            promotionTier: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool = false,
            readReplicaDBClusterIdentifiers: [Swift.String]? = nil,
            readReplicaDBInstanceIdentifiers: [Swift.String]? = nil,
            readReplicaSourceDBInstanceIdentifier: Swift.String? = nil,
            replicaMode: RdsClientTypes.ReplicaMode? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            statusInfos: [RdsClientTypes.DBInstanceStatusInfo]? = nil,
            storageEncrypted: Swift.Bool = false,
            storageType: Swift.String? = nil,
            tagList: [RdsClientTypes.Tag]? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcSecurityGroups: [RdsClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.activityStreamEngineNativeAuditFieldsIncluded = activityStreamEngineNativeAuditFieldsIncluded
            self.activityStreamKinesisStreamName = activityStreamKinesisStreamName
            self.activityStreamKmsKeyId = activityStreamKmsKeyId
            self.activityStreamMode = activityStreamMode
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.automaticRestartTime = automaticRestartTime
            self.availabilityZone = availabilityZone
            self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
            self.backupRetentionPeriod = backupRetentionPeriod
            self.cACertificateIdentifier = cACertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.customerOwnedIpEnabled = customerOwnedIpEnabled
            self.dBClusterIdentifier = dBClusterIdentifier
            self.dBInstanceArn = dBInstanceArn
            self.dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBInstanceStatus = dBInstanceStatus
            self.dBName = dBName
            self.dBParameterGroups = dBParameterGroups
            self.dBSecurityGroups = dBSecurityGroups
            self.dBSubnetGroup = dBSubnetGroup
            self.dbInstancePort = dbInstancePort
            self.dbiResourceId = dbiResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudwatchLogsExports = enabledCloudwatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAZ = multiAZ
            self.ncharCharacterSetName = ncharCharacterSetName
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.replicaMode = replicaMode
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tagList = tagList
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension DBInstanceAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user already has a DB instance with the given identifier.
public struct DBInstanceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceAutomatedBackup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case dBInstanceArn = "DBInstanceArn"
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
        case dBInstanceAutomatedBackupsReplications = "DBInstanceAutomatedBackupsReplications"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case region = "Region"
        case restoreWindow = "RestoreWindow"
        case status = "Status"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let dBInstanceArn = dBInstanceArn {
            try container.encode(dBInstanceArn, forKey: ClientRuntime.Key("DBInstanceArn"))
        }
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications {
            var dBInstanceAutomatedBackupsReplicationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplications"))
            for (index0, dbinstanceautomatedbackupsreplication0) in dBInstanceAutomatedBackupsReplications.enumerated() {
                try dBInstanceAutomatedBackupsReplicationsContainer.encode(dbinstanceautomatedbackupsreplication0, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsReplication.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let region = region {
            try container.encode(region, forKey: ClientRuntime.Key("Region"))
        }
        if let restoreWindow = restoreWindow {
            try container.encode(restoreWindow, forKey: ClientRuntime.Key("RestoreWindow"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceArn)
        dBInstanceArn = dBInstanceArnDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let restoreWindowDecoded = try containerValues.decodeIfPresent(RdsClientTypes.RestoreWindow.self, forKey: .restoreWindow)
        restoreWindow = restoreWindowDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
        if containerValues.contains(.dBInstanceAutomatedBackupsReplications) {
            struct KeyVal0{struct DBInstanceAutomatedBackupsReplication{}}
            let dBInstanceAutomatedBackupsReplicationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackupsReplication>.CodingKeys.self, forKey: .dBInstanceAutomatedBackupsReplications)
            if let dBInstanceAutomatedBackupsReplicationsWrappedContainer = dBInstanceAutomatedBackupsReplicationsWrappedContainer {
                let dBInstanceAutomatedBackupsReplicationsContainer = try dBInstanceAutomatedBackupsReplicationsWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceAutomatedBackupsReplication].self, forKey: .member)
                var dBInstanceAutomatedBackupsReplicationsBuffer:[RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil
                if let dBInstanceAutomatedBackupsReplicationsContainer = dBInstanceAutomatedBackupsReplicationsContainer {
                    dBInstanceAutomatedBackupsReplicationsBuffer = [RdsClientTypes.DBInstanceAutomatedBackupsReplication]()
                    for structureContainer0 in dBInstanceAutomatedBackupsReplicationsContainer {
                        dBInstanceAutomatedBackupsReplicationsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplicationsBuffer
            } else {
                dBInstanceAutomatedBackupsReplications = []
            }
        } else {
            dBInstanceAutomatedBackupsReplications = nil
        }
    }
}

extension RdsClientTypes.DBInstanceAutomatedBackup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceAutomatedBackup(allocatedStorage: \(Swift.String(describing: allocatedStorage)), availabilityZone: \(Swift.String(describing: availabilityZone)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), dBInstanceArn: \(Swift.String(describing: dBInstanceArn)), dBInstanceAutomatedBackupsArn: \(Swift.String(describing: dBInstanceAutomatedBackupsArn)), dBInstanceAutomatedBackupsReplications: \(Swift.String(describing: dBInstanceAutomatedBackupsReplications)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dbiResourceId: \(Swift.String(describing: dbiResourceId)), encrypted: \(Swift.String(describing: encrypted)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(Swift.String(describing: instanceCreateTime)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUsername: \(Swift.String(describing: masterUsername)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), region: \(Swift.String(describing: region)), restoreWindow: \(Swift.String(describing: restoreWindow)), status: \(Swift.String(describing: status)), storageType: \(Swift.String(describing: storageType)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), timezone: \(Swift.String(describing: timezone)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RdsClientTypes {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.
    public struct DBInstanceAutomatedBackup: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// The Availability Zone that the automated backup was created in. For information on
        ///             Amazon Web Services Regions and Availability Zones, see
        ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">Regions
        ///                 and Availability Zones.
        public var availabilityZone: Swift.String?
        /// The retention period for the automated backups.
        public var backupRetentionPeriod: Swift.Int?
        /// The Amazon Resource Name (ARN) for the automated backups.
        public var dBInstanceArn: Swift.String?
        /// The Amazon Resource Name (ARN) for the replicated automated backups.
        public var dBInstanceAutomatedBackupsArn: Swift.String?
        /// The list of replications to different Amazon Web Services Regions associated with the automated backup.
        public var dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]?
        /// The customer id of the instance that is/was associated with the automated backup.
        ///
        public var dBInstanceIdentifier: Swift.String?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public var dbiResourceId: Swift.String?
        /// Specifies whether the automated backup is encrypted.
        public var encrypted: Swift.Bool
        /// The name of the database engine for this automated backup.
        public var engine: Swift.String?
        /// The version of the database engine for the automated backup.
        public var engineVersion: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled,
        ///             and otherwise false.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// Provides the date and time that the DB instance was created.
        ///
        public var instanceCreateTime: ClientRuntime.Date?
        /// The IOPS (I/O operations per second) value for the automated backup.
        public var iops: Swift.Int?
        /// The Amazon Web Services KMS key ID for an automated backup.
        ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var kmsKeyId: Swift.String?
        /// License model information for the automated backup.
        public var licenseModel: Swift.String?
        /// The license model of an automated backup.
        public var masterUsername: Swift.String?
        /// The option group the automated backup is associated with. If omitted, the default option group for the engine specified is used.
        public var optionGroupName: Swift.String?
        /// The port number that the automated backup used for connections.
        ///         Default: Inherits from the source DB instance
        ///         Valid Values: 1150-65535
        ///
        public var port: Swift.Int
        /// The Amazon Web Services Region associated with the automated backup.
        public var region: Swift.String?
        /// Earliest and latest time an instance can be restored to.
        public var restoreWindow: RdsClientTypes.RestoreWindow?
        /// Provides a list of status information for an automated backup:
        ///
        ///
        ///
        ///                   active - automated backups for current instances
        ///
        ///
        ///
        ///                   retained - automated backups for deleted instances
        ///
        ///
        ///
        ///                   creating - automated backups that are waiting
        ///                 for the first automated snapshot to be available.
        ///
        ///
        public var status: Swift.String?
        /// Specifies the storage type associated with the automated backup.
        public var storageType: Swift.String?
        /// The ARN from the key store with which the automated backup is associated for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the automated backup. In most cases, the Timezone element is empty.
        ///             Timezone content appears only for Microsoft SQL Server DB instances
        ///             that were created with a time zone specified.
        public var timezone: Swift.String?
        /// Provides the VPC ID associated with the DB instance
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            dBInstanceArn: Swift.String? = nil,
            dBInstanceAutomatedBackupsArn: Swift.String? = nil,
            dBInstanceAutomatedBackupsReplications: [RdsClientTypes.DBInstanceAutomatedBackupsReplication]? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dbiResourceId: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            port: Swift.Int = 0,
            region: Swift.String? = nil,
            restoreWindow: RdsClientTypes.RestoreWindow? = nil,
            status: Swift.String? = nil,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.dBInstanceArn = dBInstanceArn
            self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
            self.dBInstanceAutomatedBackupsReplications = dBInstanceAutomatedBackupsReplications
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dbiResourceId = dbiResourceId
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.port = port
            self.region = region
            self.restoreWindow = restoreWindow
            self.status = status
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }
    }

}

extension DBInstanceAutomatedBackupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceAutomatedBackupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceAutomatedBackupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceAutomatedBackupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// No automated backup for this DB instance was found.
public struct DBInstanceAutomatedBackupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAutomatedBackupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceAutomatedBackupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceAutomatedBackupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceAutomatedBackupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceAutomatedBackupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceAutomatedBackupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota for retained automated backups was exceeded. This prevents you
///             from retaining any additional automated backups. The retained automated backups
///             quota is the same as your DB Instance quota.
public struct DBInstanceAutomatedBackupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceAutomatedBackupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceAutomatedBackupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceAutomatedBackupsReplication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackupsArn = "DBInstanceAutomatedBackupsArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceAutomatedBackupsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceAutomatedBackupsArn)
        dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArnDecoded
    }
}

extension RdsClientTypes.DBInstanceAutomatedBackupsReplication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceAutomatedBackupsReplication(dBInstanceAutomatedBackupsArn: \(Swift.String(describing: dBInstanceAutomatedBackupsArn)))"}
}

extension RdsClientTypes {
    /// Automated backups of a DB instance replicated to another Amazon Web Services Region. They consist of system backups, transaction logs, and database instance properties.
    public struct DBInstanceAutomatedBackupsReplication: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the replicated automated backups.
        public var dBInstanceAutomatedBackupsArn: Swift.String?

        public init (
            dBInstanceAutomatedBackupsArn: Swift.String? = nil
        )
        {
            self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        }
    }

}

extension DBInstanceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBInstanceIdentifier doesn't refer to an existing DB instance.
///
public struct DBInstanceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceRole: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes.DBInstanceRole: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceRole(featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// Describes an Amazon Web Services Identity and Access Management (IAM) role that is associated with a DB instance.
    public struct DBInstanceRole: Swift.Equatable {
        /// The name of the feature associated with the Amazon Web Services Identity and Access Management (IAM) role.
        ///             For the list of supported feature names, see DBEngineVersion.
        ///
        public var featureName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that is associated with the DB
        ///             instance.
        public var roleArn: Swift.String?
        /// Describes the state of association between the IAM role and the DB instance. The Status property returns one of the following
        ///             values:
        ///
        ///
        ///
        ///                   ACTIVE - the IAM role ARN is associated with the DB instance and can be used to
        ///                 access other Amazon Web Services services on your behalf.
        ///
        ///
        ///
        ///                   PENDING - the IAM role ARN is being associated with the DB instance.
        ///
        ///
        ///
        ///                   INVALID - the IAM role ARN is associated with the DB instance, but the DB instance is unable
        ///                 to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        ///
        ///
        public var status: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension DBInstanceRoleAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceRoleAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceRoleAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceRoleAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified RoleArn or FeatureName value is already associated with the DB instance.
public struct DBInstanceRoleAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceRoleAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRoleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceRoleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified RoleArn value doesn't match the specified feature for
///             the DB instance.
public struct DBInstanceRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBInstanceRoleQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceRoleQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBInstanceRoleQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBInstanceRoleQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't associate any more Amazon Web Services Identity and Access Management (IAM) roles with the DB instance because the quota has been reached.
public struct DBInstanceRoleQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBInstanceRoleQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBInstanceRoleQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceStatusInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if normal != false {
            try container.encode(normal, forKey: ClientRuntime.Key("Normal"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusType = statusType {
            try container.encode(statusType, forKey: ClientRuntime.Key("StatusType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .normal)
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBInstanceStatusInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBInstanceStatusInfo(message: \(Swift.String(describing: message)), normal: \(Swift.String(describing: normal)), status: \(Swift.String(describing: status)), statusType: \(Swift.String(describing: statusType)))"}
}

extension RdsClientTypes {
    /// Provides a list of status information for a DB instance.
    public struct DBInstanceStatusInfo: Swift.Equatable {
        /// Details of the error if there is an error for the instance. If the instance isn't in an error state, this value is blank.
        public var message: Swift.String?
        /// Boolean value that is true if the instance is operating normally, or false if the instance is in an error state.
        public var normal: Swift.Bool
        /// Status of the DB instance. For a StatusType of read replica, the values can be
        ///             replicating, replication stop point set, replication stop point reached, error, stopped,
        ///             or terminated.
        public var status: Swift.String?
        /// This value is currently "read replication."
        public var statusType: Swift.String?

        public init (
            message: Swift.String? = nil,
            normal: Swift.Bool = false,
            status: Swift.String? = nil,
            statusType: Swift.String? = nil
        )
        {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }
    }

}

extension DBLogFileNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBLogFileNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBLogFileNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBLogFileNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             LogFileName doesn't refer to an existing DB log file.
public struct DBLogFileNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBLogFileNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBLogFileNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBParameterGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupArn = "DBParameterGroupArn"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case dBParameterGroupName = "DBParameterGroupName"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupArn = dBParameterGroupArn {
            try container.encode(dBParameterGroupArn, forKey: ClientRuntime.Key("DBParameterGroupArn"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dBParameterGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupArn)
        dBParameterGroupArn = dBParameterGroupArnDecoded
    }
}

extension RdsClientTypes.DBParameterGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroup(dBParameterGroupArn: \(Swift.String(describing: dBParameterGroupArn)), dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), description: \(Swift.String(describing: description)))"}
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB parameter group.
    ///
    ///          This data type is used as a response element in the DescribeDBParameterGroups action.
    ///
    public struct DBParameterGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB parameter group.
        public var dBParameterGroupArn: Swift.String?
        /// The name of the DB parameter group family that this DB parameter group is compatible with.
        public var dBParameterGroupFamily: Swift.String?
        /// The name of the DB parameter group.
        public var dBParameterGroupName: Swift.String?
        /// Provides the customer-specified description for this DB parameter group.
        public var description: Swift.String?

        public init (
            dBParameterGroupArn: Swift.String? = nil,
            dBParameterGroupFamily: Swift.String? = nil,
            dBParameterGroupName: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.dBParameterGroupArn = dBParameterGroupArn
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.dBParameterGroupName = dBParameterGroupName
            self.description = description
        }
    }

}

extension DBParameterGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBParameterGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBParameterGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A DB parameter group with the same name exists.
public struct DBParameterGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBParameterGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBParameterGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBParameterGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBParameterGroupName doesn't refer to an
///         existing DB parameter group.
///
public struct DBParameterGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBParameterGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBParameterGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBParameterGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBParameterGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB parameter
///             groups.
public struct DBParameterGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBParameterGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBParameterGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBParameterGroupStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try container.encode(parameterApplyStatus, forKey: ClientRuntime.Key("ParameterApplyStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension RdsClientTypes.DBParameterGroupStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBParameterGroupStatus(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), parameterApplyStatus: \(Swift.String(describing: parameterApplyStatus)))"}
}

extension RdsClientTypes {
    /// The status of the DB parameter group.
    ///          This data type is used as a response element in the following actions:
    ///
    ///
    ///
    ///                   CreateDBInstance
    ///
    ///
    ///
    ///
    ///                   CreateDBInstanceReadReplica
    ///
    ///
    ///
    ///
    ///                   DeleteDBInstance
    ///
    ///
    ///
    ///
    ///                   ModifyDBInstance
    ///
    ///
    ///
    ///
    ///                   RebootDBInstance
    ///
    ///
    ///
    ///
    ///                   RestoreDBInstanceFromDBSnapshot
    ///
    ///
    ///
    public struct DBParameterGroupStatus: Swift.Equatable {
        /// The name of the DB parameter group.
        public var dBParameterGroupName: Swift.String?
        /// The status of parameter updates.
        public var parameterApplyStatus: Swift.String?

        public init (
            dBParameterGroupName: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil
        )
        {
            self.dBParameterGroupName = dBParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }
    }

}

extension RdsClientTypes.DBProxy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auth = "Auth"
        case createdDate = "CreatedDate"
        case dBProxyArn = "DBProxyArn"
        case dBProxyName = "DBProxyName"
        case debugLogging = "DebugLogging"
        case endpoint = "Endpoint"
        case engineFamily = "EngineFamily"
        case idleClientTimeout = "IdleClientTimeout"
        case requireTLS = "RequireTLS"
        case roleArn = "RoleArn"
        case status = "Status"
        case updatedDate = "UpdatedDate"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Auth"))
            for (index0, userauthconfiginfo0) in auth.enumerated() {
                try authContainer.encode(userauthconfiginfo0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let createdDate = createdDate {
            try container.encode(ClientRuntime.TimestampWrapper(createdDate, format: .dateTime), forKey: ClientRuntime.Key("createdDate"))
        }
        if let dBProxyArn = dBProxyArn {
            try container.encode(dBProxyArn, forKey: ClientRuntime.Key("DBProxyArn"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if debugLogging != false {
            try container.encode(debugLogging, forKey: ClientRuntime.Key("DebugLogging"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engineFamily = engineFamily {
            try container.encode(engineFamily, forKey: ClientRuntime.Key("EngineFamily"))
        }
        if idleClientTimeout != 0 {
            try container.encode(idleClientTimeout, forKey: ClientRuntime.Key("IdleClientTimeout"))
        }
        if requireTLS != false {
            try container.encode(requireTLS, forKey: ClientRuntime.Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let updatedDate = updatedDate {
            try container.encode(ClientRuntime.TimestampWrapper(updatedDate, format: .dateTime), forKey: ClientRuntime.Key("updatedDate"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let dBProxyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyArn)
        dBProxyArn = dBProxyArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyStatus.self, forKey: .status)
        status = statusDecoded
        let engineFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineFamily)
        engineFamily = engineFamilyDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[Swift.String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        if containerValues.contains(.auth) {
            struct KeyVal0{struct member{}}
            let authWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .auth)
            if let authWrappedContainer = authWrappedContainer {
                let authContainer = try authWrappedContainer.decodeIfPresent([RdsClientTypes.UserAuthConfigInfo].self, forKey: .member)
                var authBuffer:[RdsClientTypes.UserAuthConfigInfo]? = nil
                if let authContainer = authContainer {
                    authBuffer = [RdsClientTypes.UserAuthConfigInfo]()
                    for structureContainer0 in authContainer {
                        authBuffer?.append(structureContainer0)
                    }
                }
                auth = authBuffer
            } else {
                auth = []
            }
        } else {
            auth = nil
        }
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let requireTLSDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireTLS)
        requireTLS = requireTLSDecoded
        let idleClientTimeoutDecoded = try containerValues.decode(Swift.Int.self, forKey: .idleClientTimeout)
        idleClientTimeout = idleClientTimeoutDecoded
        let debugLoggingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .debugLogging)
        debugLogging = debugLoggingDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        var createdDateBuffer:ClientRuntime.Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedDate)
        var updatedDateBuffer:ClientRuntime.Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}

extension RdsClientTypes.DBProxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxy(auth: \(Swift.String(describing: auth)), createdDate: \(Swift.String(describing: createdDate)), dBProxyArn: \(Swift.String(describing: dBProxyArn)), dBProxyName: \(Swift.String(describing: dBProxyName)), debugLogging: \(Swift.String(describing: debugLogging)), endpoint: \(Swift.String(describing: endpoint)), engineFamily: \(Swift.String(describing: engineFamily)), idleClientTimeout: \(Swift.String(describing: idleClientTimeout)), requireTLS: \(Swift.String(describing: requireTLS)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), updatedDate: \(Swift.String(describing: updatedDate)), vpcId: \(Swift.String(describing: vpcId)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(Swift.String(describing: vpcSubnetIds)))"}
}

extension RdsClientTypes {
    /// The data structure representing a proxy managed by the RDS Proxy.
    ///          This data type is used as a response element in the DescribeDBProxies action.
    public struct DBProxy: Swift.Equatable {
        /// One or more data structures specifying the authorization mechanism to connect to the associated RDS DB instance
        ///         or Aurora DB cluster.
        public var auth: [RdsClientTypes.UserAuthConfigInfo]?
        /// The date and time when the proxy was first created.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the proxy.
        public var dBProxyArn: Swift.String?
        /// The identifier for the proxy. This name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
        public var dBProxyName: Swift.String?
        /// Whether the proxy includes detailed information about SQL statements in its logs.
        ///         This information helps you to debug issues involving SQL behavior or the performance
        ///         and scalability of the proxy connections. The debug information includes the text of
        ///         SQL statements that you submit through the proxy. Thus, only enable this setting
        ///         when needed for debugging, and only when you have security measures in place to
        ///         safeguard any sensitive information that appears in the logs.
        public var debugLogging: Swift.Bool
        /// The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the
        ///         connection string for a database client application.
        public var endpoint: Swift.String?
        /// The engine family applies to MySQL and PostgreSQL for both RDS and Aurora.
        public var engineFamily: Swift.String?
        /// The number of seconds a connection to the proxy can have no activity before the proxy drops the client connection.
        ///         The proxy keeps the underlying database connection open and puts it back into the connection pool for reuse by
        ///         later connection requests.
        ///          Default: 1800 (30 minutes)
        ///          Constraints: 1 to 28,800
        public var idleClientTimeout: Swift.Int
        /// Indicates whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
        public var requireTLS: Swift.Bool
        /// The Amazon Resource Name (ARN) for the IAM role that the proxy uses to access Amazon Secrets Manager.
        public var roleArn: Swift.String?
        /// The current status of this proxy. A status of available means the
        ///         proxy is ready to handle requests. Other values indicate that you must wait for
        ///         the proxy to be ready, or take some action to resolve an issue.
        public var status: RdsClientTypes.DBProxyStatus?
        /// The date and time when the proxy was last updated.
        public var updatedDate: ClientRuntime.Date?
        /// Provides the VPC ID of the DB proxy.
        public var vpcId: Swift.String?
        /// Provides a list of VPC security groups that the proxy belongs to.
        public var vpcSecurityGroupIds: [Swift.String]?
        /// The EC2 subnet IDs for the proxy.
        public var vpcSubnetIds: [Swift.String]?

        public init (
            auth: [RdsClientTypes.UserAuthConfigInfo]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            dBProxyArn: Swift.String? = nil,
            dBProxyName: Swift.String? = nil,
            debugLogging: Swift.Bool = false,
            endpoint: Swift.String? = nil,
            engineFamily: Swift.String? = nil,
            idleClientTimeout: Swift.Int = 0,
            requireTLS: Swift.Bool = false,
            roleArn: Swift.String? = nil,
            status: RdsClientTypes.DBProxyStatus? = nil,
            updatedDate: ClientRuntime.Date? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil,
            vpcSubnetIds: [Swift.String]? = nil
        )
        {
            self.auth = auth
            self.createdDate = createdDate
            self.dBProxyArn = dBProxyArn
            self.dBProxyName = dBProxyName
            self.debugLogging = debugLogging
            self.endpoint = endpoint
            self.engineFamily = engineFamily
            self.idleClientTimeout = idleClientTimeout
            self.requireTLS = requireTLS
            self.roleArn = roleArn
            self.status = status
            self.updatedDate = updatedDate
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }
    }

}

extension DBProxyAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified proxy name must be unique for all proxies owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBProxyEndpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case dBProxyEndpointArn = "DBProxyEndpointArn"
        case dBProxyEndpointName = "DBProxyEndpointName"
        case dBProxyName = "DBProxyName"
        case endpoint = "Endpoint"
        case isDefault = "IsDefault"
        case status = "Status"
        case targetRole = "TargetRole"
        case vpcId = "VpcId"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
        case vpcSubnetIds = "VpcSubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createdDate = createdDate {
            try container.encode(ClientRuntime.TimestampWrapper(createdDate, format: .dateTime), forKey: ClientRuntime.Key("createdDate"))
        }
        if let dBProxyEndpointArn = dBProxyEndpointArn {
            try container.encode(dBProxyEndpointArn, forKey: ClientRuntime.Key("DBProxyEndpointArn"))
        }
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let targetRole = targetRole {
            try container.encode(targetRole, forKey: ClientRuntime.Key("TargetRole"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSubnetIds = vpcSubnetIds {
            var vpcSubnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSubnetIds"))
            for (index0, string0) in vpcSubnetIds.enumerated() {
                try vpcSubnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointName)
        dBProxyEndpointName = dBProxyEndpointNameDecoded
        let dBProxyEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyEndpointArn)
        dBProxyEndpointArn = dBProxyEndpointArnDecoded
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpointStatus.self, forKey: .status)
        status = statusDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct member{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.vpcSubnetIds) {
            struct KeyVal0{struct member{}}
            let vpcSubnetIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .vpcSubnetIds)
            if let vpcSubnetIdsWrappedContainer = vpcSubnetIdsWrappedContainer {
                let vpcSubnetIdsContainer = try vpcSubnetIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSubnetIdsBuffer:[Swift.String]? = nil
                if let vpcSubnetIdsContainer = vpcSubnetIdsContainer {
                    vpcSubnetIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSubnetIdsContainer {
                        vpcSubnetIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSubnetIds = vpcSubnetIdsBuffer
            } else {
                vpcSubnetIds = []
            }
        } else {
            vpcSubnetIds = nil
        }
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        var createdDateBuffer:ClientRuntime.Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let targetRoleDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpointTargetRole.self, forKey: .targetRole)
        targetRole = targetRoleDecoded
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension RdsClientTypes.DBProxyEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyEndpoint(createdDate: \(Swift.String(describing: createdDate)), dBProxyEndpointArn: \(Swift.String(describing: dBProxyEndpointArn)), dBProxyEndpointName: \(Swift.String(describing: dBProxyEndpointName)), dBProxyName: \(Swift.String(describing: dBProxyName)), endpoint: \(Swift.String(describing: endpoint)), isDefault: \(Swift.String(describing: isDefault)), status: \(Swift.String(describing: status)), targetRole: \(Swift.String(describing: targetRole)), vpcId: \(Swift.String(describing: vpcId)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)), vpcSubnetIds: \(Swift.String(describing: vpcSubnetIds)))"}
}

extension RdsClientTypes {
    /// The data structure representing an endpoint associated with a DB proxy. RDS automatically creates one
    ///         endpoint for each DB proxy. For Aurora DB clusters, you can associate additional endpoints with the same
    ///         DB proxy. These endpoints can be read/write or read-only. They can also reside in different VPCs than the
    ///         associated DB proxy.
    ///          This data type is used as a response element in the DescribeDBProxyEndpoints operation.
    public struct DBProxyEndpoint: Swift.Equatable {
        /// The date and time when the DB proxy endpoint was first created.
        public var createdDate: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) for the DB proxy endpoint.
        public var dBProxyEndpointArn: Swift.String?
        /// The name for the DB proxy endpoint. An identifier must begin with a letter and
        ///         must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen
        ///         or contain two consecutive hyphens.
        public var dBProxyEndpointName: Swift.String?
        /// The identifier for the DB proxy that is associated with this DB proxy endpoint.
        public var dBProxyName: Swift.String?
        /// The endpoint that you can use to connect to the DB proxy. You include the endpoint value in the
        ///         connection string for a database client application.
        public var endpoint: Swift.String?
        /// A value that indicates whether this endpoint is the default endpoint for the associated DB proxy.
        ///         Default DB proxy endpoints always have read/write capability. Other endpoints that you associate with the
        ///         DB proxy can be either read/write or read-only.
        public var isDefault: Swift.Bool
        /// The current status of this DB proxy endpoint. A status of available means the
        ///         endpoint is ready to handle requests. Other values indicate that you must wait for
        ///         the endpoint to be ready, or take some action to resolve an issue.
        public var status: RdsClientTypes.DBProxyEndpointStatus?
        /// A value that indicates whether the DB proxy endpoint can be used for read/write or read-only operations.
        public var targetRole: RdsClientTypes.DBProxyEndpointTargetRole?
        /// Provides the VPC ID of the DB proxy endpoint.
        public var vpcId: Swift.String?
        /// Provides a list of VPC security groups that the DB proxy endpoint belongs to.
        public var vpcSecurityGroupIds: [Swift.String]?
        /// The EC2 subnet IDs for the DB proxy endpoint.
        public var vpcSubnetIds: [Swift.String]?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            dBProxyEndpointArn: Swift.String? = nil,
            dBProxyEndpointName: Swift.String? = nil,
            dBProxyName: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            status: RdsClientTypes.DBProxyEndpointStatus? = nil,
            targetRole: RdsClientTypes.DBProxyEndpointTargetRole? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroupIds: [Swift.String]? = nil,
            vpcSubnetIds: [Swift.String]? = nil
        )
        {
            self.createdDate = createdDate
            self.dBProxyEndpointArn = dBProxyEndpointArn
            self.dBProxyEndpointName = dBProxyEndpointName
            self.dBProxyName = dBProxyName
            self.endpoint = endpoint
            self.isDefault = isDefault
            self.status = status
            self.targetRole = targetRole
            self.vpcId = vpcId
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.vpcSubnetIds = vpcSubnetIds
        }
    }

}

extension DBProxyEndpointAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyEndpointAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyEndpointAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyEndpointAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified DB proxy endpoint name must be unique for all DB proxy endpoints owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyEndpointAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyEndpointAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpointNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyEndpointNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyEndpointNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyEndpointNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB proxy endpoint doesn't exist.
public struct DBProxyEndpointNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyEndpointNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyEndpointQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyEndpointQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyEndpointQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyEndpointQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB proxy already has the maximum number of endpoints.
public struct DBProxyEndpointQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyEndpointQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyEndpointQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum DBProxyEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case incompatibleNetwork
        case insufficientResourceLimits
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [DBProxyEndpointStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .incompatibleNetwork,
                .insufficientResourceLimits,
                .modifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .creating: return "creating"
            case .deleting: return "deleting"
            case .incompatibleNetwork: return "incompatible-network"
            case .insufficientResourceLimits: return "insufficient-resource-limits"
            case .modifying: return "modifying"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DBProxyEndpointStatus(rawValue: rawValue) ?? DBProxyEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum DBProxyEndpointTargetRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case readOnly
        case readWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [DBProxyEndpointTargetRole] {
            return [
                .readOnly,
                .readWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .readOnly: return "READ_ONLY"
            case .readWrite: return "READ_WRITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DBProxyEndpointTargetRole(rawValue: rawValue) ?? DBProxyEndpointTargetRole.sdkUnknown(rawValue)
        }
    }
}

extension DBProxyNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified proxy name doesn't correspond to a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your Amazon Web Services account already has the maximum number of proxies in the specified Amazon Web Services Region.
public struct DBProxyQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum DBProxyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case incompatibleNetwork
        case insufficientResourceLimits
        case modifying
        case reactivating
        case suspended
        case suspending
        case sdkUnknown(Swift.String)

        public static var allCases: [DBProxyStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .incompatibleNetwork,
                .insufficientResourceLimits,
                .modifying,
                .reactivating,
                .suspended,
                .suspending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .creating: return "creating"
            case .deleting: return "deleting"
            case .incompatibleNetwork: return "incompatible-network"
            case .insufficientResourceLimits: return "insufficient-resource-limits"
            case .modifying: return "modifying"
            case .reactivating: return "reactivating"
            case .suspended: return "suspended"
            case .suspending: return "suspending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DBProxyStatus(rawValue: rawValue) ?? DBProxyStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.DBProxyTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case port = "Port"
        case rdsResourceId = "RdsResourceId"
        case role = "Role"
        case targetArn = "TargetArn"
        case targetHealth = "TargetHealth"
        case trackedClusterId = "TrackedClusterId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let rdsResourceId = rdsResourceId {
            try container.encode(rdsResourceId, forKey: ClientRuntime.Key("RdsResourceId"))
        }
        if let role = role {
            try container.encode(role, forKey: ClientRuntime.Key("Role"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: ClientRuntime.Key("TargetArn"))
        }
        if let targetHealth = targetHealth {
            try container.encode(targetHealth, forKey: ClientRuntime.Key("TargetHealth"))
        }
        if let trackedClusterId = trackedClusterId {
            try container.encode(trackedClusterId, forKey: ClientRuntime.Key("TrackedClusterId"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let trackedClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackedClusterId)
        trackedClusterId = trackedClusterIdDecoded
        let rdsResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rdsResourceId)
        rdsResourceId = rdsResourceIdDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetType.self, forKey: .type)
        type = typeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetRole.self, forKey: .role)
        role = roleDecoded
        let targetHealthDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetHealth.self, forKey: .targetHealth)
        targetHealth = targetHealthDecoded
    }
}

extension RdsClientTypes.DBProxyTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyTarget(endpoint: \(Swift.String(describing: endpoint)), port: \(Swift.String(describing: port)), rdsResourceId: \(Swift.String(describing: rdsResourceId)), role: \(Swift.String(describing: role)), targetArn: \(Swift.String(describing: targetArn)), targetHealth: \(Swift.String(describing: targetHealth)), trackedClusterId: \(Swift.String(describing: trackedClusterId)), type: \(Swift.String(describing: type)))"}
}

extension RdsClientTypes {
    /// Contains the details for an RDS Proxy target. It represents an RDS DB instance or Aurora DB cluster
    ///         that the proxy can connect to. One or more targets are associated with an RDS Proxy target group.
    ///          This data type is used as a response element in the DescribeDBProxyTargets action.
    public struct DBProxyTarget: Swift.Equatable {
        /// The writer endpoint for the RDS DB instance or Aurora DB cluster.
        public var endpoint: Swift.String?
        /// The port that the RDS Proxy uses to connect to the target RDS DB instance or Aurora DB cluster.
        public var port: Swift.Int
        /// The identifier representing the target. It can be the instance identifier for an RDS DB instance,
        ///         or the cluster identifier for an Aurora DB cluster.
        public var rdsResourceId: Swift.String?
        /// A value that indicates whether the target of the proxy can be used for read/write or read-only operations.
        public var role: RdsClientTypes.TargetRole?
        /// The Amazon Resource Name (ARN) for the RDS DB instance or Aurora DB cluster.
        public var targetArn: Swift.String?
        /// Information about the connection health of the RDS Proxy target.
        public var targetHealth: RdsClientTypes.TargetHealth?
        /// The DB cluster identifier when the target represents an Aurora DB cluster. This field is blank when the target represents an RDS DB instance.
        public var trackedClusterId: Swift.String?
        /// Specifies the kind of database, such as an RDS DB instance or an Aurora DB cluster, that the target represents.
        public var type: RdsClientTypes.TargetType?

        public init (
            endpoint: Swift.String? = nil,
            port: Swift.Int = 0,
            rdsResourceId: Swift.String? = nil,
            role: RdsClientTypes.TargetRole? = nil,
            targetArn: Swift.String? = nil,
            targetHealth: RdsClientTypes.TargetHealth? = nil,
            trackedClusterId: Swift.String? = nil,
            type: RdsClientTypes.TargetType? = nil
        )
        {
            self.endpoint = endpoint
            self.port = port
            self.rdsResourceId = rdsResourceId
            self.role = role
            self.targetArn = targetArn
            self.targetHealth = targetHealth
            self.trackedClusterId = trackedClusterId
            self.type = type
        }
    }

}

extension DBProxyTargetAlreadyRegisteredFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyTargetAlreadyRegisteredFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyTargetAlreadyRegisteredFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyTargetAlreadyRegisteredFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The proxy is already associated with the specified RDS DB instance or Aurora DB cluster.
public struct DBProxyTargetAlreadyRegisteredFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetAlreadyRegisteredFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyTargetAlreadyRegisteredFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBProxyTargetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionPoolConfig = "ConnectionPoolConfig"
        case createdDate = "CreatedDate"
        case dBProxyName = "DBProxyName"
        case isDefault = "IsDefault"
        case status = "Status"
        case targetGroupArn = "TargetGroupArn"
        case targetGroupName = "TargetGroupName"
        case updatedDate = "UpdatedDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let connectionPoolConfig = connectionPoolConfig {
            try container.encode(connectionPoolConfig, forKey: ClientRuntime.Key("ConnectionPoolConfig"))
        }
        if let createdDate = createdDate {
            try container.encode(ClientRuntime.TimestampWrapper(createdDate, format: .dateTime), forKey: ClientRuntime.Key("createdDate"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: ClientRuntime.Key("TargetGroupArn"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        if let updatedDate = updatedDate {
            try container.encode(ClientRuntime.TimestampWrapper(updatedDate, format: .dateTime), forKey: ClientRuntime.Key("updatedDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBProxyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBProxyName)
        dBProxyName = dBProxyNameDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let connectionPoolConfigDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ConnectionPoolConfigurationInfo.self, forKey: .connectionPoolConfig)
        connectionPoolConfig = connectionPoolConfigDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        var createdDateBuffer:ClientRuntime.Date? = nil
        if let createdDateDecoded = createdDateDecoded {
            createdDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdDateDecoded, format: .dateTime)
        }
        createdDate = createdDateBuffer
        let updatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedDate)
        var updatedDateBuffer:ClientRuntime.Date? = nil
        if let updatedDateDecoded = updatedDateDecoded {
            updatedDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(updatedDateDecoded, format: .dateTime)
        }
        updatedDate = updatedDateBuffer
    }
}

extension RdsClientTypes.DBProxyTargetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyTargetGroup(connectionPoolConfig: \(Swift.String(describing: connectionPoolConfig)), createdDate: \(Swift.String(describing: createdDate)), dBProxyName: \(Swift.String(describing: dBProxyName)), isDefault: \(Swift.String(describing: isDefault)), status: \(Swift.String(describing: status)), targetGroupArn: \(Swift.String(describing: targetGroupArn)), targetGroupName: \(Swift.String(describing: targetGroupName)), updatedDate: \(Swift.String(describing: updatedDate)))"}
}

extension RdsClientTypes {
    /// Represents a set of RDS DB instances, Aurora DB clusters, or both that a proxy can connect to. Currently, each target group
    ///         is associated with exactly one RDS DB instance or Aurora DB cluster.
    ///          This data type is used as a response element in the DescribeDBProxyTargetGroups action.
    public struct DBProxyTargetGroup: Swift.Equatable {
        /// The settings that determine the size and behavior of the connection pool for the target group.
        public var connectionPoolConfig: RdsClientTypes.ConnectionPoolConfigurationInfo?
        /// The date and time when the target group was first created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for the RDS proxy associated with this target group.
        public var dBProxyName: Swift.String?
        /// Whether this target group is the first one used for connection requests by the associated proxy.
        ///         Because each proxy is currently associated with a single target group, currently this setting
        ///         is always true.
        public var isDefault: Swift.Bool
        /// The current status of this target group. A status of available means the
        ///         target group is correctly associated with a database. Other values indicate that you must wait for
        ///         the target group to be ready, or take some action to resolve an issue.
        public var status: Swift.String?
        /// The Amazon Resource Name (ARN) representing the target group.
        public var targetGroupArn: Swift.String?
        /// The identifier for the target group. This name must be unique for all target groups owned by your Amazon Web Services account in the specified Amazon Web Services Region.
        public var targetGroupName: Swift.String?
        /// The date and time when the target group was last updated.
        public var updatedDate: ClientRuntime.Date?

        public init (
            connectionPoolConfig: RdsClientTypes.ConnectionPoolConfigurationInfo? = nil,
            createdDate: ClientRuntime.Date? = nil,
            dBProxyName: Swift.String? = nil,
            isDefault: Swift.Bool = false,
            status: Swift.String? = nil,
            targetGroupArn: Swift.String? = nil,
            targetGroupName: Swift.String? = nil,
            updatedDate: ClientRuntime.Date? = nil
        )
        {
            self.connectionPoolConfig = connectionPoolConfig
            self.createdDate = createdDate
            self.dBProxyName = dBProxyName
            self.isDefault = isDefault
            self.status = status
            self.targetGroupArn = targetGroupArn
            self.targetGroupName = targetGroupName
            self.updatedDate = updatedDate
        }
    }

}

extension DBProxyTargetGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyTargetGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyTargetGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyTargetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified target group isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyTargetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyTargetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBProxyTargetNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBProxyTargetNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBProxyTargetNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBProxyTargetNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified RDS DB instance or Aurora DB cluster isn't available for a proxy owned by your Amazon Web Services account in the specified Amazon Web Services Region.
public struct DBProxyTargetNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBProxyTargetNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBProxyTargetNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSecurityGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupArn = "DBSecurityGroupArn"
        case dBSecurityGroupDescription = "DBSecurityGroupDescription"
        case dBSecurityGroupName = "DBSecurityGroupName"
        case eC2SecurityGroups = "EC2SecurityGroups"
        case iPRanges = "IPRanges"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupArn = dBSecurityGroupArn {
            try container.encode(dBSecurityGroupArn, forKey: ClientRuntime.Key("DBSecurityGroupArn"))
        }
        if let dBSecurityGroupDescription = dBSecurityGroupDescription {
            try container.encode(dBSecurityGroupDescription, forKey: ClientRuntime.Key("DBSecurityGroupDescription"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroups = eC2SecurityGroups {
            var eC2SecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EC2SecurityGroups"))
            for (index0, ec2securitygroup0) in eC2SecurityGroups.enumerated() {
                try eC2SecurityGroupsContainer.encode(ec2securitygroup0, forKey: ClientRuntime.Key("EC2SecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let iPRanges = iPRanges {
            var iPRangesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IPRanges"))
            for (index0, iprange0) in iPRanges.enumerated() {
                try iPRangesContainer.encode(iprange0, forKey: ClientRuntime.Key("IPRange.\(index0.advanced(by: 1))"))
            }
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: ClientRuntime.Key("OwnerId"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let dBSecurityGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupDescription)
        dBSecurityGroupDescription = dBSecurityGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        if containerValues.contains(.eC2SecurityGroups) {
            struct KeyVal0{struct EC2SecurityGroup{}}
            let eC2SecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EC2SecurityGroup>.CodingKeys.self, forKey: .eC2SecurityGroups)
            if let eC2SecurityGroupsWrappedContainer = eC2SecurityGroupsWrappedContainer {
                let eC2SecurityGroupsContainer = try eC2SecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.EC2SecurityGroup].self, forKey: .member)
                var eC2SecurityGroupsBuffer:[RdsClientTypes.EC2SecurityGroup]? = nil
                if let eC2SecurityGroupsContainer = eC2SecurityGroupsContainer {
                    eC2SecurityGroupsBuffer = [RdsClientTypes.EC2SecurityGroup]()
                    for structureContainer0 in eC2SecurityGroupsContainer {
                        eC2SecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                eC2SecurityGroups = eC2SecurityGroupsBuffer
            } else {
                eC2SecurityGroups = []
            }
        } else {
            eC2SecurityGroups = nil
        }
        if containerValues.contains(.iPRanges) {
            struct KeyVal0{struct IPRange{}}
            let iPRangesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.IPRange>.CodingKeys.self, forKey: .iPRanges)
            if let iPRangesWrappedContainer = iPRangesWrappedContainer {
                let iPRangesContainer = try iPRangesWrappedContainer.decodeIfPresent([RdsClientTypes.IPRange].self, forKey: .member)
                var iPRangesBuffer:[RdsClientTypes.IPRange]? = nil
                if let iPRangesContainer = iPRangesContainer {
                    iPRangesBuffer = [RdsClientTypes.IPRange]()
                    for structureContainer0 in iPRangesContainer {
                        iPRangesBuffer?.append(structureContainer0)
                    }
                }
                iPRanges = iPRangesBuffer
            } else {
                iPRanges = []
            }
        } else {
            iPRanges = nil
        }
        let dBSecurityGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupArn)
        dBSecurityGroupArn = dBSecurityGroupArnDecoded
    }
}

extension RdsClientTypes.DBSecurityGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroup(dBSecurityGroupArn: \(Swift.String(describing: dBSecurityGroupArn)), dBSecurityGroupDescription: \(Swift.String(describing: dBSecurityGroupDescription)), dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), eC2SecurityGroups: \(Swift.String(describing: eC2SecurityGroups)), iPRanges: \(Swift.String(describing: iPRanges)), ownerId: \(Swift.String(describing: ownerId)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RdsClientTypes {
    /// Contains the details for an Amazon RDS DB security group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSecurityGroups action.
    ///
    public struct DBSecurityGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB security group.
        public var dBSecurityGroupArn: Swift.String?
        /// Provides the description of the DB security group.
        public var dBSecurityGroupDescription: Swift.String?
        /// Specifies the name of the DB security group.
        public var dBSecurityGroupName: Swift.String?
        ///
        ///         Contains a list of EC2SecurityGroup elements.
        ///
        public var eC2SecurityGroups: [RdsClientTypes.EC2SecurityGroup]?
        ///
        ///         Contains a list of IPRange elements.
        ///
        public var iPRanges: [RdsClientTypes.IPRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public var ownerId: Swift.String?
        /// Provides the VpcId of the DB security group.
        public var vpcId: Swift.String?

        public init (
            dBSecurityGroupArn: Swift.String? = nil,
            dBSecurityGroupDescription: Swift.String? = nil,
            dBSecurityGroupName: Swift.String? = nil,
            eC2SecurityGroups: [RdsClientTypes.EC2SecurityGroup]? = nil,
            iPRanges: [RdsClientTypes.IPRange]? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dBSecurityGroupArn = dBSecurityGroupArn
            self.dBSecurityGroupDescription = dBSecurityGroupDescription
            self.dBSecurityGroupName = dBSecurityGroupName
            self.eC2SecurityGroups = eC2SecurityGroups
            self.iPRanges = iPRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension DBSecurityGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBSecurityGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///         A DB security group with the name specified in
///         DBSecurityGroupName already exists.
///
public struct DBSecurityGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSecurityGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupName = "DBSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSecurityGroupName)
        dBSecurityGroupName = dBSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes.DBSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupMembership(dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// This data type is used as a response element in the following actions:
    ///
    ///
    ///
    ///                   ModifyDBInstance
    ///
    ///
    ///
    ///
    ///                   RebootDBInstance
    ///
    ///
    ///
    ///
    ///                   RestoreDBInstanceFromDBSnapshot
    ///
    ///
    ///
    ///
    ///                   RestoreDBInstanceToPointInTime
    ///
    ///
    ///
    public struct DBSecurityGroupMembership: Swift.Equatable {
        /// The name of the DB security group.
        public var dBSecurityGroupName: Swift.String?
        /// The status of the DB security group.
        public var status: Swift.String?

        public init (
            dBSecurityGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dBSecurityGroupName = dBSecurityGroupName
            self.status = status
        }
    }

}

extension DBSecurityGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBSecurityGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBSecurityGroupName doesn't refer to an existing DB security group.
///
public struct DBSecurityGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSecurityGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupNotSupportedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupNotSupportedFault(message: \(Swift.String(describing: message)))"}
}

extension DBSecurityGroupNotSupportedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupNotSupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A DB security group isn't allowed for this action.
public struct DBSecurityGroupNotSupportedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupNotSupportedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSecurityGroupNotSupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSecurityGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSecurityGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBSecurityGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSecurityGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB security
///             groups.
public struct DBSecurityGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSecurityGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSecurityGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSnapshot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSnapshotArn = "DBSnapshotArn"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case originalSnapshotCreateTime = "OriginalSnapshotCreateTime"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDBSnapshotIdentifier = "SourceDBSnapshotIdentifier"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case storageType = "StorageType"
        case tagList = "TagList"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allocatedStorage != 0 {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotArn = dBSnapshotArn {
            try container.encode(dBSnapshotArn, forKey: ClientRuntime.Key("DBSnapshotArn"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if iAMDatabaseAuthenticationEnabled != false {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let instanceCreateTime = instanceCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(instanceCreateTime, format: .dateTime), forKey: ClientRuntime.Key("instanceCreateTime"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let originalSnapshotCreateTime = originalSnapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(originalSnapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("originalSnapshotCreateTime"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier {
            try container.encode(sourceDBSnapshotIdentifier, forKey: ClientRuntime.Key("SourceDBSnapshotIdentifier"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: ClientRuntime.Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let timezone = timezone {
            try container.encode(timezone, forKey: ClientRuntime.Key("Timezone"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decode(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        var instanceCreateTimeBuffer:ClientRuntime.Date? = nil
        if let instanceCreateTimeDecoded = instanceCreateTimeDecoded {
            instanceCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(instanceCreateTimeDecoded, format: .dateTime)
        }
        instanceCreateTime = instanceCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceDBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBSnapshotIdentifier)
        sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dBSnapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotArn)
        dBSnapshotArn = dBSnapshotArnDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let originalSnapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalSnapshotCreateTime)
        var originalSnapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let originalSnapshotCreateTimeDecoded = originalSnapshotCreateTimeDecoded {
            originalSnapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(originalSnapshotCreateTimeDecoded, format: .dateTime)
        }
        originalSnapshotCreateTime = originalSnapshotCreateTimeBuffer
    }
}

extension RdsClientTypes.DBSnapshot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshot(allocatedStorage: \(Swift.String(describing: allocatedStorage)), availabilityZone: \(Swift.String(describing: availabilityZone)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBSnapshotArn: \(Swift.String(describing: dBSnapshotArn)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)), dbiResourceId: \(Swift.String(describing: dbiResourceId)), encrypted: \(Swift.String(describing: encrypted)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), instanceCreateTime: \(Swift.String(describing: instanceCreateTime)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUsername: \(Swift.String(describing: masterUsername)), optionGroupName: \(Swift.String(describing: optionGroupName)), originalSnapshotCreateTime: \(Swift.String(describing: originalSnapshotCreateTime)), percentProgress: \(Swift.String(describing: percentProgress)), port: \(Swift.String(describing: port)), processorFeatures: \(Swift.String(describing: processorFeatures)), snapshotCreateTime: \(Swift.String(describing: snapshotCreateTime)), snapshotType: \(Swift.String(describing: snapshotType)), sourceDBSnapshotIdentifier: \(Swift.String(describing: sourceDBSnapshotIdentifier)), sourceRegion: \(Swift.String(describing: sourceRegion)), status: \(Swift.String(describing: status)), storageType: \(Swift.String(describing: storageType)), tagList: \(Swift.String(describing: tagList)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), timezone: \(Swift.String(describing: timezone)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB snapshot.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSnapshots action.
    ///
    public struct DBSnapshot: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// Specifies the name of the Availability Zone the DB instance was located in at the time of the DB snapshot.
        public var availabilityZone: Swift.String?
        /// Specifies the DB instance identifier of the DB instance this DB snapshot was created from.
        public var dBInstanceIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) for the DB snapshot.
        public var dBSnapshotArn: Swift.String?
        /// Specifies the identifier for the DB snapshot.
        public var dBSnapshotIdentifier: Swift.String?
        /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
        public var dbiResourceId: Swift.String?
        /// Specifies whether the DB snapshot is encrypted.
        public var encrypted: Swift.Bool
        /// Specifies the name of the database engine.
        public var engine: Swift.String?
        /// Specifies the version of the database engine.
        public var engineVersion: Swift.String?
        /// True if mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled, and otherwise false.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from
        ///             which the snapshot was taken, was created.
        public var instanceCreateTime: ClientRuntime.Date?
        /// Specifies the Provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public var iops: Swift.Int?
        ///
        ///             If Encrypted is true, the Amazon Web Services KMS key identifier
        ///             for the encrypted DB snapshot.
        ///
        ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
        public var kmsKeyId: Swift.String?
        /// License model information for the restored DB instance.
        public var licenseModel: Swift.String?
        /// Provides the master username for the DB snapshot.
        public var masterUsername: Swift.String?
        /// Provides the option group name for the DB snapshot.
        public var optionGroupName: Swift.String?
        /// Specifies the time of the CreateDBSnapshot operation in Coordinated Universal Time (UTC). Doesn't change when the snapshot is copied.
        public var originalSnapshotCreateTime: ClientRuntime.Date?
        /// The percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int
        /// Specifies the port that the database engine was listening on at the time of the snapshot.
        public var port: Swift.Int
        /// The number of CPU cores and the number of threads per core for the DB instance class
        ///             of the DB instance when the DB snapshot was created.
        public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
        /// Specifies when the snapshot was taken in Coordinated Universal Time (UTC). Changes for the copy when the snapshot is copied.
        public var snapshotCreateTime: ClientRuntime.Date?
        /// Provides the type of the DB snapshot.
        public var snapshotType: Swift.String?
        /// The DB snapshot Amazon Resource Name (ARN) that the DB snapshot was copied from. It only has a value in the case of a cross-account or cross-Region copy.
        public var sourceDBSnapshotIdentifier: Swift.String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public var sourceRegion: Swift.String?
        /// Specifies the status of this DB snapshot.
        public var status: Swift.String?
        /// Specifies the storage type associated with DB snapshot.
        public var storageType: Swift.String?
        /// A list of tags.
        ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
        ///
        public var tagList: [RdsClientTypes.Tag]?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB snapshot.
        ///             In most cases, the Timezone element is empty.
        ///             Timezone content appears only for
        ///             snapshots taken from
        ///             Microsoft SQL Server DB instances
        ///             that were created with a time zone specified.
        ///
        public var timezone: Swift.String?
        /// Provides the VPC ID associated with the DB snapshot.
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBSnapshotArn: Swift.String? = nil,
            dBSnapshotIdentifier: Swift.String? = nil,
            dbiResourceId: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: ClientRuntime.Date? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            originalSnapshotCreateTime: ClientRuntime.Date? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
            snapshotCreateTime: ClientRuntime.Date? = nil,
            snapshotType: Swift.String? = nil,
            sourceDBSnapshotIdentifier: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            status: Swift.String? = nil,
            storageType: Swift.String? = nil,
            tagList: [RdsClientTypes.Tag]? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBSnapshotArn = dBSnapshotArn
            self.dBSnapshotIdentifier = dBSnapshotIdentifier
            self.dbiResourceId = dbiResourceId
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.originalSnapshotCreateTime = originalSnapshotCreateTime
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDBSnapshotIdentifier = sourceDBSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageType = storageType
            self.tagList = tagList
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }
    }

}

extension DBSnapshotAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshotAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBSnapshotAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSnapshotAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBSnapshotIdentifier is already used by an existing snapshot.
///
public struct DBSnapshotAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSnapshotAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSnapshotAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValues = "AttributeValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValues = attributeValues {
            var attributeValuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AttributeValues"))
            for (index0, string0) in attributeValues.enumerated() {
                try attributeValuesContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        if containerValues.contains(.attributeValues) {
            struct KeyVal0{struct AttributeValue{}}
            let attributeValuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AttributeValue>.CodingKeys.self, forKey: .attributeValues)
            if let attributeValuesWrappedContainer = attributeValuesWrappedContainer {
                let attributeValuesContainer = try attributeValuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var attributeValuesBuffer:[Swift.String]? = nil
                if let attributeValuesContainer = attributeValuesContainer {
                    attributeValuesBuffer = [Swift.String]()
                    for stringContainer0 in attributeValuesContainer {
                        attributeValuesBuffer?.append(stringContainer0)
                    }
                }
                attributeValues = attributeValuesBuffer
            } else {
                attributeValues = []
            }
        } else {
            attributeValues = nil
        }
    }
}

extension RdsClientTypes.DBSnapshotAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshotAttribute(attributeName: \(Swift.String(describing: attributeName)), attributeValues: \(Swift.String(describing: attributeValues)))"}
}

extension RdsClientTypes {
    /// Contains the name and values of a manual DB snapshot attribute
    ///          Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts
    ///     to restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute
    ///     API.
    public struct DBSnapshotAttribute: Swift.Equatable {
        /// The name of the manual DB snapshot attribute.
        ///          The attribute named restore refers to the list of Amazon Web Services accounts that
        ///           have permission to copy or restore the manual DB cluster snapshot. For more information,
        ///           see the ModifyDBSnapshotAttribute
        ///           API action.
        public var attributeName: Swift.String?
        /// The value or values for the manual DB snapshot attribute.
        ///          If the AttributeName field is set to restore, then this element
        ///       returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual
        ///       DB snapshot. If a value of all is in the list, then the manual DB snapshot
        ///       is public and available for any Amazon Web Services account to copy or restore.
        public var attributeValues: [Swift.String]?

        public init (
            attributeName: Swift.String? = nil,
            attributeValues: [Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension RdsClientTypes.DBSnapshotAttributesResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotAttributes = "DBSnapshotAttributes"
        case dBSnapshotIdentifier = "DBSnapshotIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotAttributes = dBSnapshotAttributes {
            var dBSnapshotAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSnapshotAttributes"))
            for (index0, dbsnapshotattribute0) in dBSnapshotAttributes.enumerated() {
                try dBSnapshotAttributesContainer.encode(dbsnapshotattribute0, forKey: ClientRuntime.Key("DBSnapshotAttribute.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSnapshotIdentifier)
        dBSnapshotIdentifier = dBSnapshotIdentifierDecoded
        if containerValues.contains(.dBSnapshotAttributes) {
            struct KeyVal0{struct DBSnapshotAttribute{}}
            let dBSnapshotAttributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSnapshotAttribute>.CodingKeys.self, forKey: .dBSnapshotAttributes)
            if let dBSnapshotAttributesWrappedContainer = dBSnapshotAttributesWrappedContainer {
                let dBSnapshotAttributesContainer = try dBSnapshotAttributesWrappedContainer.decodeIfPresent([RdsClientTypes.DBSnapshotAttribute].self, forKey: .member)
                var dBSnapshotAttributesBuffer:[RdsClientTypes.DBSnapshotAttribute]? = nil
                if let dBSnapshotAttributesContainer = dBSnapshotAttributesContainer {
                    dBSnapshotAttributesBuffer = [RdsClientTypes.DBSnapshotAttribute]()
                    for structureContainer0 in dBSnapshotAttributesContainer {
                        dBSnapshotAttributesBuffer?.append(structureContainer0)
                    }
                }
                dBSnapshotAttributes = dBSnapshotAttributesBuffer
            } else {
                dBSnapshotAttributes = []
            }
        } else {
            dBSnapshotAttributes = nil
        }
    }
}

extension RdsClientTypes.DBSnapshotAttributesResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshotAttributesResult(dBSnapshotAttributes: \(Swift.String(describing: dBSnapshotAttributes)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)))"}
}

extension RdsClientTypes {
    /// Contains the results of a successful call to the DescribeDBSnapshotAttributes
    ///     API action.
    ///          Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts
    ///       to copy or restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute
    ///       API action.
    public struct DBSnapshotAttributesResult: Swift.Equatable {
        /// The list of attributes and values for the manual DB snapshot.
        public var dBSnapshotAttributes: [RdsClientTypes.DBSnapshotAttribute]?
        /// The identifier of the manual DB snapshot that the attributes apply to.
        public var dBSnapshotIdentifier: Swift.String?

        public init (
            dBSnapshotAttributes: [RdsClientTypes.DBSnapshotAttribute]? = nil,
            dBSnapshotIdentifier: Swift.String? = nil
        )
        {
            self.dBSnapshotAttributes = dBSnapshotAttributes
            self.dBSnapshotIdentifier = dBSnapshotIdentifier
        }
    }

}

extension DBSnapshotNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSnapshotNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBSnapshotNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSnapshotNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBSnapshotIdentifier doesn't refer to an existing DB snapshot.
///
public struct DBSnapshotNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSnapshotNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSnapshotNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DBSubnetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroupArn = "DBSubnetGroupArn"
        case dBSubnetGroupDescription = "DBSubnetGroupDescription"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupArn = dBSubnetGroupArn {
            try container.encode(dBSubnetGroupArn, forKey: ClientRuntime.Key("DBSubnetGroupArn"))
        }
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetGroupStatus = subnetGroupStatus {
            try container.encode(subnetGroupStatus, forKey: ClientRuntime.Key("SubnetGroupStatus"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Subnets"))
            for (index0, subnet0) in subnets.enumerated() {
                try subnetsContainer.encode(subnet0, forKey: ClientRuntime.Key("Subnet.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let dBSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupDescription)
        dBSubnetGroupDescription = dBSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct Subnet{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Subnet>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([RdsClientTypes.Subnet].self, forKey: .member)
                var subnetsBuffer:[RdsClientTypes.Subnet]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [RdsClientTypes.Subnet]()
                    for structureContainer0 in subnetsContainer {
                        subnetsBuffer?.append(structureContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let dBSubnetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupArn)
        dBSubnetGroupArn = dBSubnetGroupArnDecoded
    }
}

extension RdsClientTypes.DBSubnetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroup(dBSubnetGroupArn: \(Swift.String(describing: dBSubnetGroupArn)), dBSubnetGroupDescription: \(Swift.String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), subnetGroupStatus: \(Swift.String(describing: subnetGroupStatus)), subnets: \(Swift.String(describing: subnets)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RdsClientTypes {
    /// Contains the details of an Amazon RDS DB subnet group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSubnetGroups action.
    ///
    public struct DBSubnetGroup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the DB subnet group.
        public var dBSubnetGroupArn: Swift.String?
        /// Provides the description of the DB subnet group.
        public var dBSubnetGroupDescription: Swift.String?
        /// The name of the DB subnet group.
        public var dBSubnetGroupName: Swift.String?
        /// Provides the status of the DB subnet group.
        public var subnetGroupStatus: Swift.String?
        ///
        ///         Contains a list of Subnet elements.
        ///
        public var subnets: [RdsClientTypes.Subnet]?
        /// Provides the VpcId of the DB subnet group.
        public var vpcId: Swift.String?

        public init (
            dBSubnetGroupArn: Swift.String? = nil,
            dBSubnetGroupDescription: Swift.String? = nil,
            dBSubnetGroupName: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [RdsClientTypes.Subnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dBSubnetGroupArn = dBSubnetGroupArn
            self.dBSubnetGroupDescription = dBSubnetGroupDescription
            self.dBSubnetGroupName = dBSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension DBSubnetGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBSubnetGroupName is already used by an existing DB subnet group.
///
public struct DBSubnetGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupDoesNotCoverEnoughAZs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupDoesNotCoverEnoughAZs(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupDoesNotCoverEnoughAZs {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupDoesNotCoverEnoughAZsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Subnets in the DB subnet group should cover at least two Availability Zones unless there is only one Availability Zone.
public struct DBSubnetGroupDoesNotCoverEnoughAZs: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupDoesNotCoverEnoughAZsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotAllowedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupNotAllowedFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupNotAllowedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupNotAllowedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DBSubnetGroup shouldn't be specified while creating read replicas that lie
///             in the same region as the source instance.
public struct DBSubnetGroupNotAllowedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotAllowedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupNotAllowedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             DBSubnetGroupName doesn't refer to an existing DB subnet group.
///
public struct DBSubnetGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB subnet
///             groups.
public struct DBSubnetGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBSubnetQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBSubnetQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension DBSubnetQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBSubnetQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of subnets in a
///             DB subnet groups.
public struct DBSubnetQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBSubnetQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBSubnetQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DBUpgradeDependencyFailureFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DBUpgradeDependencyFailureFault(message: \(Swift.String(describing: message)))"}
}

extension DBUpgradeDependencyFailureFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DBUpgradeDependencyFailureFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB upgrade failed because a resource the DB depends on can't be
///             modified.
public struct DBUpgradeDependencyFailureFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DBUpgradeDependencyFailureFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DBUpgradeDependencyFailureFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteCustomAvailabilityZoneInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomAvailabilityZoneInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomAvailabilityZoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomAvailabilityZoneOutputError>
}

extension DeleteCustomAvailabilityZoneInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomAvailabilityZoneInput(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)))"}
}

extension DeleteCustomAvailabilityZoneInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        try container.encode("DeleteCustomAvailabilityZone", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteCustomAvailabilityZoneInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomAvailabilityZoneInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomAvailabilityZoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomAvailabilityZoneOutputError>
}

public struct DeleteCustomAvailabilityZoneInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomAvailabilityZoneInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomAvailabilityZoneInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomAvailabilityZoneInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomAvailabilityZoneOutputError>
}

public struct DeleteCustomAvailabilityZoneInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomAvailabilityZoneInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteCustomAvailabilityZoneInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCustomAvailabilityZoneInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomAvailabilityZoneOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomAvailabilityZoneOutputError>
}

public struct DeleteCustomAvailabilityZoneInput: Swift.Equatable {
    /// The custom AZ identifier.
    /// This member is required.
    public var customAvailabilityZoneId: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
    }
}

extension DeleteCustomAvailabilityZoneOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCustomAvailabilityZoneOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomAvailabilityZoneOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomAvailabilityZoneOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomAvailabilityZoneOutputResponse(customAvailabilityZone: \(Swift.String(describing: customAvailabilityZone)))"}
}

extension DeleteCustomAvailabilityZoneOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCustomAvailabilityZoneOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZone = output.customAvailabilityZone
        } else {
            self.customAvailabilityZone = nil
        }
    }
}

public struct DeleteCustomAvailabilityZoneOutputResponse: Swift.Equatable {
    /// A custom Availability Zone (AZ) is an on-premises AZ that is integrated with a VMware vSphere cluster.
    ///         For more information about RDS on VMware, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                 RDS on VMware User Guide.
    ///
    public var customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?

    public init (
        customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone? = nil
    )
    {
        self.customAvailabilityZone = customAvailabilityZone
    }
}

struct DeleteCustomAvailabilityZoneOutputResponseBody: Swift.Equatable {
    public let customAvailabilityZone: RdsClientTypes.CustomAvailabilityZone?
}

extension DeleteCustomAvailabilityZoneOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZone = "CustomAvailabilityZone"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteCustomAvailabilityZoneResult"))
        let customAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CustomAvailabilityZone.self, forKey: .customAvailabilityZone)
        customAvailabilityZone = customAvailabilityZoneDecoded
    }
}

public struct DeleteDBClusterEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

extension DeleteDBClusterEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterEndpointInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)))"}
}

extension DeleteDBClusterEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        try container.encode("DeleteDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBClusterEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBClusterEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterEndpointOutputError>
}

public struct DeleteDBClusterEndpointInput: Swift.Equatable {
    /// The identifier associated with the custom endpoint. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterEndpointIdentifier: Swift.String?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
    }
}

extension DeleteDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterEndpointOutputResponse(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension DeleteDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:
///
///
///
///                   CreateDBClusterEndpoint
///
///
///
///
///                   DescribeDBClusterEndpoints
///
///
///
///
///                   ModifyDBClusterEndpoint
///
///
///
///
///                   DeleteDBClusterEndpoint
///
///
///
///          For the data structure that represents Amazon RDS DB instance endpoints,
///         see Endpoint.
public struct DeleteDBClusterEndpointOutputResponse: Swift.Equatable {
    /// The type associated with a custom endpoint. One of: READER,
    ///        WRITER, ANY.
    public var customEndpointType: Swift.String?
    /// The Amazon Resource Name (ARN) for the endpoint.
    public var dBClusterEndpointArn: Swift.String?
    /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
    public var dBClusterEndpointResourceIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// The DNS address of the endpoint.
    public var endpoint: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a writer endpoint for a read-only secondary cluster in a global database.
    public var status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct DeleteDBClusterEndpointOutputResponseBody: Swift.Equatable {
    public let dBClusterEndpointIdentifier: Swift.String?
    public let dBClusterIdentifier: Swift.String?
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    public let endpoint: Swift.String?
    public let status: Swift.String?
    public let endpointType: Swift.String?
    public let customEndpointType: Swift.String?
    public let staticMembers: [Swift.String]?
    public let excludedMembers: [Swift.String]?
    public let dBClusterEndpointArn: Swift.String?
}

extension DeleteDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct DeleteDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

extension DeleteDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), finalDBSnapshotIdentifier: \(Swift.String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(Swift.String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: ClientRuntime.Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: ClientRuntime.Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

public struct DeleteDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterOutputError>
}

///
public struct DeleteDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier for the DB cluster to be deleted. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must match an existing DBClusterIdentifier.
    ///
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    ///
    ///       The DB cluster snapshot identifier of the new DB cluster snapshot created when SkipFinalSnapshot
    ///       is disabled.
    ///
    ///
    ///
    ///           Specifying this parameter and also skipping the creation of a final DB cluster snapshot
    ///           with the SkipFinalShapshot parameter results in an error.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    public var finalDBSnapshotIdentifier: Swift.String?
    /// A value that indicates whether to skip the creation of a final DB cluster snapshot before the DB cluster is deleted.
    ///           If skip is specified, no DB cluster snapshot is created. If skip isn't specified, a DB cluster snapshot
    ///           is created before the DB cluster is deleted. By default, skip isn't specified, and the DB cluster snapshot is created.
    ///           By default, this parameter is disabled.
    ///
    ///             You must specify a FinalDBSnapshotIdentifier parameter if SkipFinalSnapshot is disabled.
    ///
    public var skipFinalSnapshot: Swift.Bool

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        finalDBSnapshotIdentifier: Swift.String? = nil,
        skipFinalSnapshot: Swift.Bool = false
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotAlreadyExistsFault" : self = .dBClusterSnapshotAlreadyExistsFault(try DBClusterSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterSnapshotAlreadyExistsFault(DBClusterSnapshotAlreadyExistsFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension DeleteDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct DeleteDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct DeleteDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension DeleteDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct DeleteDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

extension DeleteDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)))"}
}

extension DeleteDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        try container.encode("DeleteDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

public struct DeleteDBClusterParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBClusterParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBClusterParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterParameterGroupOutputError>
}

///
public struct DeleteDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must be the name of an existing DB cluster parameter group.
    ///
    ///
    ///                You can't delete a default DB cluster parameter group.
    ///
    ///
    ///                Can't be associated with any DB clusters.
    ///
    ///
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

extension DeleteDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterParameterGroupOutputResponse()"}
}

extension DeleteDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBClusterParameterGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBClusterParameterGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDBClusterSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

extension DeleteDBClusterSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterSnapshotInput(dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DeleteDBClusterSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DeleteDBClusterSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBClusterSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBClusterSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

public struct DeleteDBClusterSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBClusterSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBClusterSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBClusterSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBClusterSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBClusterSnapshotOutputError>
}

///
public struct DeleteDBClusterSnapshotInput: Swift.Equatable {
    /// The identifier of the DB cluster snapshot to delete.
    ///          Constraints: Must be the name of an existing DB cluster snapshot in the available state.
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?

    public init (
        dBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DeleteDBClusterSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBClusterSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBClusterSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBClusterSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBClusterSnapshotOutputResponse(dBClusterSnapshot: \(Swift.String(describing: dBClusterSnapshot)))"}
}

extension DeleteDBClusterSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBClusterSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshot = output.dBClusterSnapshot
        } else {
            self.dBClusterSnapshot = nil
        }
    }
}

public struct DeleteDBClusterSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB cluster snapshot
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBClusterSnapshots action.
    ///
    public var dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?

    public init (
        dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot? = nil
    )
    {
        self.dBClusterSnapshot = dBClusterSnapshot
    }
}

struct DeleteDBClusterSnapshotOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshot: RdsClientTypes.DBClusterSnapshot?
}

extension DeleteDBClusterSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshot = "DBClusterSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBClusterSnapshotResult"))
        let dBClusterSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshot.self, forKey: .dBClusterSnapshot)
        dBClusterSnapshot = dBClusterSnapshotDecoded
    }
}

public struct DeleteDBInstanceAutomatedBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceAutomatedBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

extension DeleteDBInstanceAutomatedBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBInstanceAutomatedBackupInput(dBInstanceAutomatedBackupsArn: \(Swift.String(describing: dBInstanceAutomatedBackupsArn)), dbiResourceId: \(Swift.String(describing: dbiResourceId)))"}
}

extension DeleteDBInstanceAutomatedBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        try container.encode("DeleteDBInstanceAutomatedBackup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBInstanceAutomatedBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceAutomatedBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

public struct DeleteDBInstanceAutomatedBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceAutomatedBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceAutomatedBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

public struct DeleteDBInstanceAutomatedBackupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceAutomatedBackupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBInstanceAutomatedBackupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBInstanceAutomatedBackupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceAutomatedBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceAutomatedBackupOutputError>
}

/// Parameter input for the DeleteDBInstanceAutomatedBackup operation.
public struct DeleteDBInstanceAutomatedBackupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the automated backups to delete, for example,
    ///             arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE.
    public var dBInstanceAutomatedBackupsArn: Swift.String?
    /// The identifier for the source DB instance, which can't be changed and which is unique to an Amazon Web Services Region.
    public var dbiResourceId: Swift.String?

    public init (
        dBInstanceAutomatedBackupsArn: Swift.String? = nil,
        dbiResourceId: Swift.String? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dbiResourceId = dbiResourceId
    }
}

extension DeleteDBInstanceAutomatedBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceAutomatedBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupNotFound" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceAutomatedBackupState" : self = .invalidDBInstanceAutomatedBackupStateFault(try InvalidDBInstanceAutomatedBackupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceAutomatedBackupOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case invalidDBInstanceAutomatedBackupStateFault(InvalidDBInstanceAutomatedBackupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceAutomatedBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBInstanceAutomatedBackupOutputResponse(dBInstanceAutomatedBackup: \(Swift.String(describing: dBInstanceAutomatedBackup)))"}
}

extension DeleteDBInstanceAutomatedBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBInstanceAutomatedBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct DeleteDBInstanceAutomatedBackupOutputResponse: Swift.Equatable {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.
    public var dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct DeleteDBInstanceAutomatedBackupOutputResponseBody: Swift.Equatable {
    public let dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?
}

extension DeleteDBInstanceAutomatedBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBInstanceAutomatedBackupResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

public struct DeleteDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

extension DeleteDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), deleteAutomatedBackups: \(Swift.String(describing: deleteAutomatedBackups)), finalDBSnapshotIdentifier: \(Swift.String(describing: finalDBSnapshotIdentifier)), skipFinalSnapshot: \(Swift.String(describing: skipFinalSnapshot)))"}
}

extension DeleteDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let deleteAutomatedBackups = deleteAutomatedBackups {
            try container.encode(deleteAutomatedBackups, forKey: ClientRuntime.Key("DeleteAutomatedBackups"))
        }
        if let finalDBSnapshotIdentifier = finalDBSnapshotIdentifier {
            try container.encode(finalDBSnapshotIdentifier, forKey: ClientRuntime.Key("FinalDBSnapshotIdentifier"))
        }
        if skipFinalSnapshot != false {
            try container.encode(skipFinalSnapshot, forKey: ClientRuntime.Key("SkipFinalSnapshot"))
        }
        try container.encode("DeleteDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

public struct DeleteDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBInstanceOutputError>
}

///
public struct DeleteDBInstanceInput: Swift.Equatable {
    /// The DB instance identifier for the DB instance to be deleted. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must match the name of an existing DB instance.
    ///
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// A value that indicates whether to remove automated backups immediately after the DB
    ///             instance is deleted. This parameter isn't case-sensitive. The default is to remove
    ///             automated backups immediately after the DB instance is deleted.
    public var deleteAutomatedBackups: Swift.Bool?
    ///
    ///         The DBSnapshotIdentifier of the new DBSnapshot created when the SkipFinalSnapshot
    ///         parameter is disabled.
    ///
    ///
    ///             Specifying this parameter and also specifying to skip final DB snapshot creation in SkipFinalShapshot results in an error.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///                Can't be specified when deleting a read replica.
    ///
    ///
    public var finalDBSnapshotIdentifier: Swift.String?
    /// A value that indicates whether to skip the creation of a final DB snapshot before the DB instance is deleted.
    ///           If skip is specified, no DB snapshot is created. If skip isn't specified, a DB snapshot
    ///           is created before the DB instance is deleted. By default, skip isn't specified, and the DB snapshot is created.
    ///          When a DB instance is in a failure state and has a status of 'failed', 'incompatible-restore', or 'incompatible-network', it can only be deleted when skip is specified.
    ///          Specify skip when deleting a read replica.
    ///
    ///             The FinalDBSnapshotIdentifier parameter must be specified if skip isn't specified.
    ///
    public var skipFinalSnapshot: Swift.Bool

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        deleteAutomatedBackups: Swift.Bool? = nil,
        finalDBSnapshotIdentifier: Swift.String? = nil,
        skipFinalSnapshot: Swift.Bool = false
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.deleteAutomatedBackups = deleteAutomatedBackups
        self.finalDBSnapshotIdentifier = finalDBSnapshotIdentifier
        self.skipFinalSnapshot = skipFinalSnapshot
    }
}

extension DeleteDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupQuotaExceeded" : self = .dBInstanceAutomatedBackupQuotaExceededFault(try DBInstanceAutomatedBackupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupQuotaExceededFault(DBInstanceAutomatedBackupQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension DeleteDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct DeleteDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct DeleteDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension DeleteDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct DeleteDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

extension DeleteDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBParameterGroupInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)))"}
}

extension DeleteDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        try container.encode("DeleteDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

public struct DeleteDBParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBParameterGroupOutputError>
}

///
public struct DeleteDBParameterGroupInput: Swift.Equatable {
    /// The name of the DB parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must be the name of an existing DB parameter group
    ///
    ///
    ///                You can't delete a default DB parameter group
    ///
    ///
    ///                Can't be associated with any DB instances
    ///
    ///
    /// This member is required.
    public var dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

extension DeleteDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBParameterGroupOutputResponse()"}
}

extension DeleteDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBParameterGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBParameterGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBParameterGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDBProxyEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyEndpointOutputError>
}

extension DeleteDBProxyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBProxyEndpointInput(dBProxyEndpointName: \(Swift.String(describing: dBProxyEndpointName)))"}
}

extension DeleteDBProxyEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        try container.encode("DeleteDBProxyEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBProxyEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyEndpointOutputError>
}

public struct DeleteDBProxyEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyEndpointOutputError>
}

public struct DeleteDBProxyEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBProxyEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBProxyEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyEndpointOutputError>
}

public struct DeleteDBProxyEndpointInput: Swift.Equatable {
    /// The name of the DB proxy endpoint to delete.
    /// This member is required.
    public var dBProxyEndpointName: Swift.String?

    public init (
        dBProxyEndpointName: Swift.String? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
    }
}

extension DeleteDBProxyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBProxyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyEndpointStateFault" : self = .invalidDBProxyEndpointStateFault(try InvalidDBProxyEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBProxyEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case invalidDBProxyEndpointStateFault(InvalidDBProxyEndpointStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBProxyEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBProxyEndpointOutputResponse(dBProxyEndpoint: \(Swift.String(describing: dBProxyEndpoint)))"}
}

extension DeleteDBProxyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct DeleteDBProxyEndpointOutputResponse: Swift.Equatable {
    /// The data structure representing the details of the DB proxy endpoint that you delete.
    public var dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?

    public init (
        dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct DeleteDBProxyEndpointOutputResponseBody: Swift.Equatable {
    public let dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?
}

extension DeleteDBProxyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

public struct DeleteDBProxyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyOutputError>
}

extension DeleteDBProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBProxyInput(dBProxyName: \(Swift.String(describing: dBProxyName)))"}
}

extension DeleteDBProxyInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        try container.encode("DeleteDBProxy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBProxyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyOutputError>
}

public struct DeleteDBProxyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyOutputError>
}

public struct DeleteDBProxyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBProxyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBProxyOutputError>
}

public struct DeleteDBProxyInput: Swift.Equatable {
    /// The name of the DB proxy to delete.
    /// This member is required.
    public var dBProxyName: Swift.String?

    public init (
        dBProxyName: Swift.String? = nil
    )
    {
        self.dBProxyName = dBProxyName
    }
}

extension DeleteDBProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBProxyOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBProxyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBProxyOutputResponse(dBProxy: \(Swift.String(describing: dBProxy)))"}
}

extension DeleteDBProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct DeleteDBProxyOutputResponse: Swift.Equatable {
    /// The data structure representing the details of the DB proxy that you delete.
    public var dBProxy: RdsClientTypes.DBProxy?

    public init (
        dBProxy: RdsClientTypes.DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct DeleteDBProxyOutputResponseBody: Swift.Equatable {
    public let dBProxy: RdsClientTypes.DBProxy?
}

extension DeleteDBProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

public struct DeleteDBSecurityGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSecurityGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSecurityGroupOutputError>
}

extension DeleteDBSecurityGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSecurityGroupInput(dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)))"}
}

extension DeleteDBSecurityGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        try container.encode("DeleteDBSecurityGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBSecurityGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSecurityGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSecurityGroupOutputError>
}

public struct DeleteDBSecurityGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSecurityGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSecurityGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSecurityGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSecurityGroupOutputError>
}

public struct DeleteDBSecurityGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSecurityGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBSecurityGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBSecurityGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSecurityGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSecurityGroupOutputError>
}

///
public struct DeleteDBSecurityGroupInput: Swift.Equatable {
    /// The name of the DB security group to delete.
    ///
    ///             You can't delete the default DB security group.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///                Must not be "Default"
    ///
    ///
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?

    public init (
        dBSecurityGroupName: Swift.String? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
    }
}

extension DeleteDBSecurityGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSecurityGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSecurityGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSecurityGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSecurityGroupOutputResponse()"}
}

extension DeleteDBSecurityGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSecurityGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBSecurityGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBSecurityGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDBSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSnapshotOutputError>
}

extension DeleteDBSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSnapshotInput(dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)))"}
}

extension DeleteDBSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        try container.encode("DeleteDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSnapshotOutputError>
}

public struct DeleteDBSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSnapshotOutputError>
}

public struct DeleteDBSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSnapshotOutputError>
}

///
public struct DeleteDBSnapshotInput: Swift.Equatable {
    /// The DB snapshot identifier.
    ///          Constraints: Must be the name of an existing DB snapshot in the available state.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?

    public init (
        dBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension DeleteDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSnapshotOutputResponse(dBSnapshot: \(Swift.String(describing: dBSnapshot)))"}
}

extension DeleteDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct DeleteDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSnapshots action.
    ///
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct DeleteDBSnapshotOutputResponseBody: Swift.Equatable {
    public let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension DeleteDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct DeleteDBSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

extension DeleteDBSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSubnetGroupInput(dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)))"}
}

extension DeleteDBSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        try container.encode("DeleteDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteDBSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

public struct DeleteDBSubnetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDBSubnetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDBSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDBSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDBSubnetGroupOutputError>
}

///
public struct DeleteDBSubnetGroupInput: Swift.Equatable {
    /// The name of the database subnet group to delete.
    ///
    ///             You can't delete the default subnet group.
    ///
    ///          Constraints:
    ///          Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.
    ///          Example: mySubnetgroup
    ///
    /// This member is required.
    public var dBSubnetGroupName: Swift.String?

    public init (
        dBSubnetGroupName: Swift.String? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
    }
}

extension DeleteDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetStateFault" : self = .invalidDBSubnetStateFault(try InvalidDBSubnetStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidDBSubnetStateFault(InvalidDBSubnetStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDBSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDBSubnetGroupOutputResponse()"}
}

extension DeleteDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDBSubnetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDBSubnetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDBSubnetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

extension DeleteEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionInput(subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DeleteEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DeleteEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

public struct DeleteEventSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventSubscriptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteEventSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventSubscriptionOutputError>
}

///
public struct DeleteEventSubscriptionInput: Swift.Equatable {
    /// The name of the RDS event notification subscription you want to delete.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        subscriptionName: Swift.String? = nil
    )
    {
        self.subscriptionName = subscriptionName
    }
}

extension DeleteEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidEventSubscriptionState" : self = .invalidEventSubscriptionStateFault(try InvalidEventSubscriptionStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidEventSubscriptionStateFault(InvalidEventSubscriptionStateFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension DeleteEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct DeleteEventSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct DeleteEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RdsClientTypes.EventSubscription?
}

extension DeleteEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct DeleteGlobalClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalClusterOutputError>
}

extension DeleteGlobalClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGlobalClusterInput(globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)))"}
}

extension DeleteGlobalClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        try container.encode("DeleteGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteGlobalClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalClusterOutputError>
}

public struct DeleteGlobalClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalClusterOutputError>
}

public struct DeleteGlobalClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGlobalClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteGlobalClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGlobalClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGlobalClusterOutputError>
}

public struct DeleteGlobalClusterInput: Swift.Equatable {
    ///
    ///         The cluster identifier of the global database cluster being deleted.
    ///
    /// This member is required.
    public var globalClusterIdentifier: Swift.String?

    public init (
        globalClusterIdentifier: Swift.String? = nil
    )
    {
        self.globalClusterIdentifier = globalClusterIdentifier
    }
}

extension DeleteGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGlobalClusterOutputResponse(globalCluster: \(Swift.String(describing: globalCluster)))"}
}

extension DeleteGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct DeleteGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct DeleteGlobalClusterOutputResponseBody: Swift.Equatable {
    public let globalCluster: RdsClientTypes.GlobalCluster?
}

extension DeleteGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct DeleteInstallationMediaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstallationMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstallationMediaOutputError>
}

extension DeleteInstallationMediaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInstallationMediaInput(installationMediaId: \(Swift.String(describing: installationMediaId)))"}
}

extension DeleteInstallationMediaInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: ClientRuntime.Key("InstallationMediaId"))
        }
        try container.encode("DeleteInstallationMedia", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteInstallationMediaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstallationMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstallationMediaOutputError>
}

public struct DeleteInstallationMediaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstallationMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstallationMediaOutputError>
}

public struct DeleteInstallationMediaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInstallationMediaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteInstallationMediaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInstallationMediaInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInstallationMediaOutputError>
}

public struct DeleteInstallationMediaInput: Swift.Equatable {
    /// The installation medium ID.
    /// This member is required.
    public var installationMediaId: Swift.String?

    public init (
        installationMediaId: Swift.String? = nil
    )
    {
        self.installationMediaId = installationMediaId
    }
}

extension DeleteInstallationMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteInstallationMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstallationMediaNotFound" : self = .installationMediaNotFoundFault(try InstallationMediaNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInstallationMediaOutputError: Swift.Error, Swift.Equatable {
    case installationMediaNotFoundFault(InstallationMediaNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInstallationMediaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInstallationMediaOutputResponse(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)), engine: \(Swift.String(describing: engine)), engineInstallationMediaPath: \(Swift.String(describing: engineInstallationMediaPath)), engineVersion: \(Swift.String(describing: engineVersion)), failureCause: \(Swift.String(describing: failureCause)), installationMediaId: \(Swift.String(describing: installationMediaId)), oSInstallationMediaPath: \(Swift.String(describing: oSInstallationMediaPath)), status: \(Swift.String(describing: status)))"}
}

extension DeleteInstallationMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZoneId = output.customAvailabilityZoneId
            self.engine = output.engine
            self.engineInstallationMediaPath = output.engineInstallationMediaPath
            self.engineVersion = output.engineVersion
            self.failureCause = output.failureCause
            self.installationMediaId = output.installationMediaId
            self.oSInstallationMediaPath = output.oSInstallationMediaPath
            self.status = output.status
        } else {
            self.customAvailabilityZoneId = nil
            self.engine = nil
            self.engineInstallationMediaPath = nil
            self.engineVersion = nil
            self.failureCause = nil
            self.installationMediaId = nil
            self.oSInstallationMediaPath = nil
            self.status = nil
        }
    }
}

/// Contains the installation media for a DB engine that requires an on-premises
///           customer provided license, such as Microsoft SQL Server.
public struct DeleteInstallationMediaOutputResponse: Swift.Equatable {
    /// The custom Availability Zone (AZ) that contains the installation media.
    public var customAvailabilityZoneId: Swift.String?
    /// The DB engine.
    public var engine: Swift.String?
    /// The path to the installation medium for the DB engine.
    public var engineInstallationMediaPath: Swift.String?
    /// The engine version of the DB engine.
    public var engineVersion: Swift.String?
    /// If an installation media failure occurred, the cause of the failure.
    public var failureCause: RdsClientTypes.InstallationMediaFailureCause?
    /// The installation medium ID.
    public var installationMediaId: Swift.String?
    /// The path to the installation medium for the operating system associated with the DB engine.
    public var oSInstallationMediaPath: Swift.String?
    /// The status of the installation medium.
    public var status: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineInstallationMediaPath: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        failureCause: RdsClientTypes.InstallationMediaFailureCause? = nil,
        installationMediaId: Swift.String? = nil,
        oSInstallationMediaPath: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

struct DeleteInstallationMediaOutputResponseBody: Swift.Equatable {
    public let installationMediaId: Swift.String?
    public let customAvailabilityZoneId: Swift.String?
    public let engine: Swift.String?
    public let engineVersion: Swift.String?
    public let engineInstallationMediaPath: Swift.String?
    public let oSInstallationMediaPath: Swift.String?
    public let status: Swift.String?
    public let failureCause: RdsClientTypes.InstallationMediaFailureCause?
}

extension DeleteInstallationMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DeleteInstallationMediaResult"))
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(RdsClientTypes.InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

public struct DeleteOptionGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOptionGroupOutputError>
}

extension DeleteOptionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOptionGroupInput(optionGroupName: \(Swift.String(describing: optionGroupName)))"}
}

extension DeleteOptionGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        try container.encode("DeleteOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeleteOptionGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOptionGroupOutputError>
}

public struct DeleteOptionGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOptionGroupOutputError>
}

public struct DeleteOptionGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOptionGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteOptionGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOptionGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOptionGroupOutputError>
}

///
public struct DeleteOptionGroupInput: Swift.Equatable {
    /// The name of the option group to be deleted.
    ///
    ///             You can't delete default option groups.
    ///
    /// This member is required.
    public var optionGroupName: Swift.String?

    public init (
        optionGroupName: Swift.String? = nil
    )
    {
        self.optionGroupName = optionGroupName
    }
}

extension DeleteOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidOptionGroupStateFault" : self = .invalidOptionGroupStateFault(try InvalidOptionGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidOptionGroupStateFault(InvalidOptionGroupStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOptionGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOptionGroupOutputResponse()"}
}

extension DeleteOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOptionGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOptionGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteOptionGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterDBProxyTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterDBProxyTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterDBProxyTargetsOutputError>
}

extension DeregisterDBProxyTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterDBProxyTargetsInput(dBClusterIdentifiers: \(Swift.String(describing: dBClusterIdentifiers)), dBInstanceIdentifiers: \(Swift.String(describing: dBInstanceIdentifiers)), dBProxyName: \(Swift.String(describing: dBProxyName)), targetGroupName: \(Swift.String(describing: targetGroupName)))"}
}

extension DeregisterDBProxyTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifiers = dBClusterIdentifiers {
            var dBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterIdentifiers"))
            for (index0, string0) in dBClusterIdentifiers.enumerated() {
                try dBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifiers = dBInstanceIdentifiers {
            var dBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceIdentifiers"))
            for (index0, string0) in dBInstanceIdentifiers.enumerated() {
                try dBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("DeregisterDBProxyTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DeregisterDBProxyTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterDBProxyTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterDBProxyTargetsOutputError>
}

public struct DeregisterDBProxyTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterDBProxyTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterDBProxyTargetsOutputError>
}

public struct DeregisterDBProxyTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterDBProxyTargetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeregisterDBProxyTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterDBProxyTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterDBProxyTargetsOutputError>
}

public struct DeregisterDBProxyTargetsInput: Swift.Equatable {
    /// One or more DB cluster identifiers.
    public var dBClusterIdentifiers: [Swift.String]?
    /// One or more DB instance identifiers.
    public var dBInstanceIdentifiers: [Swift.String]?
    /// The identifier of the DBProxy that is associated with the DBProxyTargetGroup.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// The identifier of the DBProxyTargetGroup.
    public var targetGroupName: Swift.String?

    public init (
        dBClusterIdentifiers: [Swift.String]? = nil,
        dBInstanceIdentifiers: [Swift.String]? = nil,
        dBProxyName: Swift.String? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBClusterIdentifiers = dBClusterIdentifiers
        self.dBInstanceIdentifiers = dBInstanceIdentifiers
        self.dBProxyName = dBProxyName
        self.targetGroupName = targetGroupName
    }
}

extension DeregisterDBProxyTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterDBProxyTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetNotFoundFault" : self = .dBProxyTargetNotFoundFault(try DBProxyTargetNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterDBProxyTargetsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBProxyTargetNotFoundFault(DBProxyTargetNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterDBProxyTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterDBProxyTargetsOutputResponse()"}
}

extension DeregisterDBProxyTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterDBProxyTargetsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterDBProxyTargetsOutputResponseBody: Swift.Equatable {
}

extension DeregisterDBProxyTargetsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAccountAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

extension DescribeAccountAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("DescribeAccountAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAccountAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAccountAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

///
public struct DescribeAccountAttributesInput: Swift.Equatable {

    public init() {}
}

extension DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesOutputResponse(accountQuotas: \(Swift.String(describing: accountQuotas)))"}
}

extension DescribeAccountAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountQuotas = output.accountQuotas
        } else {
            self.accountQuotas = nil
        }
    }
}

/// Data returned by the DescribeAccountAttributes action.
public struct DescribeAccountAttributesOutputResponse: Swift.Equatable {
    /// A list of AccountQuota objects. Within this list, each quota has a name,
    ///             a count of usage toward the quota maximum, and a maximum value for the quota.
    public var accountQuotas: [RdsClientTypes.AccountQuota]?

    public init (
        accountQuotas: [RdsClientTypes.AccountQuota]? = nil
    )
    {
        self.accountQuotas = accountQuotas
    }
}

struct DescribeAccountAttributesOutputResponseBody: Swift.Equatable {
    public let accountQuotas: [RdsClientTypes.AccountQuota]?
}

extension DescribeAccountAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountQuotas = "AccountQuotas"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeAccountAttributesResult"))
        if containerValues.contains(.accountQuotas) {
            struct KeyVal0{struct AccountQuota{}}
            let accountQuotasWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountQuota>.CodingKeys.self, forKey: .accountQuotas)
            if let accountQuotasWrappedContainer = accountQuotasWrappedContainer {
                let accountQuotasContainer = try accountQuotasWrappedContainer.decodeIfPresent([RdsClientTypes.AccountQuota].self, forKey: .member)
                var accountQuotasBuffer:[RdsClientTypes.AccountQuota]? = nil
                if let accountQuotasContainer = accountQuotasContainer {
                    accountQuotasBuffer = [RdsClientTypes.AccountQuota]()
                    for structureContainer0 in accountQuotasContainer {
                        accountQuotasBuffer?.append(structureContainer0)
                    }
                }
                accountQuotas = accountQuotasBuffer
            } else {
                accountQuotas = []
            }
        } else {
            accountQuotas = nil
        }
    }
}

public struct DescribeCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

extension DescribeCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificatesInput(certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: ClientRuntime.Key("CertificateIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

public struct DescribeCertificatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCertificatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCertificatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCertificatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCertificatesOutputError>
}

///
public struct DescribeCertificatesInput: Swift.Equatable {
    /// The user-supplied certificate identifier. If this parameter is specified, information for only the identified certificate is returned. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must match an existing CertificateIdentifier.
    ///
    ///
    public var certificateIdentifier: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeCertificates request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        certificateIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateNotFound" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCertificatesOutputError: Swift.Error, Swift.Equatable {
    case certificateNotFoundFault(CertificateNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCertificatesOutputResponse(certificates: \(Swift.String(describing: certificates)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificates = output.certificates
            self.marker = output.marker
        } else {
            self.certificates = nil
            self.marker = nil
        }
    }
}

/// Data returned by the DescribeCertificates action.
public struct DescribeCertificatesOutputResponse: Swift.Equatable {
    /// The list of Certificate objects for the Amazon Web Services account.
    public var certificates: [RdsClientTypes.Certificate]?
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribeCertificates request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?

    public init (
        certificates: [RdsClientTypes.Certificate]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.certificates = certificates
        self.marker = marker
    }
}

struct DescribeCertificatesOutputResponseBody: Swift.Equatable {
    public let certificates: [RdsClientTypes.Certificate]?
    public let marker: Swift.String?
}

extension DescribeCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificates = "Certificates"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct Certificate{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Certificate>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([RdsClientTypes.Certificate].self, forKey: .member)
                var certificatesBuffer:[RdsClientTypes.Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [RdsClientTypes.Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeCustomAvailabilityZonesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomAvailabilityZonesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomAvailabilityZonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomAvailabilityZonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomAvailabilityZonesOutputError>
}

extension DescribeCustomAvailabilityZonesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomAvailabilityZonesInput(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeCustomAvailabilityZonesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeCustomAvailabilityZones", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeCustomAvailabilityZonesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomAvailabilityZonesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomAvailabilityZonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomAvailabilityZonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomAvailabilityZonesOutputError>
}

public struct DescribeCustomAvailabilityZonesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomAvailabilityZonesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCustomAvailabilityZonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCustomAvailabilityZonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomAvailabilityZonesOutputError>
}

public struct DescribeCustomAvailabilityZonesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCustomAvailabilityZonesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCustomAvailabilityZonesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCustomAvailabilityZonesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCustomAvailabilityZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCustomAvailabilityZonesOutputError>
}

public struct DescribeCustomAvailabilityZonesInput: Swift.Equatable {
    /// The custom AZ identifier. If this parameter is specified, information from only the specific custom AZ is returned.
    public var customAvailabilityZoneId: Swift.String?
    /// A filter that specifies one or more custom AZs to describe.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous
    ///             DescribeCustomAvailabilityZones request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///         Default: 100
    ///         Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeCustomAvailabilityZonesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeCustomAvailabilityZonesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCustomAvailabilityZonesOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomAvailabilityZonesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCustomAvailabilityZonesOutputResponse(customAvailabilityZones: \(Swift.String(describing: customAvailabilityZones)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeCustomAvailabilityZonesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCustomAvailabilityZonesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZones = output.customAvailabilityZones
            self.marker = output.marker
        } else {
            self.customAvailabilityZones = nil
            self.marker = nil
        }
    }
}

public struct DescribeCustomAvailabilityZonesOutputResponse: Swift.Equatable {
    /// The list of CustomAvailabilityZone objects for the Amazon Web Services account.
    public var customAvailabilityZones: [RdsClientTypes.CustomAvailabilityZone]?
    /// An optional pagination token provided by a previous
    ///             DescribeCustomAvailabilityZones request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        customAvailabilityZones: [RdsClientTypes.CustomAvailabilityZone]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.customAvailabilityZones = customAvailabilityZones
        self.marker = marker
    }
}

struct DescribeCustomAvailabilityZonesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let customAvailabilityZones: [RdsClientTypes.CustomAvailabilityZone]?
}

extension DescribeCustomAvailabilityZonesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZones = "CustomAvailabilityZones"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeCustomAvailabilityZonesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.customAvailabilityZones) {
            struct KeyVal0{struct CustomAvailabilityZone{}}
            let customAvailabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomAvailabilityZone>.CodingKeys.self, forKey: .customAvailabilityZones)
            if let customAvailabilityZonesWrappedContainer = customAvailabilityZonesWrappedContainer {
                let customAvailabilityZonesContainer = try customAvailabilityZonesWrappedContainer.decodeIfPresent([RdsClientTypes.CustomAvailabilityZone].self, forKey: .member)
                var customAvailabilityZonesBuffer:[RdsClientTypes.CustomAvailabilityZone]? = nil
                if let customAvailabilityZonesContainer = customAvailabilityZonesContainer {
                    customAvailabilityZonesBuffer = [RdsClientTypes.CustomAvailabilityZone]()
                    for structureContainer0 in customAvailabilityZonesContainer {
                        customAvailabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                customAvailabilityZones = customAvailabilityZonesBuffer
            } else {
                customAvailabilityZones = []
            }
        } else {
            customAvailabilityZones = nil
        }
    }
}

public struct DescribeDBClusterBacktracksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterBacktracksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterBacktracksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterBacktracksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterBacktracksOutputError>
}

extension DescribeDBClusterBacktracksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterBacktracksInput(backtrackIdentifier: \(Swift.String(describing: backtrackIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClusterBacktracksInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackIdentifier = backtrackIdentifier {
            try container.encode(backtrackIdentifier, forKey: ClientRuntime.Key("BacktrackIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterBacktracks", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterBacktracksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterBacktracksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterBacktracksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterBacktracksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterBacktracksOutputError>
}

public struct DescribeDBClusterBacktracksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterBacktracksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterBacktracksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterBacktracksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterBacktracksOutputError>
}

public struct DescribeDBClusterBacktracksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterBacktracksInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClusterBacktracksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClusterBacktracksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterBacktracksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterBacktracksOutputError>
}

///
public struct DescribeDBClusterBacktracksInput: Swift.Equatable {
    /// If specified, this value is the backtrack identifier of the backtrack to be
    ///             described.
    ///         Constraints:
    ///
    ///
    ///                 Must contain a valid universally unique identifier (UUID). For more
    ///                     information about UUIDs, see <a href="http://www.ietf.org/rfc/rfc4122.txt">A Universally Unique Identifier
    ///                         (UUID) URN Namespace.
    ///
    ///
    ///         Example: 123e4567-e89b-12d3-a456-426655440000
    ///
    public var backtrackIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster to be described. This parameter is
    ///             stored as a lowercase string.
    ///         Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 alphanumeric characters or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///         Example: my-cluster1
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// A filter that specifies one or more DB clusters to describe. Supported filters
    ///             include the following:
    ///
    ///
    ///
    ///                     db-cluster-backtrack-id - Accepts backtrack identifiers. The
    ///                     results list includes information about only the backtracks identified by these
    ///                     identifiers.
    ///
    ///
    ///
    ///                   db-cluster-backtrack-status - Accepts any of the following backtrack status values:
    ///
    ///
    ///
    ///                         applying
    ///
    ///
    ///
    ///
    ///                         completed
    ///
    ///
    ///
    ///
    ///                         failed
    ///
    ///
    ///
    ///
    ///                         pending
    ///
    ///
    ///
    ///                 The results list includes information about only the backtracks identified
    ///                     by these values.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    ///  An optional pagination token provided by a previous
    ///             DescribeDBClusterBacktracks request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///         Default: 100
    ///         Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        backtrackIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.backtrackIdentifier = backtrackIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterBacktracksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterBacktracksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterBacktrackNotFoundFault" : self = .dBClusterBacktrackNotFoundFault(try DBClusterBacktrackNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterBacktracksOutputError: Swift.Error, Swift.Equatable {
    case dBClusterBacktrackNotFoundFault(DBClusterBacktrackNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterBacktracksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterBacktracksOutputResponse(dBClusterBacktracks: \(Swift.String(describing: dBClusterBacktracks)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterBacktracksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterBacktracksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterBacktracks = output.dBClusterBacktracks
            self.marker = output.marker
        } else {
            self.dBClusterBacktracks = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBClusterBacktracks action.
public struct DescribeDBClusterBacktracksOutputResponse: Swift.Equatable {
    /// Contains a list of backtracks for the user.
    public var dBClusterBacktracks: [RdsClientTypes.DBClusterBacktrack]?
    /// A pagination token that can be used in a later DescribeDBClusterBacktracks request.
    public var marker: Swift.String?

    public init (
        dBClusterBacktracks: [RdsClientTypes.DBClusterBacktrack]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterBacktracks = dBClusterBacktracks
        self.marker = marker
    }
}

struct DescribeDBClusterBacktracksOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterBacktracks: [RdsClientTypes.DBClusterBacktrack]?
}

extension DescribeDBClusterBacktracksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterBacktracks = "DBClusterBacktracks"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterBacktracksResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterBacktracks) {
            struct KeyVal0{struct DBClusterBacktrack{}}
            let dBClusterBacktracksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterBacktrack>.CodingKeys.self, forKey: .dBClusterBacktracks)
            if let dBClusterBacktracksWrappedContainer = dBClusterBacktracksWrappedContainer {
                let dBClusterBacktracksContainer = try dBClusterBacktracksWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterBacktrack].self, forKey: .member)
                var dBClusterBacktracksBuffer:[RdsClientTypes.DBClusterBacktrack]? = nil
                if let dBClusterBacktracksContainer = dBClusterBacktracksContainer {
                    dBClusterBacktracksBuffer = [RdsClientTypes.DBClusterBacktrack]()
                    for structureContainer0 in dBClusterBacktracksContainer {
                        dBClusterBacktracksBuffer?.append(structureContainer0)
                    }
                }
                dBClusterBacktracks = dBClusterBacktracksBuffer
            } else {
                dBClusterBacktracks = []
            }
        } else {
            dBClusterBacktracks = nil
        }
    }
}

public struct DescribeDBClusterEndpointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

extension DescribeDBClusterEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterEndpointsInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClusterEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterEndpoints", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterEndpointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClusterEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClusterEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterEndpointsOutputError>
}

public struct DescribeDBClusterEndpointsInput: Swift.Equatable {
    /// The identifier of the endpoint to describe. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// A set of name-value pairs that define which endpoints to include in the output.
    ///        The filters are specified as name-value pairs, in the format
    ///        Name=endpoint_type,Values=endpoint_type1,endpoint_type2,....
    ///        Name can be one of: db-cluster-endpoint-type, db-cluster-endpoint-custom-type, db-cluster-endpoint-id, db-cluster-endpoint-status.
    ///          Values for the  db-cluster-endpoint-type filter can be one or more of: reader, writer, custom.
    ///        Values for the db-cluster-endpoint-custom-type filter can be one or more of: reader, any.
    ///        Values for the db-cluster-endpoint-status filter can be one or more of: available, creating, deleting, inactive, modifying.
    ///
    public var filters: [RdsClientTypes.Filter]?
    ///  An optional pagination token provided by a previous
    ///             DescribeDBClusterEndpoints request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///         Default: 100
    ///         Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterEndpointsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterEndpointsOutputResponse(dBClusterEndpoints: \(Swift.String(describing: dBClusterEndpoints)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterEndpoints = output.dBClusterEndpoints
            self.marker = output.marker
        } else {
            self.dBClusterEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBClusterEndpointsOutputResponse: Swift.Equatable {
    /// Contains the details of the endpoints associated with the cluster
    ///        and matching any filter conditions.
    public var dBClusterEndpoints: [RdsClientTypes.DBClusterEndpoint]?
    ///  An optional pagination token provided by a previous
    ///             DescribeDBClusterEndpoints request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBClusterEndpoints: [RdsClientTypes.DBClusterEndpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterEndpoints = dBClusterEndpoints
        self.marker = marker
    }
}

struct DescribeDBClusterEndpointsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterEndpoints: [RdsClientTypes.DBClusterEndpoint]?
}

extension DescribeDBClusterEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterEndpoints = "DBClusterEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterEndpointsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterEndpoints) {
            struct KeyVal0{struct DBClusterEndpointList{}}
            let dBClusterEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterEndpointList>.CodingKeys.self, forKey: .dBClusterEndpoints)
            if let dBClusterEndpointsWrappedContainer = dBClusterEndpointsWrappedContainer {
                let dBClusterEndpointsContainer = try dBClusterEndpointsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterEndpoint].self, forKey: .member)
                var dBClusterEndpointsBuffer:[RdsClientTypes.DBClusterEndpoint]? = nil
                if let dBClusterEndpointsContainer = dBClusterEndpointsContainer {
                    dBClusterEndpointsBuffer = [RdsClientTypes.DBClusterEndpoint]()
                    for structureContainer0 in dBClusterEndpointsContainer {
                        dBClusterEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterEndpoints = dBClusterEndpointsBuffer
            } else {
                dBClusterEndpoints = []
            }
        } else {
            dBClusterEndpoints = nil
        }
    }
}

public struct DescribeDBClusterParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

extension DescribeDBClusterParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParameterGroupsInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClusterParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusterParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

public struct DescribeDBClusterParameterGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParameterGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClusterParameterGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClusterParameterGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParameterGroupsOutputError>
}

///
public struct DescribeDBClusterParameterGroupsInput: Swift.Equatable {
    /// The name of a specific DB cluster parameter group to return details for.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DBClusterParameterGroup.
    ///
    ///
    public var dBClusterParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeDBClusterParameterGroups request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClusterParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParameterGroupsOutputResponse(dBClusterParameterGroups: \(Swift.String(describing: dBClusterParameterGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroups = output.dBClusterParameterGroups
            self.marker = output.marker
        } else {
            self.dBClusterParameterGroups = nil
            self.marker = nil
        }
    }
}

///
public struct DescribeDBClusterParameterGroupsOutputResponse: Swift.Equatable {
    /// A list of DB cluster parameter groups.
    public var dBClusterParameterGroups: [RdsClientTypes.DBClusterParameterGroup]?
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribeDBClusterParameterGroups request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBClusterParameterGroups: [RdsClientTypes.DBClusterParameterGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroups = dBClusterParameterGroups
        self.marker = marker
    }
}

struct DescribeDBClusterParameterGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterParameterGroups: [RdsClientTypes.DBClusterParameterGroup]?
}

extension DescribeDBClusterParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroups = "DBClusterParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterParameterGroups) {
            struct KeyVal0{struct DBClusterParameterGroup{}}
            let dBClusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterParameterGroup>.CodingKeys.self, forKey: .dBClusterParameterGroups)
            if let dBClusterParameterGroupsWrappedContainer = dBClusterParameterGroupsWrappedContainer {
                let dBClusterParameterGroupsContainer = try dBClusterParameterGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterParameterGroup].self, forKey: .member)
                var dBClusterParameterGroupsBuffer:[RdsClientTypes.DBClusterParameterGroup]? = nil
                if let dBClusterParameterGroupsContainer = dBClusterParameterGroupsContainer {
                    dBClusterParameterGroupsBuffer = [RdsClientTypes.DBClusterParameterGroup]()
                    for structureContainer0 in dBClusterParameterGroupsContainer {
                        dBClusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterParameterGroups = dBClusterParameterGroupsBuffer
            } else {
                dBClusterParameterGroups = []
            }
        } else {
            dBClusterParameterGroups = nil
        }
    }
}

public struct DescribeDBClusterParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

extension DescribeDBClusterParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParametersInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), source: \(Swift.String(describing: source)))"}
}

extension DescribeDBClusterParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeDBClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

public struct DescribeDBClusterParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClusterParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClusterParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterParametersOutputError>
}

///
public struct DescribeDBClusterParametersInput: Swift.Equatable {
    /// The name of a specific DB cluster parameter group to return parameter details for.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DBClusterParameterGroup.
    ///
    ///
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///       An optional pagination token provided by a previous
    ///       DescribeDBClusterParameters request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///       The maximum number of records to include in the response.
    ///       If more records exist than the specified MaxRecords value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    ///
    ///       A value that indicates to return only parameters for a specific source.
    ///       Parameter sources can be engine, service,
    ///       or customer.
    ///
    public var source: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        source: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterParametersOutputResponse(marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeDBClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

/// Provides details about a DB cluster parameter group including the parameters in the DB cluster parameter group.
public struct DescribeDBClusterParametersOutputResponse: Swift.Equatable {
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribeDBClusterParameters request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?
    /// Provides a list of parameters for the DB cluster parameter group.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBClusterParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [RdsClientTypes.Parameter]?
    public let marker: Swift.String?
}

extension DescribeDBClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBClusterSnapshotAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

extension DescribeDBClusterSnapshotAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotAttributesInput(dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)))"}
}

extension DescribeDBClusterSnapshotAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        try container.encode("DescribeDBClusterSnapshotAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

public struct DescribeDBClusterSnapshotAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotAttributesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClusterSnapshotAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClusterSnapshotAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotAttributesOutputError>
}

///
public struct DescribeDBClusterSnapshotAttributesInput: Swift.Equatable {
    /// The identifier for the DB cluster snapshot to describe the attributes for.
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?

    public init (
        dBClusterSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotAttributesOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotAttributesOutputResponse(dBClusterSnapshotAttributesResult: \(Swift.String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension DescribeDBClusterSnapshotAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBClusterSnapshotAttributesOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBClusterSnapshotAttributes
    ///             API action.
    ///         Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts
    ///             to copy or restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute
    ///             API action.
    public var dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct DescribeDBClusterSnapshotAttributesOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?
}

extension DescribeDBClusterSnapshotAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterSnapshotAttributesResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct DescribeDBClusterSnapshotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

extension DescribeDBClusterSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotsInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), filters: \(Swift.String(describing: filters)), includePublic: \(Swift.String(describing: includePublic)), includeShared: \(Swift.String(describing: includeShared)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), snapshotType: \(Swift.String(describing: snapshotType)))"}
}

extension DescribeDBClusterSnapshotsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: ClientRuntime.Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        try container.encode("DescribeDBClusterSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClusterSnapshotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClusterSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

public struct DescribeDBClusterSnapshotsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClusterSnapshotsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClusterSnapshotsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClusterSnapshotsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClusterSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClusterSnapshotsOutputError>
}

///
public struct DescribeDBClusterSnapshotsInput: Swift.Equatable {
    /// The ID of the DB cluster to retrieve the list of DB cluster snapshots for.
    ///             This parameter can't be used in conjunction with the
    ///             DBClusterSnapshotIdentifier parameter.
    ///             This parameter isn't case-sensitive.
    ///
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the identifier of an existing DBCluster.
    ///
    ///
    public var dBClusterIdentifier: Swift.String?
    /// A specific DB cluster snapshot identifier to describe.
    ///             This parameter can't be used in conjunction with the
    ///             DBClusterIdentifier parameter.
    ///             This value is stored as a lowercase string.
    ///
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the identifier of an existing DBClusterSnapshot.
    ///
    ///
    ///                If this identifier is for an automated snapshot, the SnapshotType parameter must also be specified.
    ///
    ///
    public var dBClusterSnapshotIdentifier: Swift.String?
    /// A filter that specifies one or more DB cluster snapshots to describe.
    ///          Supported filters:
    ///
    ///
    ///
    ///                   db-cluster-id - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs).
    ///
    ///
    ///
    ///                   db-cluster-snapshot-id - Accepts DB cluster snapshot identifiers.
    ///
    ///
    ///
    ///                   snapshot-type - Accepts types of DB cluster snapshots.
    ///
    ///
    ///
    ///                   engine - Accepts names of database engines.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    /// A value that indicates whether to include manual DB cluster snapshots that are public and can be copied
    ///             or restored by any Amazon Web Services account. By default, the public snapshots are not included.
    ///         You can share a manual DB cluster snapshot  as public by using the ModifyDBClusterSnapshotAttribute API action.
    public var includePublic: Swift.Bool
    /// A value that indicates whether to include shared manual DB cluster snapshots
    ///             from other Amazon Web Services accounts that this Amazon Web Services account has been given
    ///             permission to copy or restore. By default, these snapshots are not included.
    ///         You can give an Amazon Web Services account permission to restore a manual DB cluster snapshot from
    ///             another Amazon Web Services account by the ModifyDBClusterSnapshotAttribute API action.
    public var includeShared: Swift.Bool
    /// An optional pagination token provided by a previous
    ///             DescribeDBClusterSnapshots request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The type of DB cluster snapshots to be returned. You can specify one of the following values:
    ///
    ///
    ///
    ///                   automated - Return all DB cluster snapshots that have been automatically taken by
    ///               Amazon RDS for my Amazon Web Services account.
    ///
    ///
    ///
    ///                   manual - Return all DB cluster snapshots that have been taken by my Amazon Web Services account.
    ///
    ///
    ///
    ///                   shared - Return all manual DB cluster snapshots that have been shared to my Amazon Web Services account.
    ///
    ///
    ///
    ///                   public - Return all DB cluster snapshots that have been marked as public.
    ///
    ///
    ///          If you don't specify a SnapshotType value, then both automated and manual DB cluster snapshots are
    ///           returned. You can include shared DB cluster snapshots with these results by enabling the IncludeShared
    ///           parameter. You can include public DB cluster snapshots with these results by enabling the
    ///           IncludePublic parameter.
    ///          The IncludeShared and IncludePublic parameters don't apply for SnapshotType values
    ///           of manual or automated. The IncludePublic parameter doesn't apply when SnapshotType is
    ///           set to shared. The IncludeShared parameter doesn't apply when SnapshotType is set to
    ///           public.
    public var snapshotType: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includePublic: Swift.Bool = false,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        snapshotType: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

extension DescribeDBClusterSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClusterSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClusterSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClusterSnapshotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClusterSnapshotsOutputResponse(dBClusterSnapshots: \(Swift.String(describing: dBClusterSnapshots)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClusterSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClusterSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshots = output.dBClusterSnapshots
            self.marker = output.marker
        } else {
            self.dBClusterSnapshots = nil
            self.marker = nil
        }
    }
}

///
///           Provides a list of DB cluster snapshots for the user as the result of a call to the DescribeDBClusterSnapshots action.
///
public struct DescribeDBClusterSnapshotsOutputResponse: Swift.Equatable {
    /// Provides a list of DB cluster snapshots for the user.
    public var dBClusterSnapshots: [RdsClientTypes.DBClusterSnapshot]?
    ///
    ///       An optional pagination token provided by a previous
    ///           DescribeDBClusterSnapshots request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBClusterSnapshots: [RdsClientTypes.DBClusterSnapshot]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusterSnapshots = dBClusterSnapshots
        self.marker = marker
    }
}

struct DescribeDBClusterSnapshotsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusterSnapshots: [RdsClientTypes.DBClusterSnapshot]?
}

extension DescribeDBClusterSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshots = "DBClusterSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClusterSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusterSnapshots) {
            struct KeyVal0{struct DBClusterSnapshot{}}
            let dBClusterSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterSnapshot>.CodingKeys.self, forKey: .dBClusterSnapshots)
            if let dBClusterSnapshotsWrappedContainer = dBClusterSnapshotsWrappedContainer {
                let dBClusterSnapshotsContainer = try dBClusterSnapshotsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterSnapshot].self, forKey: .member)
                var dBClusterSnapshotsBuffer:[RdsClientTypes.DBClusterSnapshot]? = nil
                if let dBClusterSnapshotsContainer = dBClusterSnapshotsContainer {
                    dBClusterSnapshotsBuffer = [RdsClientTypes.DBClusterSnapshot]()
                    for structureContainer0 in dBClusterSnapshotsContainer {
                        dBClusterSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterSnapshots = dBClusterSnapshotsBuffer
            } else {
                dBClusterSnapshots = []
            }
        } else {
            dBClusterSnapshots = nil
        }
    }
}

public struct DescribeDBClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

extension DescribeDBClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClustersInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), filters: \(Swift.String(describing: filters)), includeShared: \(Swift.String(describing: includeShared)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBClusters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

public struct DescribeDBClustersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBClustersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBClustersOutputError>
}

///
public struct DescribeDBClustersInput: Swift.Equatable {
    /// The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match an existing DBClusterIdentifier.
    ///
    ///
    public var dBClusterIdentifier: Swift.String?
    /// A filter that specifies one or more DB clusters to describe.
    ///          Supported filters:
    ///
    ///
    ///
    ///                   clone-group-id - Accepts clone group identifiers.
    /// 			  The results list will only include information about
    ///               the DB clusters associated with these clone groups.
    ///
    ///
    ///
    ///                   db-cluster-id - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB clusters identified by these ARNs.
    ///
    ///
    ///
    ///                   domain - Accepts Active Directory directory IDs.
    ///               The results list will only include information about
    ///               the DB clusters associated with these domains.
    ///
    ///
    ///
    ///                   engine - Accepts engine names.
    ///               The results list will only include information about
    ///               the DB clusters for these engines.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    /// Optional Boolean parameter that specifies whether the output includes information about clusters
    ///           shared from other Amazon Web Services accounts.
    public var includeShared: Swift.Bool
    /// An optional pagination token provided by a previous
    ///             DescribeDBClusters request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.filters = filters
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBClustersOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBClustersOutputResponse(dBClusters: \(Swift.String(describing: dBClusters)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusters = output.dBClusters
            self.marker = output.marker
        } else {
            self.dBClusters = nil
            self.marker = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeDBClusters action.
public struct DescribeDBClustersOutputResponse: Swift.Equatable {
    /// Contains a list of DB clusters for the user.
    public var dBClusters: [RdsClientTypes.DBCluster]?
    /// A pagination token that can be used in a later DescribeDBClusters request.
    public var marker: Swift.String?

    public init (
        dBClusters: [RdsClientTypes.DBCluster]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBClusters = dBClusters
        self.marker = marker
    }
}

struct DescribeDBClustersOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBClusters: [RdsClientTypes.DBCluster]?
}

extension DescribeDBClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusters = "DBClusters"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBClusters) {
            struct KeyVal0{struct DBCluster{}}
            let dBClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBCluster>.CodingKeys.self, forKey: .dBClusters)
            if let dBClustersWrappedContainer = dBClustersWrappedContainer {
                let dBClustersContainer = try dBClustersWrappedContainer.decodeIfPresent([RdsClientTypes.DBCluster].self, forKey: .member)
                var dBClustersBuffer:[RdsClientTypes.DBCluster]? = nil
                if let dBClustersContainer = dBClustersContainer {
                    dBClustersBuffer = [RdsClientTypes.DBCluster]()
                    for structureContainer0 in dBClustersContainer {
                        dBClustersBuffer?.append(structureContainer0)
                    }
                }
                dBClusters = dBClustersBuffer
            } else {
                dBClusters = []
            }
        } else {
            dBClusters = nil
        }
    }
}

public struct DescribeDBEngineVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

extension DescribeDBEngineVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBEngineVersionsInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), defaultOnly: \(Swift.String(describing: defaultOnly)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), filters: \(Swift.String(describing: filters)), includeAll: \(Swift.String(describing: includeAll)), listSupportedCharacterSets: \(Swift.String(describing: listSupportedCharacterSets)), listSupportedTimezones: \(Swift.String(describing: listSupportedTimezones)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBEngineVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if defaultOnly != false {
            try container.encode(defaultOnly, forKey: ClientRuntime.Key("DefaultOnly"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let includeAll = includeAll {
            try container.encode(includeAll, forKey: ClientRuntime.Key("IncludeAll"))
        }
        if let listSupportedCharacterSets = listSupportedCharacterSets {
            try container.encode(listSupportedCharacterSets, forKey: ClientRuntime.Key("ListSupportedCharacterSets"))
        }
        if let listSupportedTimezones = listSupportedTimezones {
            try container.encode(listSupportedTimezones, forKey: ClientRuntime.Key("ListSupportedTimezones"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBEngineVersions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBEngineVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBEngineVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBEngineVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBEngineVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBEngineVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBEngineVersionsOutputError>
}

public struct DescribeDBEngineVersionsInput: Swift.Equatable {
    /// The name of a specific DB parameter group family to return details for.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match an existing DBParameterGroupFamily.
    ///
    ///
    public var dBParameterGroupFamily: Swift.String?
    /// A value that indicates whether only the default version of the specified engine or engine and major version combination is returned.
    public var defaultOnly: Swift.Bool
    /// The database engine to return.
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   aurora (for MySQL 5.6-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-postgresql
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    public var engine: Swift.String?
    /// The database engine version to return.
    ///          Example: 5.1.49
    ///
    public var engineVersion: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// A value that indicates whether to include engine versions that aren't available in the list. The default is to list only available engine versions.
    public var includeAll: Swift.Bool?
    /// A value that indicates whether to list the supported character sets for each engine version.
    ///          If this parameter is enabled and the requested engine supports the CharacterSetName parameter for CreateDBInstance,
    ///           the response includes a list of supported character sets for each engine version.
    ///
    public var listSupportedCharacterSets: Swift.Bool?
    /// A value that indicates whether to list the supported time zones for each engine version.
    ///         If this parameter is enabled and the requested engine supports the TimeZone parameter for CreateDBInstance,
    ///             the response includes a list of supported time zones for each engine version.
    ///
    public var listSupportedTimezones: Swift.Bool?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///     The maximum number of records to include in the response.
    ///     If more than the MaxRecords value is available, a pagination token called a marker is
    ///     included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        defaultOnly: Swift.Bool = false,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includeAll: Swift.Bool? = nil,
        listSupportedCharacterSets: Swift.Bool? = nil,
        listSupportedTimezones: Swift.Bool? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.defaultOnly = defaultOnly
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.includeAll = includeAll
        self.listSupportedCharacterSets = listSupportedCharacterSets
        self.listSupportedTimezones = listSupportedTimezones
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBEngineVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBEngineVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBEngineVersionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBEngineVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBEngineVersionsOutputResponse(dBEngineVersions: \(Swift.String(describing: dBEngineVersions)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBEngineVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBEngineVersions = output.dBEngineVersions
            self.marker = output.marker
        } else {
            self.dBEngineVersions = nil
            self.marker = nil
        }
    }
}

///
///             Contains the result of a successful invocation of the DescribeDBEngineVersions action.
///
public struct DescribeDBEngineVersionsOutputResponse: Swift.Equatable {
    ///
    ///             A list of DBEngineVersion elements.
    ///
    public var dBEngineVersions: [RdsClientTypes.DBEngineVersion]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBEngineVersions: [RdsClientTypes.DBEngineVersion]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBEngineVersions = dBEngineVersions
        self.marker = marker
    }
}

struct DescribeDBEngineVersionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBEngineVersions: [RdsClientTypes.DBEngineVersion]?
}

extension DescribeDBEngineVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBEngineVersions = "DBEngineVersions"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBEngineVersionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBEngineVersions) {
            struct KeyVal0{struct DBEngineVersion{}}
            let dBEngineVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBEngineVersion>.CodingKeys.self, forKey: .dBEngineVersions)
            if let dBEngineVersionsWrappedContainer = dBEngineVersionsWrappedContainer {
                let dBEngineVersionsContainer = try dBEngineVersionsWrappedContainer.decodeIfPresent([RdsClientTypes.DBEngineVersion].self, forKey: .member)
                var dBEngineVersionsBuffer:[RdsClientTypes.DBEngineVersion]? = nil
                if let dBEngineVersionsContainer = dBEngineVersionsContainer {
                    dBEngineVersionsBuffer = [RdsClientTypes.DBEngineVersion]()
                    for structureContainer0 in dBEngineVersionsContainer {
                        dBEngineVersionsBuffer?.append(structureContainer0)
                    }
                }
                dBEngineVersions = dBEngineVersionsBuffer
            } else {
                dBEngineVersions = []
            }
        } else {
            dBEngineVersions = nil
        }
    }
}

public struct DescribeDBInstanceAutomatedBackupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstanceAutomatedBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

extension DescribeDBInstanceAutomatedBackupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBInstanceAutomatedBackupsInput(dBInstanceAutomatedBackupsArn: \(Swift.String(describing: dBInstanceAutomatedBackupsArn)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dbiResourceId: \(Swift.String(describing: dbiResourceId)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBInstanceAutomatedBackupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn {
            try container.encode(dBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("DBInstanceAutomatedBackupsArn"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstanceAutomatedBackups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBInstanceAutomatedBackupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstanceAutomatedBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

public struct DescribeDBInstanceAutomatedBackupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstanceAutomatedBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstanceAutomatedBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

public struct DescribeDBInstanceAutomatedBackupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstanceAutomatedBackupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBInstanceAutomatedBackupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBInstanceAutomatedBackupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstanceAutomatedBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstanceAutomatedBackupsOutputError>
}

/// Parameter input for DescribeDBInstanceAutomatedBackups.
public struct DescribeDBInstanceAutomatedBackupsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the replicated automated backups, for example,
    ///             arn:aws:rds:us-east-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE.
    public var dBInstanceAutomatedBackupsArn: Swift.String?
    /// (Optional) The user-supplied instance identifier. If this parameter is specified, it must
    ///             match the identifier of an existing DB instance. It returns information from the
    ///             specific DB instance' automated backup. This parameter isn't case-sensitive.
    public var dBInstanceIdentifier: Swift.String?
    /// The resource ID of the DB instance that is the source of
    /// 		    the automated backup. This parameter isn't case-sensitive.
    public var dbiResourceId: Swift.String?
    /// A filter that specifies which resources to return based on status.
    /// 		       Supported filters are the following:
    /// 		
    ///
    /// 				
    /// 					             status
    /// 				
    /// 			
    ///
    ///
    ///                         active - automated backups for current instances
    ///
    ///
    ///
    ///                         retained - automated backups for deleted instances and after backup replication is stopped
    ///
    ///
    ///
    ///                         creating - automated backups that are waiting for the first automated snapshot to be available
    ///
    ///
    /// 			
    ///
    ///
    /// 		                db-instance-id - Accepts DB instance identifiers and Amazon Resource Names (ARNs).
    /// 		        The results list includes only information about the DB instance automated backups identified by these ARNs.
    /// 		
    ///
    ///
    /// 		                dbi-resource-id - Accepts DB resource identifiers and Amazon Resource Names (ARNs).
    /// 		        The results list includes only information about the DB instance resources identified by these ARNs.
    /// 		
    ///
    /// 		       Returns all resources by default. The status for each resource is specified in the response.
    public var filters: [RdsClientTypes.Filter]?
    /// The pagination token provided in the previous request. If this parameter is specified the response
    /// 			includes only records beyond the marker, up to MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified
    /// 			MaxRecords value, a pagination token called a marker is included in the response so that
    /// 			you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init (
        dBInstanceAutomatedBackupsArn: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dbiResourceId: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceAutomatedBackupsArn = dBInstanceAutomatedBackupsArn
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dbiResourceId = dbiResourceId
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBInstanceAutomatedBackupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstanceAutomatedBackupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupNotFound" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstanceAutomatedBackupsOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstanceAutomatedBackupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBInstanceAutomatedBackupsOutputResponse(dBInstanceAutomatedBackups: \(Swift.String(describing: dBInstanceAutomatedBackups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBInstanceAutomatedBackupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBInstanceAutomatedBackupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackups = output.dBInstanceAutomatedBackups
            self.marker = output.marker
        } else {
            self.dBInstanceAutomatedBackups = nil
            self.marker = nil
        }
    }
}

///
///             Contains the result of a successful invocation of the DescribeDBInstanceAutomatedBackups action.
///
public struct DescribeDBInstanceAutomatedBackupsOutputResponse: Swift.Equatable {
    ///
    ///             A list of DBInstanceAutomatedBackup instances.
    ///
    public var dBInstanceAutomatedBackups: [RdsClientTypes.DBInstanceAutomatedBackup]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?

    public init (
        dBInstanceAutomatedBackups: [RdsClientTypes.DBInstanceAutomatedBackup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBInstanceAutomatedBackups = dBInstanceAutomatedBackups
        self.marker = marker
    }
}

struct DescribeDBInstanceAutomatedBackupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBInstanceAutomatedBackups: [RdsClientTypes.DBInstanceAutomatedBackup]?
}

extension DescribeDBInstanceAutomatedBackupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackups = "DBInstanceAutomatedBackups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBInstanceAutomatedBackupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstanceAutomatedBackups) {
            struct KeyVal0{struct DBInstanceAutomatedBackup{}}
            let dBInstanceAutomatedBackupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstanceAutomatedBackup>.CodingKeys.self, forKey: .dBInstanceAutomatedBackups)
            if let dBInstanceAutomatedBackupsWrappedContainer = dBInstanceAutomatedBackupsWrappedContainer {
                let dBInstanceAutomatedBackupsContainer = try dBInstanceAutomatedBackupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstanceAutomatedBackup].self, forKey: .member)
                var dBInstanceAutomatedBackupsBuffer:[RdsClientTypes.DBInstanceAutomatedBackup]? = nil
                if let dBInstanceAutomatedBackupsContainer = dBInstanceAutomatedBackupsContainer {
                    dBInstanceAutomatedBackupsBuffer = [RdsClientTypes.DBInstanceAutomatedBackup]()
                    for structureContainer0 in dBInstanceAutomatedBackupsContainer {
                        dBInstanceAutomatedBackupsBuffer?.append(structureContainer0)
                    }
                }
                dBInstanceAutomatedBackups = dBInstanceAutomatedBackupsBuffer
            } else {
                dBInstanceAutomatedBackups = []
            }
        } else {
            dBInstanceAutomatedBackups = nil
        }
    }
}

public struct DescribeDBInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

extension DescribeDBInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBInstancesInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBInstances", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

public struct DescribeDBInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBInstancesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBInstancesOutputError>
}

///
public struct DescribeDBInstancesInput: Swift.Equatable {
    /// The user-supplied instance identifier. If this parameter is specified, information from only the specific DB instance is returned. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the identifier of an existing DBInstance.
    ///
    ///
    public var dBInstanceIdentifier: Swift.String?
    /// A filter that specifies one or more DB instances to describe.
    ///          Supported filters:
    ///
    ///
    ///
    ///                   db-cluster-id - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB instances associated with the DB clusters identified by these ARNs.
    ///
    ///
    ///
    ///                   db-instance-id - Accepts DB instance identifiers and DB
    ///               instance Amazon Resource Names (ARNs). The results list will only include information about
    ///               the DB instances identified by these ARNs.
    ///
    ///
    ///
    ///                   dbi-resource-id - Accepts DB instance resource identifiers. The results list will
    ///               only include information about the DB instances identified by these DB instance resource identifiers.
    ///
    ///
    ///
    ///                   domain - Accepts Active Directory directory IDs. The results list will only
    ///               include information about the DB instances associated with these domains.
    ///
    ///
    ///
    ///                   engine - Accepts engine names. The results list will only include information
    ///               about the DB instances for these engines.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeDBInstances request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBInstancesOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBInstancesOutputResponse(dBInstances: \(Swift.String(describing: dBInstances)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstances = output.dBInstances
            self.marker = output.marker
        } else {
            self.dBInstances = nil
            self.marker = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeDBInstances action.
///
public struct DescribeDBInstancesOutputResponse: Swift.Equatable {
    ///
    ///         A list of DBInstance instances.
    ///
    public var dBInstances: [RdsClientTypes.DBInstance]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?

    public init (
        dBInstances: [RdsClientTypes.DBInstance]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBInstances = dBInstances
        self.marker = marker
    }
}

struct DescribeDBInstancesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBInstances: [RdsClientTypes.DBInstance]?
}

extension DescribeDBInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstances = "DBInstances"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBInstances) {
            struct KeyVal0{struct DBInstance{}}
            let dBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBInstance>.CodingKeys.self, forKey: .dBInstances)
            if let dBInstancesWrappedContainer = dBInstancesWrappedContainer {
                let dBInstancesContainer = try dBInstancesWrappedContainer.decodeIfPresent([RdsClientTypes.DBInstance].self, forKey: .member)
                var dBInstancesBuffer:[RdsClientTypes.DBInstance]? = nil
                if let dBInstancesContainer = dBInstancesContainer {
                    dBInstancesBuffer = [RdsClientTypes.DBInstance]()
                    for structureContainer0 in dBInstancesContainer {
                        dBInstancesBuffer?.append(structureContainer0)
                    }
                }
                dBInstances = dBInstancesBuffer
            } else {
                dBInstances = []
            }
        } else {
            dBInstances = nil
        }
    }
}

extension RdsClientTypes.DescribeDBLogFilesDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastWritten = "LastWritten"
        case logFileName = "LogFileName"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if lastWritten != 0 {
            try container.encode(lastWritten, forKey: ClientRuntime.Key("LastWritten"))
        }
        if let logFileName = logFileName {
            try container.encode(logFileName, forKey: ClientRuntime.Key("LogFileName"))
        }
        if size != 0 {
            try container.encode(size, forKey: ClientRuntime.Key("Size"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logFileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFileName)
        logFileName = logFileNameDecoded
        let lastWrittenDecoded = try containerValues.decode(Swift.Int.self, forKey: .lastWritten)
        lastWritten = lastWrittenDecoded
        let sizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension RdsClientTypes.DescribeDBLogFilesDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBLogFilesDetails(lastWritten: \(Swift.String(describing: lastWritten)), logFileName: \(Swift.String(describing: logFileName)), size: \(Swift.String(describing: size)))"}
}

extension RdsClientTypes {
    /// This data type is used as a response element to DescribeDBLogFiles.
    public struct DescribeDBLogFilesDetails: Swift.Equatable {
        /// A POSIX timestamp when the last log entry was written.
        public var lastWritten: Swift.Int
        /// The name of the log file for the specified DB instance.
        public var logFileName: Swift.String?
        /// The size, in bytes, of the log file for the specified DB instance.
        public var size: Swift.Int

        public init (
            lastWritten: Swift.Int = 0,
            logFileName: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.lastWritten = lastWritten
            self.logFileName = logFileName
            self.size = size
        }
    }

}

public struct DescribeDBLogFilesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBLogFilesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBLogFilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBLogFilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBLogFilesOutputError>
}

extension DescribeDBLogFilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBLogFilesInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), fileLastWritten: \(Swift.String(describing: fileLastWritten)), fileSize: \(Swift.String(describing: fileSize)), filenameContains: \(Swift.String(describing: filenameContains)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBLogFilesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if fileLastWritten != 0 {
            try container.encode(fileLastWritten, forKey: ClientRuntime.Key("FileLastWritten"))
        }
        if fileSize != 0 {
            try container.encode(fileSize, forKey: ClientRuntime.Key("FileSize"))
        }
        if let filenameContains = filenameContains {
            try container.encode(filenameContains, forKey: ClientRuntime.Key("FilenameContains"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBLogFiles", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBLogFilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBLogFilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBLogFilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBLogFilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBLogFilesOutputError>
}

public struct DescribeDBLogFilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBLogFilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBLogFilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBLogFilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBLogFilesOutputError>
}

public struct DescribeDBLogFilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBLogFilesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBLogFilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBLogFilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBLogFilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBLogFilesOutputError>
}

///
public struct DescribeDBLogFilesInput: Swift.Equatable {
    /// The customer-assigned name of the DB instance that contains the log files you want to list.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBInstance.
    ///
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// Filters the available log files for files written since the specified date, in POSIX timestamp format with milliseconds.
    public var fileLastWritten: Swift.Int
    /// Filters the available log files for files larger than the specified size.
    public var fileSize: Swift.Int
    /// Filters the available log files for log file names that contain the specified string.
    public var filenameContains: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The pagination token provided in the previous request. If this parameter is specified the response includes only records beyond the marker, up to MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist than the specified MaxRecords value, a pagination token called a marker is included in the response so you can retrieve the remaining results.
    public var maxRecords: Swift.Int?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        fileLastWritten: Swift.Int = 0,
        fileSize: Swift.Int = 0,
        filenameContains: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.fileLastWritten = fileLastWritten
        self.fileSize = fileSize
        self.filenameContains = filenameContains
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBLogFilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBLogFilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBLogFilesOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBLogFilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBLogFilesOutputResponse(describeDBLogFiles: \(Swift.String(describing: describeDBLogFiles)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBLogFilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBLogFilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.describeDBLogFiles = output.describeDBLogFiles
            self.marker = output.marker
        } else {
            self.describeDBLogFiles = nil
            self.marker = nil
        }
    }
}

///
///             The response from a call to DescribeDBLogFiles.
///
public struct DescribeDBLogFilesOutputResponse: Swift.Equatable {
    /// The DB log files returned.
    public var describeDBLogFiles: [RdsClientTypes.DescribeDBLogFilesDetails]?
    /// A pagination token that can be used in a later DescribeDBLogFiles request.
    public var marker: Swift.String?

    public init (
        describeDBLogFiles: [RdsClientTypes.DescribeDBLogFilesDetails]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.describeDBLogFiles = describeDBLogFiles
        self.marker = marker
    }
}

struct DescribeDBLogFilesOutputResponseBody: Swift.Equatable {
    public let describeDBLogFiles: [RdsClientTypes.DescribeDBLogFilesDetails]?
    public let marker: Swift.String?
}

extension DescribeDBLogFilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case describeDBLogFiles = "DescribeDBLogFiles"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBLogFilesResult"))
        if containerValues.contains(.describeDBLogFiles) {
            struct KeyVal0{struct DescribeDBLogFilesDetails{}}
            let describeDBLogFilesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DescribeDBLogFilesDetails>.CodingKeys.self, forKey: .describeDBLogFiles)
            if let describeDBLogFilesWrappedContainer = describeDBLogFilesWrappedContainer {
                let describeDBLogFilesContainer = try describeDBLogFilesWrappedContainer.decodeIfPresent([RdsClientTypes.DescribeDBLogFilesDetails].self, forKey: .member)
                var describeDBLogFilesBuffer:[RdsClientTypes.DescribeDBLogFilesDetails]? = nil
                if let describeDBLogFilesContainer = describeDBLogFilesContainer {
                    describeDBLogFilesBuffer = [RdsClientTypes.DescribeDBLogFilesDetails]()
                    for structureContainer0 in describeDBLogFilesContainer {
                        describeDBLogFilesBuffer?.append(structureContainer0)
                    }
                }
                describeDBLogFiles = describeDBLogFilesBuffer
            } else {
                describeDBLogFiles = []
            }
        } else {
            describeDBLogFiles = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBParameterGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

extension DescribeDBParameterGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParameterGroupsInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBParameterGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBParameterGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBParameterGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParameterGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

public struct DescribeDBParameterGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParameterGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBParameterGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBParameterGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParameterGroupsOutputError>
}

///
public struct DescribeDBParameterGroupsInput: Swift.Equatable {
    /// The name of a specific DB parameter group to return details for.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DBClusterParameterGroup.
    ///
    ///
    public var dBParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeDBParameterGroups request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBParameterGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParameterGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParameterGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParameterGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParameterGroupsOutputResponse(dBParameterGroups: \(Swift.String(describing: dBParameterGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBParameterGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroups = output.dBParameterGroups
            self.marker = output.marker
        } else {
            self.dBParameterGroups = nil
            self.marker = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeDBParameterGroups action.
///
public struct DescribeDBParameterGroupsOutputResponse: Swift.Equatable {
    ///
    ///         A list of DBParameterGroup instances.
    ///
    public var dBParameterGroups: [RdsClientTypes.DBParameterGroup]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBParameterGroups: [RdsClientTypes.DBParameterGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBParameterGroups = dBParameterGroups
        self.marker = marker
    }
}

struct DescribeDBParameterGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBParameterGroups: [RdsClientTypes.DBParameterGroup]?
}

extension DescribeDBParameterGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroups = "DBParameterGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBParameterGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBParameterGroups) {
            struct KeyVal0{struct DBParameterGroup{}}
            let dBParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBParameterGroup>.CodingKeys.self, forKey: .dBParameterGroups)
            if let dBParameterGroupsWrappedContainer = dBParameterGroupsWrappedContainer {
                let dBParameterGroupsContainer = try dBParameterGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBParameterGroup].self, forKey: .member)
                var dBParameterGroupsBuffer:[RdsClientTypes.DBParameterGroup]? = nil
                if let dBParameterGroupsContainer = dBParameterGroupsContainer {
                    dBParameterGroupsBuffer = [RdsClientTypes.DBParameterGroup]()
                    for structureContainer0 in dBParameterGroupsContainer {
                        dBParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBParameterGroups = dBParameterGroupsBuffer
            } else {
                dBParameterGroups = []
            }
        } else {
            dBParameterGroups = nil
        }
    }
}

public struct DescribeDBParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

extension DescribeDBParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParametersInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), source: \(Swift.String(describing: source)))"}
}

extension DescribeDBParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        try container.encode("DescribeDBParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBParametersOutputError>
}

public struct DescribeDBParametersInput: Swift.Equatable {
    /// The name of a specific DB parameter group to return details for.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DBParameterGroup.
    ///
    ///
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeDBParameters request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The parameter types to return.
    ///          Default: All parameter types returned
    ///          Valid Values: user | system | engine-default
    ///
    public var source: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        source: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.source = source
    }
}

extension DescribeDBParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBParametersOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBParametersOutputResponse(marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension DescribeDBParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.parameters = output.parameters
        } else {
            self.marker = nil
            self.parameters = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeDBParameters action.
///
public struct DescribeDBParametersOutputResponse: Swift.Equatable {
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         A list of Parameter values.
    ///
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        marker: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.marker = marker
        self.parameters = parameters
    }
}

struct DescribeDBParametersOutputResponseBody: Swift.Equatable {
    public let parameters: [RdsClientTypes.Parameter]?
    public let marker: Swift.String?
}

extension DescribeDBParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBParametersResult"))
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxiesOutputError>
}

extension DescribeDBProxiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxiesInput(dBProxyName: \(Swift.String(describing: dBProxyName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBProxiesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBProxies", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBProxiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxiesOutputError>
}

public struct DescribeDBProxiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxiesOutputError>
}

public struct DescribeDBProxiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxiesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBProxiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBProxiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxiesOutputError>
}

public struct DescribeDBProxiesInput: Swift.Equatable {
    /// The name of the DB proxy. If you omit this parameter,
    ///         the output includes information about all DB proxies owned by
    ///         your Amazon Web Services account ID.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist
    ///           than the specified MaxRecords value, a pagination token called a marker is
    ///           included in the response so that the remaining results can be retrieved.
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBProxiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxiesOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxiesOutputResponse(dBProxies: \(Swift.String(describing: dBProxies)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBProxiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxies = output.dBProxies
            self.marker = output.marker
        } else {
            self.dBProxies = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBProxiesOutputResponse: Swift.Equatable {
    /// A return value representing an arbitrary number of DBProxy data structures.
    public var dBProxies: [RdsClientTypes.DBProxy]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBProxies: [RdsClientTypes.DBProxy]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBProxies = dBProxies
        self.marker = marker
    }
}

struct DescribeDBProxiesOutputResponseBody: Swift.Equatable {
    public let dBProxies: [RdsClientTypes.DBProxy]?
    public let marker: Swift.String?
}

extension DescribeDBProxiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxies = "DBProxies"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxiesResult"))
        if containerValues.contains(.dBProxies) {
            struct KeyVal0{struct member{}}
            let dBProxiesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxies)
            if let dBProxiesWrappedContainer = dBProxiesWrappedContainer {
                let dBProxiesContainer = try dBProxiesWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxy].self, forKey: .member)
                var dBProxiesBuffer:[RdsClientTypes.DBProxy]? = nil
                if let dBProxiesContainer = dBProxiesContainer {
                    dBProxiesBuffer = [RdsClientTypes.DBProxy]()
                    for structureContainer0 in dBProxiesContainer {
                        dBProxiesBuffer?.append(structureContainer0)
                    }
                }
                dBProxies = dBProxiesBuffer
            } else {
                dBProxies = []
            }
        } else {
            dBProxies = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxyEndpointsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyEndpointsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyEndpointsOutputError>
}

extension DescribeDBProxyEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxyEndpointsInput(dBProxyEndpointName: \(Swift.String(describing: dBProxyEndpointName)), dBProxyName: \(Swift.String(describing: dBProxyName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBProxyEndpointsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBProxyEndpoints", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBProxyEndpointsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyEndpointsOutputError>
}

public struct DescribeDBProxyEndpointsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyEndpointsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyEndpointsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyEndpointsOutputError>
}

public struct DescribeDBProxyEndpointsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyEndpointsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBProxyEndpointsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBProxyEndpointsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyEndpointsOutputError>
}

public struct DescribeDBProxyEndpointsInput: Swift.Equatable {
    /// The name of a DB proxy endpoint to describe. If you omit this parameter,
    ///         the output includes information about all DB proxy endpoints associated with
    ///         the specified proxy.
    public var dBProxyEndpointName: Swift.String?
    /// The name of the DB proxy whose endpoints you want to describe. If you omit
    ///         this parameter, the output includes information about all DB proxy endpoints
    ///         associated with all your DB proxies.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist
    ///           than the specified MaxRecords value, a pagination token called a marker is
    ///           included in the response so that the remaining results can be retrieved.
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBProxyEndpointName: Swift.String? = nil,
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBProxyEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyEndpointsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyEndpointsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxyEndpointsOutputResponse(dBProxyEndpoints: \(Swift.String(describing: dBProxyEndpoints)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBProxyEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxyEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoints = output.dBProxyEndpoints
            self.marker = output.marker
        } else {
            self.dBProxyEndpoints = nil
            self.marker = nil
        }
    }
}

public struct DescribeDBProxyEndpointsOutputResponse: Swift.Equatable {
    /// The list of ProxyEndpoint objects returned by the API operation.
    public var dBProxyEndpoints: [RdsClientTypes.DBProxyEndpoint]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBProxyEndpoints: [RdsClientTypes.DBProxyEndpoint]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBProxyEndpoints = dBProxyEndpoints
        self.marker = marker
    }
}

struct DescribeDBProxyEndpointsOutputResponseBody: Swift.Equatable {
    public let dBProxyEndpoints: [RdsClientTypes.DBProxyEndpoint]?
    public let marker: Swift.String?
}

extension DescribeDBProxyEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoints = "DBProxyEndpoints"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxyEndpointsResult"))
        if containerValues.contains(.dBProxyEndpoints) {
            struct KeyVal0{struct member{}}
            let dBProxyEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxyEndpoints)
            if let dBProxyEndpointsWrappedContainer = dBProxyEndpointsWrappedContainer {
                let dBProxyEndpointsContainer = try dBProxyEndpointsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyEndpoint].self, forKey: .member)
                var dBProxyEndpointsBuffer:[RdsClientTypes.DBProxyEndpoint]? = nil
                if let dBProxyEndpointsContainer = dBProxyEndpointsContainer {
                    dBProxyEndpointsBuffer = [RdsClientTypes.DBProxyEndpoint]()
                    for structureContainer0 in dBProxyEndpointsContainer {
                        dBProxyEndpointsBuffer?.append(structureContainer0)
                    }
                }
                dBProxyEndpoints = dBProxyEndpointsBuffer
            } else {
                dBProxyEndpoints = []
            }
        } else {
            dBProxyEndpoints = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxyTargetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyTargetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyTargetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetGroupsOutputError>
}

extension DescribeDBProxyTargetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxyTargetGroupsInput(dBProxyName: \(Swift.String(describing: dBProxyName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), targetGroupName: \(Swift.String(describing: targetGroupName)))"}
}

extension DescribeDBProxyTargetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("DescribeDBProxyTargetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBProxyTargetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyTargetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyTargetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetGroupsOutputError>
}

public struct DescribeDBProxyTargetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyTargetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyTargetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetGroupsOutputError>
}

public struct DescribeDBProxyTargetGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBProxyTargetGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBProxyTargetGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetGroupsOutputError>
}

public struct DescribeDBProxyTargetGroupsInput: Swift.Equatable {
    /// The identifier of the DBProxy associated with the target group.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so that the remaining
    ///         results can be retrieved.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of the DBProxyTargetGroup to describe.
    public var targetGroupName: Swift.String?

    public init (
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.targetGroupName = targetGroupName
    }
}

extension DescribeDBProxyTargetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyTargetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyTargetGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyTargetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxyTargetGroupsOutputResponse(marker: \(Swift.String(describing: marker)), targetGroups: \(Swift.String(describing: targetGroups)))"}
}

extension DescribeDBProxyTargetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxyTargetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.targetGroups = output.targetGroups
        } else {
            self.marker = nil
            self.targetGroups = nil
        }
    }
}

public struct DescribeDBProxyTargetGroupsOutputResponse: Swift.Equatable {
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// An arbitrary number of DBProxyTargetGroup objects, containing details of the corresponding target groups.
    public var targetGroups: [RdsClientTypes.DBProxyTargetGroup]?

    public init (
        marker: Swift.String? = nil,
        targetGroups: [RdsClientTypes.DBProxyTargetGroup]? = nil
    )
    {
        self.marker = marker
        self.targetGroups = targetGroups
    }
}

struct DescribeDBProxyTargetGroupsOutputResponseBody: Swift.Equatable {
    public let targetGroups: [RdsClientTypes.DBProxyTargetGroup]?
    public let marker: Swift.String?
}

extension DescribeDBProxyTargetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxyTargetGroupsResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyTargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[RdsClientTypes.DBProxyTargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [RdsClientTypes.DBProxyTargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBProxyTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetsOutputError>
}

extension DescribeDBProxyTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxyTargetsInput(dBProxyName: \(Swift.String(describing: dBProxyName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), targetGroupName: \(Swift.String(describing: targetGroupName)))"}
}

extension DescribeDBProxyTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("DescribeDBProxyTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBProxyTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetsOutputError>
}

public struct DescribeDBProxyTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetsOutputError>
}

public struct DescribeDBProxyTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBProxyTargetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBProxyTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBProxyTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBProxyTargetsOutputError>
}

public struct DescribeDBProxyTargetsInput: Swift.Equatable {
    /// The identifier of the DBProxyTarget to describe.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// This parameter is not currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so that the remaining
    ///         results can be retrieved.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of the DBProxyTargetGroup to describe.
    public var targetGroupName: Swift.String?

    public init (
        dBProxyName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBProxyName = dBProxyName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.targetGroupName = targetGroupName
    }
}

extension DescribeDBProxyTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBProxyTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetNotFoundFault" : self = .dBProxyTargetNotFoundFault(try DBProxyTargetNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBProxyTargetsOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBProxyTargetNotFoundFault(DBProxyTargetNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBProxyTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBProxyTargetsOutputResponse(marker: \(Swift.String(describing: marker)), targets: \(Swift.String(describing: targets)))"}
}

extension DescribeDBProxyTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBProxyTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.targets = output.targets
        } else {
            self.marker = nil
            self.targets = nil
        }
    }
}

public struct DescribeDBProxyTargetsOutputResponse: Swift.Equatable {
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// An arbitrary number of DBProxyTarget objects, containing details of the corresponding targets.
    public var targets: [RdsClientTypes.DBProxyTarget]?

    public init (
        marker: Swift.String? = nil,
        targets: [RdsClientTypes.DBProxyTarget]? = nil
    )
    {
        self.marker = marker
        self.targets = targets
    }
}

struct DescribeDBProxyTargetsOutputResponseBody: Swift.Equatable {
    public let targets: [RdsClientTypes.DBProxyTarget]?
    public let marker: Swift.String?
}

extension DescribeDBProxyTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case targets = "Targets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBProxyTargetsResult"))
        if containerValues.contains(.targets) {
            struct KeyVal0{struct member{}}
            let targetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targets)
            if let targetsWrappedContainer = targetsWrappedContainer {
                let targetsContainer = try targetsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyTarget].self, forKey: .member)
                var targetsBuffer:[RdsClientTypes.DBProxyTarget]? = nil
                if let targetsContainer = targetsContainer {
                    targetsBuffer = [RdsClientTypes.DBProxyTarget]()
                    for structureContainer0 in targetsContainer {
                        targetsBuffer?.append(structureContainer0)
                    }
                }
                targets = targetsBuffer
            } else {
                targets = []
            }
        } else {
            targets = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeDBSecurityGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSecurityGroupsOutputError>
}

extension DescribeDBSecurityGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSecurityGroupsInput(dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBSecurityGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBSecurityGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBSecurityGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSecurityGroupsOutputError>
}

public struct DescribeDBSecurityGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSecurityGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSecurityGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSecurityGroupsOutputError>
}

public struct DescribeDBSecurityGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSecurityGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBSecurityGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBSecurityGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSecurityGroupsOutputError>
}

///
public struct DescribeDBSecurityGroupsInput: Swift.Equatable {
    /// The name of the DB security group to return details for.
    public var dBSecurityGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeDBSecurityGroups request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBSecurityGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBSecurityGroupName = dBSecurityGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBSecurityGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSecurityGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSecurityGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSecurityGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSecurityGroupsOutputResponse(dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBSecurityGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroups = output.dBSecurityGroups
            self.marker = output.marker
        } else {
            self.dBSecurityGroups = nil
            self.marker = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeDBSecurityGroups action.
///
public struct DescribeDBSecurityGroupsOutputResponse: Swift.Equatable {
    ///
    ///         A list of DBSecurityGroup instances.
    ///
    public var dBSecurityGroups: [RdsClientTypes.DBSecurityGroup]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBSecurityGroups: [RdsClientTypes.DBSecurityGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSecurityGroups = dBSecurityGroups
        self.marker = marker
    }
}

struct DescribeDBSecurityGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBSecurityGroups: [RdsClientTypes.DBSecurityGroup]?
}

extension DescribeDBSecurityGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroups = "DBSecurityGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSecurityGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSecurityGroups) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroups)
            if let dBSecurityGroupsWrappedContainer = dBSecurityGroupsWrappedContainer {
                let dBSecurityGroupsContainer = try dBSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSecurityGroup].self, forKey: .member)
                var dBSecurityGroupsBuffer:[RdsClientTypes.DBSecurityGroup]? = nil
                if let dBSecurityGroupsContainer = dBSecurityGroupsContainer {
                    dBSecurityGroupsBuffer = [RdsClientTypes.DBSecurityGroup]()
                    for structureContainer0 in dBSecurityGroupsContainer {
                        dBSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroups = dBSecurityGroupsBuffer
            } else {
                dBSecurityGroups = []
            }
        } else {
            dBSecurityGroups = nil
        }
    }
}

public struct DescribeDBSnapshotAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotAttributesOutputError>
}

extension DescribeDBSnapshotAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSnapshotAttributesInput(dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)))"}
}

extension DescribeDBSnapshotAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        try container.encode("DescribeDBSnapshotAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBSnapshotAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotAttributesOutputError>
}

public struct DescribeDBSnapshotAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSnapshotAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSnapshotAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotAttributesOutputError>
}

public struct DescribeDBSnapshotAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotAttributesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBSnapshotAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBSnapshotAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotAttributesOutputError>
}

///
public struct DescribeDBSnapshotAttributesInput: Swift.Equatable {
    /// The identifier for the DB snapshot to describe the attributes for.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?

    public init (
        dBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension DescribeDBSnapshotAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSnapshotAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSnapshotAttributesOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSnapshotAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSnapshotAttributesOutputResponse(dBSnapshotAttributesResult: \(Swift.String(describing: dBSnapshotAttributesResult)))"}
}

extension DescribeDBSnapshotAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSnapshotAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshotAttributesResult = output.dBSnapshotAttributesResult
        } else {
            self.dBSnapshotAttributesResult = nil
        }
    }
}

public struct DescribeDBSnapshotAttributesOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBSnapshotAttributes
    ///     API action.
    ///          Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts
    ///       to copy or restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute
    ///       API action.
    public var dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?

    public init (
        dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult? = nil
    )
    {
        self.dBSnapshotAttributesResult = dBSnapshotAttributesResult
    }
}

struct DescribeDBSnapshotAttributesOutputResponseBody: Swift.Equatable {
    public let dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?
}

extension DescribeDBSnapshotAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotAttributesResult = "DBSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSnapshotAttributesResult"))
        let dBSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshotAttributesResult.self, forKey: .dBSnapshotAttributesResult)
        dBSnapshotAttributesResult = dBSnapshotAttributesResultDecoded
    }
}

public struct DescribeDBSnapshotsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotsOutputError>
}

extension DescribeDBSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSnapshotsInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)), dbiResourceId: \(Swift.String(describing: dbiResourceId)), filters: \(Swift.String(describing: filters)), includePublic: \(Swift.String(describing: includePublic)), includeShared: \(Swift.String(describing: includeShared)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), snapshotType: \(Swift.String(describing: snapshotType)))"}
}

extension DescribeDBSnapshotsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let dbiResourceId = dbiResourceId {
            try container.encode(dbiResourceId, forKey: ClientRuntime.Key("DbiResourceId"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if includePublic != false {
            try container.encode(includePublic, forKey: ClientRuntime.Key("IncludePublic"))
        }
        if includeShared != false {
            try container.encode(includeShared, forKey: ClientRuntime.Key("IncludeShared"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        try container.encode("DescribeDBSnapshots", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBSnapshotsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotsOutputError>
}

public struct DescribeDBSnapshotsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSnapshotsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSnapshotsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotsOutputError>
}

public struct DescribeDBSnapshotsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSnapshotsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBSnapshotsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBSnapshotsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSnapshotsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSnapshotsOutputError>
}

///
public struct DescribeDBSnapshotsInput: Swift.Equatable {
    /// The ID of the DB instance to retrieve the list of DB snapshots for.
    ///         This parameter can't be used in conjunction with DBSnapshotIdentifier.
    ///         This parameter isn't case-sensitive.
    ///
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the identifier of an existing DBInstance.
    ///
    ///
    public var dBInstanceIdentifier: Swift.String?
    ///
    ///         A specific DB snapshot identifier to describe. This parameter can't be used in conjunction with DBInstanceIdentifier.
    ///             This value is stored as a lowercase string.
    ///
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the identifier of an existing DBSnapshot.
    ///
    ///
    ///                If this identifier is for an automated snapshot, the SnapshotType parameter must also be specified.
    ///
    ///
    public var dBSnapshotIdentifier: Swift.String?
    /// A specific DB resource ID to describe.
    public var dbiResourceId: Swift.String?
    /// A filter that specifies one or more DB snapshots to describe.
    ///          Supported filters:
    ///
    ///
    ///
    ///                   db-instance-id - Accepts DB instance identifiers and DB
    ///               instance Amazon Resource Names (ARNs).
    ///
    ///
    ///
    ///                   db-snapshot-id - Accepts DB snapshot identifiers.
    ///
    ///
    ///
    ///                   dbi-resource-id - Accepts identifiers of source DB instances.
    ///
    ///
    ///
    ///                   snapshot-type - Accepts types of DB snapshots.
    ///
    ///
    ///
    ///                   engine - Accepts names of database engines.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    /// A value that indicates whether to include manual DB cluster snapshots that are public and can be copied
    ///           or restored by any Amazon Web Services account. By default, the public snapshots are not included.
    ///          You can share a manual DB snapshot as public by using the ModifyDBSnapshotAttribute API.
    public var includePublic: Swift.Bool
    /// A value that indicates whether to include shared manual DB cluster snapshots
    ///           from other Amazon Web Services accounts that this Amazon Web Services account has been given
    ///           permission to copy or restore. By default, these snapshots are not included.
    ///          You can give an Amazon Web Services account permission to restore a manual DB snapshot from
    ///     another Amazon Web Services account by using the ModifyDBSnapshotAttribute API action.
    public var includeShared: Swift.Bool
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeDBSnapshots request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The type of snapshots to be returned. You can specify one of the following values:
    ///
    ///
    ///
    ///                   automated - Return all DB snapshots that have been automatically taken by
    ///       Amazon RDS for my Amazon Web Services account.
    ///
    ///
    ///
    ///                   manual - Return all DB snapshots that have been taken by my Amazon Web Services account.
    ///
    ///
    ///
    ///                   shared - Return all manual DB snapshots that have been shared to my Amazon Web Services account.
    ///
    ///
    ///
    ///                   public - Return all DB snapshots that have been marked as public.
    ///
    ///
    ///
    ///                   awsbackup - Return the DB snapshots managed by the Amazon Web Services Backup service.
    ///               For information about Amazon Web Services Backup, see the
    ///                   <a href="https://docs.aws.amazon.com/aws-backup/latest/devguide/whatisbackup.html">
    ///                       Amazon Web Services Backup Developer Guide.
    ///
    ///
    ///               The awsbackup type does not apply to Aurora.
    ///
    ///
    ///          If you don't specify a SnapshotType value, then both automated and manual snapshots are
    ///       returned. Shared and public DB snapshots are not included in the returned results by default.
    ///       You can include shared snapshots with these results by enabling the IncludeShared
    ///       parameter. You can include public snapshots with these results by enabling the
    ///       IncludePublic parameter.
    ///          The IncludeShared and IncludePublic parameters don't apply for SnapshotType values
    ///       of manual or automated. The IncludePublic parameter doesn't apply when SnapshotType is
    ///       set to shared. The IncludeShared parameter doesn't apply when SnapshotType is set to
    ///       public.
    public var snapshotType: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        dbiResourceId: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        includePublic: Swift.Bool = false,
        includeShared: Swift.Bool = false,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        snapshotType: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dbiResourceId = dbiResourceId
        self.filters = filters
        self.includePublic = includePublic
        self.includeShared = includeShared
        self.marker = marker
        self.maxRecords = maxRecords
        self.snapshotType = snapshotType
    }
}

extension DescribeDBSnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSnapshotsOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSnapshotsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSnapshotsOutputResponse(dBSnapshots: \(Swift.String(describing: dBSnapshots)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBSnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshots = output.dBSnapshots
            self.marker = output.marker
        } else {
            self.dBSnapshots = nil
            self.marker = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeDBSnapshots action.
///
public struct DescribeDBSnapshotsOutputResponse: Swift.Equatable {
    ///
    ///         A list of DBSnapshot instances.
    ///
    public var dBSnapshots: [RdsClientTypes.DBSnapshot]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBSnapshots: [RdsClientTypes.DBSnapshot]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSnapshots = dBSnapshots
        self.marker = marker
    }
}

struct DescribeDBSnapshotsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBSnapshots: [RdsClientTypes.DBSnapshot]?
}

extension DescribeDBSnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshots = "DBSnapshots"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSnapshotsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSnapshots) {
            struct KeyVal0{struct DBSnapshot{}}
            let dBSnapshotsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSnapshot>.CodingKeys.self, forKey: .dBSnapshots)
            if let dBSnapshotsWrappedContainer = dBSnapshotsWrappedContainer {
                let dBSnapshotsContainer = try dBSnapshotsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSnapshot].self, forKey: .member)
                var dBSnapshotsBuffer:[RdsClientTypes.DBSnapshot]? = nil
                if let dBSnapshotsContainer = dBSnapshotsContainer {
                    dBSnapshotsBuffer = [RdsClientTypes.DBSnapshot]()
                    for structureContainer0 in dBSnapshotsContainer {
                        dBSnapshotsBuffer?.append(structureContainer0)
                    }
                }
                dBSnapshots = dBSnapshotsBuffer
            } else {
                dBSnapshots = []
            }
        } else {
            dBSnapshots = nil
        }
    }
}

public struct DescribeDBSubnetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

extension DescribeDBSubnetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSubnetGroupsInput(dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeDBSubnetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeDBSubnetGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeDBSubnetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDBSubnetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

public struct DescribeDBSubnetGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDBSubnetGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDBSubnetGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDBSubnetGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDBSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDBSubnetGroupsOutputError>
}

///
public struct DescribeDBSubnetGroupsInput: Swift.Equatable {
    /// The name of the DB subnet group to return details for.
    public var dBSubnetGroupName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///             An optional pagination token provided by a previous DescribeDBSubnetGroups request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///         a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBSubnetGroupName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBSubnetGroupName = dBSubnetGroupName
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeDBSubnetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeDBSubnetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDBSubnetGroupsOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDBSubnetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDBSubnetGroupsOutputResponse(dBSubnetGroups: \(Swift.String(describing: dBSubnetGroups)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeDBSubnetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDBSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroups = output.dBSubnetGroups
            self.marker = output.marker
        } else {
            self.dBSubnetGroups = nil
            self.marker = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeDBSubnetGroups action.
///
public struct DescribeDBSubnetGroupsOutputResponse: Swift.Equatable {
    ///
    ///         A list of DBSubnetGroup instances.
    ///
    public var dBSubnetGroups: [RdsClientTypes.DBSubnetGroup]?
    ///
    ///             An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        dBSubnetGroups: [RdsClientTypes.DBSubnetGroup]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.dBSubnetGroups = dBSubnetGroups
        self.marker = marker
    }
}

struct DescribeDBSubnetGroupsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let dBSubnetGroups: [RdsClientTypes.DBSubnetGroup]?
}

extension DescribeDBSubnetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroups = "DBSubnetGroups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeDBSubnetGroupsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.dBSubnetGroups) {
            struct KeyVal0{struct DBSubnetGroup{}}
            let dBSubnetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSubnetGroup>.CodingKeys.self, forKey: .dBSubnetGroups)
            if let dBSubnetGroupsWrappedContainer = dBSubnetGroupsWrappedContainer {
                let dBSubnetGroupsContainer = try dBSubnetGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSubnetGroup].self, forKey: .member)
                var dBSubnetGroupsBuffer:[RdsClientTypes.DBSubnetGroup]? = nil
                if let dBSubnetGroupsContainer = dBSubnetGroupsContainer {
                    dBSubnetGroupsBuffer = [RdsClientTypes.DBSubnetGroup]()
                    for structureContainer0 in dBSubnetGroupsContainer {
                        dBSubnetGroupsBuffer?.append(structureContainer0)
                    }
                }
                dBSubnetGroups = dBSubnetGroupsBuffer
            } else {
                dBSubnetGroups = []
            }
        } else {
            dBSubnetGroups = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

extension DescribeEngineDefaultClusterParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultClusterParametersInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultClusterParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultClusterParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEngineDefaultClusterParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultClusterParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

public struct DescribeEngineDefaultClusterParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultClusterParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEngineDefaultClusterParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEngineDefaultClusterParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultClusterParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultClusterParametersOutputError>
}

///
public struct DescribeEngineDefaultClusterParametersInput: Swift.Equatable {
    /// The name of the DB cluster parameter group family to return engine parameter information for.
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///       An optional pagination token provided by a previous
    ///       DescribeEngineDefaultClusterParameters request.
    ///       If this parameter is specified, the response includes
    ///       only records beyond the marker,
    ///       up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///       The maximum number of records to include in the response.
    ///       If more records exist than the specified MaxRecords value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultClusterParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultClusterParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultClusterParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultClusterParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultClusterParametersOutputResponse(engineDefaults: \(Swift.String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultClusterParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngineDefaultClusterParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultClusterParametersOutputResponse: Swift.Equatable {
    ///
    ///             Contains the result of a successful invocation of the DescribeEngineDefaultParameters action.
    ///
    public var engineDefaults: RdsClientTypes.EngineDefaults?

    public init (
        engineDefaults: RdsClientTypes.EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultClusterParametersOutputResponseBody: Swift.Equatable {
    public let engineDefaults: RdsClientTypes.EngineDefaults?
}

extension DescribeEngineDefaultClusterParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEngineDefaultClusterParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEngineDefaultParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

extension DescribeEngineDefaultParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultParametersInput(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeEngineDefaultParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeEngineDefaultParameters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEngineDefaultParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEngineDefaultParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

public struct DescribeEngineDefaultParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEngineDefaultParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEngineDefaultParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEngineDefaultParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEngineDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEngineDefaultParametersOutputError>
}

///
public struct DescribeEngineDefaultParametersInput: Swift.Equatable {
    /// The name of the DB parameter group family.
    /// This member is required.
    public var dBParameterGroupFamily: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeEngineDefaultParameters request.
    ///             If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///           a pagination token called a marker is included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        dBParameterGroupFamily: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.dBParameterGroupFamily = dBParameterGroupFamily
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeEngineDefaultParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEngineDefaultParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEngineDefaultParametersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEngineDefaultParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEngineDefaultParametersOutputResponse(engineDefaults: \(Swift.String(describing: engineDefaults)))"}
}

extension DescribeEngineDefaultParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEngineDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineDefaults = output.engineDefaults
        } else {
            self.engineDefaults = nil
        }
    }
}

public struct DescribeEngineDefaultParametersOutputResponse: Swift.Equatable {
    ///
    ///             Contains the result of a successful invocation of the DescribeEngineDefaultParameters action.
    ///
    public var engineDefaults: RdsClientTypes.EngineDefaults?

    public init (
        engineDefaults: RdsClientTypes.EngineDefaults? = nil
    )
    {
        self.engineDefaults = engineDefaults
    }
}

struct DescribeEngineDefaultParametersOutputResponseBody: Swift.Equatable {
    public let engineDefaults: RdsClientTypes.EngineDefaults?
}

extension DescribeEngineDefaultParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineDefaults = "EngineDefaults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEngineDefaultParametersResult"))
        let engineDefaultsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EngineDefaults.self, forKey: .engineDefaults)
        engineDefaults = engineDefaultsDecoded
    }
}

public struct DescribeEventCategoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

extension DescribeEventCategoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesInput(filters: \(Swift.String(describing: filters)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension DescribeEventCategoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        try container.encode("DescribeEventCategories", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventCategoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventCategoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

public struct DescribeEventCategoriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventCategoriesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEventCategoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEventCategoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventCategoriesOutputError>
}

///
public struct DescribeEventCategoriesInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The type of source that is generating the events.
    ///          Valid values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot
    ///
    public var sourceType: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        sourceType: Swift.String? = nil
    )
    {
        self.filters = filters
        self.sourceType = sourceType
    }
}

extension DescribeEventCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventCategoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventCategoriesOutputResponse(eventCategoriesMapList: \(Swift.String(describing: eventCategoriesMapList)))"}
}

extension DescribeEventCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventCategoriesMapList = output.eventCategoriesMapList
        } else {
            self.eventCategoriesMapList = nil
        }
    }
}

/// Data returned from the DescribeEventCategories operation.
public struct DescribeEventCategoriesOutputResponse: Swift.Equatable {
    /// A list of EventCategoriesMap data types.
    public var eventCategoriesMapList: [RdsClientTypes.EventCategoriesMap]?

    public init (
        eventCategoriesMapList: [RdsClientTypes.EventCategoriesMap]? = nil
    )
    {
        self.eventCategoriesMapList = eventCategoriesMapList
    }
}

struct DescribeEventCategoriesOutputResponseBody: Swift.Equatable {
    public let eventCategoriesMapList: [RdsClientTypes.EventCategoriesMap]?
}

extension DescribeEventCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategoriesMapList = "EventCategoriesMapList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventCategoriesResult"))
        if containerValues.contains(.eventCategoriesMapList) {
            struct KeyVal0{struct EventCategoriesMap{}}
            let eventCategoriesMapListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategoriesMap>.CodingKeys.self, forKey: .eventCategoriesMapList)
            if let eventCategoriesMapListWrappedContainer = eventCategoriesMapListWrappedContainer {
                let eventCategoriesMapListContainer = try eventCategoriesMapListWrappedContainer.decodeIfPresent([RdsClientTypes.EventCategoriesMap].self, forKey: .member)
                var eventCategoriesMapListBuffer:[RdsClientTypes.EventCategoriesMap]? = nil
                if let eventCategoriesMapListContainer = eventCategoriesMapListContainer {
                    eventCategoriesMapListBuffer = [RdsClientTypes.EventCategoriesMap]()
                    for structureContainer0 in eventCategoriesMapListContainer {
                        eventCategoriesMapListBuffer?.append(structureContainer0)
                    }
                }
                eventCategoriesMapList = eventCategoriesMapListBuffer
            } else {
                eventCategoriesMapList = []
            }
        } else {
            eventCategoriesMapList = nil
        }
    }
}

public struct DescribeEventSubscriptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

extension DescribeEventSubscriptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension DescribeEventSubscriptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("DescribeEventSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventSubscriptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventSubscriptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

public struct DescribeEventSubscriptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventSubscriptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEventSubscriptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEventSubscriptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventSubscriptionsOutputError>
}

///
public struct DescribeEventSubscriptionsInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribeOrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?
    ///
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the RDS event notification subscription you want to describe.
    public var subscriptionName: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.subscriptionName = subscriptionName
    }
}

extension DescribeEventSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSubscriptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventSubscriptionsOutputResponse(eventSubscriptionsList: \(Swift.String(describing: eventSubscriptionsList)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscriptionsList = output.eventSubscriptionsList
            self.marker = output.marker
        } else {
            self.eventSubscriptionsList = nil
            self.marker = nil
        }
    }
}

/// Data returned by the DescribeEventSubscriptions action.
public struct DescribeEventSubscriptionsOutputResponse: Swift.Equatable {
    /// A list of EventSubscriptions data types.
    public var eventSubscriptionsList: [RdsClientTypes.EventSubscription]?
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribeOrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        eventSubscriptionsList: [RdsClientTypes.EventSubscription]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.eventSubscriptionsList = eventSubscriptionsList
        self.marker = marker
    }
}

struct DescribeEventSubscriptionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let eventSubscriptionsList: [RdsClientTypes.EventSubscription]?
}

extension DescribeEventSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscriptionsList = "EventSubscriptionsList"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventSubscriptionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.eventSubscriptionsList) {
            struct KeyVal0{struct EventSubscription{}}
            let eventSubscriptionsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventSubscription>.CodingKeys.self, forKey: .eventSubscriptionsList)
            if let eventSubscriptionsListWrappedContainer = eventSubscriptionsListWrappedContainer {
                let eventSubscriptionsListContainer = try eventSubscriptionsListWrappedContainer.decodeIfPresent([RdsClientTypes.EventSubscription].self, forKey: .member)
                var eventSubscriptionsListBuffer:[RdsClientTypes.EventSubscription]? = nil
                if let eventSubscriptionsListContainer = eventSubscriptionsListContainer {
                    eventSubscriptionsListBuffer = [RdsClientTypes.EventSubscription]()
                    for structureContainer0 in eventSubscriptionsListContainer {
                        eventSubscriptionsListBuffer?.append(structureContainer0)
                    }
                }
                eventSubscriptionsList = eventSubscriptionsListBuffer
            } else {
                eventSubscriptionsList = []
            }
        } else {
            eventSubscriptionsList = nil
        }
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(duration: \(Swift.String(describing: duration)), endTime: \(Swift.String(describing: endTime)), eventCategories: \(Swift.String(describing: eventCategories)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)), startTime: \(Swift.String(describing: startTime)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let endTime = endTime {
            try container.encode(ClientRuntime.TimestampWrapper(endTime, format: .dateTime), forKey: ClientRuntime.Key("endTime"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        try container.encode("DescribeEvents", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEventsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEventsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

///
public struct DescribeEventsInput: Swift.Equatable {
    /// The number of minutes to retrieve events for.
    ///          Default: 60
    public var duration: Swift.Int?
    ///
    ///         The end of the time interval for which to retrieve events,
    ///         specified in ISO 8601 format. For more information about ISO 8601,
    ///         go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.
    ///
    ///          Example: 2009-07-08T18:00Z
    public var endTime: ClientRuntime.Date?
    /// A list of event categories that trigger notifications for a event notification subscription.
    public var eventCategories: [Swift.String]?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous
    ///         DescribeEvents request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response.
    ///         If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///         you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The identifier of the event source for which events are returned. If not specified, then all sources are included in the response.
    ///          Constraints:
    ///
    ///
    ///                If SourceIdentifier is supplied, SourceType must also be provided.
    ///
    ///
    ///                If the source type is a DB instance, a DBInstanceIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB cluster, a DBClusterIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB parameter group, a DBParameterGroupName value must be supplied.
    ///
    ///
    ///                If the source type is a DB security group, a DBSecurityGroupName value must be supplied.
    ///
    ///
    ///                If the source type is a DB snapshot, a DBSnapshotIdentifier value must be supplied.
    ///
    ///
    ///                If the source type is a DB cluster snapshot, a DBClusterSnapshotIdentifier value must be supplied.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    public var sourceIdentifier: Swift.String?
    /// The event source to retrieve events for. If no value is specified, all events are returned.
    public var sourceType: RdsClientTypes.SourceType?
    ///
    ///         The beginning of the time interval to retrieve events for,
    ///         specified in ISO 8601 format. For more information about ISO 8601,
    ///         go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.
    ///
    ///          Example: 2009-07-08T18:00Z
    public var startTime: ClientRuntime.Date?

    public init (
        duration: Swift.Int? = nil,
        endTime: ClientRuntime.Date? = nil,
        eventCategories: [Swift.String]? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceIdentifier: Swift.String? = nil,
        sourceType: RdsClientTypes.SourceType? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.eventCategories = eventCategories
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceIdentifier = sourceIdentifier
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(events: \(Swift.String(describing: events)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.marker = output.marker
        } else {
            self.events = nil
            self.marker = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeEvents action.
///
public struct DescribeEventsOutputResponse: Swift.Equatable {
    ///
    ///         A list of Event instances.
    ///
    public var events: [RdsClientTypes.Event]?
    ///
    ///             An optional pagination token provided by a previous
    ///             Events request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?

    public init (
        events: [RdsClientTypes.Event]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.events = events
        self.marker = marker
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let events: [RdsClientTypes.Event]?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeEventsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.events) {
            struct KeyVal0{struct Event{}}
            let eventsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Event>.CodingKeys.self, forKey: .events)
            if let eventsWrappedContainer = eventsWrappedContainer {
                let eventsContainer = try eventsWrappedContainer.decodeIfPresent([RdsClientTypes.Event].self, forKey: .member)
                var eventsBuffer:[RdsClientTypes.Event]? = nil
                if let eventsContainer = eventsContainer {
                    eventsBuffer = [RdsClientTypes.Event]()
                    for structureContainer0 in eventsContainer {
                        eventsBuffer?.append(structureContainer0)
                    }
                }
                events = eventsBuffer
            } else {
                events = []
            }
        } else {
            events = nil
        }
    }
}

public struct DescribeExportTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExportTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExportTasksOutputError>
}

extension DescribeExportTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExportTasksInput(exportTaskIdentifier: \(Swift.String(describing: exportTaskIdentifier)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), sourceArn: \(Swift.String(describing: sourceArn)))"}
}

extension DescribeExportTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        try container.encode("DescribeExportTasks", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeExportTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExportTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExportTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeExportTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeExportTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeExportTasksInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeExportTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeExportTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeExportTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeExportTasksOutputError>
}

public struct DescribeExportTasksInput: Swift.Equatable {
    /// The identifier of the snapshot export task to be described.
    public var exportTaskIdentifier: Swift.String?
    /// Filters specify one or more snapshot exports to describe. The filters are specified as name-value pairs that define what to
    ///             include in the output. Filter names and values are case-sensitive.
    ///         Supported filters include the following:
    ///
    ///
    ///
    ///                   export-task-identifier - An identifier for the snapshot export task.
    ///
    ///
    ///
    ///                   s3-bucket - The Amazon S3 bucket the snapshot is exported to.
    ///
    ///
    ///
    ///                   source-arn - The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3
    ///
    ///
    ///
    ///                     status - The status of the export task. Must be lowercase, for example, complete.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///             An optional pagination token provided by a previous DescribeExportTasks request.
    ///             If you specify this parameter, the response includes only records beyond the marker,
    ///             up to the value specified by the MaxRecords parameter.
    ///
    public var marker: Swift.String?
    ///
    ///             The maximum number of records to include in the response. If more records exist than the
    ///             specified value, a pagination token called a marker is included in the response.
    ///             You can use the marker in a later DescribeExportTasks request
    ///             to retrieve the remaining results.
    ///
    ///         Default: 100
    ///         Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
    public var sourceArn: Swift.String?

    public init (
        exportTaskIdentifier: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.exportTaskIdentifier = exportTaskIdentifier
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.sourceArn = sourceArn
    }
}

extension DescribeExportTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeExportTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExportTaskNotFound" : self = .exportTaskNotFoundFault(try ExportTaskNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExportTasksOutputError: Swift.Error, Swift.Equatable {
    case exportTaskNotFoundFault(ExportTaskNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExportTasksOutputResponse(exportTasks: \(Swift.String(describing: exportTasks)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeExportTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeExportTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportTasks = output.exportTasks
            self.marker = output.marker
        } else {
            self.exportTasks = nil
            self.marker = nil
        }
    }
}

public struct DescribeExportTasksOutputResponse: Swift.Equatable {
    /// Information about an export of a snapshot to Amazon S3.
    public var exportTasks: [RdsClientTypes.ExportTask]?
    /// A pagination token that can be used in a later DescribeExportTasks
    ///             request. A marker is used for pagination to identify the location to begin output for
    ///             the next response of DescribeExportTasks.
    public var marker: Swift.String?

    public init (
        exportTasks: [RdsClientTypes.ExportTask]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.exportTasks = exportTasks
        self.marker = marker
    }
}

struct DescribeExportTasksOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let exportTasks: [RdsClientTypes.ExportTask]?
}

extension DescribeExportTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportTasks = "ExportTasks"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeExportTasksResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.exportTasks) {
            struct KeyVal0{struct ExportTask{}}
            let exportTasksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ExportTask>.CodingKeys.self, forKey: .exportTasks)
            if let exportTasksWrappedContainer = exportTasksWrappedContainer {
                let exportTasksContainer = try exportTasksWrappedContainer.decodeIfPresent([RdsClientTypes.ExportTask].self, forKey: .member)
                var exportTasksBuffer:[RdsClientTypes.ExportTask]? = nil
                if let exportTasksContainer = exportTasksContainer {
                    exportTasksBuffer = [RdsClientTypes.ExportTask]()
                    for structureContainer0 in exportTasksContainer {
                        exportTasksBuffer?.append(structureContainer0)
                    }
                }
                exportTasks = exportTasksBuffer
            } else {
                exportTasks = []
            }
        } else {
            exportTasks = nil
        }
    }
}

public struct DescribeGlobalClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalClustersOutputError>
}

extension DescribeGlobalClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalClustersInput(filters: \(Swift.String(describing: filters)), globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeGlobalClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeGlobalClusters", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeGlobalClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalClustersOutputError>
}

public struct DescribeGlobalClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalClustersOutputError>
}

public struct DescribeGlobalClustersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalClustersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeGlobalClustersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalClustersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalClustersOutputError>
}

public struct DescribeGlobalClustersInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         The user-supplied DB cluster identifier. If this parameter is specified, information from only the specific DB cluster is returned. This parameter isn't case-sensitive.
    ///
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match an existing DBClusterIdentifier.
    ///
    ///
    public var globalClusterIdentifier: Swift.String?
    ///
    ///         An optional pagination token provided by a previous DescribeGlobalClusters request. If
    ///         this parameter is specified, the response includes only records beyond the marker, up to the value
    ///         specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///         The maximum number of records to include in the response. If more records exist than the specified
    ///         MaxRecords value, a pagination token called a marker is included in the response so that
    ///        you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.globalClusterIdentifier = globalClusterIdentifier
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeGlobalClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeGlobalClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalClustersOutputError: Swift.Error, Swift.Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalClustersOutputResponse(globalClusters: \(Swift.String(describing: globalClusters)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeGlobalClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGlobalClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalClusters = output.globalClusters
            self.marker = output.marker
        } else {
            self.globalClusters = nil
            self.marker = nil
        }
    }
}

public struct DescribeGlobalClustersOutputResponse: Swift.Equatable {
    ///
    ///         The list of global clusters returned by this request.
    ///
    public var globalClusters: [RdsClientTypes.GlobalCluster]?
    ///
    ///         An optional pagination token provided by a previous DescribeGlobalClusters request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker, up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?

    public init (
        globalClusters: [RdsClientTypes.GlobalCluster]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.globalClusters = globalClusters
        self.marker = marker
    }
}

struct DescribeGlobalClustersOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let globalClusters: [RdsClientTypes.GlobalCluster]?
}

extension DescribeGlobalClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalClusters = "GlobalClusters"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeGlobalClustersResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.globalClusters) {
            struct KeyVal0{struct GlobalClusterMember{}}
            let globalClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.GlobalClusterMember>.CodingKeys.self, forKey: .globalClusters)
            if let globalClustersWrappedContainer = globalClustersWrappedContainer {
                let globalClustersContainer = try globalClustersWrappedContainer.decodeIfPresent([RdsClientTypes.GlobalCluster].self, forKey: .member)
                var globalClustersBuffer:[RdsClientTypes.GlobalCluster]? = nil
                if let globalClustersContainer = globalClustersContainer {
                    globalClustersBuffer = [RdsClientTypes.GlobalCluster]()
                    for structureContainer0 in globalClustersContainer {
                        globalClustersBuffer?.append(structureContainer0)
                    }
                }
                globalClusters = globalClustersBuffer
            } else {
                globalClusters = []
            }
        } else {
            globalClusters = nil
        }
    }
}

public struct DescribeInstallationMediaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstallationMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstallationMediaOutputError>
}

extension DescribeInstallationMediaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstallationMediaInput(filters: \(Swift.String(describing: filters)), installationMediaId: \(Swift.String(describing: installationMediaId)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeInstallationMediaInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: ClientRuntime.Key("InstallationMediaId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeInstallationMedia", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeInstallationMediaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstallationMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstallationMediaOutputError>
}

public struct DescribeInstallationMediaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstallationMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstallationMediaOutputError>
}

public struct DescribeInstallationMediaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeInstallationMediaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeInstallationMediaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeInstallationMediaInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeInstallationMediaOutputError>
}

public struct DescribeInstallationMediaInput: Swift.Equatable {
    /// A filter that specifies one or more installation media to describe. Supported filters
    ///           include the following:
    ///
    ///
    ///
    ///                     custom-availability-zone-id - Accepts custom Availability Zone (AZ)
    ///                     identifiers. The results list includes information about only the custom AZs
    ///                     identified by these identifiers.
    ///
    ///
    ///
    ///                   engine - Accepts database engines. The results list includes information about
    ///               only the database engines identified by these identifiers.
    ///               For more information about the valid engines for installation media, see ImportInstallationMedia.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    /// The installation medium ID.
    public var installationMediaId: Swift.String?
    /// An optional pagination token provided by a previous request.
    ///           If this parameter is specified, the response includes
    ///           only records beyond the marker,
    ///           up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// An optional pagination token provided by a previous DescribeInstallationMedia request.
    ///           If this parameter is specified, the response includes
    ///           only records beyond the marker, up to the value specified by MaxRecords.
    public var maxRecords: Swift.Int?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        installationMediaId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.filters = filters
        self.installationMediaId = installationMediaId
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeInstallationMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeInstallationMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InstallationMediaNotFound" : self = .installationMediaNotFoundFault(try InstallationMediaNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstallationMediaOutputError: Swift.Error, Swift.Equatable {
    case installationMediaNotFoundFault(InstallationMediaNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstallationMediaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeInstallationMediaOutputResponse(installationMedia: \(Swift.String(describing: installationMedia)), marker: \(Swift.String(describing: marker)))"}
}

extension DescribeInstallationMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.installationMedia = output.installationMedia
            self.marker = output.marker
        } else {
            self.installationMedia = nil
            self.marker = nil
        }
    }
}

public struct DescribeInstallationMediaOutputResponse: Swift.Equatable {
    /// The list of InstallationMedia objects for the Amazon Web Services account.
    public var installationMedia: [RdsClientTypes.InstallationMedia]?
    /// An optional pagination token provided by a previous
    ///           DescribeInstallationMedia request.
    ///           If this parameter is specified, the response includes
    ///           only records beyond the marker,
    ///           up to the value specified by MaxRecords.
    public var marker: Swift.String?

    public init (
        installationMedia: [RdsClientTypes.InstallationMedia]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.installationMedia = installationMedia
        self.marker = marker
    }
}

struct DescribeInstallationMediaOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let installationMedia: [RdsClientTypes.InstallationMedia]?
}

extension DescribeInstallationMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case installationMedia = "InstallationMedia"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeInstallationMediaResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.installationMedia) {
            struct KeyVal0{struct InstallationMedia{}}
            let installationMediaWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InstallationMedia>.CodingKeys.self, forKey: .installationMedia)
            if let installationMediaWrappedContainer = installationMediaWrappedContainer {
                let installationMediaContainer = try installationMediaWrappedContainer.decodeIfPresent([RdsClientTypes.InstallationMedia].self, forKey: .member)
                var installationMediaBuffer:[RdsClientTypes.InstallationMedia]? = nil
                if let installationMediaContainer = installationMediaContainer {
                    installationMediaBuffer = [RdsClientTypes.InstallationMedia]()
                    for structureContainer0 in installationMediaContainer {
                        installationMediaBuffer?.append(structureContainer0)
                    }
                }
                installationMedia = installationMediaBuffer
            } else {
                installationMedia = []
            }
        } else {
            installationMedia = nil
        }
    }
}

public struct DescribeOptionGroupOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOptionGroupOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOptionGroupOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupOptionsOutputError>
}

extension DescribeOptionGroupOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOptionGroupOptionsInput(engineName: \(Swift.String(describing: engineName)), filters: \(Swift.String(describing: filters)), majorEngineVersion: \(Swift.String(describing: majorEngineVersion)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)))"}
}

extension DescribeOptionGroupOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        try container.encode("DescribeOptionGroupOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeOptionGroupOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOptionGroupOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOptionGroupOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupOptionsOutputError>
}

public struct DescribeOptionGroupOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOptionGroupOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOptionGroupOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupOptionsOutputError>
}

public struct DescribeOptionGroupOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupOptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeOptionGroupOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOptionGroupOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupOptionsOutputError>
}

///
public struct DescribeOptionGroupOptionsInput: Swift.Equatable {
    /// A required parameter. Options available for the given engine name are described.
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    /// This member is required.
    public var engineName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// If specified, filters the results to include only options for the specified major engine version.
    public var majorEngineVersion: Swift.String?
    /// An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    public var marker: Swift.String?
    ///
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?

    public init (
        engineName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        majorEngineVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil
    )
    {
        self.engineName = engineName
        self.filters = filters
        self.majorEngineVersion = majorEngineVersion
        self.marker = marker
        self.maxRecords = maxRecords
    }
}

extension DescribeOptionGroupOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOptionGroupOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOptionGroupOptionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOptionGroupOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOptionGroupOptionsOutputResponse(marker: \(Swift.String(describing: marker)), optionGroupOptions: \(Swift.String(describing: optionGroupOptions)))"}
}

extension DescribeOptionGroupOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOptionGroupOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.optionGroupOptions = output.optionGroupOptions
        } else {
            self.marker = nil
            self.optionGroupOptions = nil
        }
    }
}

///
public struct DescribeOptionGroupOptionsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    public var marker: Swift.String?
    /// List of available option group options.
    public var optionGroupOptions: [RdsClientTypes.OptionGroupOption]?

    public init (
        marker: Swift.String? = nil,
        optionGroupOptions: [RdsClientTypes.OptionGroupOption]? = nil
    )
    {
        self.marker = marker
        self.optionGroupOptions = optionGroupOptions
    }
}

struct DescribeOptionGroupOptionsOutputResponseBody: Swift.Equatable {
    public let optionGroupOptions: [RdsClientTypes.OptionGroupOption]?
    public let marker: Swift.String?
}

extension DescribeOptionGroupOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case optionGroupOptions = "OptionGroupOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOptionGroupOptionsResult"))
        if containerValues.contains(.optionGroupOptions) {
            struct KeyVal0{struct OptionGroupOption{}}
            let optionGroupOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOption>.CodingKeys.self, forKey: .optionGroupOptions)
            if let optionGroupOptionsWrappedContainer = optionGroupOptionsWrappedContainer {
                let optionGroupOptionsContainer = try optionGroupOptionsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroupOption].self, forKey: .member)
                var optionGroupOptionsBuffer:[RdsClientTypes.OptionGroupOption]? = nil
                if let optionGroupOptionsContainer = optionGroupOptionsContainer {
                    optionGroupOptionsBuffer = [RdsClientTypes.OptionGroupOption]()
                    for structureContainer0 in optionGroupOptionsContainer {
                        optionGroupOptionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptions = optionGroupOptionsBuffer
            } else {
                optionGroupOptions = []
            }
        } else {
            optionGroupOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeOptionGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOptionGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOptionGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupsOutputError>
}

extension DescribeOptionGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOptionGroupsInput(engineName: \(Swift.String(describing: engineName)), filters: \(Swift.String(describing: filters)), majorEngineVersion: \(Swift.String(describing: majorEngineVersion)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), optionGroupName: \(Swift.String(describing: optionGroupName)))"}
}

extension DescribeOptionGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        try container.encode("DescribeOptionGroups", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeOptionGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOptionGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOptionGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupsOutputError>
}

public struct DescribeOptionGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOptionGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOptionGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupsOutputError>
}

public struct DescribeOptionGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOptionGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeOptionGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOptionGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOptionGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOptionGroupsOutputError>
}

///
public struct DescribeOptionGroupsInput: Swift.Equatable {
    /// Filters the list of option groups to only include groups associated with a specific database engine.
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    public var engineName: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// Filters the list of option groups to only include groups associated with a specific database engine version. If specified, then EngineName must also be specified.
    public var majorEngineVersion: Swift.String?
    ///
    ///             An optional pagination token provided by a previous DescribeOptionGroups request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The name of the option group to describe. Can't be supplied together with EngineName or MajorEngineVersion.
    public var optionGroupName: Swift.String?

    public init (
        engineName: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        majorEngineVersion: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        optionGroupName: Swift.String? = nil
    )
    {
        self.engineName = engineName
        self.filters = filters
        self.majorEngineVersion = majorEngineVersion
        self.marker = marker
        self.maxRecords = maxRecords
        self.optionGroupName = optionGroupName
    }
}

extension DescribeOptionGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOptionGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOptionGroupsOutputError: Swift.Error, Swift.Equatable {
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOptionGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOptionGroupsOutputResponse(marker: \(Swift.String(describing: marker)), optionGroupsList: \(Swift.String(describing: optionGroupsList)))"}
}

extension DescribeOptionGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOptionGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.optionGroupsList = output.optionGroupsList
        } else {
            self.marker = nil
            self.optionGroupsList = nil
        }
    }
}

/// List of option groups.
public struct DescribeOptionGroupsOutputResponse: Swift.Equatable {
    /// An optional pagination token provided by a previous request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// List of option groups.
    public var optionGroupsList: [RdsClientTypes.OptionGroup]?

    public init (
        marker: Swift.String? = nil,
        optionGroupsList: [RdsClientTypes.OptionGroup]? = nil
    )
    {
        self.marker = marker
        self.optionGroupsList = optionGroupsList
    }
}

struct DescribeOptionGroupsOutputResponseBody: Swift.Equatable {
    public let optionGroupsList: [RdsClientTypes.OptionGroup]?
    public let marker: Swift.String?
}

extension DescribeOptionGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case optionGroupsList = "OptionGroupsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOptionGroupsResult"))
        if containerValues.contains(.optionGroupsList) {
            struct KeyVal0{struct OptionGroup{}}
            let optionGroupsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroup>.CodingKeys.self, forKey: .optionGroupsList)
            if let optionGroupsListWrappedContainer = optionGroupsListWrappedContainer {
                let optionGroupsListContainer = try optionGroupsListWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroup].self, forKey: .member)
                var optionGroupsListBuffer:[RdsClientTypes.OptionGroup]? = nil
                if let optionGroupsListContainer = optionGroupsListContainer {
                    optionGroupsListBuffer = [RdsClientTypes.OptionGroup]()
                    for structureContainer0 in optionGroupsListContainer {
                        optionGroupsListBuffer?.append(structureContainer0)
                    }
                }
                optionGroupsList = optionGroupsListBuffer
            } else {
                optionGroupsList = []
            }
        } else {
            optionGroupsList = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeOrderableDBInstanceOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

extension DescribeOrderableDBInstanceOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableDBInstanceOptionsInput(availabilityZoneGroup: \(Swift.String(describing: availabilityZoneGroup)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), filters: \(Swift.String(describing: filters)), licenseModel: \(Swift.String(describing: licenseModel)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), vpc: \(Swift.String(describing: vpc)))"}
}

extension DescribeOrderableDBInstanceOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: ClientRuntime.Key("AvailabilityZoneGroup"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
        try container.encode("DescribeOrderableDBInstanceOptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeOrderableDBInstanceOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrderableDBInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

public struct DescribeOrderableDBInstanceOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrderableDBInstanceOptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeOrderableDBInstanceOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOrderableDBInstanceOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrderableDBInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrderableDBInstanceOptionsOutputError>
}

///
public struct DescribeOrderableDBInstanceOptionsInput: Swift.Equatable {
    /// The Availability Zone group associated with a Local Zone. Specify this parameter to retrieve available offerings for the Local Zones in the group.
    ///         Omit this parameter to show the available offerings in the specified Amazon Web Services Region.
    public var availabilityZoneGroup: Swift.String?
    /// The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.
    public var dBInstanceClass: Swift.String?
    /// The name of the engine to retrieve DB instance options for.
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   aurora (for MySQL 5.6-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-mysql (for MySQL 5.7-compatible Aurora)
    ///
    ///
    ///
    ///                   aurora-postgresql
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    /// This member is required.
    public var engine: Swift.String?
    /// The engine version filter value. Specify this parameter to show only the available offerings matching the specified engine version.
    public var engineVersion: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The license model filter value. Specify this parameter to show only the available offerings matching the specified license model.
    public var licenseModel: Swift.String?
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribeOrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?
    ///
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates whether to show only VPC or non-VPC offerings.
    public var vpc: Swift.Bool?

    public init (
        availabilityZoneGroup: Swift.String? = nil,
        dBInstanceClass: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        licenseModel: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        vpc: Swift.Bool? = nil
    )
    {
        self.availabilityZoneGroup = availabilityZoneGroup
        self.dBInstanceClass = dBInstanceClass
        self.engine = engine
        self.engineVersion = engineVersion
        self.filters = filters
        self.licenseModel = licenseModel
        self.marker = marker
        self.maxRecords = maxRecords
        self.vpc = vpc
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeOrderableDBInstanceOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrderableDBInstanceOptionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrderableDBInstanceOptionsOutputResponse(marker: \(Swift.String(describing: marker)), orderableDBInstanceOptions: \(Swift.String(describing: orderableDBInstanceOptions)))"}
}

extension DescribeOrderableDBInstanceOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrderableDBInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.orderableDBInstanceOptions = output.orderableDBInstanceOptions
        } else {
            self.marker = nil
            self.orderableDBInstanceOptions = nil
        }
    }
}

///
///             Contains the result of a successful invocation of the DescribeOrderableDBInstanceOptions action.
///
public struct DescribeOrderableDBInstanceOptionsOutputResponse: Swift.Equatable {
    ///
    ///             An optional pagination token provided by a previous
    ///             OrderableDBInstanceOptions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to the value specified by MaxRecords .
    ///
    public var marker: Swift.String?
    /// An OrderableDBInstanceOption structure containing information about orderable options for the DB instance.
    public var orderableDBInstanceOptions: [RdsClientTypes.OrderableDBInstanceOption]?

    public init (
        marker: Swift.String? = nil,
        orderableDBInstanceOptions: [RdsClientTypes.OrderableDBInstanceOption]? = nil
    )
    {
        self.marker = marker
        self.orderableDBInstanceOptions = orderableDBInstanceOptions
    }
}

struct DescribeOrderableDBInstanceOptionsOutputResponseBody: Swift.Equatable {
    public let orderableDBInstanceOptions: [RdsClientTypes.OrderableDBInstanceOption]?
    public let marker: Swift.String?
}

extension DescribeOrderableDBInstanceOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case orderableDBInstanceOptions = "OrderableDBInstanceOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeOrderableDBInstanceOptionsResult"))
        if containerValues.contains(.orderableDBInstanceOptions) {
            struct KeyVal0{struct OrderableDBInstanceOption{}}
            let orderableDBInstanceOptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OrderableDBInstanceOption>.CodingKeys.self, forKey: .orderableDBInstanceOptions)
            if let orderableDBInstanceOptionsWrappedContainer = orderableDBInstanceOptionsWrappedContainer {
                let orderableDBInstanceOptionsContainer = try orderableDBInstanceOptionsWrappedContainer.decodeIfPresent([RdsClientTypes.OrderableDBInstanceOption].self, forKey: .member)
                var orderableDBInstanceOptionsBuffer:[RdsClientTypes.OrderableDBInstanceOption]? = nil
                if let orderableDBInstanceOptionsContainer = orderableDBInstanceOptionsContainer {
                    orderableDBInstanceOptionsBuffer = [RdsClientTypes.OrderableDBInstanceOption]()
                    for structureContainer0 in orderableDBInstanceOptionsContainer {
                        orderableDBInstanceOptionsBuffer?.append(structureContainer0)
                    }
                }
                orderableDBInstanceOptions = orderableDBInstanceOptionsBuffer
            } else {
                orderableDBInstanceOptions = []
            }
        } else {
            orderableDBInstanceOptions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribePendingMaintenanceActionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

extension DescribePendingMaintenanceActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePendingMaintenanceActionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension DescribePendingMaintenanceActionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
        try container.encode("DescribePendingMaintenanceActions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribePendingMaintenanceActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePendingMaintenanceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

public struct DescribePendingMaintenanceActionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePendingMaintenanceActionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePendingMaintenanceActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePendingMaintenanceActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePendingMaintenanceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePendingMaintenanceActionsOutputError>
}

///
public struct DescribePendingMaintenanceActionsInput: Swift.Equatable {
    /// A filter that specifies one or more resources to return pending maintenance actions for.
    ///          Supported filters:
    ///
    ///
    ///
    ///                   db-cluster-id - Accepts DB cluster identifiers and DB
    ///               cluster Amazon Resource Names (ARNs). The results list will only include pending maintenance
    ///               actions for the DB clusters identified by these ARNs.
    ///
    ///
    ///
    ///                   db-instance-id - Accepts DB instance identifiers and DB
    ///             instance ARNs. The results list will only include pending maintenance
    ///             actions for the DB instances identified by these ARNs.
    ///
    ///
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribePendingMaintenanceActions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to a number of records specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///             The maximum number of records to include in the response.
    ///             If more records exist than the specified MaxRecords value,
    ///             a pagination token called a marker is included in the response so that
    ///             you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The ARN of a resource to return pending maintenance actions for.
    public var resourceIdentifier: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.resourceIdentifier = resourceIdentifier
    }
}

extension DescribePendingMaintenanceActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribePendingMaintenanceActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePendingMaintenanceActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePendingMaintenanceActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePendingMaintenanceActionsOutputResponse(marker: \(Swift.String(describing: marker)), pendingMaintenanceActions: \(Swift.String(describing: pendingMaintenanceActions)))"}
}

extension DescribePendingMaintenanceActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePendingMaintenanceActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.pendingMaintenanceActions = output.pendingMaintenanceActions
        } else {
            self.marker = nil
            self.pendingMaintenanceActions = nil
        }
    }
}

/// Data returned from the DescribePendingMaintenanceActions action.
public struct DescribePendingMaintenanceActionsOutputResponse: Swift.Equatable {
    ///
    ///             An optional pagination token provided by a previous
    ///             DescribePendingMaintenanceActions request.
    ///             If this parameter is specified, the response includes
    ///             only records beyond the marker,
    ///             up to a number of records specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// A list of the pending maintenance actions for the resource.
    public var pendingMaintenanceActions: [RdsClientTypes.ResourcePendingMaintenanceActions]?

    public init (
        marker: Swift.String? = nil,
        pendingMaintenanceActions: [RdsClientTypes.ResourcePendingMaintenanceActions]? = nil
    )
    {
        self.marker = marker
        self.pendingMaintenanceActions = pendingMaintenanceActions
    }
}

struct DescribePendingMaintenanceActionsOutputResponseBody: Swift.Equatable {
    public let pendingMaintenanceActions: [RdsClientTypes.ResourcePendingMaintenanceActions]?
    public let marker: Swift.String?
}

extension DescribePendingMaintenanceActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case pendingMaintenanceActions = "PendingMaintenanceActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribePendingMaintenanceActionsResult"))
        if containerValues.contains(.pendingMaintenanceActions) {
            struct KeyVal0{struct ResourcePendingMaintenanceActions{}}
            let pendingMaintenanceActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ResourcePendingMaintenanceActions>.CodingKeys.self, forKey: .pendingMaintenanceActions)
            if let pendingMaintenanceActionsWrappedContainer = pendingMaintenanceActionsWrappedContainer {
                let pendingMaintenanceActionsContainer = try pendingMaintenanceActionsWrappedContainer.decodeIfPresent([RdsClientTypes.ResourcePendingMaintenanceActions].self, forKey: .member)
                var pendingMaintenanceActionsBuffer:[RdsClientTypes.ResourcePendingMaintenanceActions]? = nil
                if let pendingMaintenanceActionsContainer = pendingMaintenanceActionsContainer {
                    pendingMaintenanceActionsBuffer = [RdsClientTypes.ResourcePendingMaintenanceActions]()
                    for structureContainer0 in pendingMaintenanceActionsContainer {
                        pendingMaintenanceActionsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActions = pendingMaintenanceActionsBuffer
            } else {
                pendingMaintenanceActions = []
            }
        } else {
            pendingMaintenanceActions = nil
        }
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

public struct DescribeReservedDBInstancesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOutputError>
}

extension DescribeReservedDBInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedDBInstancesInput(dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), duration: \(Swift.String(describing: duration)), filters: \(Swift.String(describing: filters)), leaseId: \(Swift.String(describing: leaseId)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), multiAZ: \(Swift.String(describing: multiAZ)), offeringType: \(Swift.String(describing: offeringType)), productDescription: \(Swift.String(describing: productDescription)), reservedDBInstanceId: \(Swift.String(describing: reservedDBInstanceId)), reservedDBInstancesOfferingId: \(Swift.String(describing: reservedDBInstancesOfferingId)))"}
}

extension DescribeReservedDBInstancesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let leaseId = leaseId {
            try container.encode(leaseId, forKey: ClientRuntime.Key("LeaseId"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: ClientRuntime.Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        try container.encode("DescribeReservedDBInstances", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeReservedDBInstancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOutputError>
}

public struct DescribeReservedDBInstancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOutputError>
}

public struct DescribeReservedDBInstancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeReservedDBInstancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeReservedDBInstancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOutputError>
}

///
public struct DescribeReservedDBInstancesInput: Swift.Equatable {
    /// The DB instance class filter value. Specify this parameter to show only those reservations matching the specified DB instances class.
    public var dBInstanceClass: Swift.String?
    /// The duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration.
    ///          Valid Values: 1 | 3 | 31536000 | 94608000
    ///
    public var duration: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The lease identifier filter value. Specify this parameter to show only the reservation that matches the specified lease ID.
    ///
    ///             Amazon Web Services Support might request the lease ID for an issue related to a reserved DB instance.
    ///
    public var leaseId: Swift.String?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///     The maximum number of records to include in the response.
    ///     If more than the MaxRecords value is available, a pagination token called a marker is
    ///           included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates whether to show only those reservations that support Multi-AZ.
    public var multiAZ: Swift.Bool?
    /// The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type.
    ///          Valid Values: "Partial Upfront" | "All Upfront" | "No Upfront"
    ///
    public var offeringType: Swift.String?
    /// The product description filter value. Specify this parameter to show only those reservations matching the specified product description.
    public var productDescription: Swift.String?
    /// The reserved DB instance identifier filter value. Specify this parameter to show only the reservation that matches the specified reservation ID.
    public var reservedDBInstanceId: Swift.String?
    /// The offering identifier filter value. Specify this parameter to show only purchased reservations matching the specified offering identifier.
    public var reservedDBInstancesOfferingId: Swift.String?

    public init (
        dBInstanceClass: Swift.String? = nil,
        duration: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        leaseId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        multiAZ: Swift.Bool? = nil,
        offeringType: Swift.String? = nil,
        productDescription: Swift.String? = nil,
        reservedDBInstanceId: Swift.String? = nil,
        reservedDBInstancesOfferingId: Swift.String? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.filters = filters
        self.leaseId = leaseId
        self.marker = marker
        self.maxRecords = maxRecords
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
    }
}

public struct DescribeReservedDBInstancesOfferingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesOfferingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

extension DescribeReservedDBInstancesOfferingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedDBInstancesOfferingsInput(dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), duration: \(Swift.String(describing: duration)), filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), multiAZ: \(Swift.String(describing: multiAZ)), offeringType: \(Swift.String(describing: offeringType)), productDescription: \(Swift.String(describing: productDescription)), reservedDBInstancesOfferingId: \(Swift.String(describing: reservedDBInstancesOfferingId)))"}
}

extension DescribeReservedDBInstancesOfferingsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let duration = duration {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        try container.encode("DescribeReservedDBInstancesOfferings", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeReservedDBInstancesOfferingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesOfferingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

public struct DescribeReservedDBInstancesOfferingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesOfferingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReservedDBInstancesOfferingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

public struct DescribeReservedDBInstancesOfferingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReservedDBInstancesOfferingsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeReservedDBInstancesOfferingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeReservedDBInstancesOfferingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReservedDBInstancesOfferingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReservedDBInstancesOfferingsOutputError>
}

///
public struct DescribeReservedDBInstancesOfferingsInput: Swift.Equatable {
    /// The DB instance class filter value. Specify this parameter to show only the available offerings matching the specified DB instance class.
    public var dBInstanceClass: Swift.String?
    /// Duration filter value, specified in years or seconds. Specify this parameter to show only reservations for this duration.
    ///          Valid Values: 1 | 3 | 31536000 | 94608000
    ///
    public var duration: Swift.String?
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    ///
    ///     The maximum number of records to include in the response.
    ///     If more than the MaxRecords value is available, a pagination token called a marker is
    ///     included in the response so you can retrieve the remaining results.
    ///
    ///          Default: 100
    ///          Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// A value that indicates whether to show only those reservations that support Multi-AZ.
    public var multiAZ: Swift.Bool?
    /// The offering type filter value. Specify this parameter to show only the available offerings matching the specified offering type.
    ///          Valid Values: "Partial Upfront" | "All Upfront" | "No Upfront"
    ///
    public var offeringType: Swift.String?
    /// Product description filter value. Specify this parameter to show only the available offerings that contain the specified product description.
    ///
    ///             The results show offerings that partially match the filter value.
    ///
    public var productDescription: Swift.String?
    /// The offering identifier filter value. Specify this parameter to show only the available offering that matches the specified reservation identifier.
    ///          Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706
    ///
    public var reservedDBInstancesOfferingId: Swift.String?

    public init (
        dBInstanceClass: Swift.String? = nil,
        duration: Swift.String? = nil,
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        multiAZ: Swift.Bool? = nil,
        offeringType: Swift.String? = nil,
        productDescription: Swift.String? = nil,
        reservedDBInstancesOfferingId: Swift.String? = nil
    )
    {
        self.dBInstanceClass = dBInstanceClass
        self.duration = duration
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.multiAZ = multiAZ
        self.offeringType = offeringType
        self.productDescription = productDescription
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
    }
}

extension DescribeReservedDBInstancesOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedDBInstancesOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedDBInstancesOfferingNotFound" : self = .reservedDBInstancesOfferingNotFoundFault(try ReservedDBInstancesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedDBInstancesOfferingsOutputError: Swift.Error, Swift.Equatable {
    case reservedDBInstancesOfferingNotFoundFault(ReservedDBInstancesOfferingNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedDBInstancesOfferingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedDBInstancesOfferingsOutputResponse(marker: \(Swift.String(describing: marker)), reservedDBInstancesOfferings: \(Swift.String(describing: reservedDBInstancesOfferings)))"}
}

extension DescribeReservedDBInstancesOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedDBInstancesOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedDBInstancesOfferings = output.reservedDBInstancesOfferings
        } else {
            self.marker = nil
            self.reservedDBInstancesOfferings = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeReservedDBInstancesOfferings action.
///
public struct DescribeReservedDBInstancesOfferingsOutputResponse: Swift.Equatable {
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// A list of reserved DB instance offerings.
    public var reservedDBInstancesOfferings: [RdsClientTypes.ReservedDBInstancesOffering]?

    public init (
        marker: Swift.String? = nil,
        reservedDBInstancesOfferings: [RdsClientTypes.ReservedDBInstancesOffering]? = nil
    )
    {
        self.marker = marker
        self.reservedDBInstancesOfferings = reservedDBInstancesOfferings
    }
}

struct DescribeReservedDBInstancesOfferingsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let reservedDBInstancesOfferings: [RdsClientTypes.ReservedDBInstancesOffering]?
}

extension DescribeReservedDBInstancesOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedDBInstancesOfferings = "ReservedDBInstancesOfferings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeReservedDBInstancesOfferingsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedDBInstancesOfferings) {
            struct KeyVal0{struct ReservedDBInstancesOffering{}}
            let reservedDBInstancesOfferingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedDBInstancesOffering>.CodingKeys.self, forKey: .reservedDBInstancesOfferings)
            if let reservedDBInstancesOfferingsWrappedContainer = reservedDBInstancesOfferingsWrappedContainer {
                let reservedDBInstancesOfferingsContainer = try reservedDBInstancesOfferingsWrappedContainer.decodeIfPresent([RdsClientTypes.ReservedDBInstancesOffering].self, forKey: .member)
                var reservedDBInstancesOfferingsBuffer:[RdsClientTypes.ReservedDBInstancesOffering]? = nil
                if let reservedDBInstancesOfferingsContainer = reservedDBInstancesOfferingsContainer {
                    reservedDBInstancesOfferingsBuffer = [RdsClientTypes.ReservedDBInstancesOffering]()
                    for structureContainer0 in reservedDBInstancesOfferingsContainer {
                        reservedDBInstancesOfferingsBuffer?.append(structureContainer0)
                    }
                }
                reservedDBInstancesOfferings = reservedDBInstancesOfferingsBuffer
            } else {
                reservedDBInstancesOfferings = []
            }
        } else {
            reservedDBInstancesOfferings = nil
        }
    }
}

extension DescribeReservedDBInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeReservedDBInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedDBInstanceNotFound" : self = .reservedDBInstanceNotFoundFault(try ReservedDBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedDBInstancesOutputError: Swift.Error, Swift.Equatable {
    case reservedDBInstanceNotFoundFault(ReservedDBInstanceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedDBInstancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReservedDBInstancesOutputResponse(marker: \(Swift.String(describing: marker)), reservedDBInstances: \(Swift.String(describing: reservedDBInstances)))"}
}

extension DescribeReservedDBInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedDBInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.reservedDBInstances = output.reservedDBInstances
        } else {
            self.marker = nil
            self.reservedDBInstances = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the DescribeReservedDBInstances action.
///
public struct DescribeReservedDBInstancesOutputResponse: Swift.Equatable {
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// A list of reserved DB instances.
    public var reservedDBInstances: [RdsClientTypes.ReservedDBInstance]?

    public init (
        marker: Swift.String? = nil,
        reservedDBInstances: [RdsClientTypes.ReservedDBInstance]? = nil
    )
    {
        self.marker = marker
        self.reservedDBInstances = reservedDBInstances
    }
}

struct DescribeReservedDBInstancesOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let reservedDBInstances: [RdsClientTypes.ReservedDBInstance]?
}

extension DescribeReservedDBInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case reservedDBInstances = "ReservedDBInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeReservedDBInstancesResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.reservedDBInstances) {
            struct KeyVal0{struct ReservedDBInstance{}}
            let reservedDBInstancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReservedDBInstance>.CodingKeys.self, forKey: .reservedDBInstances)
            if let reservedDBInstancesWrappedContainer = reservedDBInstancesWrappedContainer {
                let reservedDBInstancesContainer = try reservedDBInstancesWrappedContainer.decodeIfPresent([RdsClientTypes.ReservedDBInstance].self, forKey: .member)
                var reservedDBInstancesBuffer:[RdsClientTypes.ReservedDBInstance]? = nil
                if let reservedDBInstancesContainer = reservedDBInstancesContainer {
                    reservedDBInstancesBuffer = [RdsClientTypes.ReservedDBInstance]()
                    for structureContainer0 in reservedDBInstancesContainer {
                        reservedDBInstancesBuffer?.append(structureContainer0)
                    }
                }
                reservedDBInstances = reservedDBInstancesBuffer
            } else {
                reservedDBInstances = []
            }
        } else {
            reservedDBInstances = nil
        }
    }
}

public struct DescribeSourceRegionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceRegionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSourceRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSourceRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceRegionsOutputError>
}

extension DescribeSourceRegionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSourceRegionsInput(filters: \(Swift.String(describing: filters)), marker: \(Swift.String(describing: marker)), maxRecords: \(Swift.String(describing: maxRecords)), regionName: \(Swift.String(describing: regionName)))"}
}

extension DescribeSourceRegionsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxRecords = maxRecords {
            try container.encode(maxRecords, forKey: ClientRuntime.Key("MaxRecords"))
        }
        if let regionName = regionName {
            try container.encode(regionName, forKey: ClientRuntime.Key("RegionName"))
        }
        try container.encode("DescribeSourceRegions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeSourceRegionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceRegionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSourceRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSourceRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceRegionsOutputError>
}

public struct DescribeSourceRegionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceRegionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSourceRegionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSourceRegionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceRegionsOutputError>
}

public struct DescribeSourceRegionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSourceRegionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSourceRegionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSourceRegionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSourceRegionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSourceRegionsOutputError>
}

///
public struct DescribeSourceRegionsInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// An optional pagination token provided by a previous DescribeSourceRegions request. If this parameter is specified, the response
    ///             includes only records beyond the marker, up to the value specified by
    ///             MaxRecords.
    public var marker: Swift.String?
    /// The maximum number of records to include in the response. If more records exist
    ///             than the specified MaxRecords value, a pagination token called a marker is
    ///             included in the response so you can retrieve the remaining results.
    ///         Default: 100
    ///         Constraints: Minimum 20, maximum 100.
    public var maxRecords: Swift.Int?
    /// The source Amazon Web Services Region name. For example, us-east-1.
    ///         Constraints:
    ///
    ///
    ///                 Must specify a valid Amazon Web Services Region name.
    ///
    ///
    public var regionName: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        marker: Swift.String? = nil,
        maxRecords: Swift.Int? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.marker = marker
        self.maxRecords = maxRecords
        self.regionName = regionName
    }
}

extension DescribeSourceRegionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSourceRegionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceRegionsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceRegionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSourceRegionsOutputResponse(marker: \(Swift.String(describing: marker)), sourceRegions: \(Swift.String(describing: sourceRegions)))"}
}

extension DescribeSourceRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSourceRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.sourceRegions = output.sourceRegions
        } else {
            self.marker = nil
            self.sourceRegions = nil
        }
    }
}

/// Contains the result of a successful invocation of the DescribeSourceRegions action.
public struct DescribeSourceRegionsOutputResponse: Swift.Equatable {
    ///
    ///         An optional pagination token provided by a previous request.
    ///         If this parameter is specified, the response includes
    ///         only records beyond the marker,
    ///         up to the value specified by MaxRecords.
    ///
    public var marker: Swift.String?
    /// A list of SourceRegion instances that contains each source Amazon Web Services Region that the
    ///             current Amazon Web Services Region can get a read replica or a DB snapshot from.
    public var sourceRegions: [RdsClientTypes.SourceRegion]?

    public init (
        marker: Swift.String? = nil,
        sourceRegions: [RdsClientTypes.SourceRegion]? = nil
    )
    {
        self.marker = marker
        self.sourceRegions = sourceRegions
    }
}

struct DescribeSourceRegionsOutputResponseBody: Swift.Equatable {
    public let marker: Swift.String?
    public let sourceRegions: [RdsClientTypes.SourceRegion]?
}

extension DescribeSourceRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case sourceRegions = "SourceRegions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeSourceRegionsResult"))
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.sourceRegions) {
            struct KeyVal0{struct SourceRegion{}}
            let sourceRegionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceRegion>.CodingKeys.self, forKey: .sourceRegions)
            if let sourceRegionsWrappedContainer = sourceRegionsWrappedContainer {
                let sourceRegionsContainer = try sourceRegionsWrappedContainer.decodeIfPresent([RdsClientTypes.SourceRegion].self, forKey: .member)
                var sourceRegionsBuffer:[RdsClientTypes.SourceRegion]? = nil
                if let sourceRegionsContainer = sourceRegionsContainer {
                    sourceRegionsBuffer = [RdsClientTypes.SourceRegion]()
                    for structureContainer0 in sourceRegionsContainer {
                        sourceRegionsBuffer?.append(structureContainer0)
                    }
                }
                sourceRegions = sourceRegionsBuffer
            } else {
                sourceRegions = []
            }
        } else {
            sourceRegions = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

extension DescribeValidDBInstanceModificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeValidDBInstanceModificationsInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)))"}
}

extension DescribeValidDBInstanceModificationsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        try container.encode("DescribeValidDBInstanceModifications", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DescribeValidDBInstanceModificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeValidDBInstanceModificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

public struct DescribeValidDBInstanceModificationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeValidDBInstanceModificationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeValidDBInstanceModificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeValidDBInstanceModificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeValidDBInstanceModificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeValidDBInstanceModificationsOutputError>
}

///
public struct DescribeValidDBInstanceModificationsInput: Swift.Equatable {
    /// The customer identifier or the ARN of your DB instance.
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

extension DescribeValidDBInstanceModificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeValidDBInstanceModificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeValidDBInstanceModificationsOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeValidDBInstanceModificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeValidDBInstanceModificationsOutputResponse(validDBInstanceModificationsMessage: \(Swift.String(describing: validDBInstanceModificationsMessage)))"}
}

extension DescribeValidDBInstanceModificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeValidDBInstanceModificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.validDBInstanceModificationsMessage = output.validDBInstanceModificationsMessage
        } else {
            self.validDBInstanceModificationsMessage = nil
        }
    }
}

public struct DescribeValidDBInstanceModificationsOutputResponse: Swift.Equatable {
    /// Information about valid modifications that you can make to your DB instance.
    ///             Contains the result of a successful call to the
    ///             DescribeValidDBInstanceModifications action.
    ///             You can use this information when you call
    ///             ModifyDBInstance.
    ///
    public var validDBInstanceModificationsMessage: RdsClientTypes.ValidDBInstanceModificationsMessage?

    public init (
        validDBInstanceModificationsMessage: RdsClientTypes.ValidDBInstanceModificationsMessage? = nil
    )
    {
        self.validDBInstanceModificationsMessage = validDBInstanceModificationsMessage
    }
}

struct DescribeValidDBInstanceModificationsOutputResponseBody: Swift.Equatable {
    public let validDBInstanceModificationsMessage: RdsClientTypes.ValidDBInstanceModificationsMessage?
}

extension DescribeValidDBInstanceModificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validDBInstanceModificationsMessage = "ValidDBInstanceModificationsMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeValidDBInstanceModificationsResult"))
        let validDBInstanceModificationsMessageDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ValidDBInstanceModificationsMessage.self, forKey: .validDBInstanceModificationsMessage)
        validDBInstanceModificationsMessage = validDBInstanceModificationsMessageDecoded
    }
}

extension RdsClientTypes.DomainMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case fQDN = "FQDN"
        case iAMRoleName = "IAMRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let fQDN = fQDN {
            try container.encode(fQDN, forKey: ClientRuntime.Key("FQDN"))
        }
        if let iAMRoleName = iAMRoleName {
            try container.encode(iAMRoleName, forKey: ClientRuntime.Key("IAMRoleName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let fQDNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fQDN)
        fQDN = fQDNDecoded
        let iAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iAMRoleName)
        iAMRoleName = iAMRoleNameDecoded
    }
}

extension RdsClientTypes.DomainMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainMembership(domain: \(Swift.String(describing: domain)), fQDN: \(Swift.String(describing: fQDN)), iAMRoleName: \(Swift.String(describing: iAMRoleName)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// An Active Directory Domain membership record associated with the DB instance or cluster.
    public struct DomainMembership: Swift.Equatable {
        /// The identifier of the Active Directory Domain.
        public var domain: Swift.String?
        /// The fully qualified domain name of the Active Directory Domain.
        public var fQDN: Swift.String?
        /// The name of the IAM role to be used when making API calls to the Directory Service.
        public var iAMRoleName: Swift.String?
        /// The status of the Active Directory Domain membership for the DB instance or cluster. Values include joined, pending-join, failed, and so on.
        public var status: Swift.String?

        public init (
            domain: Swift.String? = nil,
            fQDN: Swift.String? = nil,
            iAMRoleName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.domain = domain
            self.fQDN = fQDN
            self.iAMRoleName = iAMRoleName
            self.status = status
        }
    }

}

extension DomainNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension DomainNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<DomainNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             Domain doesn't refer to an existing Active Directory domain.
///
public struct DomainNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DomainNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DomainNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.DoubleRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if from != 0.0 {
            try container.encode(Swift.String(from), forKey: ClientRuntime.Key("From"))
        }
        if to != 0.0 {
            try container.encode(Swift.String(to), forKey: ClientRuntime.Key("To"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Swift.Double.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Swift.Double.self, forKey: .to)
        to = toDecoded
    }
}

extension RdsClientTypes.DoubleRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DoubleRange(from: \(Swift.String(describing: from)), to: \(Swift.String(describing: to)))"}
}

extension RdsClientTypes {
    /// A range of double values.
    public struct DoubleRange: Swift.Equatable {
        /// The minimum value in the range.
        public var from: Swift.Double
        /// The maximum value in the range.
        public var to: Swift.Double

        public init (
            from: Swift.Double = 0.0,
            to: Swift.Double = 0.0
        )
        {
            self.from = from
            self.to = to
        }
    }

}

public struct DownloadDBLogFilePortionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DownloadDBLogFilePortionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DownloadDBLogFilePortionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DownloadDBLogFilePortionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DownloadDBLogFilePortionOutputError>
}

extension DownloadDBLogFilePortionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DownloadDBLogFilePortionInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), logFileName: \(Swift.String(describing: logFileName)), marker: \(Swift.String(describing: marker)), numberOfLines: \(Swift.String(describing: numberOfLines)))"}
}

extension DownloadDBLogFilePortionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let logFileName = logFileName {
            try container.encode(logFileName, forKey: ClientRuntime.Key("LogFileName"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if numberOfLines != 0 {
            try container.encode(numberOfLines, forKey: ClientRuntime.Key("NumberOfLines"))
        }
        try container.encode("DownloadDBLogFilePortion", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DownloadDBLogFilePortionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DownloadDBLogFilePortionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DownloadDBLogFilePortionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DownloadDBLogFilePortionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DownloadDBLogFilePortionOutputError>
}

public struct DownloadDBLogFilePortionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DownloadDBLogFilePortionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DownloadDBLogFilePortionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DownloadDBLogFilePortionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DownloadDBLogFilePortionOutputError>
}

public struct DownloadDBLogFilePortionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DownloadDBLogFilePortionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DownloadDBLogFilePortionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DownloadDBLogFilePortionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DownloadDBLogFilePortionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DownloadDBLogFilePortionOutputError>
}

///
public struct DownloadDBLogFilePortionInput: Swift.Equatable {
    /// The customer-assigned name of the DB instance that contains the log files you want to list.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBInstance.
    ///
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the log file to be downloaded.
    /// This member is required.
    public var logFileName: Swift.String?
    /// The pagination token provided in the previous request or "0". If the Marker parameter is specified the response includes only records beyond the marker until the end of the file or up to NumberOfLines.
    public var marker: Swift.String?
    /// The number of lines to download. If the number of lines specified results in a file over 1 MB in size, the file is truncated at 1 MB in size.
    ///          If the NumberOfLines parameter is specified, then the block of lines returned can be from the beginning
    ///             or the end of the log file, depending on the value of the Marker parameter.
    ///
    ///
    ///                If neither Marker or NumberOfLines are specified, the entire log file is returned up to a
    ///               maximum of 10000 lines, starting with the most recent log entries first.
    ///
    ///
    ///                If
    ///               NumberOfLines is specified and Marker isn't specified, then the most recent lines from the end
    ///                     of the log file are returned.
    ///
    ///
    ///                If Marker is specified as "0", then the specified
    ///                       number of lines from the beginning of the log file are returned.
    ///
    ///
    ///                You can
    ///                         download the log file in blocks of lines by specifying the size of the block using
    ///                     the NumberOfLines parameter, and by specifying a value of "0" for the Marker parameter in your
    ///                     first request. Include the Marker value returned in the response as the Marker value for the next
    ///                     request, continuing until the AdditionalDataPending response element returns false.
    ///
    ///
    public var numberOfLines: Swift.Int

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        logFileName: Swift.String? = nil,
        marker: Swift.String? = nil,
        numberOfLines: Swift.Int = 0
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.logFileName = logFileName
        self.marker = marker
        self.numberOfLines = numberOfLines
    }
}

extension DownloadDBLogFilePortionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DownloadDBLogFilePortionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBLogFileNotFoundFault" : self = .dBLogFileNotFoundFault(try DBLogFileNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DownloadDBLogFilePortionOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBLogFileNotFoundFault(DBLogFileNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DownloadDBLogFilePortionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DownloadDBLogFilePortionOutputResponse(additionalDataPending: \(Swift.String(describing: additionalDataPending)), logFileData: \(Swift.String(describing: logFileData)), marker: \(Swift.String(describing: marker)))"}
}

extension DownloadDBLogFilePortionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DownloadDBLogFilePortionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.additionalDataPending = output.additionalDataPending
            self.logFileData = output.logFileData
            self.marker = output.marker
        } else {
            self.additionalDataPending = false
            self.logFileData = nil
            self.marker = nil
        }
    }
}

/// This data type is used as a response element to DownloadDBLogFilePortion.
public struct DownloadDBLogFilePortionOutputResponse: Swift.Equatable {
    /// Boolean value that if true, indicates there is more data to be downloaded.
    public var additionalDataPending: Swift.Bool
    /// Entries from the specified log file.
    public var logFileData: Swift.String?
    /// A pagination token that can be used in a later DownloadDBLogFilePortion request.
    public var marker: Swift.String?

    public init (
        additionalDataPending: Swift.Bool = false,
        logFileData: Swift.String? = nil,
        marker: Swift.String? = nil
    )
    {
        self.additionalDataPending = additionalDataPending
        self.logFileData = logFileData
        self.marker = marker
    }
}

struct DownloadDBLogFilePortionOutputResponseBody: Swift.Equatable {
    public let logFileData: Swift.String?
    public let marker: Swift.String?
    public let additionalDataPending: Swift.Bool
}

extension DownloadDBLogFilePortionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalDataPending = "AdditionalDataPending"
        case logFileData = "LogFileData"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DownloadDBLogFilePortionResult"))
        let logFileDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFileData)
        logFileData = logFileDataDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let additionalDataPendingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .additionalDataPending)
        additionalDataPending = additionalDataPendingDecoded
    }
}

extension RdsClientTypes.EC2SecurityGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2SecurityGroupId = "EC2SecurityGroupId"
        case eC2SecurityGroupName = "EC2SecurityGroupName"
        case eC2SecurityGroupOwnerId = "EC2SecurityGroupOwnerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: ClientRuntime.Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let eC2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupName)
        eC2SecurityGroupName = eC2SecurityGroupNameDecoded
        let eC2SecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupId)
        eC2SecurityGroupId = eC2SecurityGroupIdDecoded
        let eC2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eC2SecurityGroupOwnerId)
        eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerIdDecoded
    }
}

extension RdsClientTypes.EC2SecurityGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EC2SecurityGroup(eC2SecurityGroupId: \(Swift.String(describing: eC2SecurityGroupId)), eC2SecurityGroupName: \(Swift.String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(Swift.String(describing: eC2SecurityGroupOwnerId)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// This data type is used as a response element in the following actions:
    ///
    ///
    ///
    ///                   AuthorizeDBSecurityGroupIngress
    ///
    ///
    ///
    ///
    ///                   DescribeDBSecurityGroups
    ///
    ///
    ///
    ///
    ///                   RevokeDBSecurityGroupIngress
    ///
    ///
    ///
    public struct EC2SecurityGroup: Swift.Equatable {
        /// Specifies the id of the EC2 security group.
        public var eC2SecurityGroupId: Swift.String?
        /// Specifies the name of the EC2 security group.
        public var eC2SecurityGroupName: Swift.String?
        ///
        ///         Specifies the Amazon Web Services ID of the owner of the EC2 security group
        ///         specified in the EC2SecurityGroupName field.
        ///
        public var eC2SecurityGroupOwnerId: Swift.String?
        /// Provides the status of the EC2 security group. Status can be "authorizing", "authorized", "revoking", and "revoked".
        public var status: Swift.String?

        public init (
            eC2SecurityGroupId: Swift.String? = nil,
            eC2SecurityGroupName: Swift.String? = nil,
            eC2SecurityGroupOwnerId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.eC2SecurityGroupId = eC2SecurityGroupId
            self.eC2SecurityGroupName = eC2SecurityGroupName
            self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
            self.status = status
        }
    }

}

extension RdsClientTypes.Endpoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let address = address {
            try container.encode(address, forKey: ClientRuntime.Key("Address"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension RdsClientTypes.Endpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Endpoint(address: \(Swift.String(describing: address)), hostedZoneId: \(Swift.String(describing: hostedZoneId)), port: \(Swift.String(describing: port)))"}
}

extension RdsClientTypes {
    /// This data type represents the information you need to connect to an Amazon RDS DB instance.
    ///       This data type is used as a response element in the following actions:
    ///
    ///
    ///
    ///                   CreateDBInstance
    ///
    ///
    ///
    ///
    ///                   DescribeDBInstances
    ///
    ///
    ///
    ///
    ///                   DeleteDBInstance
    ///
    ///
    ///
    ///          For the data structure that represents Amazon Aurora DB cluster endpoints,
    ///         see DBClusterEndpoint.
    public struct Endpoint: Swift.Equatable {
        /// Specifies the DNS address of the DB instance.
        public var address: Swift.String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// Specifies the port that the database engine is listening on.
        public var port: Swift.Int

        public init (
            address: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }
    }

}

extension RdsClientTypes.EngineDefaults: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case marker = "Marker"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        if containerValues.contains(.parameters) {
            struct KeyVal0{struct Parameter{}}
            let parametersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Parameter>.CodingKeys.self, forKey: .parameters)
            if let parametersWrappedContainer = parametersWrappedContainer {
                let parametersContainer = try parametersWrappedContainer.decodeIfPresent([RdsClientTypes.Parameter].self, forKey: .member)
                var parametersBuffer:[RdsClientTypes.Parameter]? = nil
                if let parametersContainer = parametersContainer {
                    parametersBuffer = [RdsClientTypes.Parameter]()
                    for structureContainer0 in parametersContainer {
                        parametersBuffer?.append(structureContainer0)
                    }
                }
                parameters = parametersBuffer
            } else {
                parameters = []
            }
        } else {
            parameters = nil
        }
    }
}

extension RdsClientTypes.EngineDefaults: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineDefaults(dBParameterGroupFamily: \(Swift.String(describing: dBParameterGroupFamily)), marker: \(Swift.String(describing: marker)), parameters: \(Swift.String(describing: parameters)))"}
}

extension RdsClientTypes {
    ///
    ///             Contains the result of a successful invocation of the DescribeEngineDefaultParameters action.
    ///
    public struct EngineDefaults: Swift.Equatable {
        /// Specifies the name of the DB parameter group family that the engine default parameters apply to.
        public var dBParameterGroupFamily: Swift.String?
        ///
        ///             An optional pagination token provided by a previous
        ///             EngineDefaults request.
        ///             If this parameter is specified, the response includes
        ///             only records beyond the marker,
        ///             up to the value specified by MaxRecords .
        ///
        public var marker: Swift.String?
        /// Contains a list of engine default parameters.
        public var parameters: [RdsClientTypes.Parameter]?

        public init (
            dBParameterGroupFamily: Swift.String? = nil,
            marker: Swift.String? = nil,
            parameters: [RdsClientTypes.Parameter]? = nil
        )
        {
            self.dBParameterGroupFamily = dBParameterGroupFamily
            self.marker = marker
            self.parameters = parameters
        }
    }

}

extension RdsClientTypes {
    public enum EngineFamily: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mysql
        case postgresql
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineFamily] {
            return [
                .mysql,
                .postgresql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mysql: return "MYSQL"
            case .postgresql: return "POSTGRESQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineFamily(rawValue: rawValue) ?? EngineFamily.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.Event: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case eventCategories = "EventCategories"
        case message = "Message"
        case sourceArn = "SourceArn"
        case sourceIdentifier = "SourceIdentifier"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let date = date {
            try container.encode(ClientRuntime.TimestampWrapper(date, format: .dateTime), forKey: ClientRuntime.Key("date"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentifier)
        sourceIdentifier = sourceIdentifierDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        var dateBuffer:ClientRuntime.Date? = nil
        if let dateDecoded = dateDecoded {
            dateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateDecoded, format: .dateTime)
        }
        date = dateBuffer
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension RdsClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(date: \(Swift.String(describing: date)), eventCategories: \(Swift.String(describing: eventCategories)), message: \(Swift.String(describing: message)), sourceArn: \(Swift.String(describing: sourceArn)), sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension RdsClientTypes {
    ///
    ///         This data type is used as a response element in the DescribeEvents action.
    ///
    public struct Event: Swift.Equatable {
        /// Specifies the date and time of the event.
        public var date: ClientRuntime.Date?
        /// Specifies the category for the event.
        public var eventCategories: [Swift.String]?
        /// Provides the text of this event.
        public var message: Swift.String?
        /// The Amazon Resource Name (ARN) for the event.
        public var sourceArn: Swift.String?
        /// Provides the identifier for the source of the event.
        public var sourceIdentifier: Swift.String?
        /// Specifies the source type for this event.
        public var sourceType: RdsClientTypes.SourceType?

        public init (
            date: ClientRuntime.Date? = nil,
            eventCategories: [Swift.String]? = nil,
            message: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            sourceIdentifier: Swift.String? = nil,
            sourceType: RdsClientTypes.SourceType? = nil
        )
        {
            self.date = date
            self.eventCategories = eventCategories
            self.message = message
            self.sourceArn = sourceArn
            self.sourceIdentifier = sourceIdentifier
            self.sourceType = sourceType
        }
    }

}

extension RdsClientTypes.EventCategoriesMap: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventCategories = "EventCategories"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.eventCategories) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategories)
            if let eventCategoriesWrappedContainer = eventCategoriesWrappedContainer {
                let eventCategoriesContainer = try eventCategoriesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesBuffer:[Swift.String]? = nil
                if let eventCategoriesContainer = eventCategoriesContainer {
                    eventCategoriesBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesContainer {
                        eventCategoriesBuffer?.append(stringContainer0)
                    }
                }
                eventCategories = eventCategoriesBuffer
            } else {
                eventCategories = []
            }
        } else {
            eventCategories = nil
        }
    }
}

extension RdsClientTypes.EventCategoriesMap: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventCategoriesMap(eventCategories: \(Swift.String(describing: eventCategories)), sourceType: \(Swift.String(describing: sourceType)))"}
}

extension RdsClientTypes {
    /// Contains the results of a successful invocation of the DescribeEventCategories operation.
    public struct EventCategoriesMap: Swift.Equatable {
        /// The event categories for the specified source type
        public var eventCategories: [Swift.String]?
        /// The source type that the returned categories belong to
        public var sourceType: Swift.String?

        public init (
            eventCategories: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.eventCategories = eventCategories
            self.sourceType = sourceType
        }
    }

}

extension RdsClientTypes.EventSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case eventSubscriptionArn = "EventSubscriptionArn"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let custSubscriptionId = custSubscriptionId {
            try container.encode(custSubscriptionId, forKey: ClientRuntime.Key("CustSubscriptionId"))
        }
        if let customerAwsId = customerAwsId {
            try container.encode(customerAwsId, forKey: ClientRuntime.Key("CustomerAwsId"))
        }
        if enabled != false {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategoriesList"))
            for (index0, string0) in eventCategoriesList.enumerated() {
                try eventCategoriesListContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let eventSubscriptionArn = eventSubscriptionArn {
            try container.encode(eventSubscriptionArn, forKey: ClientRuntime.Key("EventSubscriptionArn"))
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceIdsList"))
            for (index0, string0) in sourceIdsList.enumerated() {
                try sourceIdsListContainer.encode(string0, forKey: ClientRuntime.Key("SourceId.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let subscriptionCreationTime = subscriptionCreationTime {
            try container.encode(subscriptionCreationTime, forKey: ClientRuntime.Key("SubscriptionCreationTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        if containerValues.contains(.sourceIdsList) {
            struct KeyVal0{struct SourceId{}}
            let sourceIdsListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SourceId>.CodingKeys.self, forKey: .sourceIdsList)
            if let sourceIdsListWrappedContainer = sourceIdsListWrappedContainer {
                let sourceIdsListContainer = try sourceIdsListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourceIdsListBuffer:[Swift.String]? = nil
                if let sourceIdsListContainer = sourceIdsListContainer {
                    sourceIdsListBuffer = [Swift.String]()
                    for stringContainer0 in sourceIdsListContainer {
                        sourceIdsListBuffer?.append(stringContainer0)
                    }
                }
                sourceIdsList = sourceIdsListBuffer
            } else {
                sourceIdsList = []
            }
        } else {
            sourceIdsList = nil
        }
        if containerValues.contains(.eventCategoriesList) {
            struct KeyVal0{struct EventCategory{}}
            let eventCategoriesListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EventCategory>.CodingKeys.self, forKey: .eventCategoriesList)
            if let eventCategoriesListWrappedContainer = eventCategoriesListWrappedContainer {
                let eventCategoriesListContainer = try eventCategoriesListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var eventCategoriesListBuffer:[Swift.String]? = nil
                if let eventCategoriesListContainer = eventCategoriesListContainer {
                    eventCategoriesListBuffer = [Swift.String]()
                    for stringContainer0 in eventCategoriesListContainer {
                        eventCategoriesListBuffer?.append(stringContainer0)
                    }
                }
                eventCategoriesList = eventCategoriesListBuffer
            } else {
                eventCategoriesList = []
            }
        } else {
            eventCategoriesList = nil
        }
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let eventSubscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSubscriptionArn)
        eventSubscriptionArn = eventSubscriptionArnDecoded
    }
}

extension RdsClientTypes.EventSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscription(custSubscriptionId: \(Swift.String(describing: custSubscriptionId)), customerAwsId: \(Swift.String(describing: customerAwsId)), enabled: \(Swift.String(describing: enabled)), eventCategoriesList: \(Swift.String(describing: eventCategoriesList)), eventSubscriptionArn: \(Swift.String(describing: eventSubscriptionArn)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceIdsList: \(Swift.String(describing: sourceIdsList)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), subscriptionCreationTime: \(Swift.String(describing: subscriptionCreationTime)))"}
}

extension RdsClientTypes {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public struct EventSubscription: Swift.Equatable {
        /// The RDS event notification subscription Id.
        public var custSubscriptionId: Swift.String?
        /// The Amazon Web Services customer account associated with the RDS event notification subscription.
        public var customerAwsId: Swift.String?
        /// A Boolean value indicating if the subscription is enabled. True indicates the subscription is enabled.
        public var enabled: Swift.Bool
        /// A list of event categories for the RDS event notification subscription.
        public var eventCategoriesList: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the event subscription.
        public var eventSubscriptionArn: Swift.String?
        /// The topic ARN of the RDS event notification subscription.
        public var snsTopicArn: Swift.String?
        /// A list of source IDs for the RDS event notification subscription.
        public var sourceIdsList: [Swift.String]?
        /// The source type for the RDS event notification subscription.
        public var sourceType: Swift.String?
        /// The status of the RDS event notification subscription.
        ///          Constraints:
        ///          Can be one of the following: creating | modifying | deleting | active | no-permission | topic-not-exist
        ///          The status "no-permission" indicates that RDS no longer has permission to post to the SNS topic. The status "topic-not-exist" indicates that the topic was deleted after the subscription was created.
        public var status: Swift.String?
        /// The time the RDS event notification subscription was created.
        public var subscriptionCreationTime: Swift.String?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            eventSubscriptionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension EventSubscriptionQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventSubscriptionQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension EventSubscriptionQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<EventSubscriptionQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum number of event subscriptions.
public struct EventSubscriptionQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EventSubscriptionQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EventSubscriptionQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ExportTask: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportOnly = exportOnly {
            var exportOnlyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportOnly"))
            for (index0, string0) in exportOnly.enumerated() {
                try exportOnlyContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        if let failureCause = failureCause {
            try container.encode(failureCause, forKey: ClientRuntime.Key("FailureCause"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: ClientRuntime.Key("IamRoleArn"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if percentProgress != 0 {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if let s3Bucket = s3Bucket {
            try container.encode(s3Bucket, forKey: ClientRuntime.Key("S3Bucket"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let snapshotTime = snapshotTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotTime"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let taskEndTime = taskEndTime {
            try container.encode(ClientRuntime.TimestampWrapper(taskEndTime, format: .dateTime), forKey: ClientRuntime.Key("taskEndTime"))
        }
        if let taskStartTime = taskStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(taskStartTime, format: .dateTime), forKey: ClientRuntime.Key("taskStartTime"))
        }
        if totalExtractedDataInGB != 0 {
            try container.encode(totalExtractedDataInGB, forKey: ClientRuntime.Key("TotalExtractedDataInGB"))
        }
        if let warningMessage = warningMessage {
            try container.encode(warningMessage, forKey: ClientRuntime.Key("WarningMessage"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:ClientRuntime.Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:ClientRuntime.Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

extension RdsClientTypes.ExportTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportTask(exportOnly: \(Swift.String(describing: exportOnly)), exportTaskIdentifier: \(Swift.String(describing: exportTaskIdentifier)), failureCause: \(Swift.String(describing: failureCause)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), percentProgress: \(Swift.String(describing: percentProgress)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Prefix: \(Swift.String(describing: s3Prefix)), snapshotTime: \(Swift.String(describing: snapshotTime)), sourceArn: \(Swift.String(describing: sourceArn)), status: \(Swift.String(describing: status)), taskEndTime: \(Swift.String(describing: taskEndTime)), taskStartTime: \(Swift.String(describing: taskStartTime)), totalExtractedDataInGB: \(Swift.String(describing: totalExtractedDataInGB)), warningMessage: \(Swift.String(describing: warningMessage)))"}
}

extension RdsClientTypes {
    /// Contains the details of a snapshot export to Amazon S3.
    ///
    ///         This data type is used as a response element in the DescribeExportTasks action.
    ///
    public struct ExportTask: Swift.Equatable {
        /// The data exported from the snapshot. Valid values are the following:
        ///
        ///
        ///
        ///                   database - Export all the data from a specified database.
        ///
        ///
        ///
        ///                   database.table
        ///                   table-name -
        ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
        ///
        ///
        ///
        ///                   database.schema
        ///                   schema-name - Export a database schema of the snapshot.
        ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
        ///
        ///
        ///
        ///                   database.schema.table
        ///                   table-name - Export a table of the database schema.
        ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
        ///
        ///
        public var exportOnly: [Swift.String]?
        /// A unique identifier for the snapshot export task. This ID isn't an identifier for
        ///             the Amazon S3 bucket where the snapshot is exported to.
        public var exportTaskIdentifier: Swift.String?
        /// The reason the export failed, if it failed.
        public var failureCause: Swift.String?
        /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot.
        public var iamRoleArn: Swift.String?
        /// The key identifier of the Amazon Web Services KMS customer master key (CMK) that is used to encrypt the snapshot when it's exported to
        ///             Amazon S3. The Amazon Web Services KMS CMK identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export
        ///             must have encryption and decryption permissions to use this Amazon Web Services KMS CMK.
        public var kmsKeyId: Swift.String?
        /// The progress of the snapshot export task as a percentage.
        public var percentProgress: Swift.Int
        /// The Amazon S3 bucket that the snapshot is exported to.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.
        public var s3Prefix: Swift.String?
        /// The time that the snapshot was created.
        public var snapshotTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
        public var sourceArn: Swift.String?
        /// The progress status of the export task.
        public var status: Swift.String?
        /// The time that the snapshot export task completed.
        public var taskEndTime: ClientRuntime.Date?
        /// The time that the snapshot export task started.
        public var taskStartTime: ClientRuntime.Date?
        /// The total amount of data exported, in gigabytes.
        public var totalExtractedDataInGB: Swift.Int
        /// A warning about the snapshot export task.
        public var warningMessage: Swift.String?

        public init (
            exportOnly: [Swift.String]? = nil,
            exportTaskIdentifier: Swift.String? = nil,
            failureCause: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil,
            snapshotTime: ClientRuntime.Date? = nil,
            sourceArn: Swift.String? = nil,
            status: Swift.String? = nil,
            taskEndTime: ClientRuntime.Date? = nil,
            taskStartTime: ClientRuntime.Date? = nil,
            totalExtractedDataInGB: Swift.Int = 0,
            warningMessage: Swift.String? = nil
        )
        {
            self.exportOnly = exportOnly
            self.exportTaskIdentifier = exportTaskIdentifier
            self.failureCause = failureCause
            self.iamRoleArn = iamRoleArn
            self.kmsKeyId = kmsKeyId
            self.percentProgress = percentProgress
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
            self.snapshotTime = snapshotTime
            self.sourceArn = sourceArn
            self.status = status
            self.taskEndTime = taskEndTime
            self.taskStartTime = taskStartTime
            self.totalExtractedDataInGB = totalExtractedDataInGB
            self.warningMessage = warningMessage
        }
    }

}

extension ExportTaskAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportTaskAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ExportTaskAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ExportTaskAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't start an export task that's already running.
public struct ExportTaskAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExportTaskAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExportTaskAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExportTaskNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportTaskNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ExportTaskNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ExportTaskNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The export task doesn't exist.
public struct ExportTaskNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExportTaskNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExportTaskNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct FailoverDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

extension FailoverDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), targetDBInstanceIdentifier: \(Swift.String(describing: targetDBInstanceIdentifier)))"}
}

extension FailoverDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: ClientRuntime.Key("TargetDBInstanceIdentifier"))
        }
        try container.encode("FailoverDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct FailoverDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

public struct FailoverDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: FailoverDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = FailoverDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverDBClusterOutputError>
}

///
public struct FailoverDBClusterInput: Swift.Equatable {
    /// A DB cluster identifier to force a failover for. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBCluster.
    ///
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the instance to promote to the primary instance.
    ///         You must specify the instance identifier for an Aurora Replica in the DB cluster.
    ///         For example, mydbcluster-replica1.
    public var targetDBInstanceIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        targetDBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
    }
}

extension FailoverDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension FailoverDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailoverDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct FailoverDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct FailoverDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension FailoverDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("FailoverDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct FailoverGlobalClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverGlobalClusterOutputError>
}

extension FailoverGlobalClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverGlobalClusterInput(globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)), targetDbClusterIdentifier: \(Swift.String(describing: targetDbClusterIdentifier)))"}
}

extension FailoverGlobalClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let targetDbClusterIdentifier = targetDbClusterIdentifier {
            try container.encode(targetDbClusterIdentifier, forKey: ClientRuntime.Key("TargetDbClusterIdentifier"))
        }
        try container.encode("FailoverGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct FailoverGlobalClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverGlobalClusterOutputError>
}

public struct FailoverGlobalClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FailoverGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FailoverGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverGlobalClusterOutputError>
}

public struct FailoverGlobalClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FailoverGlobalClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: FailoverGlobalClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = FailoverGlobalClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<FailoverGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FailoverGlobalClusterOutputError>
}

public struct FailoverGlobalClusterInput: Swift.Equatable {
    /// Identifier of the Aurora global database (GlobalCluster)
    ///     that should be failed over. The identifier is the unique key assigned by
    ///     the user when the Aurora global database was created. In other words,
    ///     it's the name of the Aurora global database that you want to fail over.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing
    ///       GlobalCluster (Aurora global database).
    ///
    ///
    /// This member is required.
    public var globalClusterIdentifier: Swift.String?
    /// Identifier of the secondary Aurora DB cluster that you want to promote to primary for the Aurora
    ///        global database (GlobalCluster.) Use the Amazon Resource Name (ARN) for the identifier so that
    ///        Aurora can locate the cluster in its Amazon Web Services Region.
    ///
    /// This member is required.
    public var targetDbClusterIdentifier: Swift.String?

    public init (
        globalClusterIdentifier: Swift.String? = nil,
        targetDbClusterIdentifier: Swift.String? = nil
    )
    {
        self.globalClusterIdentifier = globalClusterIdentifier
        self.targetDbClusterIdentifier = targetDbClusterIdentifier
    }
}

extension FailoverGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension FailoverGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FailoverGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension FailoverGlobalClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverGlobalClusterOutputResponse(globalCluster: \(Swift.String(describing: globalCluster)))"}
}

extension FailoverGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailoverGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct FailoverGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct FailoverGlobalClusterOutputResponseBody: Swift.Equatable {
    public let globalCluster: RdsClientTypes.GlobalCluster?
}

extension FailoverGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("FailoverGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

extension RdsClientTypes.FailoverState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDbClusterArn = "FromDbClusterArn"
        case status = "Status"
        case toDbClusterArn = "ToDbClusterArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let fromDbClusterArn = fromDbClusterArn {
            try container.encode(fromDbClusterArn, forKey: ClientRuntime.Key("FromDbClusterArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let toDbClusterArn = toDbClusterArn {
            try container.encode(toDbClusterArn, forKey: ClientRuntime.Key("ToDbClusterArn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.FailoverStatus.self, forKey: .status)
        status = statusDecoded
        let fromDbClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDbClusterArn)
        fromDbClusterArn = fromDbClusterArnDecoded
        let toDbClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDbClusterArn)
        toDbClusterArn = toDbClusterArnDecoded
    }
}

extension RdsClientTypes.FailoverState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailoverState(fromDbClusterArn: \(Swift.String(describing: fromDbClusterArn)), status: \(Swift.String(describing: status)), toDbClusterArn: \(Swift.String(describing: toDbClusterArn)))"}
}

extension RdsClientTypes {
    /// Contains the state of scheduled or in-process failover operations on an
    ///       Aurora global database (GlobalCluster). This Data type is empty unless a failover
    ///       operation is scheduled or is currently underway on the Aurora global database.
    public struct FailoverState: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being demoted, and which is associated with this
        ///        state.
        public var fromDbClusterArn: Swift.String?
        /// The current status of the Aurora global database (GlobalCluster). Possible values are as follows:
        ///
        ///
        ///
        ///                pending  A request to fail over the Aurora global database (GlobalCluster) has been received by the service. The
        ///         GlobalCluster's primary DB cluster and the specified secondary DB cluster are being verified before the failover
        ///         process can start.
        ///
        ///
        ///                failing-over  This status covers the range of Aurora internal operations that take place during the failover process, such
        ///         as demoting the primary Aurora DB cluster, promoting the secondary Aurora DB, and synchronizing replicas.
        ///
        ///
        ///                cancelling  The request to fail over the Aurora global database (GlobalCluster) was cancelled and the primary
        ///         Aurora DB cluster and the selected secondary Aurora DB cluster are returning to their previous states.
        ///
        ///
        ///
        public var status: RdsClientTypes.FailoverStatus?
        /// The Amazon Resource Name (ARN) of the Aurora DB cluster that is currently being promoted, and which is associated
        ///      with this state.
        public var toDbClusterArn: Swift.String?

        public init (
            fromDbClusterArn: Swift.String? = nil,
            status: RdsClientTypes.FailoverStatus? = nil,
            toDbClusterArn: Swift.String? = nil
        )
        {
            self.fromDbClusterArn = fromDbClusterArn
            self.status = status
            self.toDbClusterArn = toDbClusterArn
        }
    }

}

extension RdsClientTypes {
    public enum FailoverStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelling
        case failingOver
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverStatus] {
            return [
                .cancelling,
                .failingOver,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelling: return "cancelling"
            case .failingOver: return "failing-over"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailoverStatus(rawValue: rawValue) ?? FailoverStatus.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Values"))
            for (index0, string0) in values.enumerated() {
                try valuesContainer.encode(string0, forKey: ClientRuntime.Key("Value.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct Value{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Value>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var valuesBuffer:[Swift.String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [Swift.String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension RdsClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension RdsClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results
    ///             from a describe operation. Filters can be used to match a set of resources by specific
    ///             criteria, such as IDs. The filters supported by a describe operation are documented
    ///             with the describe operation.
    ///
    ///             Currently, wildcards are not supported in filters.
    ///
    ///         The following actions can be filtered:
    ///
    ///
    ///
    ///                   DescribeDBClusterBacktracks
    ///
    ///
    ///
    ///
    ///                   DescribeDBClusterEndpoints
    ///
    ///
    ///
    ///
    ///                   DescribeDBClusters
    ///
    ///
    ///
    ///
    ///                   DescribeDBInstances
    ///
    ///
    ///
    ///
    ///                   DescribePendingMaintenanceActions
    ///
    ///
    ///
    public struct Filter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        /// This member is required.
        public var name: Swift.String?
        /// One or more filter values. Filter values are case-sensitive.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension RdsClientTypes.GlobalCluster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case failoverState = "FailoverState"
        case globalClusterArn = "GlobalClusterArn"
        case globalClusterIdentifier = "GlobalClusterIdentifier"
        case globalClusterMembers = "GlobalClusterMembers"
        case globalClusterResourceId = "GlobalClusterResourceId"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let failoverState = failoverState {
            try container.encode(failoverState, forKey: ClientRuntime.Key("FailoverState"))
        }
        if let globalClusterArn = globalClusterArn {
            try container.encode(globalClusterArn, forKey: ClientRuntime.Key("GlobalClusterArn"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let globalClusterMembers = globalClusterMembers {
            var globalClusterMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GlobalClusterMembers"))
            for (index0, globalclustermember0) in globalClusterMembers.enumerated() {
                try globalClusterMembersContainer.encode(globalclustermember0, forKey: ClientRuntime.Key("GlobalClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let globalClusterResourceId = globalClusterResourceId {
            try container.encode(globalClusterResourceId, forKey: ClientRuntime.Key("GlobalClusterResourceId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterIdentifier)
        globalClusterIdentifier = globalClusterIdentifierDecoded
        let globalClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterResourceId)
        globalClusterResourceId = globalClusterResourceIdDecoded
        let globalClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalClusterArn)
        globalClusterArn = globalClusterArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        if containerValues.contains(.globalClusterMembers) {
            struct KeyVal0{struct GlobalClusterMember{}}
            let globalClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.GlobalClusterMember>.CodingKeys.self, forKey: .globalClusterMembers)
            if let globalClusterMembersWrappedContainer = globalClusterMembersWrappedContainer {
                let globalClusterMembersContainer = try globalClusterMembersWrappedContainer.decodeIfPresent([RdsClientTypes.GlobalClusterMember].self, forKey: .member)
                var globalClusterMembersBuffer:[RdsClientTypes.GlobalClusterMember]? = nil
                if let globalClusterMembersContainer = globalClusterMembersContainer {
                    globalClusterMembersBuffer = [RdsClientTypes.GlobalClusterMember]()
                    for structureContainer0 in globalClusterMembersContainer {
                        globalClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                globalClusterMembers = globalClusterMembersBuffer
            } else {
                globalClusterMembers = []
            }
        } else {
            globalClusterMembers = nil
        }
        let failoverStateDecoded = try containerValues.decodeIfPresent(RdsClientTypes.FailoverState.self, forKey: .failoverState)
        failoverState = failoverStateDecoded
    }
}

extension RdsClientTypes.GlobalCluster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalCluster(databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), failoverState: \(Swift.String(describing: failoverState)), globalClusterArn: \(Swift.String(describing: globalClusterArn)), globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)), globalClusterMembers: \(Swift.String(describing: globalClusterMembers)), globalClusterResourceId: \(Swift.String(describing: globalClusterResourceId)), status: \(Swift.String(describing: status)), storageEncrypted: \(Swift.String(describing: storageEncrypted)))"}
}

extension RdsClientTypes {
    /// A data type representing an Aurora global database.
    public struct GlobalCluster: Swift.Equatable {
        ///
        ///         The default database name within the new global database cluster.
        ///
        public var databaseName: Swift.String?
        ///
        ///         The deletion protection setting for the new global database cluster.
        ///
        public var deletionProtection: Swift.Bool?
        ///
        ///         The Aurora database engine used by the global database cluster.
        ///
        public var engine: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// A data object containing all properties for the current state of an in-process or pending failover process for this Aurora global database.
        ///       This object is empty unless the FailoverGlobalCluster API operation has been called on this Aurora global database (GlobalCluster).
        ///
        public var failoverState: RdsClientTypes.FailoverState?
        /// The Amazon Resource Name (ARN) for the global database cluster.
        public var globalClusterArn: Swift.String?
        ///
        ///         Contains a user-supplied global database cluster identifier. This identifier is the unique key that
        ///         identifies a global database cluster.
        ///
        public var globalClusterIdentifier: Swift.String?
        ///
        ///         The list of cluster IDs for secondary clusters within the global database cluster. Currently limited to
        ///         1 item.
        ///
        public var globalClusterMembers: [RdsClientTypes.GlobalClusterMember]?
        ///
        ///         The Amazon Web Services Region-unique, immutable identifier for the global database cluster. This identifier is found in
        ///         Amazon Web Services CloudTrail log entries whenever the Amazon Web Services KMS customer master key (CMK) for the DB cluster is accessed.
        ///
        public var globalClusterResourceId: Swift.String?
        /// Specifies the current state of this global database cluster.
        public var status: Swift.String?
        ///
        ///         The storage encryption setting for the global database cluster.
        ///
        public var storageEncrypted: Swift.Bool?

        public init (
            databaseName: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            failoverState: RdsClientTypes.FailoverState? = nil,
            globalClusterArn: Swift.String? = nil,
            globalClusterIdentifier: Swift.String? = nil,
            globalClusterMembers: [RdsClientTypes.GlobalClusterMember]? = nil,
            globalClusterResourceId: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool? = nil
        )
        {
            self.databaseName = databaseName
            self.deletionProtection = deletionProtection
            self.engine = engine
            self.engineVersion = engineVersion
            self.failoverState = failoverState
            self.globalClusterArn = globalClusterArn
            self.globalClusterIdentifier = globalClusterIdentifier
            self.globalClusterMembers = globalClusterMembers
            self.globalClusterResourceId = globalClusterResourceId
            self.status = status
            self.storageEncrypted = storageEncrypted
        }
    }

}

extension GlobalClusterAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalClusterAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension GlobalClusterAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<GlobalClusterAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GlobalClusterIdentifier already exists. Choose a new global database identifier (unique name) to create a new global database cluster.
public struct GlobalClusterAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension GlobalClusterAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.GlobalClusterMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterArn = "DBClusterArn"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case isWriter = "IsWriter"
        case readers = "Readers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: ClientRuntime.Key("DBClusterArn"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: ClientRuntime.Key("GlobalWriteForwardingStatus"))
        }
        if isWriter != false {
            try container.encode(isWriter, forKey: ClientRuntime.Key("IsWriter"))
        }
        if let readers = readers {
            var readersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Readers"))
            for (index0, string0) in readers.enumerated() {
                try readersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.readers) {
            struct KeyVal0{struct member{}}
            let readersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .readers)
            if let readersWrappedContainer = readersWrappedContainer {
                let readersContainer = try readersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readersBuffer:[Swift.String]? = nil
                if let readersContainer = readersContainer {
                    readersBuffer = [Swift.String]()
                    for stringContainer0 in readersContainer {
                        readersBuffer?.append(stringContainer0)
                    }
                }
                readers = readersBuffer
            } else {
                readers = []
            }
        } else {
            readers = nil
        }
        let isWriterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isWriter)
        isWriter = isWriterDecoded
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
    }
}

extension RdsClientTypes.GlobalClusterMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalClusterMember(dBClusterArn: \(Swift.String(describing: dBClusterArn)), globalWriteForwardingStatus: \(Swift.String(describing: globalWriteForwardingStatus)), isWriter: \(Swift.String(describing: isWriter)), readers: \(Swift.String(describing: readers)))"}
}

extension RdsClientTypes {
    ///
    ///         A data structure with information about any primary and
    ///         secondary clusters associated with an Aurora global database.
    ///
    public struct GlobalClusterMember: Swift.Equatable {
        ///
        ///        The Amazon Resource Name (ARN) for each Aurora cluster.
        ///
        public var dBClusterArn: Swift.String?
        /// Specifies whether a secondary cluster in an Aurora global database has
        ///         write forwarding enabled, not enabled, or is in the process of enabling it.
        public var globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus?
        ///
        ///         Specifies whether the Aurora cluster is the primary cluster
        ///         (that is, has read-write capability) for the Aurora global
        ///         database with which it is associated.
        ///
        public var isWriter: Swift.Bool
        ///
        ///         The Amazon Resource Name (ARN) for each read-only secondary cluster
        ///         associated with the Aurora global database.
        ///
        public var readers: [Swift.String]?

        public init (
            dBClusterArn: Swift.String? = nil,
            globalWriteForwardingStatus: RdsClientTypes.WriteForwardingStatus? = nil,
            isWriter: Swift.Bool = false,
            readers: [Swift.String]? = nil
        )
        {
            self.dBClusterArn = dBClusterArn
            self.globalWriteForwardingStatus = globalWriteForwardingStatus
            self.isWriter = isWriter
            self.readers = readers
        }
    }

}

extension GlobalClusterNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalClusterNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension GlobalClusterNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<GlobalClusterNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The GlobalClusterIdentifier doesn't refer to an existing global database cluster.
public struct GlobalClusterNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension GlobalClusterNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GlobalClusterQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GlobalClusterQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension GlobalClusterQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<GlobalClusterQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of global database clusters for this account is already at the maximum allowed.
public struct GlobalClusterQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GlobalClusterQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension GlobalClusterQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes {
    public enum IAMAuthMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [IAMAuthMode] {
            return [
                .disabled,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IAMAuthMode(rawValue: rawValue) ?? IAMAuthMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.IPRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cIDRIP = "CIDRIP"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let cIDRIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cIDRIP)
        cIDRIP = cIDRIPDecoded
    }
}

extension RdsClientTypes.IPRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IPRange(cIDRIP: \(Swift.String(describing: cIDRIP)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    ///
    ///         This data type is used as a response element in the DescribeDBSecurityGroups action.
    ///
    public struct IPRange: Swift.Equatable {
        /// Specifies the IP range.
        public var cIDRIP: Swift.String?
        /// Specifies the status of the IP range. Status can be "authorizing", "authorized", "revoking", and "revoked".
        public var status: Swift.String?

        public init (
            cIDRIP: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.cIDRIP = cIDRIP
            self.status = status
        }
    }

}

extension IamRoleMissingPermissionsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IamRoleMissingPermissionsFault(message: \(Swift.String(describing: message)))"}
}

extension IamRoleMissingPermissionsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IamRoleMissingPermissionsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The IAM role requires additional permissions to export to an Amazon S3 bucket.
public struct IamRoleMissingPermissionsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IamRoleMissingPermissionsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IamRoleMissingPermissionsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IamRoleNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IamRoleNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension IamRoleNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<IamRoleNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The IAM role is missing for exporting to an Amazon S3 bucket.
public struct IamRoleNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IamRoleNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IamRoleNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ImportInstallationMediaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportInstallationMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportInstallationMediaOutputError>
}

extension ImportInstallationMediaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportInstallationMediaInput(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)), engine: \(Swift.String(describing: engine)), engineInstallationMediaPath: \(Swift.String(describing: engineInstallationMediaPath)), engineVersion: \(Swift.String(describing: engineVersion)), oSInstallationMediaPath: \(Swift.String(describing: oSInstallationMediaPath)))"}
}

extension ImportInstallationMediaInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineInstallationMediaPath = engineInstallationMediaPath {
            try container.encode(engineInstallationMediaPath, forKey: ClientRuntime.Key("EngineInstallationMediaPath"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let oSInstallationMediaPath = oSInstallationMediaPath {
            try container.encode(oSInstallationMediaPath, forKey: ClientRuntime.Key("OSInstallationMediaPath"))
        }
        try container.encode("ImportInstallationMedia", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ImportInstallationMediaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportInstallationMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportInstallationMediaOutputError>
}

public struct ImportInstallationMediaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportInstallationMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportInstallationMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportInstallationMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportInstallationMediaOutputError>
}

public struct ImportInstallationMediaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportInstallationMediaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ImportInstallationMediaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportInstallationMediaInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportInstallationMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportInstallationMediaOutputError>
}

public struct ImportInstallationMediaInput: Swift.Equatable {
    /// The identifier of the custom Availability Zone (AZ) to import the installation media to.
    /// This member is required.
    public var customAvailabilityZoneId: Swift.String?
    /// The name of the database engine to be used for this instance.
    ///
    ///
    ///          The list only includes supported DB engines that require an on-premises
    ///           customer provided license.
    ///
    ///
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    /// This member is required.
    public var engine: Swift.String?
    /// The path to the installation medium for the specified DB engine.
    ///          Example: SQLServerISO/en_sql_server_2016_enterprise_x64_dvd_8701793.iso
    ///
    /// This member is required.
    public var engineInstallationMediaPath: Swift.String?
    /// The version number of the database engine to use.
    ///          For a list of valid engine versions, call DescribeDBEngineVersions.
    ///          The following are the database engines and links to information about the major and minor
    ///           versions. The list only includes DB engines that require an on-premises
    ///           customer provided license.
    ///
    ///
    ///             Microsoft SQL Server
    ///
    ///
    ///          See <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_SQLServer.html#SQLServer.Concepts.General.VersionSupport">
    ///           Microsoft SQL Server Versions on Amazon RDS in the Amazon RDS User Guide.
    ///
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The path to the installation medium for the operating system associated with the specified DB engine.
    ///         Example: WindowsISO/en_windows_server_2016_x64_dvd_9327751.iso
    ///
    /// This member is required.
    public var oSInstallationMediaPath: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineInstallationMediaPath: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        oSInstallationMediaPath: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.oSInstallationMediaPath = oSInstallationMediaPath
    }
}

extension ImportInstallationMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ImportInstallationMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomAvailabilityZoneNotFound" : self = .customAvailabilityZoneNotFoundFault(try CustomAvailabilityZoneNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstallationMediaAlreadyExists" : self = .installationMediaAlreadyExistsFault(try InstallationMediaAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportInstallationMediaOutputError: Swift.Error, Swift.Equatable {
    case customAvailabilityZoneNotFoundFault(CustomAvailabilityZoneNotFoundFault)
    case installationMediaAlreadyExistsFault(InstallationMediaAlreadyExistsFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportInstallationMediaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportInstallationMediaOutputResponse(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)), engine: \(Swift.String(describing: engine)), engineInstallationMediaPath: \(Swift.String(describing: engineInstallationMediaPath)), engineVersion: \(Swift.String(describing: engineVersion)), failureCause: \(Swift.String(describing: failureCause)), installationMediaId: \(Swift.String(describing: installationMediaId)), oSInstallationMediaPath: \(Swift.String(describing: oSInstallationMediaPath)), status: \(Swift.String(describing: status)))"}
}

extension ImportInstallationMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportInstallationMediaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customAvailabilityZoneId = output.customAvailabilityZoneId
            self.engine = output.engine
            self.engineInstallationMediaPath = output.engineInstallationMediaPath
            self.engineVersion = output.engineVersion
            self.failureCause = output.failureCause
            self.installationMediaId = output.installationMediaId
            self.oSInstallationMediaPath = output.oSInstallationMediaPath
            self.status = output.status
        } else {
            self.customAvailabilityZoneId = nil
            self.engine = nil
            self.engineInstallationMediaPath = nil
            self.engineVersion = nil
            self.failureCause = nil
            self.installationMediaId = nil
            self.oSInstallationMediaPath = nil
            self.status = nil
        }
    }
}

/// Contains the installation media for a DB engine that requires an on-premises
///           customer provided license, such as Microsoft SQL Server.
public struct ImportInstallationMediaOutputResponse: Swift.Equatable {
    /// The custom Availability Zone (AZ) that contains the installation media.
    public var customAvailabilityZoneId: Swift.String?
    /// The DB engine.
    public var engine: Swift.String?
    /// The path to the installation medium for the DB engine.
    public var engineInstallationMediaPath: Swift.String?
    /// The engine version of the DB engine.
    public var engineVersion: Swift.String?
    /// If an installation media failure occurred, the cause of the failure.
    public var failureCause: RdsClientTypes.InstallationMediaFailureCause?
    /// The installation medium ID.
    public var installationMediaId: Swift.String?
    /// The path to the installation medium for the operating system associated with the DB engine.
    public var oSInstallationMediaPath: Swift.String?
    /// The status of the installation medium.
    public var status: Swift.String?

    public init (
        customAvailabilityZoneId: Swift.String? = nil,
        engine: Swift.String? = nil,
        engineInstallationMediaPath: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        failureCause: RdsClientTypes.InstallationMediaFailureCause? = nil,
        installationMediaId: Swift.String? = nil,
        oSInstallationMediaPath: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.customAvailabilityZoneId = customAvailabilityZoneId
        self.engine = engine
        self.engineInstallationMediaPath = engineInstallationMediaPath
        self.engineVersion = engineVersion
        self.failureCause = failureCause
        self.installationMediaId = installationMediaId
        self.oSInstallationMediaPath = oSInstallationMediaPath
        self.status = status
    }
}

struct ImportInstallationMediaOutputResponseBody: Swift.Equatable {
    public let installationMediaId: Swift.String?
    public let customAvailabilityZoneId: Swift.String?
    public let engine: Swift.String?
    public let engineVersion: Swift.String?
    public let engineInstallationMediaPath: Swift.String?
    public let oSInstallationMediaPath: Swift.String?
    public let status: Swift.String?
    public let failureCause: RdsClientTypes.InstallationMediaFailureCause?
}

extension ImportInstallationMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ImportInstallationMediaResult"))
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(RdsClientTypes.InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension RdsClientTypes.InstallationMedia: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAvailabilityZoneId = "CustomAvailabilityZoneId"
        case engine = "Engine"
        case engineInstallationMediaPath = "EngineInstallationMediaPath"
        case engineVersion = "EngineVersion"
        case failureCause = "FailureCause"
        case installationMediaId = "InstallationMediaId"
        case oSInstallationMediaPath = "OSInstallationMediaPath"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let customAvailabilityZoneId = customAvailabilityZoneId {
            try container.encode(customAvailabilityZoneId, forKey: ClientRuntime.Key("CustomAvailabilityZoneId"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineInstallationMediaPath = engineInstallationMediaPath {
            try container.encode(engineInstallationMediaPath, forKey: ClientRuntime.Key("EngineInstallationMediaPath"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let failureCause = failureCause {
            try container.encode(failureCause, forKey: ClientRuntime.Key("FailureCause"))
        }
        if let installationMediaId = installationMediaId {
            try container.encode(installationMediaId, forKey: ClientRuntime.Key("InstallationMediaId"))
        }
        if let oSInstallationMediaPath = oSInstallationMediaPath {
            try container.encode(oSInstallationMediaPath, forKey: ClientRuntime.Key("OSInstallationMediaPath"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installationMediaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installationMediaId)
        installationMediaId = installationMediaIdDecoded
        let customAvailabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAvailabilityZoneId)
        customAvailabilityZoneId = customAvailabilityZoneIdDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineInstallationMediaPath)
        engineInstallationMediaPath = engineInstallationMediaPathDecoded
        let oSInstallationMediaPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oSInstallationMediaPath)
        oSInstallationMediaPath = oSInstallationMediaPathDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(RdsClientTypes.InstallationMediaFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension RdsClientTypes.InstallationMedia: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstallationMedia(customAvailabilityZoneId: \(Swift.String(describing: customAvailabilityZoneId)), engine: \(Swift.String(describing: engine)), engineInstallationMediaPath: \(Swift.String(describing: engineInstallationMediaPath)), engineVersion: \(Swift.String(describing: engineVersion)), failureCause: \(Swift.String(describing: failureCause)), installationMediaId: \(Swift.String(describing: installationMediaId)), oSInstallationMediaPath: \(Swift.String(describing: oSInstallationMediaPath)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// Contains the installation media for a DB engine that requires an on-premises
    ///           customer provided license, such as Microsoft SQL Server.
    public struct InstallationMedia: Swift.Equatable {
        /// The custom Availability Zone (AZ) that contains the installation media.
        public var customAvailabilityZoneId: Swift.String?
        /// The DB engine.
        public var engine: Swift.String?
        /// The path to the installation medium for the DB engine.
        public var engineInstallationMediaPath: Swift.String?
        /// The engine version of the DB engine.
        public var engineVersion: Swift.String?
        /// If an installation media failure occurred, the cause of the failure.
        public var failureCause: RdsClientTypes.InstallationMediaFailureCause?
        /// The installation medium ID.
        public var installationMediaId: Swift.String?
        /// The path to the installation medium for the operating system associated with the DB engine.
        public var oSInstallationMediaPath: Swift.String?
        /// The status of the installation medium.
        public var status: Swift.String?

        public init (
            customAvailabilityZoneId: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineInstallationMediaPath: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            failureCause: RdsClientTypes.InstallationMediaFailureCause? = nil,
            installationMediaId: Swift.String? = nil,
            oSInstallationMediaPath: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.customAvailabilityZoneId = customAvailabilityZoneId
            self.engine = engine
            self.engineInstallationMediaPath = engineInstallationMediaPath
            self.engineVersion = engineVersion
            self.failureCause = failureCause
            self.installationMediaId = installationMediaId
            self.oSInstallationMediaPath = oSInstallationMediaPath
            self.status = status
        }
    }

}

extension InstallationMediaAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstallationMediaAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension InstallationMediaAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InstallationMediaAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified installation medium has already been imported.
public struct InstallationMediaAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstallationMediaAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InstallationMediaAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.InstallationMediaFailureCause: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.InstallationMediaFailureCause: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstallationMediaFailureCause(message: \(Swift.String(describing: message)))"}
}

extension RdsClientTypes {
    /// Contains the cause of an installation media failure. Installation media is used
    ///           for a DB engine that requires an on-premises
    ///           customer provided license, such as Microsoft SQL Server.
    public struct InstallationMediaFailureCause: Swift.Equatable {
        /// The reason that an installation media import failed.
        public var message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension InstallationMediaNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstallationMediaNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension InstallationMediaNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InstallationMediaNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             InstallationMediaID doesn't refer to an existing installation medium.
public struct InstallationMediaNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstallationMediaNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InstallationMediaNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InstanceQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension InstanceQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB
///             instances.
public struct InstanceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InstanceQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InstanceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientAvailableIPsInSubnetFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientAvailableIPsInSubnetFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientAvailableIPsInSubnetFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientAvailableIPsInSubnetFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed because there aren't enough available IP addresses
///            in the proxy's subnets. Add more CIDR blocks to the VPC or remove IP address that aren't required
///            from the subnets.
public struct InsufficientAvailableIPsInSubnetFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientAvailableIPsInSubnetFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientAvailableIPsInSubnetFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientDBClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientDBClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB cluster doesn't have enough capacity for the current operation.
public struct InsufficientDBClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientDBClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientDBInstanceCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientDBInstanceCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientDBInstanceCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientDBInstanceCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified DB instance class isn't available in the specified Availability
///             Zone.
public struct InsufficientDBInstanceCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDBInstanceCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientDBInstanceCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientStorageClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InsufficientStorageClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InsufficientStorageClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InsufficientStorageClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is insufficient storage available for the current action. You might be able to
///             resolve this error by updating your subnet group to use different Availability Zones
///             that have more storage available.
public struct InsufficientStorageClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientStorageClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InsufficientStorageClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterCapacityFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterCapacityFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterCapacityFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterCapacityFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             Capacity isn't a valid Aurora Serverless DB cluster
///             capacity. Valid capacity values are 2, 4, 8, 16,
///             32, 64, 128, and 256.
public struct InvalidDBClusterCapacityFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterCapacityFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterCapacityFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterEndpointStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterEndpointStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterEndpointStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterEndpointStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed on the endpoint while the endpoint is in this state.
public struct InvalidDBClusterEndpointStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterEndpointStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterEndpointStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterSnapshotStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterSnapshotStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterSnapshotStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied value isn't a valid DB cluster snapshot state.
public struct InvalidDBClusterSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterSnapshotStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBClusterStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBClusterStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBClusterStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBClusterStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed while the cluster is in this state.
public struct InvalidDBClusterStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBClusterStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceAutomatedBackupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBInstanceAutomatedBackupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBInstanceAutomatedBackupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBInstanceAutomatedBackupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The automated backup is in an invalid state.
///     	    For example, this automated backup is associated with an active instance.
public struct InvalidDBInstanceAutomatedBackupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceAutomatedBackupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBInstanceAutomatedBackupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBInstanceStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBInstanceStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBInstanceStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBInstanceStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB instance isn't in a valid state.
public struct InvalidDBInstanceStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBInstanceStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBInstanceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBParameterGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBParameterGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBParameterGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBParameterGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB parameter group is in use or is in an invalid state. If you are attempting
///             to delete the parameter group, you can't delete it when the parameter group is in
///             this state.
public struct InvalidDBParameterGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBParameterGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBParameterGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBProxyEndpointStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBProxyEndpointStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBProxyEndpointStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBProxyEndpointStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform this operation while the DB proxy endpoint is in a particular state.
public struct InvalidDBProxyEndpointStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBProxyEndpointStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBProxyEndpointStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBProxyStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBProxyStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBProxyStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBProxyStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation can't be performed while the proxy is in this state.
public struct InvalidDBProxyStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBProxyStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBProxyStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSecurityGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSecurityGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSecurityGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSecurityGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the DB security group doesn't allow deletion.
public struct InvalidDBSecurityGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSecurityGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSecurityGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSnapshotStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSnapshotStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSnapshotStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSnapshotStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the DB snapshot doesn't allow deletion.
public struct InvalidDBSnapshotStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSnapshotStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSnapshotStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSubnetGroupFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSubnetGroupFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSubnetGroupFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DBSubnetGroup doesn't belong to the same VPC as that of an existing
///             cross-region read replica of the same source instance.
public struct InvalidDBSubnetGroupFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSubnetGroupFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSubnetGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSubnetGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSubnetGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet group cannot be deleted because it's in use.
public struct InvalidDBSubnetGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSubnetGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDBSubnetStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDBSubnetStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidDBSubnetStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidDBSubnetStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             The DB subnet isn't in the available state.
///
public struct InvalidDBSubnetStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDBSubnetStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDBSubnetStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSubscriptionStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEventSubscriptionStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidEventSubscriptionStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidEventSubscriptionStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This error can occur if someone else is modifying a subscription. You should retry the action.
public struct InvalidEventSubscriptionStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSubscriptionStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEventSubscriptionStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportOnlyFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidExportOnlyFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidExportOnlyFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidExportOnlyFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The export is invalid for exporting to an Amazon S3 bucket.
public struct InvalidExportOnlyFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportOnlyFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidExportOnlyFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportSourceStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidExportSourceStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidExportSourceStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidExportSourceStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The state of the export snapshot is invalid for exporting to an Amazon S3 bucket.
public struct InvalidExportSourceStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportSourceStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidExportSourceStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportTaskStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidExportTaskStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidExportTaskStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidExportTaskStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't cancel an export task that has completed.
public struct InvalidExportTaskStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportTaskStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidExportTaskStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGlobalClusterStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidGlobalClusterStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidGlobalClusterStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidGlobalClusterStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The global cluster is in an invalid state and can't perform the requested operation.
public struct InvalidGlobalClusterStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGlobalClusterStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidGlobalClusterStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOptionGroupStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOptionGroupStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidOptionGroupStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidOptionGroupStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             The option group isn't in the available state.
///
public struct InvalidOptionGroupStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOptionGroupStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOptionGroupStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRestoreFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRestoreFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidRestoreFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidRestoreFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cannot restore from VPC backup to non-VPC DB instance.
public struct InvalidRestoreFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRestoreFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRestoreFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidS3BucketFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidS3BucketFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidS3BucketFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon S3 bucket name can't be found or Amazon RDS isn't
///             authorized to access the specified Amazon S3 bucket. Verify the SourceS3BucketName and S3IngestionRoleArn values and try again.
public struct InvalidS3BucketFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidS3BucketFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSubnet(message: \(Swift.String(describing: message)))"}
}

extension InvalidSubnet {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidSubnetBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested subnet is invalid, or multiple subnets were requested that are not all in a common VPC.
public struct InvalidSubnet: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidVPCNetworkStateFault(message: \(Swift.String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<InvalidVPCNetworkStateFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet group doesn't cover all Availability Zones after it's
///             created because of users' change.
public struct InvalidVPCNetworkStateFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidVPCNetworkStateFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSKeyNotAccessibleFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSKeyNotAccessibleFault(message: \(Swift.String(describing: message)))"}
}

extension KMSKeyNotAccessibleFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<KMSKeyNotAccessibleFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred accessing an Amazon Web Services KMS key.
public struct KMSKeyNotAccessibleFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSKeyNotAccessibleFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSKeyNotAccessibleFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(filters: \(Swift.String(describing: filters)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let filters = filters {
            var filtersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Filters"))
            for (index0, filter0) in filters.enumerated() {
                try filtersContainer.encode(filter0, forKey: ClientRuntime.Key("Filter.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        try container.encode("ListTagsForResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// This parameter isn't currently supported.
    public var filters: [RdsClientTypes.Filter]?
    /// The Amazon RDS resource with tags to be listed. This value is an Amazon Resource Name (ARN). For information about
    ///             creating an ARN,
    ///             see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///                 Constructing an ARN for Amazon RDS in the Amazon RDS User Guide.
    /// This member is required.
    public var resourceName: Swift.String?

    public init (
        filters: [RdsClientTypes.Filter]? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.resourceName = resourceName
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// List of tags returned by the ListTagsForResource operation.
    public var tagList: [RdsClientTypes.Tag]?

    public init (
        tagList: [RdsClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [RdsClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ListTagsForResourceResult"))
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
    }
}

extension RdsClientTypes.MinimumEngineVersionPerAllowedValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValue = "AllowedValue"
        case minimumEngineVersion = "MinimumEngineVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValue = allowedValue {
            try container.encode(allowedValue, forKey: ClientRuntime.Key("AllowedValue"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: ClientRuntime.Key("MinimumEngineVersion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValue)
        allowedValue = allowedValueDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
    }
}

extension RdsClientTypes.MinimumEngineVersionPerAllowedValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MinimumEngineVersionPerAllowedValue(allowedValue: \(Swift.String(describing: allowedValue)), minimumEngineVersion: \(Swift.String(describing: minimumEngineVersion)))"}
}

extension RdsClientTypes {
    /// The minimum DB engine version required for each corresponding allowed value for an option setting.
    public struct MinimumEngineVersionPerAllowedValue: Swift.Equatable {
        /// The allowed value for an option setting.
        public var allowedValue: Swift.String?
        /// The minimum DB engine version required for the allowed value.
        public var minimumEngineVersion: Swift.String?

        public init (
            allowedValue: Swift.String? = nil,
            minimumEngineVersion: Swift.String? = nil
        )
        {
            self.allowedValue = allowedValue
            self.minimumEngineVersion = minimumEngineVersion
        }
    }

}

public struct ModifyCertificatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCertificatesOutputError>
}

extension ModifyCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyCertificatesInput(certificateIdentifier: \(Swift.String(describing: certificateIdentifier)), removeCustomerOverride: \(Swift.String(describing: removeCustomerOverride)))"}
}

extension ModifyCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let certificateIdentifier = certificateIdentifier {
            try container.encode(certificateIdentifier, forKey: ClientRuntime.Key("CertificateIdentifier"))
        }
        if let removeCustomerOverride = removeCustomerOverride {
            try container.encode(removeCustomerOverride, forKey: ClientRuntime.Key("RemoveCustomerOverride"))
        }
        try container.encode("ModifyCertificates", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCertificatesOutputError>
}

public struct ModifyCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCertificatesOutputError>
}

public struct ModifyCertificatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCertificatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyCertificatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyCertificatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCertificatesOutputError>
}

public struct ModifyCertificatesInput: Swift.Equatable {
    /// The new default certificate identifier to override the current one with.
    ///          To determine the valid values, use the describe-certificates CLI
    ///             command or the DescribeCertificates API operation.
    public var certificateIdentifier: Swift.String?
    /// A value that indicates whether to remove the override for the default certificate.
    ///             If the override is removed, the default certificate is the system
    ///             default.
    public var removeCustomerOverride: Swift.Bool?

    public init (
        certificateIdentifier: Swift.String? = nil,
        removeCustomerOverride: Swift.Bool? = nil
    )
    {
        self.certificateIdentifier = certificateIdentifier
        self.removeCustomerOverride = removeCustomerOverride
    }
}

extension ModifyCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CertificateNotFound" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCertificatesOutputError: Swift.Error, Swift.Equatable {
    case certificateNotFoundFault(CertificateNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyCertificatesOutputResponse(certificate: \(Swift.String(describing: certificate)))"}
}

extension ModifyCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
        } else {
            self.certificate = nil
        }
    }
}

public struct ModifyCertificatesOutputResponse: Swift.Equatable {
    /// A CA certificate for an Amazon Web Services account.
    public var certificate: RdsClientTypes.Certificate?

    public init (
        certificate: RdsClientTypes.Certificate? = nil
    )
    {
        self.certificate = certificate
    }
}

struct ModifyCertificatesOutputResponseBody: Swift.Equatable {
    public let certificate: RdsClientTypes.Certificate?
}

extension ModifyCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyCertificatesResult"))
        let certificateDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

public struct ModifyCurrentDBClusterCapacityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCurrentDBClusterCapacityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyCurrentDBClusterCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyCurrentDBClusterCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

extension ModifyCurrentDBClusterCapacityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyCurrentDBClusterCapacityInput(capacity: \(Swift.String(describing: capacity)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), secondsBeforeTimeout: \(Swift.String(describing: secondsBeforeTimeout)), timeoutAction: \(Swift.String(describing: timeoutAction)))"}
}

extension ModifyCurrentDBClusterCapacityInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let capacity = capacity {
            try container.encode(capacity, forKey: ClientRuntime.Key("Capacity"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: ClientRuntime.Key("SecondsBeforeTimeout"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: ClientRuntime.Key("TimeoutAction"))
        }
        try container.encode("ModifyCurrentDBClusterCapacity", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyCurrentDBClusterCapacityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCurrentDBClusterCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyCurrentDBClusterCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyCurrentDBClusterCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

public struct ModifyCurrentDBClusterCapacityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCurrentDBClusterCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyCurrentDBClusterCapacityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyCurrentDBClusterCapacityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

public struct ModifyCurrentDBClusterCapacityInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyCurrentDBClusterCapacityInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyCurrentDBClusterCapacityInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyCurrentDBClusterCapacityInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyCurrentDBClusterCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyCurrentDBClusterCapacityOutputError>
}

public struct ModifyCurrentDBClusterCapacityInput: Swift.Equatable {
    /// The DB cluster capacity.
    ///         When you change the capacity of a paused Aurora Serverless DB cluster, it automatically resumes.
    ///         Constraints:
    ///
    ///
    ///                 For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
    ///
    ///
    ///                 For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
    ///
    ///
    public var capacity: Swift.Int?
    /// The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.
    ///         Constraints:
    ///
    ///
    ///                 Must match the identifier of an existing DB cluster.
    ///
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The amount of time, in seconds, that Aurora Serverless tries to find a scaling point
    ///             to perform seamless scaling before enforcing the timeout action. The default is
    ///             300.
    ///         Specify a value between 10 and 600 seconds.
    public var secondsBeforeTimeout: Swift.Int?
    /// The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.
    ///
    ///             ForceApplyCapacityChange, the default, sets the capacity to the specified value as soon as possible.
    ///
    ///             RollbackCapacityChange ignores the capacity change if a scaling point isn't found in the timeout period.
    public var timeoutAction: Swift.String?

    public init (
        capacity: Swift.Int? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        secondsBeforeTimeout: Swift.Int? = nil,
        timeoutAction: Swift.String? = nil
    )
    {
        self.capacity = capacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}

extension ModifyCurrentDBClusterCapacityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyCurrentDBClusterCapacityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterCapacityFault" : self = .invalidDBClusterCapacityFault(try InvalidDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyCurrentDBClusterCapacityOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterCapacityFault(InvalidDBClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyCurrentDBClusterCapacityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyCurrentDBClusterCapacityOutputResponse(currentCapacity: \(Swift.String(describing: currentCapacity)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), pendingCapacity: \(Swift.String(describing: pendingCapacity)), secondsBeforeTimeout: \(Swift.String(describing: secondsBeforeTimeout)), timeoutAction: \(Swift.String(describing: timeoutAction)))"}
}

extension ModifyCurrentDBClusterCapacityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyCurrentDBClusterCapacityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentCapacity = output.currentCapacity
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.pendingCapacity = output.pendingCapacity
            self.secondsBeforeTimeout = output.secondsBeforeTimeout
            self.timeoutAction = output.timeoutAction
        } else {
            self.currentCapacity = nil
            self.dBClusterIdentifier = nil
            self.pendingCapacity = nil
            self.secondsBeforeTimeout = nil
            self.timeoutAction = nil
        }
    }
}

public struct ModifyCurrentDBClusterCapacityOutputResponse: Swift.Equatable {
    /// The current capacity of the DB cluster.
    public var currentCapacity: Swift.Int?
    /// A user-supplied DB cluster identifier. This identifier is the unique key that
    ///             identifies a DB cluster.
    public var dBClusterIdentifier: Swift.String?
    /// A value that specifies the capacity that the DB cluster scales to next.
    public var pendingCapacity: Swift.Int?
    /// The number of seconds before a call to ModifyCurrentDBClusterCapacity times out.
    public var secondsBeforeTimeout: Swift.Int?
    /// The timeout action of a call to ModifyCurrentDBClusterCapacity, either
    ///             ForceApplyCapacityChange or RollbackCapacityChange.
    public var timeoutAction: Swift.String?

    public init (
        currentCapacity: Swift.Int? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        pendingCapacity: Swift.Int? = nil,
        secondsBeforeTimeout: Swift.Int? = nil,
        timeoutAction: Swift.String? = nil
    )
    {
        self.currentCapacity = currentCapacity
        self.dBClusterIdentifier = dBClusterIdentifier
        self.pendingCapacity = pendingCapacity
        self.secondsBeforeTimeout = secondsBeforeTimeout
        self.timeoutAction = timeoutAction
    }
}

struct ModifyCurrentDBClusterCapacityOutputResponseBody: Swift.Equatable {
    public let dBClusterIdentifier: Swift.String?
    public let pendingCapacity: Swift.Int?
    public let currentCapacity: Swift.Int?
    public let secondsBeforeTimeout: Swift.Int?
    public let timeoutAction: Swift.String?
}

extension ModifyCurrentDBClusterCapacityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentCapacity = "CurrentCapacity"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case pendingCapacity = "PendingCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case timeoutAction = "TimeoutAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyCurrentDBClusterCapacityResult"))
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let pendingCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pendingCapacity)
        pendingCapacity = pendingCapacityDecoded
        let currentCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentCapacity)
        currentCapacity = currentCapacityDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
    }
}

public struct ModifyDBClusterEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

extension ModifyDBClusterEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterEndpointInput(dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)))"}
}

extension ModifyDBClusterEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterEndpointIdentifier = dBClusterEndpointIdentifier {
            try container.encode(dBClusterEndpointIdentifier, forKey: ClientRuntime.Key("DBClusterEndpointIdentifier"))
        }
        if let endpointType = endpointType {
            try container.encode(endpointType, forKey: ClientRuntime.Key("EndpointType"))
        }
        if let excludedMembers = excludedMembers {
            var excludedMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedMembers"))
            for (index0, string0) in excludedMembers.enumerated() {
                try excludedMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let staticMembers = staticMembers {
            var staticMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StaticMembers"))
            for (index0, string0) in staticMembers.enumerated() {
                try staticMembersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBClusterEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBClusterEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterEndpointOutputError>
}

public struct ModifyDBClusterEndpointInput: Swift.Equatable {
    /// The identifier of the endpoint to modify. This parameter is stored as a lowercase string.
    /// This member is required.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, ANY.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?

    public init (
        dBClusterEndpointIdentifier: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil
    )
    {
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
    }
}

extension ModifyDBClusterEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterEndpointNotFoundFault" : self = .dBClusterEndpointNotFoundFault(try DBClusterEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterEndpointStateFault" : self = .invalidDBClusterEndpointStateFault(try InvalidDBClusterEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBClusterEndpointNotFoundFault(DBClusterEndpointNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterEndpointStateFault(InvalidDBClusterEndpointStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterEndpointOutputResponse(customEndpointType: \(Swift.String(describing: customEndpointType)), dBClusterEndpointArn: \(Swift.String(describing: dBClusterEndpointArn)), dBClusterEndpointIdentifier: \(Swift.String(describing: dBClusterEndpointIdentifier)), dBClusterEndpointResourceIdentifier: \(Swift.String(describing: dBClusterEndpointResourceIdentifier)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), endpoint: \(Swift.String(describing: endpoint)), endpointType: \(Swift.String(describing: endpointType)), excludedMembers: \(Swift.String(describing: excludedMembers)), staticMembers: \(Swift.String(describing: staticMembers)), status: \(Swift.String(describing: status)))"}
}

extension ModifyDBClusterEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customEndpointType = output.customEndpointType
            self.dBClusterEndpointArn = output.dBClusterEndpointArn
            self.dBClusterEndpointIdentifier = output.dBClusterEndpointIdentifier
            self.dBClusterEndpointResourceIdentifier = output.dBClusterEndpointResourceIdentifier
            self.dBClusterIdentifier = output.dBClusterIdentifier
            self.endpoint = output.endpoint
            self.endpointType = output.endpointType
            self.excludedMembers = output.excludedMembers
            self.staticMembers = output.staticMembers
            self.status = output.status
        } else {
            self.customEndpointType = nil
            self.dBClusterEndpointArn = nil
            self.dBClusterEndpointIdentifier = nil
            self.dBClusterEndpointResourceIdentifier = nil
            self.dBClusterIdentifier = nil
            self.endpoint = nil
            self.endpointType = nil
            self.excludedMembers = nil
            self.staticMembers = nil
            self.status = nil
        }
    }
}

/// This data type represents the information you need to connect to an Amazon Aurora DB cluster.
///       This data type is used as a response element in the following actions:
///
///
///
///                   CreateDBClusterEndpoint
///
///
///
///
///                   DescribeDBClusterEndpoints
///
///
///
///
///                   ModifyDBClusterEndpoint
///
///
///
///
///                   DeleteDBClusterEndpoint
///
///
///
///          For the data structure that represents Amazon RDS DB instance endpoints,
///         see Endpoint.
public struct ModifyDBClusterEndpointOutputResponse: Swift.Equatable {
    /// The type associated with a custom endpoint. One of: READER,
    ///        WRITER, ANY.
    public var customEndpointType: Swift.String?
    /// The Amazon Resource Name (ARN) for the endpoint.
    public var dBClusterEndpointArn: Swift.String?
    /// The identifier associated with the endpoint. This parameter is stored as a lowercase string.
    public var dBClusterEndpointIdentifier: Swift.String?
    /// A unique system-generated identifier for an endpoint. It remains the same for the whole life of the endpoint.
    public var dBClusterEndpointResourceIdentifier: Swift.String?
    /// The DB cluster identifier of the DB cluster associated with the endpoint. This parameter is
    ///             stored as a lowercase string.
    public var dBClusterIdentifier: Swift.String?
    /// The DNS address of the endpoint.
    public var endpoint: Swift.String?
    /// The type of the endpoint. One of: READER, WRITER, CUSTOM.
    public var endpointType: Swift.String?
    /// List of DB instance identifiers that aren't part of the custom endpoint group.
    ///        All other eligible instances are reachable through the custom endpoint.
    ///        Only relevant if the list of static members is empty.
    public var excludedMembers: [Swift.String]?
    /// List of DB instance identifiers that are part of the custom endpoint group.
    public var staticMembers: [Swift.String]?
    /// The current status of the endpoint. One of: creating, available, deleting, inactive, modifying. The inactive state applies to an endpoint that can't be used for a certain kind of cluster,
    ///      such as a writer endpoint for a read-only secondary cluster in a global database.
    public var status: Swift.String?

    public init (
        customEndpointType: Swift.String? = nil,
        dBClusterEndpointArn: Swift.String? = nil,
        dBClusterEndpointIdentifier: Swift.String? = nil,
        dBClusterEndpointResourceIdentifier: Swift.String? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        endpoint: Swift.String? = nil,
        endpointType: Swift.String? = nil,
        excludedMembers: [Swift.String]? = nil,
        staticMembers: [Swift.String]? = nil,
        status: Swift.String? = nil
    )
    {
        self.customEndpointType = customEndpointType
        self.dBClusterEndpointArn = dBClusterEndpointArn
        self.dBClusterEndpointIdentifier = dBClusterEndpointIdentifier
        self.dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifier
        self.dBClusterIdentifier = dBClusterIdentifier
        self.endpoint = endpoint
        self.endpointType = endpointType
        self.excludedMembers = excludedMembers
        self.staticMembers = staticMembers
        self.status = status
    }
}

struct ModifyDBClusterEndpointOutputResponseBody: Swift.Equatable {
    public let dBClusterEndpointIdentifier: Swift.String?
    public let dBClusterIdentifier: Swift.String?
    public let dBClusterEndpointResourceIdentifier: Swift.String?
    public let endpoint: Swift.String?
    public let status: Swift.String?
    public let endpointType: Swift.String?
    public let customEndpointType: Swift.String?
    public let staticMembers: [Swift.String]?
    public let excludedMembers: [Swift.String]?
    public let dBClusterEndpointArn: Swift.String?
}

extension ModifyDBClusterEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpointType = "CustomEndpointType"
        case dBClusterEndpointArn = "DBClusterEndpointArn"
        case dBClusterEndpointIdentifier = "DBClusterEndpointIdentifier"
        case dBClusterEndpointResourceIdentifier = "DBClusterEndpointResourceIdentifier"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case endpoint = "Endpoint"
        case endpointType = "EndpointType"
        case excludedMembers = "ExcludedMembers"
        case staticMembers = "StaticMembers"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterEndpointResult"))
        let dBClusterEndpointIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointIdentifier)
        dBClusterEndpointIdentifier = dBClusterEndpointIdentifierDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterEndpointResourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointResourceIdentifier)
        dBClusterEndpointResourceIdentifier = dBClusterEndpointResourceIdentifierDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let customEndpointTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointType)
        customEndpointType = customEndpointTypeDecoded
        if containerValues.contains(.staticMembers) {
            struct KeyVal0{struct member{}}
            let staticMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .staticMembers)
            if let staticMembersWrappedContainer = staticMembersWrappedContainer {
                let staticMembersContainer = try staticMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var staticMembersBuffer:[Swift.String]? = nil
                if let staticMembersContainer = staticMembersContainer {
                    staticMembersBuffer = [Swift.String]()
                    for stringContainer0 in staticMembersContainer {
                        staticMembersBuffer?.append(stringContainer0)
                    }
                }
                staticMembers = staticMembersBuffer
            } else {
                staticMembers = []
            }
        } else {
            staticMembers = nil
        }
        if containerValues.contains(.excludedMembers) {
            struct KeyVal0{struct member{}}
            let excludedMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedMembers)
            if let excludedMembersWrappedContainer = excludedMembersWrappedContainer {
                let excludedMembersContainer = try excludedMembersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedMembersBuffer:[Swift.String]? = nil
                if let excludedMembersContainer = excludedMembersContainer {
                    excludedMembersBuffer = [Swift.String]()
                    for stringContainer0 in excludedMembersContainer {
                        excludedMembersBuffer?.append(stringContainer0)
                    }
                }
                excludedMembers = excludedMembersBuffer
            } else {
                excludedMembers = []
            }
        } else {
            excludedMembers = nil
        }
        let dBClusterEndpointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterEndpointArn)
        dBClusterEndpointArn = dBClusterEndpointArnDecoded
    }
}

public struct ModifyDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

extension ModifyDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterInput(allowMajorVersionUpgrade: \(Swift.String(describing: allowMajorVersionUpgrade)), applyImmediately: \(Swift.String(describing: applyImmediately)), backtrackWindow: \(Swift.String(describing: backtrackWindow)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cloudwatchLogsExportConfiguration: \(Swift.String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBInstanceParameterGroupName: \(Swift.String(describing: dBInstanceParameterGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableGlobalWriteForwarding: \(Swift.String(describing: enableGlobalWriteForwarding)), enableHttpEndpoint: \(Swift.String(describing: enableHttpEndpoint)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engineVersion: \(Swift.String(describing: engineVersion)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), newDBClusterIdentifier: \(Swift.String(describing: newDBClusterIdentifier)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), scalingConfiguration: \(Swift.String(describing: scalingConfiguration)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: ClientRuntime.Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBInstanceParameterGroupName = dBInstanceParameterGroupName {
            try container.encode(dBInstanceParameterGroupName, forKey: ClientRuntime.Key("DBInstanceParameterGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableGlobalWriteForwarding = enableGlobalWriteForwarding {
            try container.encode(enableGlobalWriteForwarding, forKey: ClientRuntime.Key("EnableGlobalWriteForwarding"))
        }
        if let enableHttpEndpoint = enableHttpEndpoint {
            try container.encode(enableHttpEndpoint, forKey: ClientRuntime.Key("EnableHttpEndpoint"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let newDBClusterIdentifier = newDBClusterIdentifier {
            try container.encode(newDBClusterIdentifier, forKey: ClientRuntime.Key("NewDBClusterIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

public struct ModifyDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterOutputError>
}

///
public struct ModifyDBClusterInput: Swift.Equatable {
    /// A value that indicates whether major version upgrades are allowed.
    ///          Constraints: You must allow major version upgrades when specifying a value for the
    ///                 EngineVersion parameter that is a different major version than the DB
    ///             cluster's current version.
    public var allowMajorVersionUpgrade: Swift.Bool
    /// A value that indicates whether the modifications in this request and
    ///       any pending modifications are asynchronously applied
    ///       as soon as possible, regardless of the
    ///       PreferredMaintenanceWindow setting for the DB cluster.
    ///       If this parameter is disabled, changes to the
    ///       DB cluster are applied during the next maintenance window.
    ///          The ApplyImmediately parameter only affects the EnableIAMDatabaseAuthentication,
    ///       MasterUserPassword, and NewDBClusterIdentifier values. If the ApplyImmediately
    ///       parameter is disabled, then changes to the EnableIAMDatabaseAuthentication, MasterUserPassword,
    ///       and NewDBClusterIdentifier values are applied during the next maintenance window. All other changes are
    ///       applied immediately, regardless of the value of the ApplyImmediately parameter.
    ///          By default, this parameter is disabled.
    public var applyImmediately: Swift.Bool
    /// The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.
    ///
    ///             Currently, Backtrack is only supported for Aurora MySQL DB clusters.
    ///
    ///         Default: 0
    ///         Constraints:
    ///
    ///
    ///                If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    public var backtrackWindow: Swift.Int?
    /// The number of days for which automated backups are retained. You must specify a minimum value of 1.
    ///          Default: 1
    ///          Constraints:
    ///
    ///
    ///                Must be a value from 1 to 35
    ///
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB cluster.
    public var cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration?
    /// A value that indicates whether to copy all tags from the DB cluster to snapshots of the DB cluster.
    ///             The default is not to copy them.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The DB cluster identifier for the cluster being modified. This parameter isn't case-sensitive.
    ///          Constraints: This identifier must match the identifier of an existing DB
    ///             cluster.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the DB cluster parameter group to use for the DB cluster.
    public var dBClusterParameterGroupName: Swift.String?
    /// The name of the DB parameter group to apply to all instances of the DB cluster.
    ///
    ///             When you apply a parameter group using the DBInstanceParameterGroupName parameter, the DB
    ///                 cluster isn't rebooted automatically. Also, parameter changes aren't
    ///                 applied during the next maintenance window but instead are applied immediately.
    ///
    ///          Default: The existing name setting
    ///          Constraints:
    ///
    ///
    ///                The DB parameter group must be in the same DB parameter group family as this DB cluster.
    ///
    ///
    ///                The DBInstanceParameterGroupName parameter is only valid in combination with
    ///               the AllowMajorVersionUpgrade parameter.
    ///
    ///
    public var dBInstanceParameterGroupName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to move the DB cluster to.
    ///           Specify none to remove the cluster from its current domain.
    ///           The domain must be created prior to this operation.
    ///
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication
    ///             in the Amazon Aurora User Guide.
    ///
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// A value that indicates whether to enable this DB cluster to forward write operations to the primary cluster of an
    ///       Aurora global database (GlobalCluster). By default, write operations are not allowed on Aurora DB clusters that
    ///       are secondary clusters in an Aurora global database.
    ///          You can set this value only on Aurora DB clusters that are members of an Aurora global database. With this parameter
    ///       enabled, a secondary cluster can forward writes to the current primary cluster and the resulting changes are replicated back to
    ///       this cluster. For the primary DB cluster of an Aurora global database, this value is used immediately if the primary is
    ///       demoted by the FailoverGlobalCluster API operation, but it does nothing until then.
    ///
    public var enableGlobalWriteForwarding: Swift.Bool?
    /// A value that indicates whether to enable the HTTP endpoint for an Aurora Serverless DB cluster. By default, the HTTP endpoint
    ///             is disabled.
    ///         When enabled, the HTTP endpoint provides a connectionless web service API for running
    ///             SQL queries on the Aurora Serverless DB cluster. You can also query your database
    ///             from inside the RDS console with the query editor.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/data-api.html">Using the Data API for Aurora Serverless in the
    ///             Amazon Aurora User Guide.
    public var enableHttpEndpoint: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication in the Amazon Aurora User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The version number of the database engine to which you want to upgrade.
    ///             Changing this parameter results in an outage. The change is applied during
    ///             the next maintenance window unless ApplyImmediately is enabled.
    ///         To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"
    ///
    ///         To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"
    ///
    ///         To list all of the available engine versions for aurora-postgresql, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"
    ///
    public var engineVersion: Swift.String?
    /// The new password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
    ///          Constraints: Must contain from 8 to 41 characters.
    public var masterUserPassword: Swift.String?
    /// The new DB cluster identifier for the DB cluster when renaming a DB cluster. This value is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    ///
    ///                The first character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-cluster2
    ///
    public var newDBClusterIdentifier: Swift.String?
    /// A value that indicates that the DB cluster should be associated with the specified option group.
    ///             Changing this parameter doesn't result in an outage except in the following case, and the change
    ///             is applied during the next maintenance window
    ///             unless the ApplyImmediately is enabled for this request. If the parameter change results in an option group that
    ///             enables OEM, this change can cause a brief (sub-second) period during which new connections
    ///             are rejected but existing connections are not interrupted.
    ///
    ///          Permanent options can't be removed from an option group. The option group can't be removed from a DB cluster once it is associated with a DB cluster.
    public var optionGroupName: Swift.String?
    /// The port number on which the DB cluster accepts connections.
    ///          Constraints: Value must be 1150-65535
    ///
    ///          Default: The same port as the original DB cluster.
    public var port: Swift.Int?
    /// The daily time range during which automated backups are created
    ///             if automated backups are enabled,
    ///             using the BackupRetentionPeriod parameter.
    ///
    ///          The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region.
    ///             To view the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow">
    ///                 Backup window in the Amazon Aurora User Guide.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred maintenance window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
    ///          Format: ddd:hh24:mi-ddd:hh24:mi
    ///
    ///          The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region, occurring on a random day of the
    ///             week. To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora">
    ///                 Adjusting the Preferred DB Cluster Maintenance Window in the Amazon Aurora User Guide.
    ///
    ///          Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
    ///          Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The scaling properties of the DB cluster. You can only modify scaling properties for DB clusters in serverless DB engine mode.
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// A list of VPC security groups that the DB cluster will belong to.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        backtrackWindow: Swift.Int? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBInstanceParameterGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableGlobalWriteForwarding: Swift.Bool? = nil,
        enableHttpEndpoint: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        newDBClusterIdentifier: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBInstanceParameterGroupName = dBInstanceParameterGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableGlobalWriteForwarding = enableGlobalWriteForwarding
        self.enableHttpEndpoint = enableHttpEndpoint
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engineVersion = engineVersion
        self.masterUserPassword = masterUserPassword
        self.newDBClusterIdentifier = newDBClusterIdentifier
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.scalingConfiguration = scalingConfiguration
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension ModifyDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct ModifyDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct ModifyDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension ModifyDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct ModifyDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

extension ModifyDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), parameters: \(Swift.String(describing: parameters)))"}
}

extension ModifyDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

public struct ModifyDBClusterParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBClusterParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBClusterParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterParameterGroupOutputError>
}

///
public struct ModifyDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group to modify.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// A list of parameters in the DB cluster parameter group to modify.
    ///          Valid Values (for the application method): immediate | pending-reboot
    ///
    ///
    ///             You can use the immediate value with dynamic parameters only. You can use the
    ///               pending-reboot value for both dynamic and static parameters.
    ///             When the application method is immediate, changes to dynamic parameters are applied immediately
    ///           to the DB clusters associated with the parameter group. When the application method is pending-reboot,
    ///           changes to dynamic and static parameters are applied after a reboot without failover to the DB clusters associated with the
    ///           parameter group.
    ///
    /// This member is required.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)))"}
}

extension ModifyDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

///
public struct ModifyDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB cluster parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters or numbers.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///
    ///             This value is stored as a lowercase string.
    ///
    public var dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ModifyDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroupName: Swift.String?
}

extension ModifyDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ModifyDBClusterSnapshotAttributeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

extension ModifyDBClusterSnapshotAttributeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterSnapshotAttributeInput(attributeName: \(Swift.String(describing: attributeName)), dBClusterSnapshotIdentifier: \(Swift.String(describing: dBClusterSnapshotIdentifier)), valuesToAdd: \(Swift.String(describing: valuesToAdd)), valuesToRemove: \(Swift.String(describing: valuesToRemove)))"}
}

extension ModifyDBClusterSnapshotAttributeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier {
            try container.encode(dBClusterSnapshotIdentifier, forKey: ClientRuntime.Key("DBClusterSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBClusterSnapshotAttribute", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBClusterSnapshotAttributeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBClusterSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

public struct ModifyDBClusterSnapshotAttributeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBClusterSnapshotAttributeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBClusterSnapshotAttributeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBClusterSnapshotAttributeInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBClusterSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBClusterSnapshotAttributeOutputError>
}

///
public struct ModifyDBClusterSnapshotAttributeInput: Swift.Equatable {
    /// The name of the DB cluster snapshot attribute to modify.
    ///         To manage authorization for other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot,
    ///             set this value to restore.
    ///
    ///             To view the list of attributes available to modify, use the
    ///                 DescribeDBClusterSnapshotAttributes API action.
    ///
    /// This member is required.
    public var attributeName: Swift.String?
    /// The identifier for the DB cluster snapshot to modify the attributes for.
    /// This member is required.
    public var dBClusterSnapshotIdentifier: Swift.String?
    /// A list of DB cluster snapshot attributes to add to the attribute specified by AttributeName.
    ///         To authorize other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this list to include one or more Amazon Web Services account
    ///             IDs, or all to make the manual DB cluster snapshot restorable by
    ///             any Amazon Web Services account. Do not add the all value for any
    ///             manual DB cluster snapshots that contain private information that you don't want available
    ///             to all Amazon Web Services accounts.
    public var valuesToAdd: [Swift.String]?
    /// A list of DB cluster snapshot attributes to remove from the attribute specified by AttributeName.
    ///         To remove authorization for other Amazon Web Services accounts to copy or restore a manual DB cluster snapshot, set this list to include
    ///             one or more Amazon Web Services account
    ///             identifiers, or all to remove authorization for any Amazon Web Services account to copy or
    ///             restore the DB cluster snapshot. If you specify all, an Amazon Web Services account whose account ID is
    ///             explicitly added to the restore attribute
    ///             can still copy or restore a manual DB cluster snapshot.
    public var valuesToRemove: [Swift.String]?

    public init (
        attributeName: Swift.String? = nil,
        dBClusterSnapshotIdentifier: Swift.String? = nil,
        valuesToAdd: [Swift.String]? = nil,
        valuesToRemove: [Swift.String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBClusterSnapshotIdentifier = dBClusterSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBClusterSnapshotAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceeded" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBClusterSnapshotAttributeOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBClusterSnapshotAttributeOutputResponse(dBClusterSnapshotAttributesResult: \(Swift.String(describing: dBClusterSnapshotAttributesResult)))"}
}

extension ModifyDBClusterSnapshotAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBClusterSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterSnapshotAttributesResult = output.dBClusterSnapshotAttributesResult
        } else {
            self.dBClusterSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBClusterSnapshotAttributeOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBClusterSnapshotAttributes
    ///             API action.
    ///         Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts
    ///             to copy or restore a manual DB cluster snapshot. For more information, see the ModifyDBClusterSnapshotAttribute
    ///             API action.
    public var dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?

    public init (
        dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult? = nil
    )
    {
        self.dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResult
    }
}

struct ModifyDBClusterSnapshotAttributeOutputResponseBody: Swift.Equatable {
    public let dBClusterSnapshotAttributesResult: RdsClientTypes.DBClusterSnapshotAttributesResult?
}

extension ModifyDBClusterSnapshotAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterSnapshotAttributesResult = "DBClusterSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBClusterSnapshotAttributeResult"))
        let dBClusterSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBClusterSnapshotAttributesResult.self, forKey: .dBClusterSnapshotAttributesResult)
        dBClusterSnapshotAttributesResult = dBClusterSnapshotAttributesResultDecoded
    }
}

public struct ModifyDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

extension ModifyDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBInstanceInput(allocatedStorage: \(Swift.String(describing: allocatedStorage)), allowMajorVersionUpgrade: \(Swift.String(describing: allowMajorVersionUpgrade)), applyImmediately: \(Swift.String(describing: applyImmediately)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), awsBackupRecoveryPointArn: \(Swift.String(describing: awsBackupRecoveryPointArn)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(Swift.String(describing: cACertificateIdentifier)), certificateRotationRestart: \(Swift.String(describing: certificateRotationRestart)), cloudwatchLogsExportConfiguration: \(Swift.String(describing: cloudwatchLogsExportConfiguration)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBPortNumber: \(Swift.String(describing: dBPortNumber)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCustomerOwnedIp: \(Swift.String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(Swift.String(describing: enablePerformanceInsights)), engineVersion: \(Swift.String(describing: engineVersion)), iops: \(Swift.String(describing: iops)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), newDBInstanceIdentifier: \(Swift.String(describing: newDBInstanceIdentifier)), optionGroupName: \(Swift.String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(Swift.String(describing: performanceInsightsRetentionPeriod)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), processorFeatures: \(Swift.String(describing: processorFeatures)), promotionTier: \(Swift.String(describing: promotionTier)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), replicaMode: \(Swift.String(describing: replicaMode)), storageType: \(Swift.String(describing: storageType)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), tdeCredentialPassword: \(Swift.String(describing: tdeCredentialPassword)), useDefaultProcessorFeatures: \(Swift.String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if allowMajorVersionUpgrade != false {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let awsBackupRecoveryPointArn = awsBackupRecoveryPointArn {
            try container.encode(awsBackupRecoveryPointArn, forKey: ClientRuntime.Key("AwsBackupRecoveryPointArn"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let certificateRotationRestart = certificateRotationRestart {
            try container.encode(certificateRotationRestart, forKey: ClientRuntime.Key("CertificateRotationRestart"))
        }
        if let cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration {
            try container.encode(cloudwatchLogsExportConfiguration, forKey: ClientRuntime.Key("CloudwatchLogsExportConfiguration"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBPortNumber = dBPortNumber {
            try container.encode(dBPortNumber, forKey: ClientRuntime.Key("DBPortNumber"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let newDBInstanceIdentifier = newDBInstanceIdentifier {
            try container.encode(newDBInstanceIdentifier, forKey: ClientRuntime.Key("NewDBInstanceIdentifier"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let promotionTier = promotionTier {
            try container.encode(promotionTier, forKey: ClientRuntime.Key("PromotionTier"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let replicaMode = replicaMode {
            try container.encode(replicaMode, forKey: ClientRuntime.Key("ReplicaMode"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

public struct ModifyDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBInstanceOutputError>
}

///
public struct ModifyDBInstanceInput: Swift.Equatable {
    /// The new amount of storage in gibibytes (GiB) to allocate for the DB instance.
    ///
    ///
    ///          For MariaDB, MySQL, Oracle, and PostgreSQL,
    ///           the value supplied must be at least 10% greater than the current value.
    ///           Values that are not at least 10% greater than the existing value are rounded up
    ///           so that they are 10% greater than the current value.
    ///
    ///
    ///          For the valid values for allocated storage for each engine,
    ///           see CreateDBInstance.
    ///
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether major version upgrades are allowed. Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.
    ///          Constraints: Major version upgrades must be allowed when specifying a value for the EngineVersion parameter that is a different major version than the DB instance's current version.
    public var allowMajorVersionUpgrade: Swift.Bool
    /// A value that indicates whether the modifications in this request and
    ///         any pending modifications are asynchronously applied
    ///         as soon as possible, regardless of the
    ///         PreferredMaintenanceWindow setting for the DB instance. By default, this parameter is
    ///           disabled.
    ///
    ///
    ///         If this parameter is disabled, changes to the
    ///         DB instance are applied during the next maintenance window. Some parameter changes can cause an outage
    ///         and are applied on the next call to RebootDBInstance, or the next failure reboot.
    ///         Review the table of parameters in <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.DBInstance.Modifying.html">Modifying a DB Instance
    ///           in the Amazon RDS User Guide. to see the impact of enabling
    ///           or disabling ApplyImmediately for each modified parameter and to determine when the changes are applied.
    ///
    public var applyImmediately: Swift.Bool
    ///
    ///     A value that indicates whether minor version upgrades are applied automatically
    ///     to the DB instance during the maintenance window.
    ///     Changing this parameter doesn't result in an outage except in the following case
    ///     and the change is asynchronously applied as soon as possible.
    ///     An outage results if this parameter is enabled during the maintenance window,
    ///     and a newer minor version is available, and RDS has enabled auto patching for that engine version.
    ///
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the recovery point in Amazon Web Services Backup.
    public var awsBackupRecoveryPointArn: Swift.String?
    /// The number of days to retain automated backups. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.
    ///
    ///             Enabling and disabling backups can result in a brief I/O suspension that lasts from a few seconds to a few minutes, depending on the size and class of your DB instance.
    ///
    ///         These changes are applied during the next maintenance window unless the ApplyImmediately parameter is enabled
    ///             for this request. If you change the parameter from one non-zero value to another non-zero value, the change is asynchronously
    ///             applied as soon as possible.
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. The retention period for automated backups is managed by the DB
    ///             cluster. For more information, see ModifyDBCluster.
    ///          Default: Uses existing setting
    ///          Constraints:
    ///
    ///
    ///                Must be a value from 0 to 35
    ///
    ///
    ///                Can be specified for a MySQL read replica only if the source is running MySQL 5.6 or
    ///                     later
    ///
    ///
    ///                Can be specified for a PostgreSQL read replica only if the source is running PostgreSQL
    ///                     9.3.5
    ///
    ///
    ///                Can't be set to 0 if the DB instance is a source to read replicas
    ///
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// Indicates the certificate that needs to be associated with the instance.
    public var cACertificateIdentifier: Swift.String?
    /// A value that indicates whether the DB instance is restarted when you rotate your
    ///             SSL/TLS certificate.
    ///         By default, the DB instance is restarted when you rotate your SSL/TLS certificate. The certificate
    ///             is not updated until the DB instance is restarted.
    ///
    ///             Set this parameter only if you are not using SSL/TLS to connect to the DB instance.
    ///
    ///         If you are using SSL/TLS to connect to the DB instance, follow the appropriate instructions for your
    ///             DB engine to rotate your SSL/TLS certificate:
    ///
    ///
    ///                 For more information about rotating your SSL/TLS certificate for RDS DB engines, see
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL-certificate-rotation.html">
    ///                         Rotating Your SSL/TLS Certificate. in the Amazon RDS User Guide.
    ///
    ///
    ///
    ///                 For more information about rotating your SSL/TLS certificate for Aurora DB engines, see
    ///                     <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.SSL-certificate-rotation.html">
    ///                         Rotating Your SSL/TLS Certificate in the Amazon Aurora User Guide.
    ///
    ///
    ///
    public var certificateRotationRestart: Swift.Bool?
    /// The configuration setting for the log types to be enabled for export to CloudWatch Logs for a specific DB instance.
    ///         A change to the CloudwatchLogsExportConfiguration parameter is always applied to the DB instance
    ///             immediately. Therefore, the ApplyImmediately parameter has no effect.
    public var cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration?
    /// A value that indicates whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. Copying tags to snapshots is managed by the DB cluster. Setting this
    ///           value for an Aurora DB instance has no effect on the DB cluster setting. For more
    ///           information, see ModifyDBCluster.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The new compute and memory capacity of the DB instance, for example, db.m4.large.
    ///           Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class in the Amazon RDS User Guide.
    ///
    ///          If you modify the DB instance class, an outage occurs during the change.
    ///         The change is applied during the next maintenance window,
    ///         unless ApplyImmediately is enabled for this request.
    ///
    ///          Default: Uses existing setting
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier. This value is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBInstance.
    ///
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the DB parameter group to apply to the DB instance. Changing this
    ///             setting doesn't result in an outage. The parameter group name itself is changed
    ///             immediately, but the actual parameter changes are not applied until you reboot the
    ///             instance without failover. In this case, the DB instance isn't rebooted automatically and the
    ///             parameter changes isn't applied during the next maintenance window.
    ///          Default: Uses existing setting
    ///          Constraints: The DB parameter group must be in the same DB parameter group family as this DB instance.
    public var dBParameterGroupName: Swift.String?
    /// The port number on which the database accepts connections.
    ///          The value of the DBPortNumber parameter must not match any of the port values specified for options in the option
    ///       group for the DB instance.
    ///          Your database will restart when you change the DBPortNumber value regardless of the value of the ApplyImmediately
    ///       parameter.
    ///
    ///             MySQL
    ///
    ///
    ///       Default: 3306
    ///
    ///           Valid values: 1150-65535
    ///
    ///
    ///             MariaDB
    ///
    ///
    ///       Default: 3306
    ///
    ///           Valid values: 1150-65535
    ///
    ///
    ///             PostgreSQL
    ///
    ///
    ///       Default: 5432
    ///
    ///           Valid values: 1150-65535
    ///
    ///          Type: Integer
    ///
    ///             Oracle
    ///
    ///
    ///       Default: 1521
    ///
    ///           Valid values: 1150-65535
    ///
    ///
    ///             SQL Server
    ///
    ///
    ///       Default: 1433
    ///
    ///          Valid values: 1150-65535 except 1234, 1434,
    ///                 3260, 3343, 3389, 47001, and
    ///                 49152-49156.
    ///
    ///             Amazon Aurora
    ///
    ///
    ///       Default: 3306
    ///
    ///           Valid values: 1150-65535
    ///
    public var dBPortNumber: Swift.Int?
    /// A list of DB security groups to authorize on this DB instance. Changing this setting doesn't result in an outage and the change is asynchronously applied as soon as possible.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match existing DBSecurityGroups.
    ///
    ///
    public var dBSecurityGroups: [Swift.String]?
    /// The new DB subnet group for the DB instance.
    ///           You can use this parameter to move your DB instance to a different VPC.
    ///
    ///           If your DB instance isn't in a VPC, you can also use this parameter to move your DB instance into a VPC.
    ///           For more information, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html#USER_VPC.Non-VPC2VPC">Working with a DB instance in a VPC
    ///           in the Amazon RDS User Guide.
    ///
    ///          Changing the subnet group causes an outage during the change.
    ///         The change is applied during the next maintenance window,
    ///         unless you enable ApplyImmediately.
    ///
    ///          Constraints: If supplied, must match the name of an existing DBSubnetGroup.
    ///          Example: mySubnetGroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance.
    ///
    public var deletionProtection: Swift.Bool?
    /// The Active Directory directory ID to move the DB instance to.
    ///           Specify none to remove the instance from its current domain.
    ///           The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///           Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///           Kerberos Authentication in the Amazon RDS User Guide.
    public var domain: Swift.String?
    /// The name of the IAM role to use when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.
    ///         A CoIP provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.
    ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on Amazon Web Services Outposts
    ///             in the Amazon RDS User Guide.
    ///         For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses
    ///             in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///          This setting doesn't apply to Amazon Aurora. Mapping Amazon Web Services IAM accounts to database accounts is managed by the DB
    ///           cluster.
    ///
    ///          For more information about IAM database authentication, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///               IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the DB instance.
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using Amazon Performance Insights in the Amazon Relational Database Service
    ///                     User Guide.
    ///
    public var enablePerformanceInsights: Swift.Bool?
    ///
    ///     The version number of the database engine to upgrade to.
    ///     Changing this parameter results in an outage and the change
    ///     is applied during the next maintenance window
    ///     unless the ApplyImmediately parameter is enabled for this request.
    ///
    ///          For major version upgrades, if a nondefault DB parameter group is currently in use, a
    ///             new DB parameter group in the DB parameter group family for the new engine version must
    ///             be specified. The new DB parameter group can be the default for that DB parameter group
    ///             family.
    ///          If you specify only a major version, Amazon RDS will update the DB instance to the
    ///           default minor version if the current minor version is lower.
    ///           For information about valid engine versions, see CreateDBInstance,
    ///           or call DescribeDBEngineVersions.
    public var engineVersion: Swift.String?
    /// The new Provisioned IOPS (I/O operations per second) value for the RDS instance.
    ///
    ///          Changing this setting doesn't result in an outage and
    ///             the change is applied during the next maintenance window
    ///             unless the ApplyImmediately parameter is enabled for this request.
    ///           If you are migrating from Provisioned IOPS to standard storage, set this value to 0.
    ///           The DB instance will require a reboot for the change in storage type to take effect.
    ///
    ///          If you choose to migrate your DB instance from using standard storage to using
    ///             Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process
    ///             can take time. The duration of the migration depends on several factors such as database
    ///             load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS
    ///             provisioned (if any), and the number of prior scale storage operations. Typical
    ///             migration times are under 24 hours, but the process can take up to several days in some
    ///             cases. During the migration, the DB instance is available for use, but might experience
    ///             performance degradation. While the migration takes place, nightly backups for the
    ///             instance are suspended. No other Amazon RDS operations can take place for the instance,
    ///             including modifying the instance, rebooting the instance, deleting the instance,
    ///             creating a read replica for the instance, and creating a DB snapshot of the instance.
    ///          Constraints: For MariaDB, MySQL, Oracle, and PostgreSQL,
    ///           the value supplied must be at least 10% greater than the current value.
    ///           Values that are not at least 10% greater than the existing value are rounded up so that they are 10% greater than the current value.
    ///
    ///          Default: Uses existing setting
    public var iops: Swift.Int?
    /// The license model for the DB instance.
    ///         Valid values: license-included | bring-your-own-license |
    ///             general-public-license
    ///
    public var licenseModel: Swift.String?
    /// The new password for the master user. The password can include any printable ASCII character except "/", """, or "@".
    ///
    ///         Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.
    ///         Between the time of the request and the completion of the request,
    ///         the MasterUserPassword element exists in the
    ///         PendingModifiedValues element of the operation response.
    ///
    ///
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. The password for the master user is managed by the DB cluster. For
    ///             more information, see ModifyDBCluster.
    ///
    ///
    ///          Default: Uses existing setting
    ///
    ///
    ///             MariaDB
    ///
    ///          Constraints: Must contain from 8 to 41 characters.
    ///
    ///
    ///             Microsoft SQL Server
    ///
    ///          Constraints: Must contain from 8 to 128 characters.
    ///
    ///
    ///             MySQL
    ///
    ///          Constraints: Must contain from 8 to 41 characters.
    ///
    ///
    ///             Oracle
    ///
    ///          Constraints: Must contain from 8 to 30 characters.
    ///
    ///
    ///             PostgreSQL
    ///
    ///          Constraints: Must contain from 8 to 128 characters.
    ///
    ///
    ///             Amazon RDS API actions never return the password,
    ///               so this action provides a way to regain access to a primary instance user if the password is lost.
    ///               This includes restoring privileges that might have been accidentally revoked.
    ///
    ///
    public var masterUserPassword: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
    ///         For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling
    ///             in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting Enhanced Monitoring metrics, specify 0. The default is 0.
    ///          If MonitoringRoleArn is specified, then you must also set MonitoringInterval
    ///       to a value other than 0.
    ///          Valid Values: 0, 1, 5, 10, 15, 30, 60
    ///
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs. For
    ///       example, arn:aws:iam:123456789012:role/emaccess. For information on creating a monitoring role,
    ///       go to <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.html#USER_Monitoring.OS.IAMRole">To
    ///           create an IAM role for Amazon RDS Enhanced Monitoring in the Amazon RDS User Guide.
    ///
    ///          If MonitoringInterval is set to a value other than 0, then you must supply a MonitoringRoleArn value.
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment.
    ///     Changing this parameter doesn't result in an outage and the change
    ///     is applied during the next maintenance window
    ///     unless the ApplyImmediately parameter is
    ///         enabled for this request.
    ///
    public var multiAZ: Swift.Bool?
    ///
    ///             The new DB instance identifier for the DB instance when renaming a DB
    ///             instance. When you change the DB instance identifier, an instance
    ///             reboot occurs immediately if you enable ApplyImmediately, or will occur
    ///             during the next maintenance window if you disable Apply Immediately. This value is stored
    ///             as a lowercase string.
    ///
    ///
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                The first character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///          Example: mydbinstance
    ///
    public var newDBInstanceIdentifier: Swift.String?
    ///
    ///             A value that indicates the DB instance should be associated with the specified option group.
    ///             Changing this parameter doesn't result in an outage except in the following case and the change
    ///             is applied during the next maintenance window
    ///             unless the ApplyImmediately parameter is enabled
    ///             for this request. If the parameter change results in an option group that
    ///             enables OEM, this change can cause a brief (sub-second) period during which new connections
    ///             are rejected but existing connections are not interrupted.
    ///
    ///          Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///         If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your Amazon Web Services account.
    ///             Your Amazon Web Services account has a different default CMK for each Amazon Web Services Region.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
    public var performanceInsightsRetentionPeriod: Swift.Int?
    ///
    ///         The daily time range during which automated backups are created
    ///         if automated backups are enabled,
    ///         as determined by the BackupRetentionPeriod parameter.
    ///         Changing this parameter doesn't result in an outage and the change is asynchronously applied as soon as possible.
    ///         The default is a 30-minute window selected at random from an
    ///         8-hour block of time for each Amazon Web Services Region. For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Backup window in the Amazon RDS User Guide.
    ///
    ///
    ///
    ///             Amazon Aurora
    ///
    ///         Not applicable. The daily time range for creating automated backups is managed by
    ///             the DB cluster. For more information, see ModifyDBCluster.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi
    ///
    ///
    ///                Must be in Universal Time Coordinated (UTC)
    ///
    ///
    ///                Must not conflict with the preferred maintenance window
    ///
    ///
    ///                Must be at least 30 minutes
    ///
    ///
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range (in UTC) during which system maintenance can occur, which
    ///             might result in an outage. Changing this parameter doesn't result in an outage, except
    ///             in the following situation, and the change is asynchronously applied as soon as
    ///             possible. If there are pending actions that cause a reboot, and the maintenance window
    ///             is changed to include the current time, then changing this parameter will cause a reboot
    ///             of the DB instance. If moving this window to the current time, there must be at least 30
    ///             minutes between the current time and end of the window to ensure pending changes are
    ///             applied.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance">Amazon RDS Maintenance Window in the Amazon RDS User Guide.
    ///
    ///          Default: Uses existing setting
    ///          Format: ddd:hh24:mi-ddd:hh24:mi
    ///          Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun
    ///          Constraints: Must be at least 30 minutes
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that specifies the order in which an Aurora Replica is promoted to the primary instance
    ///       after a failure of the existing primary instance. For more information,
    ///       see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">
    ///           Fault Tolerance for an Aurora DB Cluster in the Amazon Aurora User Guide.
    ///
    ///          Default: 1
    ///          Valid Values: 0 - 15
    public var promotionTier: Swift.Int?
    /// A value that indicates whether the DB instance is publicly accessible.
    ///
    ///          When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
    ///          When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
    ///
    ///             PubliclyAccessible only applies to DB instances in a VPC.
    ///       The DB instance must be part of a public subnet and
    ///       PubliclyAccessible must be enabled for it to be publicly accessible.
    ///
    ///          Changes to the PubliclyAccessible parameter are applied immediately regardless
    ///       of the value of the ApplyImmediately parameter.
    public var publiclyAccessible: Swift.Bool?
    /// A value that sets the open mode of a replica database to either mounted or read-only.
    ///
    ///             Currently, this parameter is only supported for Oracle DB instances.
    ///
    ///         Mounted DB replicas are included in Oracle Enterprise Edition. The main use case for
    ///             mounted replicas is cross-Region disaster recovery. The primary database doesn't use
    ///             Active Data Guard to transmit information to the mounted replica. Because it doesn't
    ///             accept user connections, a mounted replica can't serve a read-only workload.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/oracle-read-replicas.html">Working with Oracle Read Replicas for Amazon RDS
    ///             in the Amazon RDS User Guide.
    public var replicaMode: RdsClientTypes.ReplicaMode?
    /// Specifies the storage type to be associated with the DB instance.
    ///
    ///          If you specify Provisioned IOPS (io1),
    ///           you must also include a value for the Iops parameter.
    ///
    ///          If you choose to migrate your DB instance from using standard storage to using
    ///             Provisioned IOPS, or from using Provisioned IOPS to using standard storage, the process
    ///             can take time. The duration of the migration depends on several factors such as database
    ///             load, storage size, storage type (standard or Provisioned IOPS), amount of IOPS
    ///             provisioned (if any), and the number of prior scale storage operations. Typical
    ///             migration times are under 24 hours, but the process can take up to several days in some
    ///             cases. During the migration, the DB instance is available for use, but might experience
    ///             performance degradation. While the migration takes place, nightly backups for the
    ///             instance are suspended. No other Amazon RDS operations can take place for the instance,
    ///             including modifying the instance, rebooting the instance, deleting the instance,
    ///             creating a read replica for the instance, and creating a DB snapshot of the instance.
    ///
    ///           Valid values: standard | gp2 | io1
    ///
    ///          Default: io1 if the Iops parameter
    ///           is specified, otherwise gp2
    ///
    public var storageType: Swift.String?
    /// The ARN from the key store with which to associate the instance for TDE encryption.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device.
    public var tdeCredentialPassword: Swift.String?
    /// A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A list of EC2 VPC security groups to authorize on this DB instance. This change is asynchronously applied as soon as possible.
    ///
    ///             Amazon Aurora
    ///
    ///          Not applicable. The associated list of EC2 VPC security groups is managed by
    ///           the DB cluster. For more information, see ModifyDBCluster.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match existing VpcSecurityGroupIds.
    ///
    ///
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        allowMajorVersionUpgrade: Swift.Bool = false,
        applyImmediately: Swift.Bool = false,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        awsBackupRecoveryPointArn: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        cACertificateIdentifier: Swift.String? = nil,
        certificateRotationRestart: Swift.Bool? = nil,
        cloudwatchLogsExportConfiguration: RdsClientTypes.CloudwatchLogsExportConfiguration? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBPortNumber: Swift.Int? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        newDBInstanceIdentifier: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        promotionTier: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        replicaMode: RdsClientTypes.ReplicaMode? = nil,
        storageType: Swift.String? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.applyImmediately = applyImmediately
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.awsBackupRecoveryPointArn = awsBackupRecoveryPointArn
        self.backupRetentionPeriod = backupRetentionPeriod
        self.cACertificateIdentifier = cACertificateIdentifier
        self.certificateRotationRestart = certificateRotationRestart
        self.cloudwatchLogsExportConfiguration = cloudwatchLogsExportConfiguration
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBParameterGroupName = dBParameterGroupName
        self.dBPortNumber = dBPortNumber
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engineVersion = engineVersion
        self.iops = iops
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.newDBInstanceIdentifier = newDBInstanceIdentifier
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.promotionTier = promotionTier
        self.publiclyAccessible = publiclyAccessible
        self.replicaMode = replicaMode
        self.storageType = storageType
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFound" : self = .certificateNotFoundFault(try CertificateNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBUpgradeDependencyFailure" : self = .dBUpgradeDependencyFailureFault(try DBUpgradeDependencyFailureFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case certificateNotFoundFault(CertificateNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBUpgradeDependencyFailureFault(DBUpgradeDependencyFailureFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension ModifyDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct ModifyDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct ModifyDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension ModifyDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct ModifyDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

extension ModifyDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBParameterGroupInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), parameters: \(Swift.String(describing: parameters)))"}
}

extension ModifyDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

public struct ModifyDBParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBParameterGroupOutputError>
}

///
public struct ModifyDBParameterGroupInput: Swift.Equatable {
    /// The name of the DB parameter group.
    ///          Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DBParameterGroup.
    ///
    ///
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// An array of parameter names, values, and the application methods for the parameter update. At least one parameter name, value, and
    ///           application method method must be supplied; later arguments are optional. A maximum of 20 parameters can be modified in a single request.
    ///          Valid Values (for the application method): immediate | pending-reboot
    ///
    ///
    ///             You can use the immediate value with dynamic parameters only. You can use the
    ///               pending-reboot value for both dynamic and static parameters.
    ///             When the application method is immediate, changes to dynamic parameters are applied immediately
    ///           to the DB instances associated with the parameter group. When the application method is pending-reboot,
    ///           changes to dynamic and static parameters are applied after a reboot without failover to the DB instances associated with the
    ///           parameter group.
    ///
    /// This member is required.
    public var parameters: [RdsClientTypes.Parameter]?

    public init (
        dBParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
    }
}

extension ModifyDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBParameterGroupOutputResponse(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)))"}
}

extension ModifyDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the
///         ModifyDBParameterGroup or ResetDBParameterGroup action.
///
public struct ModifyDBParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB parameter group.
    public var dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ModifyDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroupName: Swift.String?
}

extension ModifyDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

public struct ModifyDBProxyEndpointInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyEndpointOutputError>
}

extension ModifyDBProxyEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBProxyEndpointInput(dBProxyEndpointName: \(Swift.String(describing: dBProxyEndpointName)), newDBProxyEndpointName: \(Swift.String(describing: newDBProxyEndpointName)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension ModifyDBProxyEndpointInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBProxyEndpointName = dBProxyEndpointName {
            try container.encode(dBProxyEndpointName, forKey: ClientRuntime.Key("DBProxyEndpointName"))
        }
        if let newDBProxyEndpointName = newDBProxyEndpointName {
            try container.encode(newDBProxyEndpointName, forKey: ClientRuntime.Key("NewDBProxyEndpointName"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBProxyEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBProxyEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyEndpointOutputError>
}

public struct ModifyDBProxyEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyEndpointOutputError>
}

public struct ModifyDBProxyEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBProxyEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBProxyEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyEndpointOutputError>
}

public struct ModifyDBProxyEndpointInput: Swift.Equatable {
    /// The name of the DB proxy sociated with the DB proxy endpoint that you want to modify.
    /// This member is required.
    public var dBProxyEndpointName: Swift.String?
    /// The new identifier for the DBProxyEndpoint. An identifier must
    ///         begin with a letter and must contain only ASCII letters, digits, and hyphens; it
    ///         can't end with a hyphen or contain two consecutive hyphens.
    public var newDBProxyEndpointName: Swift.String?
    /// The VPC security group IDs for the DB proxy endpoint. When the DB proxy endpoint
    ///         uses a different VPC than the original proxy, you also specify a different
    ///         set of security group IDs than for the original proxy.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        dBProxyEndpointName: Swift.String? = nil,
        newDBProxyEndpointName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.dBProxyEndpointName = dBProxyEndpointName
        self.newDBProxyEndpointName = newDBProxyEndpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension ModifyDBProxyEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyEndpointAlreadyExistsFault" : self = .dBProxyEndpointAlreadyExistsFault(try DBProxyEndpointAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyEndpointNotFoundFault" : self = .dBProxyEndpointNotFoundFault(try DBProxyEndpointNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyEndpointStateFault" : self = .invalidDBProxyEndpointStateFault(try InvalidDBProxyEndpointStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyEndpointOutputError: Swift.Error, Swift.Equatable {
    case dBProxyEndpointAlreadyExistsFault(DBProxyEndpointAlreadyExistsFault)
    case dBProxyEndpointNotFoundFault(DBProxyEndpointNotFoundFault)
    case invalidDBProxyEndpointStateFault(InvalidDBProxyEndpointStateFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBProxyEndpointOutputResponse(dBProxyEndpoint: \(Swift.String(describing: dBProxyEndpoint)))"}
}

extension ModifyDBProxyEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBProxyEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyEndpoint = output.dBProxyEndpoint
        } else {
            self.dBProxyEndpoint = nil
        }
    }
}

public struct ModifyDBProxyEndpointOutputResponse: Swift.Equatable {
    /// The DBProxyEndpoint object representing the new settings for the DB proxy endpoint.
    public var dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?

    public init (
        dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint? = nil
    )
    {
        self.dBProxyEndpoint = dBProxyEndpoint
    }
}

struct ModifyDBProxyEndpointOutputResponseBody: Swift.Equatable {
    public let dBProxyEndpoint: RdsClientTypes.DBProxyEndpoint?
}

extension ModifyDBProxyEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyEndpoint = "DBProxyEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBProxyEndpointResult"))
        let dBProxyEndpointDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyEndpoint.self, forKey: .dBProxyEndpoint)
        dBProxyEndpoint = dBProxyEndpointDecoded
    }
}

public struct ModifyDBProxyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyOutputError>
}

extension ModifyDBProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBProxyInput(auth: \(Swift.String(describing: auth)), dBProxyName: \(Swift.String(describing: dBProxyName)), debugLogging: \(Swift.String(describing: debugLogging)), idleClientTimeout: \(Swift.String(describing: idleClientTimeout)), newDBProxyName: \(Swift.String(describing: newDBProxyName)), requireTLS: \(Swift.String(describing: requireTLS)), roleArn: \(Swift.String(describing: roleArn)), securityGroups: \(Swift.String(describing: securityGroups)))"}
}

extension ModifyDBProxyInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let auth = auth {
            var authContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Auth"))
            for (index0, userauthconfig0) in auth.enumerated() {
                try authContainer.encode(userauthconfig0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let debugLogging = debugLogging {
            try container.encode(debugLogging, forKey: ClientRuntime.Key("DebugLogging"))
        }
        if let idleClientTimeout = idleClientTimeout {
            try container.encode(idleClientTimeout, forKey: ClientRuntime.Key("IdleClientTimeout"))
        }
        if let newDBProxyName = newDBProxyName {
            try container.encode(newDBProxyName, forKey: ClientRuntime.Key("NewDBProxyName"))
        }
        if let requireTLS = requireTLS {
            try container.encode(requireTLS, forKey: ClientRuntime.Key("RequireTLS"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroups"))
            for (index0, string0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBProxy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBProxyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyOutputError>
}

public struct ModifyDBProxyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyOutputError>
}

public struct ModifyDBProxyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBProxyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBProxyInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyOutputError>
}

public struct ModifyDBProxyInput: Swift.Equatable {
    /// The new authentication settings for the DBProxy.
    public var auth: [RdsClientTypes.UserAuthConfig]?
    /// The identifier for the DBProxy to modify.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// Whether the proxy includes detailed information about SQL statements in its logs.
    ///         This information helps you to debug issues involving SQL behavior or the performance
    ///         and scalability of the proxy connections. The debug information includes the text of
    ///         SQL statements that you submit through the proxy. Thus, only enable this setting
    ///         when needed for debugging, and only when you have security measures in place to
    ///         safeguard any sensitive information that appears in the logs.
    public var debugLogging: Swift.Bool?
    /// The number of seconds that a connection to the proxy can be inactive before the proxy disconnects it. You can set this
    ///         value higher or lower than the connection timeout limit for the associated database.
    public var idleClientTimeout: Swift.Int?
    /// The new identifier for the DBProxy. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    public var newDBProxyName: Swift.String?
    /// Whether Transport Layer Security (TLS) encryption is required for connections to the proxy.
    ///         By enabling this setting, you can enforce encrypted TLS connections to the proxy, even if the associated database doesn't
    ///         use TLS.
    public var requireTLS: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role that the proxy uses to access secrets in Amazon Web Services Secrets Manager.
    public var roleArn: Swift.String?
    /// The new list of security groups for the DBProxy.
    public var securityGroups: [Swift.String]?

    public init (
        auth: [RdsClientTypes.UserAuthConfig]? = nil,
        dBProxyName: Swift.String? = nil,
        debugLogging: Swift.Bool? = nil,
        idleClientTimeout: Swift.Int? = nil,
        newDBProxyName: Swift.String? = nil,
        requireTLS: Swift.Bool? = nil,
        roleArn: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.auth = auth
        self.dBProxyName = dBProxyName
        self.debugLogging = debugLogging
        self.idleClientTimeout = idleClientTimeout
        self.newDBProxyName = newDBProxyName
        self.requireTLS = requireTLS
        self.roleArn = roleArn
        self.securityGroups = securityGroups
    }
}

extension ModifyDBProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyAlreadyExistsFault" : self = .dBProxyAlreadyExistsFault(try DBProxyAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyOutputError: Swift.Error, Swift.Equatable {
    case dBProxyAlreadyExistsFault(DBProxyAlreadyExistsFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBProxyOutputResponse(dBProxy: \(Swift.String(describing: dBProxy)))"}
}

extension ModifyDBProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxy = output.dBProxy
        } else {
            self.dBProxy = nil
        }
    }
}

public struct ModifyDBProxyOutputResponse: Swift.Equatable {
    /// The DBProxy object representing the new settings for the proxy.
    public var dBProxy: RdsClientTypes.DBProxy?

    public init (
        dBProxy: RdsClientTypes.DBProxy? = nil
    )
    {
        self.dBProxy = dBProxy
    }
}

struct ModifyDBProxyOutputResponseBody: Swift.Equatable {
    public let dBProxy: RdsClientTypes.DBProxy?
}

extension ModifyDBProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxy = "DBProxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBProxyResult"))
        let dBProxyDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxy.self, forKey: .dBProxy)
        dBProxy = dBProxyDecoded
    }
}

public struct ModifyDBProxyTargetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyTargetGroupOutputError>
}

extension ModifyDBProxyTargetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBProxyTargetGroupInput(connectionPoolConfig: \(Swift.String(describing: connectionPoolConfig)), dBProxyName: \(Swift.String(describing: dBProxyName)), newName: \(Swift.String(describing: newName)), targetGroupName: \(Swift.String(describing: targetGroupName)))"}
}

extension ModifyDBProxyTargetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let connectionPoolConfig = connectionPoolConfig {
            try container.encode(connectionPoolConfig, forKey: ClientRuntime.Key("ConnectionPoolConfig"))
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let newName = newName {
            try container.encode(newName, forKey: ClientRuntime.Key("NewName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("ModifyDBProxyTargetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBProxyTargetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyTargetGroupOutputError>
}

public struct ModifyDBProxyTargetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBProxyTargetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBProxyTargetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyTargetGroupOutputError>
}

public struct ModifyDBProxyTargetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBProxyTargetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBProxyTargetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBProxyTargetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBProxyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBProxyTargetGroupOutputError>
}

public struct ModifyDBProxyTargetGroupInput: Swift.Equatable {
    /// The settings that determine the size and behavior of the connection pool for the target group.
    public var connectionPoolConfig: RdsClientTypes.ConnectionPoolConfiguration?
    /// The name of the new proxy to which to assign the target group.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// The new name for the modified DBProxyTarget. An identifier must begin with a letter and must contain only ASCII letters, digits, and hyphens; it can't end with a hyphen or contain two consecutive hyphens.
    public var newName: Swift.String?
    /// The name of the new target group to assign to the proxy.
    /// This member is required.
    public var targetGroupName: Swift.String?

    public init (
        connectionPoolConfig: RdsClientTypes.ConnectionPoolConfiguration? = nil,
        dBProxyName: Swift.String? = nil,
        newName: Swift.String? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.connectionPoolConfig = connectionPoolConfig
        self.dBProxyName = dBProxyName
        self.newName = newName
        self.targetGroupName = targetGroupName
    }
}

extension ModifyDBProxyTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBProxyTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBProxyTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBProxyTargetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBProxyTargetGroupOutputResponse(dBProxyTargetGroup: \(Swift.String(describing: dBProxyTargetGroup)))"}
}

extension ModifyDBProxyTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBProxyTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyTargetGroup = output.dBProxyTargetGroup
        } else {
            self.dBProxyTargetGroup = nil
        }
    }
}

public struct ModifyDBProxyTargetGroupOutputResponse: Swift.Equatable {
    /// The settings of the modified DBProxyTarget.
    public var dBProxyTargetGroup: RdsClientTypes.DBProxyTargetGroup?

    public init (
        dBProxyTargetGroup: RdsClientTypes.DBProxyTargetGroup? = nil
    )
    {
        self.dBProxyTargetGroup = dBProxyTargetGroup
    }
}

struct ModifyDBProxyTargetGroupOutputResponseBody: Swift.Equatable {
    public let dBProxyTargetGroup: RdsClientTypes.DBProxyTargetGroup?
}

extension ModifyDBProxyTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyTargetGroup = "DBProxyTargetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBProxyTargetGroupResult"))
        let dBProxyTargetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBProxyTargetGroup.self, forKey: .dBProxyTargetGroup)
        dBProxyTargetGroup = dBProxyTargetGroupDecoded
    }
}

public struct ModifyDBSnapshotAttributeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotAttributeOutputError>
}

extension ModifyDBSnapshotAttributeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSnapshotAttributeInput(attributeName: \(Swift.String(describing: attributeName)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)), valuesToAdd: \(Swift.String(describing: valuesToAdd)), valuesToRemove: \(Swift.String(describing: valuesToRemove)))"}
}

extension ModifyDBSnapshotAttributeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let valuesToAdd = valuesToAdd {
            var valuesToAddContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToAdd"))
            for (index0, string0) in valuesToAdd.enumerated() {
                try valuesToAddContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        if let valuesToRemove = valuesToRemove {
            var valuesToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValuesToRemove"))
            for (index0, string0) in valuesToRemove.enumerated() {
                try valuesToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("AttributeValue.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSnapshotAttribute", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBSnapshotAttributeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotAttributeOutputError>
}

public struct ModifyDBSnapshotAttributeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSnapshotAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSnapshotAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotAttributeOutputError>
}

public struct ModifyDBSnapshotAttributeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotAttributeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBSnapshotAttributeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBSnapshotAttributeInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotAttributeOutputError>
}

///
public struct ModifyDBSnapshotAttributeInput: Swift.Equatable {
    /// The name of the DB snapshot attribute to modify.
    ///          To manage authorization for other Amazon Web Services accounts to copy or restore a manual DB snapshot,
    ///       set this value to restore.
    ///
    ///             To view the list of attributes available to modify, use the
    ///               DescribeDBSnapshotAttributes API action.
    ///
    /// This member is required.
    public var attributeName: Swift.String?
    /// The identifier for the DB snapshot to modify the attributes for.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// A list of DB snapshot attributes to add to the attribute specified by AttributeName.
    ///          To authorize other Amazon Web Services accounts to copy or restore a manual snapshot, set this list to include one or more Amazon Web Services account
    ///       IDs, or all to make the manual DB snapshot restorable by
    ///       any Amazon Web Services account. Do not add the all value for any
    ///       manual DB snapshots that contain private information that you don't want available
    ///       to all Amazon Web Services accounts.
    public var valuesToAdd: [Swift.String]?
    /// A list of DB snapshot attributes to remove from the attribute specified by AttributeName.
    ///          To remove authorization for other Amazon Web Services accounts to copy or restore a manual snapshot, set this list to include
    ///       one or more Amazon Web Services account
    ///       identifiers, or all to remove authorization for any Amazon Web Services account to copy or
    ///       restore the DB snapshot. If you specify all, an Amazon Web Services account whose
    ///       account ID is explicitly added to the restore attribute
    ///       can still copy or restore the manual DB snapshot.
    public var valuesToRemove: [Swift.String]?

    public init (
        attributeName: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        valuesToAdd: [Swift.String]? = nil,
        valuesToRemove: [Swift.String]? = nil
    )
    {
        self.attributeName = attributeName
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.valuesToAdd = valuesToAdd
        self.valuesToRemove = valuesToRemove
    }
}

extension ModifyDBSnapshotAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSnapshotAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SharedSnapshotQuotaExceeded" : self = .sharedSnapshotQuotaExceededFault(try SharedSnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSnapshotAttributeOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case sharedSnapshotQuotaExceededFault(SharedSnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSnapshotAttributeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSnapshotAttributeOutputResponse(dBSnapshotAttributesResult: \(Swift.String(describing: dBSnapshotAttributesResult)))"}
}

extension ModifyDBSnapshotAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSnapshotAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshotAttributesResult = output.dBSnapshotAttributesResult
        } else {
            self.dBSnapshotAttributesResult = nil
        }
    }
}

public struct ModifyDBSnapshotAttributeOutputResponse: Swift.Equatable {
    /// Contains the results of a successful call to the DescribeDBSnapshotAttributes
    ///     API action.
    ///          Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts
    ///       to copy or restore a manual DB snapshot. For more information, see the ModifyDBSnapshotAttribute
    ///       API action.
    public var dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?

    public init (
        dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult? = nil
    )
    {
        self.dBSnapshotAttributesResult = dBSnapshotAttributesResult
    }
}

struct ModifyDBSnapshotAttributeOutputResponseBody: Swift.Equatable {
    public let dBSnapshotAttributesResult: RdsClientTypes.DBSnapshotAttributesResult?
}

extension ModifyDBSnapshotAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshotAttributesResult = "DBSnapshotAttributesResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSnapshotAttributeResult"))
        let dBSnapshotAttributesResultDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshotAttributesResult.self, forKey: .dBSnapshotAttributesResult)
        dBSnapshotAttributesResult = dBSnapshotAttributesResultDecoded
    }
}

public struct ModifyDBSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotOutputError>
}

extension ModifyDBSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSnapshotInput(dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)), engineVersion: \(Swift.String(describing: engineVersion)), optionGroupName: \(Swift.String(describing: optionGroupName)))"}
}

extension ModifyDBSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        try container.encode("ModifyDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotOutputError>
}

public struct ModifyDBSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotOutputError>
}

public struct ModifyDBSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSnapshotOutputError>
}

public struct ModifyDBSnapshotInput: Swift.Equatable {
    /// The identifier of the DB snapshot to modify.
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// The engine version to upgrade the DB snapshot to.
    ///
    ///
    ///          The following are the database engines and engine versions that are available when you upgrade a DB snapshot.
    ///
    ///
    ///
    ///             MySQL
    ///
    ///
    ///
    ///
    ///
    ///                   5.5.46 (supported for 5.1 DB snapshots)
    ///
    ///
    ///
    ///
    ///
    ///             Oracle
    ///
    ///
    ///
    ///
    ///
    ///                   12.1.0.2.v8  (supported for 12.1.0.1 DB snapshots)
    ///
    ///
    ///
    ///                   11.2.0.4.v12 (supported for 11.2.0.2 DB snapshots)
    ///
    ///
    ///
    ///                   11.2.0.4.v11 (supported for 11.2.0.3 DB snapshots)
    ///
    ///
    ///
    ///
    ///             PostgreSQL
    ///
    ///          For the list of engine versions that are available for upgrading a DB snapshot, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.PostgreSQL.html#USER_UpgradeDBInstance.PostgreSQL.MajorVersion">
    ///               Upgrading the PostgreSQL DB Engine for Amazon RDS.
    ///
    public var engineVersion: Swift.String?
    /// The option group to identify with the upgraded DB snapshot.
    ///
    ///
    ///         You can specify this parameter when you upgrade an Oracle DB snapshot.
    ///             The same option group considerations apply when upgrading a DB snapshot as when upgrading a DB instance.
    ///             For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Oracle.html#USER_UpgradeDBInstance.Oracle.OGPG.OG">Option group considerations in the Amazon RDS User Guide.
    ///
    public var optionGroupName: Swift.String?

    public init (
        dBSnapshotIdentifier: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        optionGroupName: Swift.String? = nil
    )
    {
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.engineVersion = engineVersion
        self.optionGroupName = optionGroupName
    }
}

extension ModifyDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSnapshotOutputResponse(dBSnapshot: \(Swift.String(describing: dBSnapshot)))"}
}

extension ModifyDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSnapshot = output.dBSnapshot
        } else {
            self.dBSnapshot = nil
        }
    }
}

public struct ModifyDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB snapshot.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSnapshots action.
    ///
    public var dBSnapshot: RdsClientTypes.DBSnapshot?

    public init (
        dBSnapshot: RdsClientTypes.DBSnapshot? = nil
    )
    {
        self.dBSnapshot = dBSnapshot
    }
}

struct ModifyDBSnapshotOutputResponseBody: Swift.Equatable {
    public let dBSnapshot: RdsClientTypes.DBSnapshot?
}

extension ModifyDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSnapshot = "DBSnapshot"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSnapshotResult"))
        let dBSnapshotDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSnapshot.self, forKey: .dBSnapshot)
        dBSnapshot = dBSnapshotDecoded
    }
}

public struct ModifyDBSubnetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

extension ModifyDBSubnetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSubnetGroupInput(dBSubnetGroupDescription: \(Swift.String(describing: dBSubnetGroupDescription)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension ModifyDBSubnetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSubnetGroupDescription = dBSubnetGroupDescription {
            try container.encode(dBSubnetGroupDescription, forKey: ClientRuntime.Key("DBSubnetGroupDescription"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SubnetIds"))
            for (index0, string0) in subnetIds.enumerated() {
                try subnetIdsContainer.encode(string0, forKey: ClientRuntime.Key("SubnetIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyDBSubnetGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyDBSubnetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyDBSubnetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

public struct ModifyDBSubnetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyDBSubnetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyDBSubnetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyDBSubnetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyDBSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyDBSubnetGroupOutputError>
}

///
public struct ModifyDBSubnetGroupInput: Swift.Equatable {
    /// The description for the DB subnet group.
    public var dBSubnetGroupDescription: Swift.String?
    /// The name for the DB subnet group. This value is stored as a lowercase string.
    ///           You can't modify the default subnet group.
    ///
    ///          Constraints: Must match the name of an existing DBSubnetGroup. Must not be default.
    ///          Example: mySubnetgroup
    ///
    /// This member is required.
    public var dBSubnetGroupName: Swift.String?
    /// The EC2 subnet IDs for the DB subnet group.
    /// This member is required.
    public var subnetIds: [Swift.String]?

    public init (
        dBSubnetGroupDescription: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil
    )
    {
        self.dBSubnetGroupDescription = dBSubnetGroupDescription
        self.dBSubnetGroupName = dBSubnetGroupName
        self.subnetIds = subnetIds
    }
}

extension ModifyDBSubnetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyDBSubnetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetQuotaExceededFault" : self = .dBSubnetQuotaExceededFault(try DBSubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetAlreadyInUse" : self = .subnetAlreadyInUse(try SubnetAlreadyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyDBSubnetGroupOutputError: Swift.Error, Swift.Equatable {
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case dBSubnetQuotaExceededFault(DBSubnetQuotaExceededFault)
    case invalidSubnet(InvalidSubnet)
    case subnetAlreadyInUse(SubnetAlreadyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyDBSubnetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyDBSubnetGroupOutputResponse(dBSubnetGroup: \(Swift.String(describing: dBSubnetGroup)))"}
}

extension ModifyDBSubnetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyDBSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSubnetGroup = output.dBSubnetGroup
        } else {
            self.dBSubnetGroup = nil
        }
    }
}

public struct ModifyDBSubnetGroupOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB subnet group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSubnetGroups action.
    ///
    public var dBSubnetGroup: RdsClientTypes.DBSubnetGroup?

    public init (
        dBSubnetGroup: RdsClientTypes.DBSubnetGroup? = nil
    )
    {
        self.dBSubnetGroup = dBSubnetGroup
    }
}

struct ModifyDBSubnetGroupOutputResponseBody: Swift.Equatable {
    public let dBSubnetGroup: RdsClientTypes.DBSubnetGroup?
}

extension ModifyDBSubnetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSubnetGroup = "DBSubnetGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyDBSubnetGroupResult"))
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSubnetGroup.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
    }
}

public struct ModifyEventSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

extension ModifyEventSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionInput(enabled: \(Swift.String(describing: enabled)), eventCategories: \(Swift.String(describing: eventCategories)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), sourceType: \(Swift.String(describing: sourceType)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension ModifyEventSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let eventCategories = eventCategories {
            var eventCategoriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EventCategories"))
            for (index0, string0) in eventCategories.enumerated() {
                try eventCategoriesContainer.encode(string0, forKey: ClientRuntime.Key("EventCategory.\(index0.advanced(by: 1))"))
            }
        }
        if let snsTopicArn = snsTopicArn {
            try container.encode(snsTopicArn, forKey: ClientRuntime.Key("SnsTopicArn"))
        }
        if let sourceType = sourceType {
            try container.encode(sourceType, forKey: ClientRuntime.Key("SourceType"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("ModifyEventSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyEventSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyEventSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

public struct ModifyEventSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyEventSubscriptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyEventSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyEventSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyEventSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyEventSubscriptionOutputError>
}

///
public struct ModifyEventSubscriptionInput: Swift.Equatable {
    ///
    ///             A value that indicates whether to activate the subscription.
    ///
    public var enabled: Swift.Bool?
    ///
    ///             A list of event categories for a source type (SourceType) that you want to subscribe to.
    ///             You can see a list of the categories for a given source type
    ///             in <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.html">Events in the Amazon RDS User Guide
    ///             or by using the DescribeEventCategories operation.
    ///
    public var eventCategories: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the SNS topic created for event notification. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
    public var snsTopicArn: Swift.String?
    /// The type of source that is generating the events. For example, if you want to be notified of events generated by a DB instance, you would set this parameter to db-instance. If this value isn't specified, all events are returned.
    ///          Valid values: db-instance | db-cluster | db-parameter-group | db-security-group | db-snapshot | db-cluster-snapshot
    ///
    public var sourceType: Swift.String?
    /// The name of the RDS event notification subscription.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        enabled: Swift.Bool? = nil,
        eventCategories: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        sourceType: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.enabled = enabled
        self.eventCategories = eventCategories
        self.snsTopicArn = snsTopicArn
        self.sourceType = sourceType
        self.subscriptionName = subscriptionName
    }
}

extension ModifyEventSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyEventSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EventSubscriptionQuotaExceeded" : self = .eventSubscriptionQuotaExceededFault(try EventSubscriptionQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSInvalidTopic" : self = .sNSInvalidTopicFault(try SNSInvalidTopicFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSNoAuthorization" : self = .sNSNoAuthorizationFault(try SNSNoAuthorizationFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SNSTopicArnNotFound" : self = .sNSTopicArnNotFoundFault(try SNSTopicArnNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionCategoryNotFound" : self = .subscriptionCategoryNotFoundFault(try SubscriptionCategoryNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyEventSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case eventSubscriptionQuotaExceededFault(EventSubscriptionQuotaExceededFault)
    case sNSInvalidTopicFault(SNSInvalidTopicFault)
    case sNSNoAuthorizationFault(SNSNoAuthorizationFault)
    case sNSTopicArnNotFoundFault(SNSTopicArnNotFoundFault)
    case subscriptionCategoryNotFoundFault(SubscriptionCategoryNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyEventSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyEventSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension ModifyEventSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyEventSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct ModifyEventSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct ModifyEventSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RdsClientTypes.EventSubscription?
}

extension ModifyEventSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyEventSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct ModifyGlobalClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyGlobalClusterOutputError>
}

extension ModifyGlobalClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyGlobalClusterInput(allowMajorVersionUpgrade: \(Swift.String(describing: allowMajorVersionUpgrade)), deletionProtection: \(Swift.String(describing: deletionProtection)), engineVersion: \(Swift.String(describing: engineVersion)), globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)), newGlobalClusterIdentifier: \(Swift.String(describing: newGlobalClusterIdentifier)))"}
}

extension ModifyGlobalClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowMajorVersionUpgrade = allowMajorVersionUpgrade {
            try container.encode(allowMajorVersionUpgrade, forKey: ClientRuntime.Key("AllowMajorVersionUpgrade"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        if let newGlobalClusterIdentifier = newGlobalClusterIdentifier {
            try container.encode(newGlobalClusterIdentifier, forKey: ClientRuntime.Key("NewGlobalClusterIdentifier"))
        }
        try container.encode("ModifyGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyGlobalClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyGlobalClusterOutputError>
}

public struct ModifyGlobalClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyGlobalClusterOutputError>
}

public struct ModifyGlobalClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyGlobalClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyGlobalClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyGlobalClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyGlobalClusterOutputError>
}

public struct ModifyGlobalClusterInput: Swift.Equatable {
    /// A value that indicates whether major version upgrades are allowed.
    ///          Constraints: You must allow major version upgrades when specifying a value for the
    ///                 EngineVersion parameter that is a different major version than the DB
    ///             cluster's current version.
    ///          If you upgrade the major version of a global database, the cluster and DB instance parameter
    ///         groups are set to the default parameter groups for the new version. Apply any custom parameter
    ///         groups after completing the upgrade.
    public var allowMajorVersionUpgrade: Swift.Bool?
    ///
    ///         Indicates if the global database cluster has deletion protection enabled. The global database cluster
    ///         can't be deleted when deletion protection is enabled.
    ///
    public var deletionProtection: Swift.Bool?
    /// The version number of the database engine to which you want to upgrade.
    ///           Changing this parameter results in an outage. The change is applied during
    ///           the next maintenance window unless ApplyImmediately is enabled.
    ///          To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'
    ///
    ///          To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-mysql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'
    ///
    ///          To list all of the available engine versions for aurora-postgresql, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-postgresql --query '*[]|[?SupportsGlobalDatabases == `true`].[EngineVersion]'
    ///
    public var engineVersion: Swift.String?
    ///
    ///         The DB cluster identifier for the global cluster being modified. This parameter isn't case-sensitive.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing global database cluster.
    ///
    ///
    public var globalClusterIdentifier: Swift.String?
    ///
    ///         The new cluster identifier for the global database cluster when modifying a global database cluster.
    ///         This value is stored as a lowercase string.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    ///
    ///                The first character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-cluster2
    ///
    public var newGlobalClusterIdentifier: Swift.String?

    public init (
        allowMajorVersionUpgrade: Swift.Bool? = nil,
        deletionProtection: Swift.Bool? = nil,
        engineVersion: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil,
        newGlobalClusterIdentifier: Swift.String? = nil
    )
    {
        self.allowMajorVersionUpgrade = allowMajorVersionUpgrade
        self.deletionProtection = deletionProtection
        self.engineVersion = engineVersion
        self.globalClusterIdentifier = globalClusterIdentifier
        self.newGlobalClusterIdentifier = newGlobalClusterIdentifier
    }
}

extension ModifyGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyGlobalClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyGlobalClusterOutputResponse(globalCluster: \(Swift.String(describing: globalCluster)))"}
}

extension ModifyGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct ModifyGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct ModifyGlobalClusterOutputResponseBody: Swift.Equatable {
    public let globalCluster: RdsClientTypes.GlobalCluster?
}

extension ModifyGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct ModifyOptionGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyOptionGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyOptionGroupOutputError>
}

extension ModifyOptionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyOptionGroupInput(applyImmediately: \(Swift.String(describing: applyImmediately)), optionGroupName: \(Swift.String(describing: optionGroupName)), optionsToInclude: \(Swift.String(describing: optionsToInclude)), optionsToRemove: \(Swift.String(describing: optionsToRemove)))"}
}

extension ModifyOptionGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if applyImmediately != false {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let optionsToInclude = optionsToInclude {
            var optionsToIncludeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsToInclude"))
            for (index0, optionconfiguration0) in optionsToInclude.enumerated() {
                try optionsToIncludeContainer.encode(optionconfiguration0, forKey: ClientRuntime.Key("OptionConfiguration.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsToRemove = optionsToRemove {
            var optionsToRemoveContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsToRemove"))
            for (index0, string0) in optionsToRemove.enumerated() {
                try optionsToRemoveContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("ModifyOptionGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ModifyOptionGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyOptionGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyOptionGroupOutputError>
}

public struct ModifyOptionGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyOptionGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyOptionGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyOptionGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyOptionGroupOutputError>
}

public struct ModifyOptionGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyOptionGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ModifyOptionGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ModifyOptionGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyOptionGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyOptionGroupOutputError>
}

///
public struct ModifyOptionGroupInput: Swift.Equatable {
    /// A value that indicates whether to apply the change immediately or during the next maintenance window for each instance associated with the option group.
    public var applyImmediately: Swift.Bool
    /// The name of the option group to be modified.
    ///          Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance
    /// This member is required.
    public var optionGroupName: Swift.String?
    /// Options in this list are added to the option group or, if already present, the specified configuration is used to update the existing configuration.
    public var optionsToInclude: [RdsClientTypes.OptionConfiguration]?
    /// Options in this list are removed from the option group.
    public var optionsToRemove: [Swift.String]?

    public init (
        applyImmediately: Swift.Bool = false,
        optionGroupName: Swift.String? = nil,
        optionsToInclude: [RdsClientTypes.OptionConfiguration]? = nil,
        optionsToRemove: [Swift.String]? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.optionGroupName = optionGroupName
        self.optionsToInclude = optionsToInclude
        self.optionsToRemove = optionsToRemove
    }
}

extension ModifyOptionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyOptionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidOptionGroupStateFault" : self = .invalidOptionGroupStateFault(try InvalidOptionGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyOptionGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidOptionGroupStateFault(InvalidOptionGroupStateFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyOptionGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyOptionGroupOutputResponse(optionGroup: \(Swift.String(describing: optionGroup)))"}
}

extension ModifyOptionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyOptionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.optionGroup = output.optionGroup
        } else {
            self.optionGroup = nil
        }
    }
}

public struct ModifyOptionGroupOutputResponse: Swift.Equatable {
    ///
    public var optionGroup: RdsClientTypes.OptionGroup?

    public init (
        optionGroup: RdsClientTypes.OptionGroup? = nil
    )
    {
        self.optionGroup = optionGroup
    }
}

struct ModifyOptionGroupOutputResponseBody: Swift.Equatable {
    public let optionGroup: RdsClientTypes.OptionGroup?
}

extension ModifyOptionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroup = "OptionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ModifyOptionGroupResult"))
        let optionGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.OptionGroup.self, forKey: .optionGroup)
        optionGroup = optionGroupDecoded
    }
}

extension RdsClientTypes.Option: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupMemberships = "DBSecurityGroupMemberships"
        case optionDescription = "OptionDescription"
        case optionName = "OptionName"
        case optionSettings = "OptionSettings"
        case optionVersion = "OptionVersion"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case port = "Port"
        case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupMemberships = dBSecurityGroupMemberships {
            var dBSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroupMemberships"))
            for (index0, dbsecuritygroupmembership0) in dBSecurityGroupMemberships.enumerated() {
                try dBSecurityGroupMembershipsContainer.encode(dbsecuritygroupmembership0, forKey: ClientRuntime.Key("DBSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let optionDescription = optionDescription {
            try container.encode(optionDescription, forKey: ClientRuntime.Key("OptionDescription"))
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: ClientRuntime.Key("OptionName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionSettings"))
            for (index0, optionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(optionsetting0, forKey: ClientRuntime.Key("OptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionVersion = optionVersion {
            try container.encode(optionVersion, forKey: ClientRuntime.Key("OptionVersion"))
        }
        if permanent != false {
            try container.encode(permanent, forKey: ClientRuntime.Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: ClientRuntime.Key("Persistent"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let vpcSecurityGroupMemberships = vpcSecurityGroupMemberships {
            var vpcSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupMemberships"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroupMemberships.enumerated() {
                try vpcSecurityGroupMembershipsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let optionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionDescription)
        optionDescription = optionDescriptionDecoded
        let persistentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let optionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionVersion)
        optionVersion = optionVersionDecoded
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct OptionSetting{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionSetting>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[RdsClientTypes.OptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [RdsClientTypes.OptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
        if containerValues.contains(.dBSecurityGroupMemberships) {
            struct KeyVal0{struct DBSecurityGroup{}}
            let dBSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroup>.CodingKeys.self, forKey: .dBSecurityGroupMemberships)
            if let dBSecurityGroupMembershipsWrappedContainer = dBSecurityGroupMembershipsWrappedContainer {
                let dBSecurityGroupMembershipsContainer = try dBSecurityGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DBSecurityGroupMembership].self, forKey: .member)
                var dBSecurityGroupMembershipsBuffer:[RdsClientTypes.DBSecurityGroupMembership]? = nil
                if let dBSecurityGroupMembershipsContainer = dBSecurityGroupMembershipsContainer {
                    dBSecurityGroupMembershipsBuffer = [RdsClientTypes.DBSecurityGroupMembership]()
                    for structureContainer0 in dBSecurityGroupMembershipsContainer {
                        dBSecurityGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBSecurityGroupMemberships = dBSecurityGroupMembershipsBuffer
            } else {
                dBSecurityGroupMemberships = []
            }
        } else {
            dBSecurityGroupMemberships = nil
        }
        if containerValues.contains(.vpcSecurityGroupMemberships) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroupMemberships)
            if let vpcSecurityGroupMembershipsWrappedContainer = vpcSecurityGroupMembershipsWrappedContainer {
                let vpcSecurityGroupMembershipsContainer = try vpcSecurityGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupMembershipsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupMembershipsContainer = vpcSecurityGroupMembershipsContainer {
                    vpcSecurityGroupMembershipsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupMembershipsContainer {
                        vpcSecurityGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroupMemberships = vpcSecurityGroupMembershipsBuffer
            } else {
                vpcSecurityGroupMemberships = []
            }
        } else {
            vpcSecurityGroupMemberships = nil
        }
    }
}

extension RdsClientTypes.Option: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Option(dBSecurityGroupMemberships: \(Swift.String(describing: dBSecurityGroupMemberships)), optionDescription: \(Swift.String(describing: optionDescription)), optionName: \(Swift.String(describing: optionName)), optionSettings: \(Swift.String(describing: optionSettings)), optionVersion: \(Swift.String(describing: optionVersion)), permanent: \(Swift.String(describing: permanent)), persistent: \(Swift.String(describing: persistent)), port: \(Swift.String(describing: port)), vpcSecurityGroupMemberships: \(Swift.String(describing: vpcSecurityGroupMemberships)))"}
}

extension RdsClientTypes {
    /// Option details.
    public struct Option: Swift.Equatable {
        /// If the option requires access to a port, then this DB security group allows access to the port.
        public var dBSecurityGroupMemberships: [RdsClientTypes.DBSecurityGroupMembership]?
        /// The description of the option.
        public var optionDescription: Swift.String?
        /// The name of the option.
        public var optionName: Swift.String?
        /// The option settings for this option.
        public var optionSettings: [RdsClientTypes.OptionSetting]?
        /// The version of the option.
        public var optionVersion: Swift.String?
        /// Indicate if this option is permanent.
        public var permanent: Swift.Bool
        /// Indicate if this option is persistent.
        public var persistent: Swift.Bool
        /// If required, the port configured for this option to use.
        public var port: Swift.Int?
        /// If the option requires access to a port, then this VPC security group allows access to the port.
        public var vpcSecurityGroupMemberships: [RdsClientTypes.VpcSecurityGroupMembership]?

        public init (
            dBSecurityGroupMemberships: [RdsClientTypes.DBSecurityGroupMembership]? = nil,
            optionDescription: Swift.String? = nil,
            optionName: Swift.String? = nil,
            optionSettings: [RdsClientTypes.OptionSetting]? = nil,
            optionVersion: Swift.String? = nil,
            permanent: Swift.Bool = false,
            persistent: Swift.Bool = false,
            port: Swift.Int? = nil,
            vpcSecurityGroupMemberships: [RdsClientTypes.VpcSecurityGroupMembership]? = nil
        )
        {
            self.dBSecurityGroupMemberships = dBSecurityGroupMemberships
            self.optionDescription = optionDescription
            self.optionName = optionName
            self.optionSettings = optionSettings
            self.optionVersion = optionVersion
            self.permanent = permanent
            self.persistent = persistent
            self.port = port
            self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
        }
    }

}

extension RdsClientTypes.OptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroupMemberships = "DBSecurityGroupMemberships"
        case optionName = "OptionName"
        case optionSettings = "OptionSettings"
        case optionVersion = "OptionVersion"
        case port = "Port"
        case vpcSecurityGroupMemberships = "VpcSecurityGroupMemberships"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBSecurityGroupMemberships = dBSecurityGroupMemberships {
            var dBSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroupMemberships"))
            for (index0, string0) in dBSecurityGroupMemberships.enumerated() {
                try dBSecurityGroupMembershipsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionName = optionName {
            try container.encode(optionName, forKey: ClientRuntime.Key("OptionName"))
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionSettings"))
            for (index0, optionsetting0) in optionSettings.enumerated() {
                try optionSettingsContainer.encode(optionsetting0, forKey: ClientRuntime.Key("OptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionVersion = optionVersion {
            try container.encode(optionVersion, forKey: ClientRuntime.Key("OptionVersion"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let vpcSecurityGroupMemberships = vpcSecurityGroupMemberships {
            var vpcSecurityGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupMemberships"))
            for (index0, string0) in vpcSecurityGroupMemberships.enumerated() {
                try vpcSecurityGroupMembershipsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let optionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionVersion)
        optionVersion = optionVersionDecoded
        if containerValues.contains(.dBSecurityGroupMemberships) {
            struct KeyVal0{struct DBSecurityGroupName{}}
            let dBSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBSecurityGroupName>.CodingKeys.self, forKey: .dBSecurityGroupMemberships)
            if let dBSecurityGroupMembershipsWrappedContainer = dBSecurityGroupMembershipsWrappedContainer {
                let dBSecurityGroupMembershipsContainer = try dBSecurityGroupMembershipsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var dBSecurityGroupMembershipsBuffer:[Swift.String]? = nil
                if let dBSecurityGroupMembershipsContainer = dBSecurityGroupMembershipsContainer {
                    dBSecurityGroupMembershipsBuffer = [Swift.String]()
                    for stringContainer0 in dBSecurityGroupMembershipsContainer {
                        dBSecurityGroupMembershipsBuffer?.append(stringContainer0)
                    }
                }
                dBSecurityGroupMemberships = dBSecurityGroupMembershipsBuffer
            } else {
                dBSecurityGroupMemberships = []
            }
        } else {
            dBSecurityGroupMemberships = nil
        }
        if containerValues.contains(.vpcSecurityGroupMemberships) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupMemberships)
            if let vpcSecurityGroupMembershipsWrappedContainer = vpcSecurityGroupMembershipsWrappedContainer {
                let vpcSecurityGroupMembershipsContainer = try vpcSecurityGroupMembershipsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupMembershipsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupMembershipsContainer = vpcSecurityGroupMembershipsContainer {
                    vpcSecurityGroupMembershipsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupMembershipsContainer {
                        vpcSecurityGroupMembershipsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupMemberships = vpcSecurityGroupMembershipsBuffer
            } else {
                vpcSecurityGroupMemberships = []
            }
        } else {
            vpcSecurityGroupMemberships = nil
        }
        if containerValues.contains(.optionSettings) {
            struct KeyVal0{struct OptionSetting{}}
            let optionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionSetting>.CodingKeys.self, forKey: .optionSettings)
            if let optionSettingsWrappedContainer = optionSettingsWrappedContainer {
                let optionSettingsContainer = try optionSettingsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionSetting].self, forKey: .member)
                var optionSettingsBuffer:[RdsClientTypes.OptionSetting]? = nil
                if let optionSettingsContainer = optionSettingsContainer {
                    optionSettingsBuffer = [RdsClientTypes.OptionSetting]()
                    for structureContainer0 in optionSettingsContainer {
                        optionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionSettings = optionSettingsBuffer
            } else {
                optionSettings = []
            }
        } else {
            optionSettings = nil
        }
    }
}

extension RdsClientTypes.OptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionConfiguration(dBSecurityGroupMemberships: \(Swift.String(describing: dBSecurityGroupMemberships)), optionName: \(Swift.String(describing: optionName)), optionSettings: \(Swift.String(describing: optionSettings)), optionVersion: \(Swift.String(describing: optionVersion)), port: \(Swift.String(describing: port)), vpcSecurityGroupMemberships: \(Swift.String(describing: vpcSecurityGroupMemberships)))"}
}

extension RdsClientTypes {
    /// A list of all available options
    public struct OptionConfiguration: Swift.Equatable {
        /// A list of DBSecurityGroupMembership name strings used for this option.
        public var dBSecurityGroupMemberships: [Swift.String]?
        /// The configuration of options to include in a group.
        /// This member is required.
        public var optionName: Swift.String?
        /// The option settings to include in an option group.
        public var optionSettings: [RdsClientTypes.OptionSetting]?
        /// The version for the option.
        public var optionVersion: Swift.String?
        /// The optional port for the option.
        public var port: Swift.Int?
        /// A list of VpcSecurityGroupMembership name strings used for this option.
        public var vpcSecurityGroupMemberships: [Swift.String]?

        public init (
            dBSecurityGroupMemberships: [Swift.String]? = nil,
            optionName: Swift.String? = nil,
            optionSettings: [RdsClientTypes.OptionSetting]? = nil,
            optionVersion: Swift.String? = nil,
            port: Swift.Int? = nil,
            vpcSecurityGroupMemberships: [Swift.String]? = nil
        )
        {
            self.dBSecurityGroupMemberships = dBSecurityGroupMemberships
            self.optionName = optionName
            self.optionSettings = optionSettings
            self.optionVersion = optionVersion
            self.port = port
            self.vpcSecurityGroupMemberships = vpcSecurityGroupMemberships
        }
    }

}

extension RdsClientTypes.OptionGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsVpcAndNonVpcInstanceMemberships = "AllowsVpcAndNonVpcInstanceMemberships"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case optionGroupArn = "OptionGroupArn"
        case optionGroupDescription = "OptionGroupDescription"
        case optionGroupName = "OptionGroupName"
        case options = "Options"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowsVpcAndNonVpcInstanceMemberships != false {
            try container.encode(allowsVpcAndNonVpcInstanceMemberships, forKey: ClientRuntime.Key("AllowsVpcAndNonVpcInstanceMemberships"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let optionGroupArn = optionGroupArn {
            try container.encode(optionGroupArn, forKey: ClientRuntime.Key("OptionGroupArn"))
        }
        if let optionGroupDescription = optionGroupDescription {
            try container.encode(optionGroupDescription, forKey: ClientRuntime.Key("OptionGroupDescription"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let options = options {
            var optionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Options"))
            for (index0, option0) in options.enumerated() {
                try optionsContainer.encode(option0, forKey: ClientRuntime.Key("Option.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let optionGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupDescription)
        optionGroupDescription = optionGroupDescriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        if containerValues.contains(.options) {
            struct KeyVal0{struct Option{}}
            let optionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Option>.CodingKeys.self, forKey: .options)
            if let optionsWrappedContainer = optionsWrappedContainer {
                let optionsContainer = try optionsWrappedContainer.decodeIfPresent([RdsClientTypes.Option].self, forKey: .member)
                var optionsBuffer:[RdsClientTypes.Option]? = nil
                if let optionsContainer = optionsContainer {
                    optionsBuffer = [RdsClientTypes.Option]()
                    for structureContainer0 in optionsContainer {
                        optionsBuffer?.append(structureContainer0)
                    }
                }
                options = optionsBuffer
            } else {
                options = []
            }
        } else {
            options = nil
        }
        let allowsVpcAndNonVpcInstanceMembershipsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowsVpcAndNonVpcInstanceMemberships)
        allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMembershipsDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let optionGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupArn)
        optionGroupArn = optionGroupArnDecoded
    }
}

extension RdsClientTypes.OptionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroup(allowsVpcAndNonVpcInstanceMemberships: \(Swift.String(describing: allowsVpcAndNonVpcInstanceMemberships)), engineName: \(Swift.String(describing: engineName)), majorEngineVersion: \(Swift.String(describing: majorEngineVersion)), optionGroupArn: \(Swift.String(describing: optionGroupArn)), optionGroupDescription: \(Swift.String(describing: optionGroupDescription)), optionGroupName: \(Swift.String(describing: optionGroupName)), options: \(Swift.String(describing: options)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension RdsClientTypes {
    ///
    public struct OptionGroup: Swift.Equatable {
        /// Indicates whether this option group can be applied to both VPC
        ///            and non-VPC instances. The value true indicates the option group
        ///            can be applied to both VPC and non-VPC instances.
        ///
        public var allowsVpcAndNonVpcInstanceMemberships: Swift.Bool
        /// Indicates the name of the engine that this option group can be applied to.
        public var engineName: Swift.String?
        /// Indicates the major engine version associated with this option group.
        public var majorEngineVersion: Swift.String?
        /// The Amazon Resource Name (ARN) for the option group.
        public var optionGroupArn: Swift.String?
        /// Provides a description of the option group.
        public var optionGroupDescription: Swift.String?
        /// Specifies the name of the option group.
        public var optionGroupName: Swift.String?
        /// Indicates what options are available in the option group.
        public var options: [RdsClientTypes.Option]?
        /// If AllowsVpcAndNonVpcInstanceMemberships is false, this field is blank.
        ///            If AllowsVpcAndNonVpcInstanceMemberships is true and this field is blank,
        ///            then this option group can be applied to both VPC and non-VPC instances.
        ///            If this field contains a value, then this option group can only be
        ///            applied to instances that are in the VPC indicated by this field.
        ///
        public var vpcId: Swift.String?

        public init (
            allowsVpcAndNonVpcInstanceMemberships: Swift.Bool = false,
            engineName: Swift.String? = nil,
            majorEngineVersion: Swift.String? = nil,
            optionGroupArn: Swift.String? = nil,
            optionGroupDescription: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            options: [RdsClientTypes.Option]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allowsVpcAndNonVpcInstanceMemberships = allowsVpcAndNonVpcInstanceMemberships
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.optionGroupArn = optionGroupArn
            self.optionGroupDescription = optionGroupDescription
            self.optionGroupName = optionGroupName
            self.options = options
            self.vpcId = vpcId
        }
    }

}

extension OptionGroupAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension OptionGroupAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptionGroupAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The option group you are trying to create already exists.
public struct OptionGroupAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OptionGroupAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.OptionGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes.OptionGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupMembership(optionGroupName: \(Swift.String(describing: optionGroupName)), status: \(Swift.String(describing: status)))"}
}

extension RdsClientTypes {
    /// Provides information on the option groups the DB instance is a member of.
    public struct OptionGroupMembership: Swift.Equatable {
        /// The name of the option group that the instance belongs to.
        public var optionGroupName: Swift.String?
        /// The status of the DB instance's option group membership. Valid values are:
        ///       in-sync,
        ///       pending-apply,
        ///       pending-removal,
        ///       pending-maintenance-apply,
        ///       pending-maintenance-removal,
        ///       applying,
        ///       removing,
        ///       and failed.
        ///
        public var status: Swift.String?

        public init (
            optionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.optionGroupName = optionGroupName
            self.status = status
        }
    }

}

extension OptionGroupNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension OptionGroupNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptionGroupNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified option group could not be found.
public struct OptionGroupNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OptionGroupNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.OptionGroupOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultPort = "DefaultPort"
        case description = "Description"
        case engineName = "EngineName"
        case majorEngineVersion = "MajorEngineVersion"
        case minimumRequiredMinorEngineVersion = "MinimumRequiredMinorEngineVersion"
        case name = "Name"
        case optionGroupOptionSettings = "OptionGroupOptionSettings"
        case optionGroupOptionVersions = "OptionGroupOptionVersions"
        case optionsConflictsWith = "OptionsConflictsWith"
        case optionsDependedOn = "OptionsDependedOn"
        case permanent = "Permanent"
        case persistent = "Persistent"
        case portRequired = "PortRequired"
        case requiresAutoMinorEngineVersionUpgrade = "RequiresAutoMinorEngineVersionUpgrade"
        case supportsOptionVersionDowngrade = "SupportsOptionVersionDowngrade"
        case vpcOnly = "VpcOnly"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let defaultPort = defaultPort {
            try container.encode(defaultPort, forKey: ClientRuntime.Key("DefaultPort"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engineName = engineName {
            try container.encode(engineName, forKey: ClientRuntime.Key("EngineName"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion {
            try container.encode(minimumRequiredMinorEngineVersion, forKey: ClientRuntime.Key("MinimumRequiredMinorEngineVersion"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let optionGroupOptionSettings = optionGroupOptionSettings {
            var optionGroupOptionSettingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupOptionSettings"))
            for (index0, optiongroupoptionsetting0) in optionGroupOptionSettings.enumerated() {
                try optionGroupOptionSettingsContainer.encode(optiongroupoptionsetting0, forKey: ClientRuntime.Key("OptionGroupOptionSetting.\(index0.advanced(by: 1))"))
            }
        }
        if let optionGroupOptionVersions = optionGroupOptionVersions {
            var optionGroupOptionVersionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionGroupOptionVersions"))
            for (index0, optionversion0) in optionGroupOptionVersions.enumerated() {
                try optionGroupOptionVersionsContainer.encode(optionversion0, forKey: ClientRuntime.Key("OptionVersion.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsConflictsWith = optionsConflictsWith {
            var optionsConflictsWithContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsConflictsWith"))
            for (index0, string0) in optionsConflictsWith.enumerated() {
                try optionsConflictsWithContainer.encode(string0, forKey: ClientRuntime.Key("OptionConflictName.\(index0.advanced(by: 1))"))
            }
        }
        if let optionsDependedOn = optionsDependedOn {
            var optionsDependedOnContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OptionsDependedOn"))
            for (index0, string0) in optionsDependedOn.enumerated() {
                try optionsDependedOnContainer.encode(string0, forKey: ClientRuntime.Key("OptionName.\(index0.advanced(by: 1))"))
            }
        }
        if permanent != false {
            try container.encode(permanent, forKey: ClientRuntime.Key("Permanent"))
        }
        if persistent != false {
            try container.encode(persistent, forKey: ClientRuntime.Key("Persistent"))
        }
        if portRequired != false {
            try container.encode(portRequired, forKey: ClientRuntime.Key("PortRequired"))
        }
        if requiresAutoMinorEngineVersionUpgrade != false {
            try container.encode(requiresAutoMinorEngineVersionUpgrade, forKey: ClientRuntime.Key("RequiresAutoMinorEngineVersionUpgrade"))
        }
        if let supportsOptionVersionDowngrade = supportsOptionVersionDowngrade {
            try container.encode(supportsOptionVersionDowngrade, forKey: ClientRuntime.Key("SupportsOptionVersionDowngrade"))
        }
        if vpcOnly != false {
            try container.encode(vpcOnly, forKey: ClientRuntime.Key("VpcOnly"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineName)
        engineName = engineNameDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let minimumRequiredMinorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumRequiredMinorEngineVersion)
        minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersionDecoded
        let portRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .portRequired)
        portRequired = portRequiredDecoded
        let defaultPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultPort)
        defaultPort = defaultPortDecoded
        if containerValues.contains(.optionsDependedOn) {
            struct KeyVal0{struct OptionName{}}
            let optionsDependedOnWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionName>.CodingKeys.self, forKey: .optionsDependedOn)
            if let optionsDependedOnWrappedContainer = optionsDependedOnWrappedContainer {
                let optionsDependedOnContainer = try optionsDependedOnWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var optionsDependedOnBuffer:[Swift.String]? = nil
                if let optionsDependedOnContainer = optionsDependedOnContainer {
                    optionsDependedOnBuffer = [Swift.String]()
                    for stringContainer0 in optionsDependedOnContainer {
                        optionsDependedOnBuffer?.append(stringContainer0)
                    }
                }
                optionsDependedOn = optionsDependedOnBuffer
            } else {
                optionsDependedOn = []
            }
        } else {
            optionsDependedOn = nil
        }
        if containerValues.contains(.optionsConflictsWith) {
            struct KeyVal0{struct OptionConflictName{}}
            let optionsConflictsWithWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionConflictName>.CodingKeys.self, forKey: .optionsConflictsWith)
            if let optionsConflictsWithWrappedContainer = optionsConflictsWithWrappedContainer {
                let optionsConflictsWithContainer = try optionsConflictsWithWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var optionsConflictsWithBuffer:[Swift.String]? = nil
                if let optionsConflictsWithContainer = optionsConflictsWithContainer {
                    optionsConflictsWithBuffer = [Swift.String]()
                    for stringContainer0 in optionsConflictsWithContainer {
                        optionsConflictsWithBuffer?.append(stringContainer0)
                    }
                }
                optionsConflictsWith = optionsConflictsWithBuffer
            } else {
                optionsConflictsWith = []
            }
        } else {
            optionsConflictsWith = nil
        }
        let persistentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .persistent)
        persistent = persistentDecoded
        let permanentDecoded = try containerValues.decode(Swift.Bool.self, forKey: .permanent)
        permanent = permanentDecoded
        let requiresAutoMinorEngineVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requiresAutoMinorEngineVersionUpgrade)
        requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgradeDecoded
        let vpcOnlyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vpcOnly)
        vpcOnly = vpcOnlyDecoded
        let supportsOptionVersionDowngradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsOptionVersionDowngrade)
        supportsOptionVersionDowngrade = supportsOptionVersionDowngradeDecoded
        if containerValues.contains(.optionGroupOptionSettings) {
            struct KeyVal0{struct OptionGroupOptionSetting{}}
            let optionGroupOptionSettingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionGroupOptionSetting>.CodingKeys.self, forKey: .optionGroupOptionSettings)
            if let optionGroupOptionSettingsWrappedContainer = optionGroupOptionSettingsWrappedContainer {
                let optionGroupOptionSettingsContainer = try optionGroupOptionSettingsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionGroupOptionSetting].self, forKey: .member)
                var optionGroupOptionSettingsBuffer:[RdsClientTypes.OptionGroupOptionSetting]? = nil
                if let optionGroupOptionSettingsContainer = optionGroupOptionSettingsContainer {
                    optionGroupOptionSettingsBuffer = [RdsClientTypes.OptionGroupOptionSetting]()
                    for structureContainer0 in optionGroupOptionSettingsContainer {
                        optionGroupOptionSettingsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionSettings = optionGroupOptionSettingsBuffer
            } else {
                optionGroupOptionSettings = []
            }
        } else {
            optionGroupOptionSettings = nil
        }
        if containerValues.contains(.optionGroupOptionVersions) {
            struct KeyVal0{struct OptionVersion{}}
            let optionGroupOptionVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OptionVersion>.CodingKeys.self, forKey: .optionGroupOptionVersions)
            if let optionGroupOptionVersionsWrappedContainer = optionGroupOptionVersionsWrappedContainer {
                let optionGroupOptionVersionsContainer = try optionGroupOptionVersionsWrappedContainer.decodeIfPresent([RdsClientTypes.OptionVersion].self, forKey: .member)
                var optionGroupOptionVersionsBuffer:[RdsClientTypes.OptionVersion]? = nil
                if let optionGroupOptionVersionsContainer = optionGroupOptionVersionsContainer {
                    optionGroupOptionVersionsBuffer = [RdsClientTypes.OptionVersion]()
                    for structureContainer0 in optionGroupOptionVersionsContainer {
                        optionGroupOptionVersionsBuffer?.append(structureContainer0)
                    }
                }
                optionGroupOptionVersions = optionGroupOptionVersionsBuffer
            } else {
                optionGroupOptionVersions = []
            }
        } else {
            optionGroupOptionVersions = nil
        }
    }
}

extension RdsClientTypes.OptionGroupOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupOption(defaultPort: \(Swift.String(describing: defaultPort)), description: \(Swift.String(describing: description)), engineName: \(Swift.String(describing: engineName)), majorEngineVersion: \(Swift.String(describing: majorEngineVersion)), minimumRequiredMinorEngineVersion: \(Swift.String(describing: minimumRequiredMinorEngineVersion)), name: \(Swift.String(describing: name)), optionGroupOptionSettings: \(Swift.String(describing: optionGroupOptionSettings)), optionGroupOptionVersions: \(Swift.String(describing: optionGroupOptionVersions)), optionsConflictsWith: \(Swift.String(describing: optionsConflictsWith)), optionsDependedOn: \(Swift.String(describing: optionsDependedOn)), permanent: \(Swift.String(describing: permanent)), persistent: \(Swift.String(describing: persistent)), portRequired: \(Swift.String(describing: portRequired)), requiresAutoMinorEngineVersionUpgrade: \(Swift.String(describing: requiresAutoMinorEngineVersionUpgrade)), supportsOptionVersionDowngrade: \(Swift.String(describing: supportsOptionVersionDowngrade)), vpcOnly: \(Swift.String(describing: vpcOnly)))"}
}

extension RdsClientTypes {
    /// Available option.
    public struct OptionGroupOption: Swift.Equatable {
        /// If the option requires a port, specifies the default port for the option.
        public var defaultPort: Swift.Int?
        /// The description of the option.
        public var description: Swift.String?
        /// The name of the engine that this option can be applied to.
        public var engineName: Swift.String?
        /// Indicates the major engine version that the option is available for.
        public var majorEngineVersion: Swift.String?
        /// The minimum required engine version for the option to be applied.
        public var minimumRequiredMinorEngineVersion: Swift.String?
        /// The name of the option.
        public var name: Swift.String?
        /// The option settings that are available (and the default value) for each option in an option group.
        public var optionGroupOptionSettings: [RdsClientTypes.OptionGroupOptionSetting]?
        /// The versions that are available for the option.
        public var optionGroupOptionVersions: [RdsClientTypes.OptionVersion]?
        /// The options that conflict with this option.
        public var optionsConflictsWith: [Swift.String]?
        /// The options that are prerequisites for this option.
        public var optionsDependedOn: [Swift.String]?
        /// Permanent options can never be removed from an option group. An option group containing a permanent option can't be removed from a DB instance.
        public var permanent: Swift.Bool
        /// Persistent options can't be removed from an option group while DB instances are associated with the option group. If you disassociate all DB instances from the option group, your can remove the persistent option from the option group.
        public var persistent: Swift.Bool
        /// Specifies whether the option requires a port.
        public var portRequired: Swift.Bool
        /// If true, you must enable the Auto Minor Version Upgrade setting for your DB instance
        ///             before you can use this option.
        ///             You can enable Auto Minor Version Upgrade when you first create your DB instance,
        ///             or by modifying your DB instance later.
        ///
        public var requiresAutoMinorEngineVersionUpgrade: Swift.Bool
        /// If true, you can change the option to an earlier version of the option.
        ///             This only applies to options that have different versions available.
        ///
        public var supportsOptionVersionDowngrade: Swift.Bool?
        /// If true, you can only use this option with a DB instance that is in a VPC.
        ///
        public var vpcOnly: Swift.Bool

        public init (
            defaultPort: Swift.Int? = nil,
            description: Swift.String? = nil,
            engineName: Swift.String? = nil,
            majorEngineVersion: Swift.String? = nil,
            minimumRequiredMinorEngineVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            optionGroupOptionSettings: [RdsClientTypes.OptionGroupOptionSetting]? = nil,
            optionGroupOptionVersions: [RdsClientTypes.OptionVersion]? = nil,
            optionsConflictsWith: [Swift.String]? = nil,
            optionsDependedOn: [Swift.String]? = nil,
            permanent: Swift.Bool = false,
            persistent: Swift.Bool = false,
            portRequired: Swift.Bool = false,
            requiresAutoMinorEngineVersionUpgrade: Swift.Bool = false,
            supportsOptionVersionDowngrade: Swift.Bool? = nil,
            vpcOnly: Swift.Bool = false
        )
        {
            self.defaultPort = defaultPort
            self.description = description
            self.engineName = engineName
            self.majorEngineVersion = majorEngineVersion
            self.minimumRequiredMinorEngineVersion = minimumRequiredMinorEngineVersion
            self.name = name
            self.optionGroupOptionSettings = optionGroupOptionSettings
            self.optionGroupOptionVersions = optionGroupOptionVersions
            self.optionsConflictsWith = optionsConflictsWith
            self.optionsDependedOn = optionsDependedOn
            self.permanent = permanent
            self.persistent = persistent
            self.portRequired = portRequired
            self.requiresAutoMinorEngineVersionUpgrade = requiresAutoMinorEngineVersionUpgrade
            self.supportsOptionVersionDowngrade = supportsOptionVersionDowngrade
            self.vpcOnly = vpcOnly
        }
    }

}

extension RdsClientTypes.OptionGroupOptionSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case defaultValue = "DefaultValue"
        case isModifiable = "IsModifiable"
        case isRequired = "IsRequired"
        case minimumEngineVersionPerAllowedValue = "MinimumEngineVersionPerAllowedValue"
        case settingDescription = "SettingDescription"
        case settingName = "SettingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if isRequired != false {
            try container.encode(isRequired, forKey: ClientRuntime.Key("IsRequired"))
        }
        if let minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue {
            var minimumEngineVersionPerAllowedValueContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MinimumEngineVersionPerAllowedValue"))
            for (index0, minimumengineversionperallowedvalue0) in minimumEngineVersionPerAllowedValue.enumerated() {
                try minimumEngineVersionPerAllowedValueContainer.encode(minimumengineversionperallowedvalue0, forKey: ClientRuntime.Key("MinimumEngineVersionPerAllowedValue.\(index0.advanced(by: 1))"))
            }
        }
        if let settingDescription = settingDescription {
            try container.encode(settingDescription, forKey: ClientRuntime.Key("SettingDescription"))
        }
        if let settingName = settingName {
            try container.encode(settingName, forKey: ClientRuntime.Key("SettingName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingName)
        settingName = settingNameDecoded
        let settingDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingDescription)
        settingDescription = settingDescriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let isRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRequired)
        isRequired = isRequiredDecoded
        if containerValues.contains(.minimumEngineVersionPerAllowedValue) {
            struct KeyVal0{struct MinimumEngineVersionPerAllowedValue{}}
            let minimumEngineVersionPerAllowedValueWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.MinimumEngineVersionPerAllowedValue>.CodingKeys.self, forKey: .minimumEngineVersionPerAllowedValue)
            if let minimumEngineVersionPerAllowedValueWrappedContainer = minimumEngineVersionPerAllowedValueWrappedContainer {
                let minimumEngineVersionPerAllowedValueContainer = try minimumEngineVersionPerAllowedValueWrappedContainer.decodeIfPresent([RdsClientTypes.MinimumEngineVersionPerAllowedValue].self, forKey: .member)
                var minimumEngineVersionPerAllowedValueBuffer:[RdsClientTypes.MinimumEngineVersionPerAllowedValue]? = nil
                if let minimumEngineVersionPerAllowedValueContainer = minimumEngineVersionPerAllowedValueContainer {
                    minimumEngineVersionPerAllowedValueBuffer = [RdsClientTypes.MinimumEngineVersionPerAllowedValue]()
                    for structureContainer0 in minimumEngineVersionPerAllowedValueContainer {
                        minimumEngineVersionPerAllowedValueBuffer?.append(structureContainer0)
                    }
                }
                minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValueBuffer
            } else {
                minimumEngineVersionPerAllowedValue = []
            }
        } else {
            minimumEngineVersionPerAllowedValue = nil
        }
    }
}

extension RdsClientTypes.OptionGroupOptionSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupOptionSetting(allowedValues: \(Swift.String(describing: allowedValues)), applyType: \(Swift.String(describing: applyType)), defaultValue: \(Swift.String(describing: defaultValue)), isModifiable: \(Swift.String(describing: isModifiable)), isRequired: \(Swift.String(describing: isRequired)), minimumEngineVersionPerAllowedValue: \(Swift.String(describing: minimumEngineVersionPerAllowedValue)), settingDescription: \(Swift.String(describing: settingDescription)), settingName: \(Swift.String(describing: settingName)))"}
}

extension RdsClientTypes {
    /// Option group option settings are used to display settings available for each option with their default values and other information. These values are used with the DescribeOptionGroupOptions action.
    public struct OptionGroupOptionSetting: Swift.Equatable {
        /// Indicates the acceptable values for the option group option.
        public var allowedValues: Swift.String?
        /// The DB engine specific parameter type for the option group option.
        public var applyType: Swift.String?
        /// The default value for the option group option.
        public var defaultValue: Swift.String?
        /// Boolean value where true indicates that this option group option can be changed from the default value.
        public var isModifiable: Swift.Bool
        /// Boolean value where true indicates that a value must be specified for this option setting of the option group option.
        public var isRequired: Swift.Bool
        /// The minimum DB engine version required for the corresponding allowed value for this option setting.
        public var minimumEngineVersionPerAllowedValue: [RdsClientTypes.MinimumEngineVersionPerAllowedValue]?
        /// The description of the option group option.
        public var settingDescription: Swift.String?
        /// The name of the option group option.
        public var settingName: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            applyType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            isModifiable: Swift.Bool = false,
            isRequired: Swift.Bool = false,
            minimumEngineVersionPerAllowedValue: [RdsClientTypes.MinimumEngineVersionPerAllowedValue]? = nil,
            settingDescription: Swift.String? = nil,
            settingName: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.defaultValue = defaultValue
            self.isModifiable = isModifiable
            self.isRequired = isRequired
            self.minimumEngineVersionPerAllowedValue = minimumEngineVersionPerAllowedValue
            self.settingDescription = settingDescription
            self.settingName = settingName
        }
    }

}

extension OptionGroupQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionGroupQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension OptionGroupQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<OptionGroupQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The quota of 20 option groups was exceeded for this Amazon Web Services account.
public struct OptionGroupQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptionGroupQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OptionGroupQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.OptionSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case defaultValue = "DefaultValue"
        case description = "Description"
        case isCollection = "IsCollection"
        case isModifiable = "IsModifiable"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let defaultValue = defaultValue {
            try container.encode(defaultValue, forKey: ClientRuntime.Key("DefaultValue"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isCollection != false {
            try container.encode(isCollection, forKey: ClientRuntime.Key("IsCollection"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let isCollectionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCollection)
        isCollection = isCollectionDecoded
    }
}

extension RdsClientTypes.OptionSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionSetting(allowedValues: \(Swift.String(describing: allowedValues)), applyType: \(Swift.String(describing: applyType)), dataType: \(Swift.String(describing: dataType)), defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), isCollection: \(Swift.String(describing: isCollection)), isModifiable: \(Swift.String(describing: isModifiable)), name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension RdsClientTypes {
    /// Option settings are the actual settings being applied or configured for that option. It is used when you modify an option group or describe option groups. For example, the NATIVE_NETWORK_ENCRYPTION option has a setting called SQLNET.ENCRYPTION_SERVER that can have several different values.
    public struct OptionSetting: Swift.Equatable {
        /// The allowed values of the option setting.
        public var allowedValues: Swift.String?
        /// The DB engine specific parameter type.
        public var applyType: Swift.String?
        /// The data type of the option setting.
        public var dataType: Swift.String?
        /// The default value of the option setting.
        public var defaultValue: Swift.String?
        /// The description of the option setting.
        public var description: Swift.String?
        /// Indicates if the option setting is part of a collection.
        public var isCollection: Swift.Bool
        /// A Boolean value that, when true, indicates the option setting can be modified from the default.
        public var isModifiable: Swift.Bool
        /// The name of the option that has settings that you can set.
        public var name: Swift.String?
        /// The current value of the option setting.
        public var value: Swift.String?

        public init (
            allowedValues: Swift.String? = nil,
            applyType: Swift.String? = nil,
            dataType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            isCollection: Swift.Bool = false,
            isModifiable: Swift.Bool = false,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyType = applyType
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.isCollection = isCollection
            self.isModifiable = isModifiable
            self.name = name
            self.value = value
        }
    }

}

extension RdsClientTypes.OptionVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDefault = "IsDefault"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if isDefault != false {
            try container.encode(isDefault, forKey: ClientRuntime.Key("IsDefault"))
        }
        if let version = version {
            try container.encode(version, forKey: ClientRuntime.Key("Version"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let isDefaultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension RdsClientTypes.OptionVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptionVersion(isDefault: \(Swift.String(describing: isDefault)), version: \(Swift.String(describing: version)))"}
}

extension RdsClientTypes {
    /// The version for an option. Option group option versions are returned by
    ///             the DescribeOptionGroupOptions action.
    public struct OptionVersion: Swift.Equatable {
        /// True if the version is the default version of the option, and otherwise false.
        public var isDefault: Swift.Bool
        /// The version of the option.
        public var version: Swift.String?

        public init (
            isDefault: Swift.Bool = false,
            version: Swift.String? = nil
        )
        {
            self.isDefault = isDefault
            self.version = version
        }
    }

}

extension RdsClientTypes.OrderableDBInstanceOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneGroup = "AvailabilityZoneGroup"
        case availabilityZones = "AvailabilityZones"
        case availableProcessorFeatures = "AvailableProcessorFeatures"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case outpostCapable = "OutpostCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportedActivityStreamModes = "SupportedActivityStreamModes"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsKerberosAuthentication = "SupportsKerberosAuthentication"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: ClientRuntime.Key("AvailabilityZoneGroup"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let availableProcessorFeatures = availableProcessorFeatures {
            var availableProcessorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailableProcessorFeatures"))
            for (index0, availableprocessorfeature0) in availableProcessorFeatures.enumerated() {
                try availableProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: ClientRuntime.Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: ClientRuntime.Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: ClientRuntime.Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: ClientRuntime.Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: ClientRuntime.Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: ClientRuntime.Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: ClientRuntime.Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: ClientRuntime.Key("MultiAZCapable"))
        }
        if outpostCapable != false {
            try container.encode(outpostCapable, forKey: ClientRuntime.Key("OutpostCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: ClientRuntime.Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let supportedActivityStreamModes = supportedActivityStreamModes {
            var supportedActivityStreamModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedActivityStreamModes"))
            for (index0, string0) in supportedActivityStreamModes.enumerated() {
                try supportedActivityStreamModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: ClientRuntime.Key("SupportsEnhancedMonitoring"))
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: ClientRuntime.Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: ClientRuntime.Key("SupportsIops"))
        }
        if let supportsKerberosAuthentication = supportsKerberosAuthentication {
            try container.encode(supportsKerberosAuthentication, forKey: ClientRuntime.Key("SupportsKerberosAuthentication"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: ClientRuntime.Key("SupportsPerformanceInsights"))
        }
        if let supportsStorageAutoscaling = supportsStorageAutoscaling {
            try container.encode(supportsStorageAutoscaling, forKey: ClientRuntime.Key("SupportsStorageAutoscaling"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: ClientRuntime.Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[RdsClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [RdsClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
        if containerValues.contains(.availableProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let availableProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .availableProcessorFeatures)
            if let availableProcessorFeaturesWrappedContainer = availableProcessorFeaturesWrappedContainer {
                let availableProcessorFeaturesContainer = try availableProcessorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailableProcessorFeature].self, forKey: .member)
                var availableProcessorFeaturesBuffer:[RdsClientTypes.AvailableProcessorFeature]? = nil
                if let availableProcessorFeaturesContainer = availableProcessorFeaturesContainer {
                    availableProcessorFeaturesBuffer = [RdsClientTypes.AvailableProcessorFeature]()
                    for structureContainer0 in availableProcessorFeaturesContainer {
                        availableProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                availableProcessorFeatures = availableProcessorFeaturesBuffer
            } else {
                availableProcessorFeatures = []
            }
        } else {
            availableProcessorFeatures = nil
        }
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
        let supportsKerberosAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsKerberosAuthentication)
        supportsKerberosAuthentication = supportsKerberosAuthenticationDecoded
        let outpostCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .outpostCapable)
        outpostCapable = outpostCapableDecoded
        if containerValues.contains(.supportedActivityStreamModes) {
            struct KeyVal0{struct member{}}
            let supportedActivityStreamModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedActivityStreamModes)
            if let supportedActivityStreamModesWrappedContainer = supportedActivityStreamModesWrappedContainer {
                let supportedActivityStreamModesContainer = try supportedActivityStreamModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedActivityStreamModesBuffer:[Swift.String]? = nil
                if let supportedActivityStreamModesContainer = supportedActivityStreamModesContainer {
                    supportedActivityStreamModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedActivityStreamModesContainer {
                        supportedActivityStreamModesBuffer?.append(stringContainer0)
                    }
                }
                supportedActivityStreamModes = supportedActivityStreamModesBuffer
            } else {
                supportedActivityStreamModes = []
            }
        } else {
            supportedActivityStreamModes = nil
        }
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension RdsClientTypes.OrderableDBInstanceOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderableDBInstanceOption(availabilityZoneGroup: \(Swift.String(describing: availabilityZoneGroup)), availabilityZones: \(Swift.String(describing: availabilityZones)), availableProcessorFeatures: \(Swift.String(describing: availableProcessorFeatures)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), licenseModel: \(Swift.String(describing: licenseModel)), maxIopsPerDbInstance: \(Swift.String(describing: maxIopsPerDbInstance)), maxIopsPerGib: \(Swift.String(describing: maxIopsPerGib)), maxStorageSize: \(Swift.String(describing: maxStorageSize)), minIopsPerDbInstance: \(Swift.String(describing: minIopsPerDbInstance)), minIopsPerGib: \(Swift.String(describing: minIopsPerGib)), minStorageSize: \(Swift.String(describing: minStorageSize)), multiAZCapable: \(Swift.String(describing: multiAZCapable)), outpostCapable: \(Swift.String(describing: outpostCapable)), readReplicaCapable: \(Swift.String(describing: readReplicaCapable)), storageType: \(Swift.String(describing: storageType)), supportedActivityStreamModes: \(Swift.String(describing: supportedActivityStreamModes)), supportedEngineModes: \(Swift.String(describing: supportedEngineModes)), supportsEnhancedMonitoring: \(Swift.String(describing: supportsEnhancedMonitoring)), supportsGlobalDatabases: \(Swift.String(describing: supportsGlobalDatabases)), supportsIAMDatabaseAuthentication: \(Swift.String(describing: supportsIAMDatabaseAuthentication)), supportsIops: \(Swift.String(describing: supportsIops)), supportsKerberosAuthentication: \(Swift.String(describing: supportsKerberosAuthentication)), supportsPerformanceInsights: \(Swift.String(describing: supportsPerformanceInsights)), supportsStorageAutoscaling: \(Swift.String(describing: supportsStorageAutoscaling)), supportsStorageEncryption: \(Swift.String(describing: supportsStorageEncryption)), vpc: \(Swift.String(describing: vpc)))"}
}

extension RdsClientTypes {
    /// Contains a list of available options for a DB instance.
    ///
    ///           This data type is used as a response element in the DescribeOrderableDBInstanceOptions action.
    ///
    public struct OrderableDBInstanceOption: Swift.Equatable {
        /// The Availability Zone group for a DB instance.
        public var availabilityZoneGroup: Swift.String?
        /// A list of Availability Zones for a DB instance.
        public var availabilityZones: [RdsClientTypes.AvailabilityZone]?
        /// A list of the available processor features for the DB instance class of a DB instance.
        public var availableProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]?
        /// The DB instance class for a DB instance.
        public var dBInstanceClass: Swift.String?
        /// The engine type of a DB instance.
        public var engine: Swift.String?
        /// The engine version of a DB instance.
        public var engineVersion: Swift.String?
        /// The license model for a DB instance.
        public var licenseModel: Swift.String?
        /// Maximum total provisioned IOPS for a DB instance.
        public var maxIopsPerDbInstance: Swift.Int?
        /// Maximum provisioned IOPS per GiB for a DB instance.
        public var maxIopsPerGib: Swift.Double?
        /// Maximum storage size for a DB instance.
        public var maxStorageSize: Swift.Int?
        /// Minimum total provisioned IOPS for a DB instance.
        public var minIopsPerDbInstance: Swift.Int?
        /// Minimum provisioned IOPS per GiB for a DB instance.
        public var minIopsPerGib: Swift.Double?
        /// Minimum storage size for a DB instance.
        public var minStorageSize: Swift.Int?
        /// Indicates whether a DB instance is Multi-AZ capable.
        public var multiAZCapable: Swift.Bool
        /// Whether a DB instance supports RDS on Outposts.
        ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Amazon RDS on Amazon Web Services Outposts
        ///             in the Amazon RDS User Guide.
        ///
        public var outpostCapable: Swift.Bool
        /// Indicates whether a DB instance can have a read replica.
        public var readReplicaCapable: Swift.Bool
        /// Indicates the storage type for a DB instance.
        public var storageType: Swift.String?
        /// The list of supported modes for Database Activity Streams. Aurora PostgreSQL returns the value [sync,
        ///           async]. Aurora MySQL and RDS for Oracle return [async] only. If Database Activity Streams
        ///           isn't supported, the return value is an empty list.
        public var supportedActivityStreamModes: [Swift.String]?
        /// A list of the supported DB engine modes.
        public var supportedEngineModes: [Swift.String]?
        /// Indicates whether a DB instance supports Enhanced Monitoring at intervals from 1 to 60 seconds.
        public var supportsEnhancedMonitoring: Swift.Bool
        /// A value that indicates whether you can use Aurora global databases with a specific combination of other DB engine attributes.
        public var supportsGlobalDatabases: Swift.Bool
        /// Indicates whether a DB instance supports IAM database authentication.
        public var supportsIAMDatabaseAuthentication: Swift.Bool
        /// Indicates whether a DB instance supports provisioned IOPS.
        public var supportsIops: Swift.Bool
        /// Whether a DB instance supports Kerberos Authentication.
        public var supportsKerberosAuthentication: Swift.Bool?
        /// True if a DB instance supports Performance Insights, otherwise false.
        public var supportsPerformanceInsights: Swift.Bool
        /// Whether Amazon RDS can automatically scale storage for DB instances that use the specified DB instance class.
        public var supportsStorageAutoscaling: Swift.Bool?
        /// Indicates whether a DB instance supports encrypted storage.
        public var supportsStorageEncryption: Swift.Bool
        /// Indicates whether a DB instance is in a VPC.
        public var vpc: Swift.Bool

        public init (
            availabilityZoneGroup: Swift.String? = nil,
            availabilityZones: [RdsClientTypes.AvailabilityZone]? = nil,
            availableProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]? = nil,
            dBInstanceClass: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            maxIopsPerDbInstance: Swift.Int? = nil,
            maxIopsPerGib: Swift.Double? = nil,
            maxStorageSize: Swift.Int? = nil,
            minIopsPerDbInstance: Swift.Int? = nil,
            minIopsPerGib: Swift.Double? = nil,
            minStorageSize: Swift.Int? = nil,
            multiAZCapable: Swift.Bool = false,
            outpostCapable: Swift.Bool = false,
            readReplicaCapable: Swift.Bool = false,
            storageType: Swift.String? = nil,
            supportedActivityStreamModes: [Swift.String]? = nil,
            supportedEngineModes: [Swift.String]? = nil,
            supportsEnhancedMonitoring: Swift.Bool = false,
            supportsGlobalDatabases: Swift.Bool = false,
            supportsIAMDatabaseAuthentication: Swift.Bool = false,
            supportsIops: Swift.Bool = false,
            supportsKerberosAuthentication: Swift.Bool? = nil,
            supportsPerformanceInsights: Swift.Bool = false,
            supportsStorageAutoscaling: Swift.Bool? = nil,
            supportsStorageEncryption: Swift.Bool = false,
            vpc: Swift.Bool = false
        )
        {
            self.availabilityZoneGroup = availabilityZoneGroup
            self.availabilityZones = availabilityZones
            self.availableProcessorFeatures = availableProcessorFeatures
            self.dBInstanceClass = dBInstanceClass
            self.engine = engine
            self.engineVersion = engineVersion
            self.licenseModel = licenseModel
            self.maxIopsPerDbInstance = maxIopsPerDbInstance
            self.maxIopsPerGib = maxIopsPerGib
            self.maxStorageSize = maxStorageSize
            self.minIopsPerDbInstance = minIopsPerDbInstance
            self.minIopsPerGib = minIopsPerGib
            self.minStorageSize = minStorageSize
            self.multiAZCapable = multiAZCapable
            self.outpostCapable = outpostCapable
            self.readReplicaCapable = readReplicaCapable
            self.storageType = storageType
            self.supportedActivityStreamModes = supportedActivityStreamModes
            self.supportedEngineModes = supportedEngineModes
            self.supportsEnhancedMonitoring = supportsEnhancedMonitoring
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthentication
            self.supportsIops = supportsIops
            self.supportsKerberosAuthentication = supportsKerberosAuthentication
            self.supportsPerformanceInsights = supportsPerformanceInsights
            self.supportsStorageAutoscaling = supportsStorageAutoscaling
            self.supportsStorageEncryption = supportsStorageEncryption
            self.vpc = vpc
        }
    }

}

extension RdsClientTypes.Outpost: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension RdsClientTypes.Outpost: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Outpost(arn: \(Swift.String(describing: arn)))"}
}

extension RdsClientTypes {
    /// A data type that represents an Outpost.
    ///          For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Amazon RDS on Amazon Web Services Outposts
    ///           in the Amazon RDS User Guide.
    ///
    public struct Outpost: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Outpost.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension RdsClientTypes.Parameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues = "AllowedValues"
        case applyMethod = "ApplyMethod"
        case applyType = "ApplyType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case minimumEngineVersion = "MinimumEngineVersion"
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
        case source = "Source"
        case supportedEngineModes = "SupportedEngineModes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allowedValues = allowedValues {
            try container.encode(allowedValues, forKey: ClientRuntime.Key("AllowedValues"))
        }
        if let applyMethod = applyMethod {
            try container.encode(applyMethod, forKey: ClientRuntime.Key("ApplyMethod"))
        }
        if let applyType = applyType {
            try container.encode(applyType, forKey: ClientRuntime.Key("ApplyType"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if isModifiable != false {
            try container.encode(isModifiable, forKey: ClientRuntime.Key("IsModifiable"))
        }
        if let minimumEngineVersion = minimumEngineVersion {
            try container.encode(minimumEngineVersion, forKey: ClientRuntime.Key("MinimumEngineVersion"))
        }
        if let parameterName = parameterName {
            try container.encode(parameterName, forKey: ClientRuntime.Key("ParameterName"))
        }
        if let parameterValue = parameterValue {
            try container.encode(parameterValue, forKey: ClientRuntime.Key("ParameterValue"))
        }
        if let source = source {
            try container.encode(source, forKey: ClientRuntime.Key("Source"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let applyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyType)
        applyType = applyTypeDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let minimumEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumEngineVersion)
        minimumEngineVersion = minimumEngineVersionDecoded
        let applyMethodDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ApplyMethod.self, forKey: .applyMethod)
        applyMethod = applyMethodDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
    }
}

extension RdsClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(allowedValues: \(Swift.String(describing: allowedValues)), applyMethod: \(Swift.String(describing: applyMethod)), applyType: \(Swift.String(describing: applyType)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), isModifiable: \(Swift.String(describing: isModifiable)), minimumEngineVersion: \(Swift.String(describing: minimumEngineVersion)), parameterName: \(Swift.String(describing: parameterName)), parameterValue: \(Swift.String(describing: parameterValue)), source: \(Swift.String(describing: source)), supportedEngineModes: \(Swift.String(describing: supportedEngineModes)))"}
}

extension RdsClientTypes {
    ///
    ///         This data type is used as a request parameter in the
    ///         ModifyDBParameterGroup and ResetDBParameterGroup actions.
    ///
    ///          This data type is used as a response element in the
    ///         DescribeEngineDefaultParameters and DescribeDBParameters actions.
    public struct Parameter: Swift.Equatable {
        /// Specifies the valid range of values for the parameter.
        public var allowedValues: Swift.String?
        /// Indicates when to apply parameter updates.
        public var applyMethod: RdsClientTypes.ApplyMethod?
        /// Specifies the engine specific parameters type.
        public var applyType: Swift.String?
        /// Specifies the valid data type for the parameter.
        public var dataType: Swift.String?
        /// Provides a description of the parameter.
        public var description: Swift.String?
        ///
        ///         Indicates whether (true) or not (false) the parameter can be modified.
        ///         Some parameters have security or operational implications
        ///         that prevent them from being changed.
        ///
        public var isModifiable: Swift.Bool
        /// The earliest engine version to which the parameter can apply.
        public var minimumEngineVersion: Swift.String?
        /// Specifies the name of the parameter.
        public var parameterName: Swift.String?
        /// Specifies the value of the parameter.
        public var parameterValue: Swift.String?
        /// Indicates the source of the parameter value.
        public var source: Swift.String?
        /// The valid DB engine modes.
        public var supportedEngineModes: [Swift.String]?

        public init (
            allowedValues: Swift.String? = nil,
            applyMethod: RdsClientTypes.ApplyMethod? = nil,
            applyType: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isModifiable: Swift.Bool = false,
            minimumEngineVersion: Swift.String? = nil,
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil,
            source: Swift.String? = nil,
            supportedEngineModes: [Swift.String]? = nil
        )
        {
            self.allowedValues = allowedValues
            self.applyMethod = applyMethod
            self.applyType = applyType
            self.dataType = dataType
            self.description = description
            self.isModifiable = isModifiable
            self.minimumEngineVersion = minimumEngineVersion
            self.parameterName = parameterName
            self.parameterValue = parameterValue
            self.source = source
            self.supportedEngineModes = supportedEngineModes
        }
    }

}

extension RdsClientTypes.PendingCloudwatchLogsExports: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogTypesToDisable"))
            for (index0, string0) in logTypesToDisable.enumerated() {
                try logTypesToDisableContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogTypesToEnable"))
            for (index0, string0) in logTypesToEnable.enumerated() {
                try logTypesToEnableContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.logTypesToEnable) {
            struct KeyVal0{struct member{}}
            let logTypesToEnableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToEnable)
            if let logTypesToEnableWrappedContainer = logTypesToEnableWrappedContainer {
                let logTypesToEnableContainer = try logTypesToEnableWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var logTypesToEnableBuffer:[Swift.String]? = nil
                if let logTypesToEnableContainer = logTypesToEnableContainer {
                    logTypesToEnableBuffer = [Swift.String]()
                    for stringContainer0 in logTypesToEnableContainer {
                        logTypesToEnableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToEnable = logTypesToEnableBuffer
            } else {
                logTypesToEnable = []
            }
        } else {
            logTypesToEnable = nil
        }
        if containerValues.contains(.logTypesToDisable) {
            struct KeyVal0{struct member{}}
            let logTypesToDisableWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .logTypesToDisable)
            if let logTypesToDisableWrappedContainer = logTypesToDisableWrappedContainer {
                let logTypesToDisableContainer = try logTypesToDisableWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var logTypesToDisableBuffer:[Swift.String]? = nil
                if let logTypesToDisableContainer = logTypesToDisableContainer {
                    logTypesToDisableBuffer = [Swift.String]()
                    for stringContainer0 in logTypesToDisableContainer {
                        logTypesToDisableBuffer?.append(stringContainer0)
                    }
                }
                logTypesToDisable = logTypesToDisableBuffer
            } else {
                logTypesToDisable = []
            }
        } else {
            logTypesToDisable = nil
        }
    }
}

extension RdsClientTypes.PendingCloudwatchLogsExports: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingCloudwatchLogsExports(logTypesToDisable: \(Swift.String(describing: logTypesToDisable)), logTypesToEnable: \(Swift.String(describing: logTypesToEnable)))"}
}

extension RdsClientTypes {
    /// A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.
    public struct PendingCloudwatchLogsExports: Swift.Equatable {
        /// Log types that are in the process of being enabled. After they are enabled, these log types are exported to CloudWatch Logs.
        public var logTypesToDisable: [Swift.String]?
        /// Log types that are in the process of being deactivated. After they are deactivated, these log types aren't exported to CloudWatch Logs.
        public var logTypesToEnable: [Swift.String]?

        public init (
            logTypesToDisable: [Swift.String]? = nil,
            logTypesToEnable: [Swift.String]? = nil
        )
        {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }
    }

}

extension RdsClientTypes.PendingMaintenanceAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case autoAppliedAfterDate = "AutoAppliedAfterDate"
        case currentApplyDate = "CurrentApplyDate"
        case description = "Description"
        case forcedApplyDate = "ForcedApplyDate"
        case optInStatus = "OptInStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let action = action {
            try container.encode(action, forKey: ClientRuntime.Key("Action"))
        }
        if let autoAppliedAfterDate = autoAppliedAfterDate {
            try container.encode(ClientRuntime.TimestampWrapper(autoAppliedAfterDate, format: .dateTime), forKey: ClientRuntime.Key("autoAppliedAfterDate"))
        }
        if let currentApplyDate = currentApplyDate {
            try container.encode(ClientRuntime.TimestampWrapper(currentApplyDate, format: .dateTime), forKey: ClientRuntime.Key("currentApplyDate"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let forcedApplyDate = forcedApplyDate {
            try container.encode(ClientRuntime.TimestampWrapper(forcedApplyDate, format: .dateTime), forKey: ClientRuntime.Key("forcedApplyDate"))
        }
        if let optInStatus = optInStatus {
            try container.encode(optInStatus, forKey: ClientRuntime.Key("OptInStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let autoAppliedAfterDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoAppliedAfterDate)
        var autoAppliedAfterDateBuffer:ClientRuntime.Date? = nil
        if let autoAppliedAfterDateDecoded = autoAppliedAfterDateDecoded {
            autoAppliedAfterDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(autoAppliedAfterDateDecoded, format: .dateTime)
        }
        autoAppliedAfterDate = autoAppliedAfterDateBuffer
        let forcedApplyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forcedApplyDate)
        var forcedApplyDateBuffer:ClientRuntime.Date? = nil
        if let forcedApplyDateDecoded = forcedApplyDateDecoded {
            forcedApplyDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(forcedApplyDateDecoded, format: .dateTime)
        }
        forcedApplyDate = forcedApplyDateBuffer
        let optInStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optInStatus)
        optInStatus = optInStatusDecoded
        let currentApplyDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentApplyDate)
        var currentApplyDateBuffer:ClientRuntime.Date? = nil
        if let currentApplyDateDecoded = currentApplyDateDecoded {
            currentApplyDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(currentApplyDateDecoded, format: .dateTime)
        }
        currentApplyDate = currentApplyDateBuffer
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RdsClientTypes.PendingMaintenanceAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingMaintenanceAction(action: \(Swift.String(describing: action)), autoAppliedAfterDate: \(Swift.String(describing: autoAppliedAfterDate)), currentApplyDate: \(Swift.String(describing: currentApplyDate)), description: \(Swift.String(describing: description)), forcedApplyDate: \(Swift.String(describing: forcedApplyDate)), optInStatus: \(Swift.String(describing: optInStatus)))"}
}

extension RdsClientTypes {
    /// Provides information about a pending maintenance action for a resource.
    public struct PendingMaintenanceAction: Swift.Equatable {
        /// The type of pending maintenance action that is available for the resource.
        ///           Valid actions are system-update, db-upgrade, hardware-maintenance,
        ///           and ca-certificate-rotation.
        public var action: Swift.String?
        /// The date of the maintenance window when the action is applied.
        ///            The maintenance action is applied to the resource during
        ///            its first maintenance window after this date.
        public var autoAppliedAfterDate: ClientRuntime.Date?
        /// The effective date when the pending maintenance action is applied
        ///            to the resource. This date takes into account opt-in requests received from
        ///            the ApplyPendingMaintenanceAction API, the AutoAppliedAfterDate,
        ///            and the ForcedApplyDate. This value is blank if an
        ///            opt-in request has not been received and nothing has been specified as
        ///            AutoAppliedAfterDate or ForcedApplyDate.
        public var currentApplyDate: ClientRuntime.Date?
        /// A description providing more detail about the maintenance action.
        public var description: Swift.String?
        /// The date when the maintenance action is automatically applied.
        ///          On this date, the maintenance action is applied to the resource as soon as possible,
        ///             regardless of the maintenance window for the resource. There might be a delay of
        ///             one or more days from this date before the maintenance action is applied.
        public var forcedApplyDate: ClientRuntime.Date?
        /// Indicates the type of opt-in request that has been received for the resource.
        public var optInStatus: Swift.String?

        public init (
            action: Swift.String? = nil,
            autoAppliedAfterDate: ClientRuntime.Date? = nil,
            currentApplyDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forcedApplyDate: ClientRuntime.Date? = nil,
            optInStatus: Swift.String? = nil
        )
        {
            self.action = action
            self.autoAppliedAfterDate = autoAppliedAfterDate
            self.currentApplyDate = currentApplyDate
            self.description = description
            self.forcedApplyDate = forcedApplyDate
            self.optInStatus = optInStatus
        }
    }

}

extension RdsClientTypes.PendingModifiedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case cACertificateIdentifier = "CACertificateIdentifier"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceIdentifier = "DBInstanceIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudwatchLogsExports = "PendingCloudwatchLogsExports"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let cACertificateIdentifier = cACertificateIdentifier {
            try container.encode(cACertificateIdentifier, forKey: ClientRuntime.Key("CACertificateIdentifier"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let pendingCloudwatchLogsExports = pendingCloudwatchLogsExports {
            try container.encode(pendingCloudwatchLogsExports, forKey: ClientRuntime.Key("PendingCloudwatchLogsExports"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let dBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceIdentifier)
        dBInstanceIdentifier = dBInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let cACertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cACertificateIdentifier)
        cACertificateIdentifier = cACertificateIdentifierDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let pendingCloudwatchLogsExportsDecoded = try containerValues.decodeIfPresent(RdsClientTypes.PendingCloudwatchLogsExports.self, forKey: .pendingCloudwatchLogsExports)
        pendingCloudwatchLogsExports = pendingCloudwatchLogsExportsDecoded
        if containerValues.contains(.processorFeatures) {
            struct KeyVal0{struct ProcessorFeature{}}
            let processorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessorFeature>.CodingKeys.self, forKey: .processorFeatures)
            if let processorFeaturesWrappedContainer = processorFeaturesWrappedContainer {
                let processorFeaturesContainer = try processorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.ProcessorFeature].self, forKey: .member)
                var processorFeaturesBuffer:[RdsClientTypes.ProcessorFeature]? = nil
                if let processorFeaturesContainer = processorFeaturesContainer {
                    processorFeaturesBuffer = [RdsClientTypes.ProcessorFeature]()
                    for structureContainer0 in processorFeaturesContainer {
                        processorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                processorFeatures = processorFeaturesBuffer
            } else {
                processorFeatures = []
            }
        } else {
            processorFeatures = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
    }
}

extension RdsClientTypes.PendingModifiedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingModifiedValues(allocatedStorage: \(Swift.String(describing: allocatedStorage)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), cACertificateIdentifier: \(Swift.String(describing: cACertificateIdentifier)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), engineVersion: \(Swift.String(describing: engineVersion)), iAMDatabaseAuthenticationEnabled: \(Swift.String(describing: iAMDatabaseAuthenticationEnabled)), iops: \(Swift.String(describing: iops)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), multiAZ: \(Swift.String(describing: multiAZ)), pendingCloudwatchLogsExports: \(Swift.String(describing: pendingCloudwatchLogsExports)), port: \(Swift.String(describing: port)), processorFeatures: \(Swift.String(describing: processorFeatures)), storageType: \(Swift.String(describing: storageType)))"}
}

extension RdsClientTypes {
    ///
    ///         This data type is used as a response element in the ModifyDBInstance operation and
    ///           contains changes that will be applied during the next maintenance window.
    ///
    public struct PendingModifiedValues: Swift.Equatable {
        /// The allocated storage size for the DB instance specified in gibibytes (GiB).
        public var allocatedStorage: Swift.Int?
        /// The number of days for which automated backups are retained.
        public var backupRetentionPeriod: Swift.Int?
        /// The identifier of the CA certificate for the DB instance.
        public var cACertificateIdentifier: Swift.String?
        /// The name of the compute and memory capacity class for the DB instance.
        public var dBInstanceClass: Swift.String?
        /// The  database identifier for the DB instance.
        public var dBInstanceIdentifier: Swift.String?
        /// The DB subnet group for the DB instance.
        public var dBSubnetGroupName: Swift.String?
        /// The database engine version.
        public var engineVersion: Swift.String?
        /// Whether mapping of Amazon Web Services Identity and Access Management (IAM) accounts to database accounts is enabled.
        public var iAMDatabaseAuthenticationEnabled: Swift.Bool?
        /// The Provisioned IOPS value for the DB instance.
        public var iops: Swift.Int?
        /// The license model for the DB instance.
        ///         Valid values: license-included | bring-your-own-license |
        ///             general-public-license
        ///
        public var licenseModel: Swift.String?
        /// The master credentials for the DB instance.
        public var masterUserPassword: Swift.String?
        /// A value that indicates that the Single-AZ DB instance will change to a Multi-AZ deployment.
        public var multiAZ: Swift.Bool?
        /// A list of the log types whose configuration is still pending. In other words, these log types are in the process of being activated or deactivated.
        public var pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports?
        /// The port for the DB instance.
        public var port: Swift.Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class
        ///             of the DB instance.
        public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
        /// The storage type of the DB instance.
        public var storageType: Swift.String?

        public init (
            allocatedStorage: Swift.Int? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            cACertificateIdentifier: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceIdentifier: Swift.String? = nil,
            dBSubnetGroupName: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iAMDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            licenseModel: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            pendingCloudwatchLogsExports: RdsClientTypes.PendingCloudwatchLogsExports? = nil,
            port: Swift.Int? = nil,
            processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.cACertificateIdentifier = cACertificateIdentifier
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceIdentifier = dBInstanceIdentifier
            self.dBSubnetGroupName = dBSubnetGroupName
            self.engineVersion = engineVersion
            self.iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudwatchLogsExports = pendingCloudwatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.storageType = storageType
        }
    }

}

extension PointInTimeRestoreNotEnabledFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PointInTimeRestoreNotEnabledFault(message: \(Swift.String(describing: message)))"}
}

extension PointInTimeRestoreNotEnabledFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<PointInTimeRestoreNotEnabledFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///             SourceDBInstanceIdentifier
///         refers to a DB instance with
///         BackupRetentionPeriod equal to 0.
///
public struct PointInTimeRestoreNotEnabledFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PointInTimeRestoreNotEnabledFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PointInTimeRestoreNotEnabledFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ProcessorFeature: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RdsClientTypes.ProcessorFeature: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProcessorFeature(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension RdsClientTypes {
    /// Contains the processor features of a DB instance class.
    ///         To specify the number of CPU cores, use the coreCount feature name
    ///             for the Name parameter. To specify the number of threads per core, use the
    ///             threadsPerCore feature name for the Name parameter.
    ///         You can set the processor features of the DB instance class for a DB instance when you
    ///             call one of the following actions:
    ///
    ///
    ///
    ///                   CreateDBInstance
    ///
    ///
    ///
    ///
    ///                   ModifyDBInstance
    ///
    ///
    ///
    ///
    ///                   RestoreDBInstanceFromDBSnapshot
    ///
    ///
    ///
    ///
    ///                   RestoreDBInstanceFromS3
    ///
    ///
    ///
    ///
    ///                   RestoreDBInstanceToPointInTime
    ///
    ///
    ///
    ///         You can view the valid processor values for a particular instance class by calling the
    ///                 DescribeOrderableDBInstanceOptions action and specifying the
    ///             instance class for the DBInstanceClass parameter.
    ///         In addition, you can use the following actions for DB instance class processor information:
    ///
    ///
    ///
    ///                   DescribeDBInstances
    ///
    ///
    ///
    ///
    ///                   DescribeDBSnapshots
    ///
    ///
    ///
    ///
    ///                   DescribeValidDBInstanceModifications
    ///
    ///
    ///
    ///         If you call DescribeDBInstances, ProcessorFeature returns
    ///             non-null values only if the following conditions are met:
    ///
    ///
    ///                You are accessing an Oracle DB instance.
    ///
    ///
    ///                 Your Oracle DB instance class supports configuring the number of CPU cores and threads per core.
    ///
    ///
    ///                The current number CPU cores and threads is set to a non-default value.
    ///
    ///
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor">Configuring the
    ///                 Processor of the DB Instance Class in the Amazon RDS User Guide.
    ///
    ///
    public struct ProcessorFeature: Swift.Equatable {
        /// The name of the processor feature. Valid names are coreCount and threadsPerCore.
        public var name: Swift.String?
        /// The value of a processor feature name.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct PromoteReadReplicaDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

extension PromoteReadReplicaDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteReadReplicaDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)))"}
}

extension PromoteReadReplicaDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("PromoteReadReplicaDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PromoteReadReplicaDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

public struct PromoteReadReplicaDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PromoteReadReplicaDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PromoteReadReplicaDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaDBClusterOutputError>
}

///
public struct PromoteReadReplicaDBClusterInput: Swift.Equatable {
    /// The identifier of the DB cluster read replica to promote. This parameter isn't
    ///             case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DB cluster read replica.
    ///
    ///
    ///          Example: my-cluster-replica1
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension PromoteReadReplicaDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteReadReplicaDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension PromoteReadReplicaDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteReadReplicaDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct PromoteReadReplicaDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct PromoteReadReplicaDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension PromoteReadReplicaDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PromoteReadReplicaDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct PromoteReadReplicaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaOutputError>
}

extension PromoteReadReplicaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteReadReplicaInput(backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)))"}
}

extension PromoteReadReplicaInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        try container.encode("PromoteReadReplica", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PromoteReadReplicaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaOutputError>
}

public struct PromoteReadReplicaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteReadReplicaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteReadReplicaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaOutputError>
}

public struct PromoteReadReplicaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteReadReplicaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PromoteReadReplicaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PromoteReadReplicaInput
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteReadReplicaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteReadReplicaOutputError>
}

///
public struct PromoteReadReplicaInput: Swift.Equatable {
    /// The number of days for which automated backups are retained. Setting this parameter to a positive number enables backups. Setting this parameter to 0 disables automated backups.
    ///          Default: 1
    ///          Constraints:
    ///
    ///
    ///                Must be a value from 0 to 35.
    ///
    ///
    ///                Can't be set to 0 if the DB instance is a source to read replicas.
    ///
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// The DB instance identifier. This value is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing read replica DB instance.
    ///
    ///
    ///          Example: mydbinstance
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    ///
    ///         The daily time range during which automated backups are created
    ///         if automated backups are enabled,
    ///         using the BackupRetentionPeriod parameter.
    ///
    ///
    ///             The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region.
    ///             To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/AdjustingTheMaintenanceWindow.html">
    ///             Adjusting the Preferred Maintenance Window in the Amazon RDS User Guide.
    ///
    ///          Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred maintenance window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredBackupWindow: Swift.String?

    public init (
        backupRetentionPeriod: Swift.Int? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil
    )
    {
        self.backupRetentionPeriod = backupRetentionPeriod
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.preferredBackupWindow = preferredBackupWindow
    }
}

extension PromoteReadReplicaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PromoteReadReplicaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteReadReplicaOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteReadReplicaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteReadReplicaOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension PromoteReadReplicaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteReadReplicaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct PromoteReadReplicaOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct PromoteReadReplicaOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension PromoteReadReplicaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PromoteReadReplicaResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension ProvisionedIopsNotAvailableInAZFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedIopsNotAvailableInAZFault(message: \(Swift.String(describing: message)))"}
}

extension ProvisionedIopsNotAvailableInAZFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ProvisionedIopsNotAvailableInAZFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Provisioned IOPS not available in the specified Availability Zone.
public struct ProvisionedIopsNotAvailableInAZFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProvisionedIopsNotAvailableInAZFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ProvisionedIopsNotAvailableInAZFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PurchaseReservedDBInstancesOfferingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedDBInstancesOfferingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

extension PurchaseReservedDBInstancesOfferingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseReservedDBInstancesOfferingInput(dBInstanceCount: \(Swift.String(describing: dBInstanceCount)), reservedDBInstanceId: \(Swift.String(describing: reservedDBInstanceId)), reservedDBInstancesOfferingId: \(Swift.String(describing: reservedDBInstancesOfferingId)), tags: \(Swift.String(describing: tags)))"}
}

extension PurchaseReservedDBInstancesOfferingInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceCount = dBInstanceCount {
            try container.encode(dBInstanceCount, forKey: ClientRuntime.Key("DBInstanceCount"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: ClientRuntime.Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("PurchaseReservedDBInstancesOffering", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct PurchaseReservedDBInstancesOfferingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedDBInstancesOfferingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

public struct PurchaseReservedDBInstancesOfferingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedDBInstancesOfferingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PurchaseReservedDBInstancesOfferingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

public struct PurchaseReservedDBInstancesOfferingInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PurchaseReservedDBInstancesOfferingInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PurchaseReservedDBInstancesOfferingInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PurchaseReservedDBInstancesOfferingInput
    public typealias MOutput = ClientRuntime.OperationOutput<PurchaseReservedDBInstancesOfferingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PurchaseReservedDBInstancesOfferingOutputError>
}

///
public struct PurchaseReservedDBInstancesOfferingInput: Swift.Equatable {
    /// The number of instances to reserve.
    ///          Default: 1
    ///
    public var dBInstanceCount: Swift.Int?
    /// Customer-specified identifier to track this reservation.
    ///          Example: myreservationID
    public var reservedDBInstanceId: Swift.String?
    /// The ID of the Reserved DB instance offering to purchase.
    ///          Example: 438012d3-4052-4cc7-b2e3-8d3372e0e706
    /// This member is required.
    public var reservedDBInstancesOfferingId: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?

    public init (
        dBInstanceCount: Swift.Int? = nil,
        reservedDBInstanceId: Swift.String? = nil,
        reservedDBInstancesOfferingId: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil
    )
    {
        self.dBInstanceCount = dBInstanceCount
        self.reservedDBInstanceId = reservedDBInstanceId
        self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
        self.tags = tags
    }
}

extension PurchaseReservedDBInstancesOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PurchaseReservedDBInstancesOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ReservedDBInstanceAlreadyExists" : self = .reservedDBInstanceAlreadyExistsFault(try ReservedDBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedDBInstanceQuotaExceeded" : self = .reservedDBInstanceQuotaExceededFault(try ReservedDBInstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedDBInstancesOfferingNotFound" : self = .reservedDBInstancesOfferingNotFoundFault(try ReservedDBInstancesOfferingNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseReservedDBInstancesOfferingOutputError: Swift.Error, Swift.Equatable {
    case reservedDBInstanceAlreadyExistsFault(ReservedDBInstanceAlreadyExistsFault)
    case reservedDBInstanceQuotaExceededFault(ReservedDBInstanceQuotaExceededFault)
    case reservedDBInstancesOfferingNotFoundFault(ReservedDBInstancesOfferingNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseReservedDBInstancesOfferingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PurchaseReservedDBInstancesOfferingOutputResponse(reservedDBInstance: \(Swift.String(describing: reservedDBInstance)))"}
}

extension PurchaseReservedDBInstancesOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PurchaseReservedDBInstancesOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservedDBInstance = output.reservedDBInstance
        } else {
            self.reservedDBInstance = nil
        }
    }
}

public struct PurchaseReservedDBInstancesOfferingOutputResponse: Swift.Equatable {
    ///
    ///             This data type is used as a response element in the
    ///             DescribeReservedDBInstances and
    ///             PurchaseReservedDBInstancesOffering actions.
    ///
    public var reservedDBInstance: RdsClientTypes.ReservedDBInstance?

    public init (
        reservedDBInstance: RdsClientTypes.ReservedDBInstance? = nil
    )
    {
        self.reservedDBInstance = reservedDBInstance
    }
}

struct PurchaseReservedDBInstancesOfferingOutputResponseBody: Swift.Equatable {
    public let reservedDBInstance: RdsClientTypes.ReservedDBInstance?
}

extension PurchaseReservedDBInstancesOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedDBInstance = "ReservedDBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("PurchaseReservedDBInstancesOfferingResult"))
        let reservedDBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ReservedDBInstance.self, forKey: .reservedDBInstance)
        reservedDBInstance = reservedDBInstanceDecoded
    }
}

extension RdsClientTypes.Range: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case step = "Step"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if from != 0 {
            try container.encode(from, forKey: ClientRuntime.Key("From"))
        }
        if let step = step {
            try container.encode(step, forKey: ClientRuntime.Key("Step"))
        }
        if to != 0 {
            try container.encode(to, forKey: ClientRuntime.Key("To"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decode(Swift.Int.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decode(Swift.Int.self, forKey: .to)
        to = toDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .step)
        step = stepDecoded
    }
}

extension RdsClientTypes.Range: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Range(from: \(Swift.String(describing: from)), step: \(Swift.String(describing: step)), to: \(Swift.String(describing: to)))"}
}

extension RdsClientTypes {
    /// A range of integer values.
    public struct Range: Swift.Equatable {
        /// The minimum value in the range.
        public var from: Swift.Int
        /// The step value for the range.
        ///             For example, if you have a range of 5,000 to 10,000,
        ///             with a step value of 1,000,
        ///             the valid values start at 5,000 and step up by 1,000.
        ///             Even though 7,500 is within the range,
        ///             it isn't a valid value for the range.
        ///             The valid values are 5,000, 6,000, 7,000, 8,000...
        ///
        public var step: Swift.Int?
        /// The maximum value in the range.
        public var to: Swift.Int

        public init (
            from: Swift.Int = 0,
            step: Swift.Int? = nil,
            to: Swift.Int = 0
        )
        {
            self.from = from
            self.step = step
            self.to = to
        }
    }

}

public struct RebootDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

extension RebootDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), forceFailover: \(Swift.String(describing: forceFailover)))"}
}

extension RebootDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let forceFailover = forceFailover {
            try container.encode(forceFailover, forKey: ClientRuntime.Key("ForceFailover"))
        }
        try container.encode("RebootDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RebootDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

public struct RebootDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RebootDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootDBInstanceOutputError>
}

///
public struct RebootDBInstanceInput: Swift.Equatable {
    /// The DB instance identifier. This parameter is stored as a lowercase string.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBInstance.
    ///
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    ///
    ///           A value that indicates whether the reboot is conducted through a Multi-AZ failover.
    ///
    ///          Constraint: You can't enable force failover if the instance isn't configured for Multi-AZ.
    public var forceFailover: Swift.Bool?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        forceFailover: Swift.Bool? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.forceFailover = forceFailover
    }
}

extension RebootDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RebootDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension RebootDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RebootDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RebootDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RebootDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension RebootDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RebootDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RdsClientTypes.RecurringCharge: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if recurringChargeAmount != 0.0 {
            try container.encode(Swift.String(recurringChargeAmount), forKey: ClientRuntime.Key("RecurringChargeAmount"))
        }
        if let recurringChargeFrequency = recurringChargeFrequency {
            try container.encode(recurringChargeFrequency, forKey: ClientRuntime.Key("RecurringChargeFrequency"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decode(Swift.Double.self, forKey: .recurringChargeAmount)
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension RdsClientTypes.RecurringCharge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecurringCharge(recurringChargeAmount: \(Swift.String(describing: recurringChargeAmount)), recurringChargeFrequency: \(Swift.String(describing: recurringChargeFrequency)))"}
}

extension RdsClientTypes {
    ///
    ///             This data type is used as a response element in the
    ///             DescribeReservedDBInstances and DescribeReservedDBInstancesOfferings actions.
    ///
    public struct RecurringCharge: Swift.Equatable {
        /// The amount of the recurring charge.
        public var recurringChargeAmount: Swift.Double
        /// The frequency of the recurring charge.
        public var recurringChargeFrequency: Swift.String?

        public init (
            recurringChargeAmount: Swift.Double = 0.0,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }

}

public struct RegisterDBProxyTargetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDBProxyTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDBProxyTargetsOutputError>
}

extension RegisterDBProxyTargetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDBProxyTargetsInput(dBClusterIdentifiers: \(Swift.String(describing: dBClusterIdentifiers)), dBInstanceIdentifiers: \(Swift.String(describing: dBInstanceIdentifiers)), dBProxyName: \(Swift.String(describing: dBProxyName)), targetGroupName: \(Swift.String(describing: targetGroupName)))"}
}

extension RegisterDBProxyTargetsInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifiers = dBClusterIdentifiers {
            var dBClusterIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterIdentifiers"))
            for (index0, string0) in dBClusterIdentifiers.enumerated() {
                try dBClusterIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceIdentifiers = dBInstanceIdentifiers {
            var dBInstanceIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBInstanceIdentifiers"))
            for (index0, string0) in dBInstanceIdentifiers.enumerated() {
                try dBInstanceIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBProxyName = dBProxyName {
            try container.encode(dBProxyName, forKey: ClientRuntime.Key("DBProxyName"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: ClientRuntime.Key("TargetGroupName"))
        }
        try container.encode("RegisterDBProxyTargets", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RegisterDBProxyTargetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDBProxyTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDBProxyTargetsOutputError>
}

public struct RegisterDBProxyTargetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDBProxyTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterDBProxyTargetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterDBProxyTargetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDBProxyTargetsOutputError>
}

public struct RegisterDBProxyTargetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterDBProxyTargetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RegisterDBProxyTargetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterDBProxyTargetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterDBProxyTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterDBProxyTargetsOutputError>
}

public struct RegisterDBProxyTargetsInput: Swift.Equatable {
    /// One or more DB cluster identifiers.
    public var dBClusterIdentifiers: [Swift.String]?
    /// One or more DB instance identifiers.
    public var dBInstanceIdentifiers: [Swift.String]?
    /// The identifier of the DBProxy that is associated with the DBProxyTargetGroup.
    /// This member is required.
    public var dBProxyName: Swift.String?
    /// The identifier of the DBProxyTargetGroup.
    public var targetGroupName: Swift.String?

    public init (
        dBClusterIdentifiers: [Swift.String]? = nil,
        dBInstanceIdentifiers: [Swift.String]? = nil,
        dBProxyName: Swift.String? = nil,
        targetGroupName: Swift.String? = nil
    )
    {
        self.dBClusterIdentifiers = dBClusterIdentifiers
        self.dBInstanceIdentifiers = dBInstanceIdentifiers
        self.dBProxyName = dBProxyName
        self.targetGroupName = targetGroupName
    }
}

extension RegisterDBProxyTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterDBProxyTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetAlreadyRegisteredFault" : self = .dBProxyTargetAlreadyRegisteredFault(try DBProxyTargetAlreadyRegisteredFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientAvailableIPsInSubnetFault" : self = .insufficientAvailableIPsInSubnetFault(try InsufficientAvailableIPsInSubnetFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBProxyStateFault" : self = .invalidDBProxyStateFault(try InvalidDBProxyStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterDBProxyTargetsOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetAlreadyRegisteredFault(DBProxyTargetAlreadyRegisteredFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case insufficientAvailableIPsInSubnetFault(InsufficientAvailableIPsInSubnetFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidDBProxyStateFault(InvalidDBProxyStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterDBProxyTargetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterDBProxyTargetsOutputResponse(dBProxyTargets: \(Swift.String(describing: dBProxyTargets)))"}
}

extension RegisterDBProxyTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterDBProxyTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBProxyTargets = output.dBProxyTargets
        } else {
            self.dBProxyTargets = nil
        }
    }
}

public struct RegisterDBProxyTargetsOutputResponse: Swift.Equatable {
    /// One or more DBProxyTarget objects that are created when you register targets with a target group.
    public var dBProxyTargets: [RdsClientTypes.DBProxyTarget]?

    public init (
        dBProxyTargets: [RdsClientTypes.DBProxyTarget]? = nil
    )
    {
        self.dBProxyTargets = dBProxyTargets
    }
}

struct RegisterDBProxyTargetsOutputResponseBody: Swift.Equatable {
    public let dBProxyTargets: [RdsClientTypes.DBProxyTarget]?
}

extension RegisterDBProxyTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBProxyTargets = "DBProxyTargets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RegisterDBProxyTargetsResult"))
        if containerValues.contains(.dBProxyTargets) {
            struct KeyVal0{struct member{}}
            let dBProxyTargetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dBProxyTargets)
            if let dBProxyTargetsWrappedContainer = dBProxyTargetsWrappedContainer {
                let dBProxyTargetsContainer = try dBProxyTargetsWrappedContainer.decodeIfPresent([RdsClientTypes.DBProxyTarget].self, forKey: .member)
                var dBProxyTargetsBuffer:[RdsClientTypes.DBProxyTarget]? = nil
                if let dBProxyTargetsContainer = dBProxyTargetsContainer {
                    dBProxyTargetsBuffer = [RdsClientTypes.DBProxyTarget]()
                    for structureContainer0 in dBProxyTargetsContainer {
                        dBProxyTargetsBuffer?.append(structureContainer0)
                    }
                }
                dBProxyTargets = dBProxyTargetsBuffer
            } else {
                dBProxyTargets = []
            }
        } else {
            dBProxyTargets = nil
        }
    }
}

public struct RemoveFromGlobalClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFromGlobalClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveFromGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveFromGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFromGlobalClusterOutputError>
}

extension RemoveFromGlobalClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveFromGlobalClusterInput(dbClusterIdentifier: \(Swift.String(describing: dbClusterIdentifier)), globalClusterIdentifier: \(Swift.String(describing: globalClusterIdentifier)))"}
}

extension RemoveFromGlobalClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dbClusterIdentifier = dbClusterIdentifier {
            try container.encode(dbClusterIdentifier, forKey: ClientRuntime.Key("DbClusterIdentifier"))
        }
        if let globalClusterIdentifier = globalClusterIdentifier {
            try container.encode(globalClusterIdentifier, forKey: ClientRuntime.Key("GlobalClusterIdentifier"))
        }
        try container.encode("RemoveFromGlobalCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveFromGlobalClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFromGlobalClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveFromGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveFromGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFromGlobalClusterOutputError>
}

public struct RemoveFromGlobalClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFromGlobalClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveFromGlobalClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveFromGlobalClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFromGlobalClusterOutputError>
}

public struct RemoveFromGlobalClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveFromGlobalClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveFromGlobalClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveFromGlobalClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveFromGlobalClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveFromGlobalClusterOutputError>
}

public struct RemoveFromGlobalClusterInput: Swift.Equatable {
    ///
    ///         The Amazon Resource Name (ARN) identifying the cluster that was detached from the Aurora global database cluster.
    ///
    public var dbClusterIdentifier: Swift.String?
    ///
    ///         The cluster identifier to detach from the Aurora global database cluster.
    ///
    public var globalClusterIdentifier: Swift.String?

    public init (
        dbClusterIdentifier: Swift.String? = nil,
        globalClusterIdentifier: Swift.String? = nil
    )
    {
        self.dbClusterIdentifier = dbClusterIdentifier
        self.globalClusterIdentifier = globalClusterIdentifier
    }
}

extension RemoveFromGlobalClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveFromGlobalClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GlobalClusterNotFoundFault" : self = .globalClusterNotFoundFault(try GlobalClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGlobalClusterStateFault" : self = .invalidGlobalClusterStateFault(try InvalidGlobalClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFromGlobalClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case globalClusterNotFoundFault(GlobalClusterNotFoundFault)
    case invalidGlobalClusterStateFault(InvalidGlobalClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFromGlobalClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveFromGlobalClusterOutputResponse(globalCluster: \(Swift.String(describing: globalCluster)))"}
}

extension RemoveFromGlobalClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveFromGlobalClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalCluster = output.globalCluster
        } else {
            self.globalCluster = nil
        }
    }
}

public struct RemoveFromGlobalClusterOutputResponse: Swift.Equatable {
    /// A data type representing an Aurora global database.
    public var globalCluster: RdsClientTypes.GlobalCluster?

    public init (
        globalCluster: RdsClientTypes.GlobalCluster? = nil
    )
    {
        self.globalCluster = globalCluster
    }
}

struct RemoveFromGlobalClusterOutputResponseBody: Swift.Equatable {
    public let globalCluster: RdsClientTypes.GlobalCluster?
}

extension RemoveFromGlobalClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalCluster = "GlobalCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RemoveFromGlobalClusterResult"))
        let globalClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.GlobalCluster.self, forKey: .globalCluster)
        globalCluster = globalClusterDecoded
    }
}

public struct RemoveRoleFromDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

extension RemoveRoleFromDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRoleFromDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension RemoveRoleFromDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveRoleFromDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveRoleFromDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveRoleFromDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBClusterOutputError>
}

public struct RemoveRoleFromDBClusterInput: Swift.Equatable {
    /// The name of the DB cluster to disassociate the IAM role from.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the feature for the DB cluster that the IAM role is to be disassociated from.
    ///             For the list of supported feature names, see DBEngineVersion.
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to disassociate from the Aurora DB cluster, for example
    ///         arn:aws:iam::123456789012:role/AuroraAccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension RemoveRoleFromDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterRoleNotFound" : self = .dBClusterRoleNotFoundFault(try DBClusterRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterRoleNotFoundFault(DBClusterRoleNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRoleFromDBClusterOutputResponse()"}
}

extension RemoveRoleFromDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveRoleFromDBClusterOutputResponseBody: Swift.Equatable {
}

extension RemoveRoleFromDBClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveRoleFromDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBInstanceOutputError>
}

extension RemoveRoleFromDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRoleFromDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), featureName: \(Swift.String(describing: featureName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension RemoveRoleFromDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let featureName = featureName {
            try container.encode(featureName, forKey: ClientRuntime.Key("FeatureName"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        try container.encode("RemoveRoleFromDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveRoleFromDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBInstanceOutputError>
}

public struct RemoveRoleFromDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveRoleFromDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveRoleFromDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBInstanceOutputError>
}

public struct RemoveRoleFromDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveRoleFromDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveRoleFromDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveRoleFromDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveRoleFromDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveRoleFromDBInstanceOutputError>
}

public struct RemoveRoleFromDBInstanceInput: Swift.Equatable {
    /// The name of the DB instance to disassociate the IAM role from.
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the feature for the DB instance that the IAM role is to be disassociated from.
    ///             For the list of supported feature names, see DBEngineVersion.
    ///
    /// This member is required.
    public var featureName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to disassociate from the DB instance,
    ///             for example, arn:aws:iam::123456789012:role/AccessRole.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        featureName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.featureName = featureName
        self.roleArn = roleArn
    }
}

extension RemoveRoleFromDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveRoleFromDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceRoleNotFound" : self = .dBInstanceRoleNotFoundFault(try DBInstanceRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveRoleFromDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBInstanceRoleNotFoundFault(DBInstanceRoleNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveRoleFromDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveRoleFromDBInstanceOutputResponse()"}
}

extension RemoveRoleFromDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveRoleFromDBInstanceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveRoleFromDBInstanceOutputResponseBody: Swift.Equatable {
}

extension RemoveRoleFromDBInstanceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

extension RemoveSourceIdentifierFromSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveSourceIdentifierFromSubscriptionInput(sourceIdentifier: \(Swift.String(describing: sourceIdentifier)), subscriptionName: \(Swift.String(describing: subscriptionName)))"}
}

extension RemoveSourceIdentifierFromSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceIdentifier = sourceIdentifier {
            try container.encode(sourceIdentifier, forKey: ClientRuntime.Key("SourceIdentifier"))
        }
        if let subscriptionName = subscriptionName {
            try container.encode(subscriptionName, forKey: ClientRuntime.Key("SubscriptionName"))
        }
        try container.encode("RemoveSourceIdentifierFromSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveSourceIdentifierFromSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

public struct RemoveSourceIdentifierFromSubscriptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveSourceIdentifierFromSubscriptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveSourceIdentifierFromSubscriptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveSourceIdentifierFromSubscriptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveSourceIdentifierFromSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveSourceIdentifierFromSubscriptionOutputError>
}

///
public struct RemoveSourceIdentifierFromSubscriptionInput: Swift.Equatable {
    ///
    ///             The source identifier to be removed from the subscription, such as the DB instance identifier
    ///             for a DB instance or the name of a security group.
    ///
    /// This member is required.
    public var sourceIdentifier: Swift.String?
    /// The name of the RDS event notification subscription you want to remove a source identifier from.
    /// This member is required.
    public var subscriptionName: Swift.String?

    public init (
        sourceIdentifier: Swift.String? = nil,
        subscriptionName: Swift.String? = nil
    )
    {
        self.sourceIdentifier = sourceIdentifier
        self.subscriptionName = subscriptionName
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveSourceIdentifierFromSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "SourceNotFound" : self = .sourceNotFoundFault(try SourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubscriptionNotFound" : self = .subscriptionNotFoundFault(try SubscriptionNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveSourceIdentifierFromSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case sourceNotFoundFault(SourceNotFoundFault)
    case subscriptionNotFoundFault(SubscriptionNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveSourceIdentifierFromSubscriptionOutputResponse(eventSubscription: \(Swift.String(describing: eventSubscription)))"}
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveSourceIdentifierFromSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventSubscription = output.eventSubscription
        } else {
            self.eventSubscription = nil
        }
    }
}

public struct RemoveSourceIdentifierFromSubscriptionOutputResponse: Swift.Equatable {
    /// Contains the results of a successful invocation of the DescribeEventSubscriptions action.
    public var eventSubscription: RdsClientTypes.EventSubscription?

    public init (
        eventSubscription: RdsClientTypes.EventSubscription? = nil
    )
    {
        self.eventSubscription = eventSubscription
    }
}

struct RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Swift.Equatable {
    public let eventSubscription: RdsClientTypes.EventSubscription?
}

extension RemoveSourceIdentifierFromSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventSubscription = "EventSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RemoveSourceIdentifierFromSubscriptionResult"))
        let eventSubscriptionDecoded = try containerValues.decodeIfPresent(RdsClientTypes.EventSubscription.self, forKey: .eventSubscription)
        eventSubscription = eventSubscriptionDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceInput(resourceName: \(Swift.String(describing: resourceName)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension RemoveTagsFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceName = resourceName {
            try container.encode(resourceName, forKey: ClientRuntime.Key("ResourceName"))
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
            for (index0, string0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTagsFromResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveTagsFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveTagsFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

///
public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon RDS resource that the tags are removed from. This value is an Amazon Resource Name (ARN). For information about
    ///             creating an ARN,
    ///             see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.ARN.html#USER_Tagging.ARN.Constructing">
    ///                 Constructing an ARN for Amazon RDS in the Amazon RDS User Guide.
    ///
    /// This member is required.
    public var resourceName: Swift.String?
    /// The tag key (name) of the tag to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceName: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyNotFoundFault" : self = .dBProxyNotFoundFault(try DBProxyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBProxyTargetGroupNotFoundFault" : self = .dBProxyTargetGroupNotFoundFault(try DBProxyTargetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBProxyNotFoundFault(DBProxyNotFoundFault)
    case dBProxyTargetGroupNotFoundFault(DBProxyTargetGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceOutputResponse()"}
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RdsClientTypes {
    public enum ReplicaMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mounted
        case openReadOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicaMode] {
            return [
                .mounted,
                .openReadOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mounted: return "mounted"
            case .openReadOnly: return "open-read-only"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicaMode(rawValue: rawValue) ?? ReplicaMode.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.ReservedDBInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case dBInstanceClass = "DBInstanceClass"
        case dBInstanceCount = "DBInstanceCount"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case leaseId = "LeaseId"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case recurringCharges = "RecurringCharges"
        case reservedDBInstanceArn = "ReservedDBInstanceArn"
        case reservedDBInstanceId = "ReservedDBInstanceId"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case startTime = "StartTime"
        case state = "State"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: ClientRuntime.Key("CurrencyCode"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if dBInstanceCount != 0 {
            try container.encode(dBInstanceCount, forKey: ClientRuntime.Key("DBInstanceCount"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(Swift.String(fixedPrice), forKey: ClientRuntime.Key("FixedPrice"))
        }
        if let leaseId = leaseId {
            try container.encode(leaseId, forKey: ClientRuntime.Key("LeaseId"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: ClientRuntime.Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedDBInstanceArn = reservedDBInstanceArn {
            try container.encode(reservedDBInstanceArn, forKey: ClientRuntime.Key("ReservedDBInstanceArn"))
        }
        if let reservedDBInstanceId = reservedDBInstanceId {
            try container.encode(reservedDBInstanceId, forKey: ClientRuntime.Key("ReservedDBInstanceId"))
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        if let startTime = startTime {
            try container.encode(ClientRuntime.TimestampWrapper(startTime, format: .dateTime), forKey: ClientRuntime.Key("startTime"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if usagePrice != 0.0 {
            try container.encode(Swift.String(usagePrice), forKey: ClientRuntime.Key("UsagePrice"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstanceId)
        reservedDBInstanceId = reservedDBInstanceIdDecoded
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let dBInstanceCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .dBInstanceCount)
        dBInstanceCount = dBInstanceCountDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RdsClientTypes.RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RdsClientTypes.RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RdsClientTypes.RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
        let reservedDBInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstanceArn)
        reservedDBInstanceArn = reservedDBInstanceArnDecoded
        let leaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .leaseId)
        leaseId = leaseIdDecoded
    }
}

extension RdsClientTypes.ReservedDBInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedDBInstance(currencyCode: \(Swift.String(describing: currencyCode)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceCount: \(Swift.String(describing: dBInstanceCount)), duration: \(Swift.String(describing: duration)), fixedPrice: \(Swift.String(describing: fixedPrice)), leaseId: \(Swift.String(describing: leaseId)), multiAZ: \(Swift.String(describing: multiAZ)), offeringType: \(Swift.String(describing: offeringType)), productDescription: \(Swift.String(describing: productDescription)), recurringCharges: \(Swift.String(describing: recurringCharges)), reservedDBInstanceArn: \(Swift.String(describing: reservedDBInstanceArn)), reservedDBInstanceId: \(Swift.String(describing: reservedDBInstanceId)), reservedDBInstancesOfferingId: \(Swift.String(describing: reservedDBInstancesOfferingId)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), usagePrice: \(Swift.String(describing: usagePrice)))"}
}

extension RdsClientTypes {
    ///
    ///             This data type is used as a response element in the
    ///             DescribeReservedDBInstances and
    ///             PurchaseReservedDBInstancesOffering actions.
    ///
    public struct ReservedDBInstance: Swift.Equatable {
        /// The currency code for the reserved DB instance.
        public var currencyCode: Swift.String?
        /// The DB instance class for the reserved DB instance.
        public var dBInstanceClass: Swift.String?
        /// The number of reserved DB instances.
        public var dBInstanceCount: Swift.Int
        /// The duration of the reservation in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this reserved DB instance.
        public var fixedPrice: Swift.Double
        /// The unique identifier for the lease associated with the reserved DB instance.
        ///
        ///             Amazon Web Services Support might request the lease ID for an issue related to a reserved DB instance.
        ///
        public var leaseId: Swift.String?
        /// Indicates if the reservation applies to Multi-AZ deployments.
        public var multiAZ: Swift.Bool
        /// The offering type of this reserved DB instance.
        public var offeringType: Swift.String?
        /// The description of the reserved DB instance.
        public var productDescription: Swift.String?
        /// The recurring price charged to run this reserved DB instance.
        public var recurringCharges: [RdsClientTypes.RecurringCharge]?
        /// The Amazon Resource Name (ARN) for the reserved DB instance.
        public var reservedDBInstanceArn: Swift.String?
        /// The unique identifier for the reservation.
        public var reservedDBInstanceId: Swift.String?
        /// The offering identifier.
        public var reservedDBInstancesOfferingId: Swift.String?
        /// The time the reservation started.
        public var startTime: ClientRuntime.Date?
        /// The state of the reserved DB instance.
        public var state: Swift.String?
        /// The hourly price charged for this reserved DB instance.
        public var usagePrice: Swift.Double

        public init (
            currencyCode: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            dBInstanceCount: Swift.Int = 0,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            leaseId: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            offeringType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            recurringCharges: [RdsClientTypes.RecurringCharge]? = nil,
            reservedDBInstanceArn: Swift.String? = nil,
            reservedDBInstanceId: Swift.String? = nil,
            reservedDBInstancesOfferingId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            usagePrice: Swift.Double = 0.0
        )
        {
            self.currencyCode = currencyCode
            self.dBInstanceClass = dBInstanceClass
            self.dBInstanceCount = dBInstanceCount
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.leaseId = leaseId
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.recurringCharges = recurringCharges
            self.reservedDBInstanceArn = reservedDBInstanceArn
            self.reservedDBInstanceId = reservedDBInstanceId
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }
    }

}

extension ReservedDBInstanceAlreadyExistsFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedDBInstanceAlreadyExistsFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedDBInstanceAlreadyExistsFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstanceAlreadyExistsFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User already has a reservation with the given identifier.
public struct ReservedDBInstanceAlreadyExistsFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceAlreadyExistsFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedDBInstanceAlreadyExistsFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstanceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedDBInstanceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedDBInstanceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstanceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified reserved DB Instance not found.
public struct ReservedDBInstanceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedDBInstanceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservedDBInstanceQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedDBInstanceQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedDBInstanceQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstanceQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would exceed the user's DB Instance quota.
public struct ReservedDBInstanceQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstanceQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedDBInstanceQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ReservedDBInstancesOffering: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case dBInstanceClass = "DBInstanceClass"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case multiAZ = "MultiAZ"
        case offeringType = "OfferingType"
        case productDescription = "ProductDescription"
        case recurringCharges = "RecurringCharges"
        case reservedDBInstancesOfferingId = "ReservedDBInstancesOfferingId"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let currencyCode = currencyCode {
            try container.encode(currencyCode, forKey: ClientRuntime.Key("CurrencyCode"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if duration != 0 {
            try container.encode(duration, forKey: ClientRuntime.Key("Duration"))
        }
        if fixedPrice != 0.0 {
            try container.encode(Swift.String(fixedPrice), forKey: ClientRuntime.Key("FixedPrice"))
        }
        if multiAZ != false {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let offeringType = offeringType {
            try container.encode(offeringType, forKey: ClientRuntime.Key("OfferingType"))
        }
        if let productDescription = productDescription {
            try container.encode(productDescription, forKey: ClientRuntime.Key("ProductDescription"))
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RecurringCharges"))
            for (index0, recurringcharge0) in recurringCharges.enumerated() {
                try recurringChargesContainer.encode(recurringcharge0, forKey: ClientRuntime.Key("RecurringCharge.\(index0.advanced(by: 1))"))
            }
        }
        if let reservedDBInstancesOfferingId = reservedDBInstancesOfferingId {
            try container.encode(reservedDBInstancesOfferingId, forKey: ClientRuntime.Key("ReservedDBInstancesOfferingId"))
        }
        if usagePrice != 0.0 {
            try container.encode(Swift.String(usagePrice), forKey: ClientRuntime.Key("UsagePrice"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedDBInstancesOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedDBInstancesOfferingId)
        reservedDBInstancesOfferingId = reservedDBInstancesOfferingIdDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let durationDecoded = try containerValues.decode(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decode(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let offeringTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringType)
        offeringType = offeringTypeDecoded
        let multiAZDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        if containerValues.contains(.recurringCharges) {
            struct KeyVal0{struct RecurringCharge{}}
            let recurringChargesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.RecurringCharge>.CodingKeys.self, forKey: .recurringCharges)
            if let recurringChargesWrappedContainer = recurringChargesWrappedContainer {
                let recurringChargesContainer = try recurringChargesWrappedContainer.decodeIfPresent([RdsClientTypes.RecurringCharge].self, forKey: .member)
                var recurringChargesBuffer:[RdsClientTypes.RecurringCharge]? = nil
                if let recurringChargesContainer = recurringChargesContainer {
                    recurringChargesBuffer = [RdsClientTypes.RecurringCharge]()
                    for structureContainer0 in recurringChargesContainer {
                        recurringChargesBuffer?.append(structureContainer0)
                    }
                }
                recurringCharges = recurringChargesBuffer
            } else {
                recurringCharges = []
            }
        } else {
            recurringCharges = nil
        }
    }
}

extension RdsClientTypes.ReservedDBInstancesOffering: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedDBInstancesOffering(currencyCode: \(Swift.String(describing: currencyCode)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), duration: \(Swift.String(describing: duration)), fixedPrice: \(Swift.String(describing: fixedPrice)), multiAZ: \(Swift.String(describing: multiAZ)), offeringType: \(Swift.String(describing: offeringType)), productDescription: \(Swift.String(describing: productDescription)), recurringCharges: \(Swift.String(describing: recurringCharges)), reservedDBInstancesOfferingId: \(Swift.String(describing: reservedDBInstancesOfferingId)), usagePrice: \(Swift.String(describing: usagePrice)))"}
}

extension RdsClientTypes {
    ///
    ///             This data type is used as a response element in the DescribeReservedDBInstancesOfferings action.
    ///
    public struct ReservedDBInstancesOffering: Swift.Equatable {
        /// The currency code for the reserved DB instance offering.
        public var currencyCode: Swift.String?
        /// The DB instance class for the reserved DB instance.
        public var dBInstanceClass: Swift.String?
        /// The duration of the offering in seconds.
        public var duration: Swift.Int
        /// The fixed price charged for this offering.
        public var fixedPrice: Swift.Double
        /// Indicates if the offering applies to Multi-AZ deployments.
        public var multiAZ: Swift.Bool
        /// The offering type.
        public var offeringType: Swift.String?
        /// The database engine used by the offering.
        public var productDescription: Swift.String?
        /// The recurring price charged to run this reserved DB instance.
        public var recurringCharges: [RdsClientTypes.RecurringCharge]?
        /// The offering identifier.
        public var reservedDBInstancesOfferingId: Swift.String?
        /// The hourly price charged for this offering.
        public var usagePrice: Swift.Double

        public init (
            currencyCode: Swift.String? = nil,
            dBInstanceClass: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double = 0.0,
            multiAZ: Swift.Bool = false,
            offeringType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            recurringCharges: [RdsClientTypes.RecurringCharge]? = nil,
            reservedDBInstancesOfferingId: Swift.String? = nil,
            usagePrice: Swift.Double = 0.0
        )
        {
            self.currencyCode = currencyCode
            self.dBInstanceClass = dBInstanceClass
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.multiAZ = multiAZ
            self.offeringType = offeringType
            self.productDescription = productDescription
            self.recurringCharges = recurringCharges
            self.reservedDBInstancesOfferingId = reservedDBInstancesOfferingId
            self.usagePrice = usagePrice
        }
    }

}

extension ReservedDBInstancesOfferingNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedDBInstancesOfferingNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ReservedDBInstancesOfferingNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ReservedDBInstancesOfferingNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Specified offering does not exist.
public struct ReservedDBInstancesOfferingNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedDBInstancesOfferingNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedDBInstancesOfferingNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResetDBClusterParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

extension ResetDBClusterParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBClusterParameterGroupInput(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), parameters: \(Swift.String(describing: parameters)), resetAllParameters: \(Swift.String(describing: resetAllParameters)))"}
}

extension ResetDBClusterParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetDBClusterParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResetDBClusterParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBClusterParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

public struct ResetDBClusterParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBClusterParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ResetDBClusterParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetDBClusterParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBClusterParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBClusterParameterGroupOutputError>
}

///
public struct ResetDBClusterParameterGroupInput: Swift.Equatable {
    /// The name of the DB cluster parameter group to reset.
    /// This member is required.
    public var dBClusterParameterGroupName: Swift.String?
    /// A list of parameter names in the DB cluster parameter group to reset to the default values. You can't use this
    ///         parameter if the ResetAllParameters parameter is enabled.
    public var parameters: [RdsClientTypes.Parameter]?
    /// A value that indicates whether to reset all parameters in the DB cluster parameter group
    ///         to their default values. You can't use this parameter if there
    ///         is a list of parameter names specified for the Parameters parameter.
    public var resetAllParameters: Swift.Bool

    public init (
        dBClusterParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBClusterParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBClusterParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBClusterParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBClusterParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBClusterParameterGroupOutputResponse(dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)))"}
}

extension ResetDBClusterParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetDBClusterParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBClusterParameterGroupName = output.dBClusterParameterGroupName
        } else {
            self.dBClusterParameterGroupName = nil
        }
    }
}

///
public struct ResetDBClusterParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB cluster parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must be 1 to 255 letters or numbers.
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///
    ///             This value is stored as a lowercase string.
    ///
    public var dBClusterParameterGroupName: Swift.String?

    public init (
        dBClusterParameterGroupName: Swift.String? = nil
    )
    {
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
    }
}

struct ResetDBClusterParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBClusterParameterGroupName: Swift.String?
}

extension ResetDBClusterParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetDBClusterParameterGroupResult"))
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
    }
}

public struct ResetDBParameterGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

extension ResetDBParameterGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBParameterGroupInput(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), parameters: \(Swift.String(describing: parameters)), resetAllParameters: \(Swift.String(describing: resetAllParameters)))"}
}

extension ResetDBParameterGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let parameters = parameters {
            var parametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Parameters"))
            for (index0, parameter0) in parameters.enumerated() {
                try parametersContainer.encode(parameter0, forKey: ClientRuntime.Key("Parameter.\(index0.advanced(by: 1))"))
            }
        }
        if resetAllParameters != false {
            try container.encode(resetAllParameters, forKey: ClientRuntime.Key("ResetAllParameters"))
        }
        try container.encode("ResetDBParameterGroup", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct ResetDBParameterGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetDBParameterGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

public struct ResetDBParameterGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetDBParameterGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ResetDBParameterGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetDBParameterGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetDBParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetDBParameterGroupOutputError>
}

///
public struct ResetDBParameterGroupInput: Swift.Equatable {
    /// The name of the DB parameter group.
    ///          Constraints:
    ///
    ///
    ///                Must match the name of an existing DBParameterGroup.
    ///
    ///
    /// This member is required.
    public var dBParameterGroupName: Swift.String?
    /// To reset the entire DB parameter group, specify the DBParameterGroup
    ///             name and ResetAllParameters parameters. To reset specific parameters,
    ///             provide a list of the following: ParameterName and
    ///             ApplyMethod. A maximum of 20 parameters can be modified in a single
    ///             request.
    ///
    ///             MySQL
    ///
    ///          Valid Values (for Apply method): immediate | pending-reboot
    ///
    ///          You can use the immediate value with dynamic parameters only. You can use
    ///             the pending-reboot value for both dynamic and static parameters, and changes
    ///             are applied when DB instance reboots.
    ///
    ///             MariaDB
    ///
    ///          Valid Values (for Apply method): immediate | pending-reboot
    ///
    ///          You can use the immediate value with dynamic parameters only. You can use
    ///       the pending-reboot value for both dynamic and static parameters, and changes
    ///       are applied when DB instance reboots.
    ///
    ///             Oracle
    ///
    ///          Valid Values (for Apply method): pending-reboot
    ///
    public var parameters: [RdsClientTypes.Parameter]?
    ///
    ///           A value that indicates whether to reset all parameters in the DB parameter group to default values.
    ///           By default, all parameters in the DB parameter group are reset to default values.
    ///
    public var resetAllParameters: Swift.Bool

    public init (
        dBParameterGroupName: Swift.String? = nil,
        parameters: [RdsClientTypes.Parameter]? = nil,
        resetAllParameters: Swift.Bool = false
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
        self.parameters = parameters
        self.resetAllParameters = resetAllParameters
    }
}

extension ResetDBParameterGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ResetDBParameterGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBParameterGroupState" : self = .invalidDBParameterGroupStateFault(try InvalidDBParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetDBParameterGroupOutputError: Swift.Error, Swift.Equatable {
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case invalidDBParameterGroupStateFault(InvalidDBParameterGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetDBParameterGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetDBParameterGroupOutputResponse(dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)))"}
}

extension ResetDBParameterGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResetDBParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBParameterGroupName = output.dBParameterGroupName
        } else {
            self.dBParameterGroupName = nil
        }
    }
}

///
///         Contains the result of a successful invocation of the
///         ModifyDBParameterGroup or ResetDBParameterGroup action.
///
public struct ResetDBParameterGroupOutputResponse: Swift.Equatable {
    /// The name of the DB parameter group.
    public var dBParameterGroupName: Swift.String?

    public init (
        dBParameterGroupName: Swift.String? = nil
    )
    {
        self.dBParameterGroupName = dBParameterGroupName
    }
}

struct ResetDBParameterGroupOutputResponseBody: Swift.Equatable {
    public let dBParameterGroupName: Swift.String?
}

extension ResetDBParameterGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBParameterGroupName = "DBParameterGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("ResetDBParameterGroupResult"))
        let dBParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupName)
        dBParameterGroupName = dBParameterGroupNameDecoded
    }
}

extension ResourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<ResourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource ID was not found.
public struct ResourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ResourcePendingMaintenanceActions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingMaintenanceActionDetails = "PendingMaintenanceActionDetails"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let pendingMaintenanceActionDetails = pendingMaintenanceActionDetails {
            var pendingMaintenanceActionDetailsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PendingMaintenanceActionDetails"))
            for (index0, pendingmaintenanceaction0) in pendingMaintenanceActionDetails.enumerated() {
                try pendingMaintenanceActionDetailsContainer.encode(pendingmaintenanceaction0, forKey: ClientRuntime.Key("PendingMaintenanceAction.\(index0.advanced(by: 1))"))
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try container.encode(resourceIdentifier, forKey: ClientRuntime.Key("ResourceIdentifier"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        if containerValues.contains(.pendingMaintenanceActionDetails) {
            struct KeyVal0{struct PendingMaintenanceAction{}}
            let pendingMaintenanceActionDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PendingMaintenanceAction>.CodingKeys.self, forKey: .pendingMaintenanceActionDetails)
            if let pendingMaintenanceActionDetailsWrappedContainer = pendingMaintenanceActionDetailsWrappedContainer {
                let pendingMaintenanceActionDetailsContainer = try pendingMaintenanceActionDetailsWrappedContainer.decodeIfPresent([RdsClientTypes.PendingMaintenanceAction].self, forKey: .member)
                var pendingMaintenanceActionDetailsBuffer:[RdsClientTypes.PendingMaintenanceAction]? = nil
                if let pendingMaintenanceActionDetailsContainer = pendingMaintenanceActionDetailsContainer {
                    pendingMaintenanceActionDetailsBuffer = [RdsClientTypes.PendingMaintenanceAction]()
                    for structureContainer0 in pendingMaintenanceActionDetailsContainer {
                        pendingMaintenanceActionDetailsBuffer?.append(structureContainer0)
                    }
                }
                pendingMaintenanceActionDetails = pendingMaintenanceActionDetailsBuffer
            } else {
                pendingMaintenanceActionDetails = []
            }
        } else {
            pendingMaintenanceActionDetails = nil
        }
    }
}

extension RdsClientTypes.ResourcePendingMaintenanceActions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePendingMaintenanceActions(pendingMaintenanceActionDetails: \(Swift.String(describing: pendingMaintenanceActionDetails)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension RdsClientTypes {
    /// Describes the pending maintenance actions for a resource.
    public struct ResourcePendingMaintenanceActions: Swift.Equatable {
        /// A list that provides details about the pending maintenance actions for the resource.
        public var pendingMaintenanceActionDetails: [RdsClientTypes.PendingMaintenanceAction]?
        /// The ARN of the resource that has pending maintenance actions.
        public var resourceIdentifier: Swift.String?

        public init (
            pendingMaintenanceActionDetails: [RdsClientTypes.PendingMaintenanceAction]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.pendingMaintenanceActionDetails = pendingMaintenanceActionDetails
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

public struct RestoreDBClusterFromS3InputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromS3Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromS3Input>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromS3OutputError>
}

extension RestoreDBClusterFromS3Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterFromS3Input(availabilityZones: \(Swift.String(describing: availabilityZones)), backtrackWindow: \(Swift.String(describing: backtrackWindow)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), characterSetName: \(Swift.String(describing: characterSetName)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3IngestionRoleArn: \(Swift.String(describing: s3IngestionRoleArn)), s3Prefix: \(Swift.String(describing: s3Prefix)), sourceEngine: \(Swift.String(describing: sourceEngine)), sourceEngineVersion: \(Swift.String(describing: sourceEngineVersion)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterFromS3Input: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3IngestionRoleArn = s3IngestionRoleArn {
            try container.encode(s3IngestionRoleArn, forKey: ClientRuntime.Key("S3IngestionRoleArn"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let sourceEngine = sourceEngine {
            try container.encode(sourceEngine, forKey: ClientRuntime.Key("SourceEngine"))
        }
        if let sourceEngineVersion = sourceEngineVersion {
            try container.encode(sourceEngineVersion, forKey: ClientRuntime.Key("SourceEngineVersion"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromS3", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBClusterFromS3InputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromS3Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromS3Input>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromS3OutputError>
}

public struct RestoreDBClusterFromS3InputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromS3Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromS3Input>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromS3OutputError>
}

public struct RestoreDBClusterFromS3InputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromS3InputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDBClusterFromS3Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDBClusterFromS3Input
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromS3OutputError>
}

public struct RestoreDBClusterFromS3Input: Swift.Equatable {
    /// A list of Availability Zones (AZs) where instances in the restored DB cluster can be created.
    public var availabilityZones: [Swift.String]?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.
    ///
    ///             Currently, Backtrack is only supported for Aurora MySQL DB clusters.
    ///
    ///         Default: 0
    ///         Constraints:
    ///
    ///
    ///                If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    public var backtrackWindow: Swift.Int?
    /// The number of days for which automated backups of the restored DB cluster are retained. You must specify a minimum value of 1.
    ///         Default: 1
    ///         Constraints:
    ///
    ///
    ///                Must be a value from 1 to 35
    ///
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// A value that indicates that the restored DB cluster should be associated with the specified CharacterSet.
    public var characterSetName: Swift.String?
    /// A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The name of the DB cluster to create from the source data in the Amazon S3 bucket. This parameter isn't case-sensitive.
    ///         Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///         Example: my-cluster1
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the DB cluster parameter group to associate
    ///             with the restored DB cluster. If this argument is omitted, default.aurora5.6 is used.
    ///
    ///         Constraints:
    ///
    ///
    ///                If supplied, must match the name of an existing DBClusterParameterGroup.
    ///
    ///
    public var dBClusterParameterGroupName: Swift.String?
    /// A DB subnet group to associate with the restored DB cluster.
    ///         Constraints: If supplied, must match the name of an existing DBSubnetGroup.
    ///
    ///         Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// The database name for the restored DB cluster.
    public var databaseName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB cluster in.
    ///           The domain must be created prior to this operation.
    ///
    ///
    ///         For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication
    ///         in the Amazon Aurora User Guide.
    ///
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication in the Amazon Aurora User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The name of the database engine to be used for this DB cluster.
    ///         Valid Values: aurora (for MySQL 5.6-compatible Aurora), aurora-mysql (for MySQL 5.7-compatible Aurora), and aurora-postgresql
    ///
    /// This member is required.
    public var engine: Swift.String?
    /// The version number of the database engine to use.
    ///         To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"
    ///
    ///         To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"
    ///
    ///         To list all of the available engine versions for aurora-postgresql, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"
    ///
    ///
    ///             Aurora MySQL
    ///
    ///         Example: 5.6.10a, 5.6.mysql_aurora.1.19.2, 5.7.12, 5.7.mysql_aurora.2.04.5
    ///
    ///
    ///             Aurora PostgreSQL
    ///
    ///         Example: 9.6.3, 10.7
    ///
    public var engineVersion: Swift.String?
    /// The Amazon Web Services KMS key identifier for an encrypted DB cluster.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///             To use a CMK in a different Amazon Web Services account, specify the key ARN or alias ARN.
    ///         If the StorageEncrypted parameter is enabled, and you do
    ///             not specify a value for the KmsKeyId parameter, then
    ///             Amazon RDS will use your default CMK. There is a
    ///             default CMK for your Amazon Web Services account. Your Amazon Web Services account has a different
    ///             default CMK for each Amazon Web Services Region.
    public var kmsKeyId: Swift.String?
    /// The password for the master database user. This password can contain any printable ASCII character except "/", """, or "@".
    ///         Constraints: Must contain from 8 to 41 characters.
    /// This member is required.
    public var masterUserPassword: Swift.String?
    /// The name of the master user for the restored DB cluster.
    ///         Constraints:
    ///
    ///
    ///                Must be 1 to 16 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    /// This member is required.
    public var masterUsername: Swift.String?
    /// A value that indicates that the restored DB cluster should be associated with the specified option group.
    ///         Permanent options can't be removed from an option group. An option group can't be removed from a
    ///             DB cluster once it is associated with a DB cluster.
    public var optionGroupName: Swift.String?
    /// The port number on which the instances in the restored DB cluster accept connections.
    ///
    ///             Default: 3306
    ///
    public var port: Swift.Int?
    /// The daily time range during which automated backups are created
    ///             if automated backups are enabled
    ///             using the BackupRetentionPeriod parameter.
    ///
    ///         The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region.
    ///             To view the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.Backups.BackupWindow">
    ///                 Backup window in the Amazon Aurora User Guide.
    ///
    ///         Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred maintenance window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredBackupWindow: Swift.String?
    /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
    ///         Format: ddd:hh24:mi-ddd:hh24:mi
    ///
    ///         The default is a 30-minute window selected at random from an
    ///             8-hour block of time for each Amazon Web Services Region, occurring on a random day of the
    ///             week. To see the time blocks available, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_UpgradeDBInstance.Maintenance.html#AdjustingTheMaintenanceWindow.Aurora">
    ///                 Adjusting the Preferred Maintenance Window in the Amazon Aurora User Guide.
    ///
    ///         Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
    ///         Constraints: Minimum 30-minute window.
    public var preferredMaintenanceWindow: Swift.String?
    /// The name of the Amazon S3 bucket that contains the data used to create the Amazon Aurora DB cluster.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services Identity and Access Management (IAM) role that authorizes
    ///         Amazon RDS to access the Amazon S3 bucket on your behalf.
    /// This member is required.
    public var s3IngestionRoleArn: Swift.String?
    /// The prefix for all of the file names that contain the data used to create the Amazon Aurora DB cluster.
    ///         If you do not specify a SourceS3Prefix value, then the Amazon Aurora DB cluster is
    ///         created by using all of the files in the Amazon S3 bucket.
    public var s3Prefix: Swift.String?
    /// The identifier for the database engine that was backed up to create the files stored in the
    ///             Amazon S3 bucket.
    ///
    ///         Valid values: mysql
    ///
    /// This member is required.
    public var sourceEngine: Swift.String?
    /// The version of the database that the backup files were created from.
    ///         MySQL versions 5.5, 5.6, and 5.7 are supported.
    ///
    ///         Example: 5.6.40, 5.7.28
    ///
    /// This member is required.
    public var sourceEngineVersion: Swift.String?
    /// A value that indicates whether the restored DB cluster is encrypted.
    public var storageEncrypted: Swift.Bool?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A list of EC2 VPC security groups to associate with the restored DB cluster.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        backtrackWindow: Swift.Int? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        characterSetName: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3IngestionRoleArn: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        sourceEngine: Swift.String? = nil,
        sourceEngineVersion: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.backupRetentionPeriod = backupRetentionPeriod
        self.characterSetName = characterSetName
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.optionGroupName = optionGroupName
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.s3BucketName = s3BucketName
        self.s3IngestionRoleArn = s3IngestionRoleArn
        self.s3Prefix = s3Prefix
        self.sourceEngine = sourceEngine
        self.sourceEngineVersion = sourceEngineVersion
        self.storageEncrypted = storageEncrypted
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterFromS3OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromS3OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSubnetGroupStateFault" : self = .invalidDBSubnetGroupStateFault(try InvalidDBSubnetGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromS3OutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSubnetGroupStateFault(InvalidDBSubnetGroupStateFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromS3OutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterFromS3OutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension RestoreDBClusterFromS3OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterFromS3OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromS3OutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromS3OutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension RestoreDBClusterFromS3OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterFromS3Result"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBClusterFromSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

extension RestoreDBClusterFromSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterFromSnapshotInput(availabilityZones: \(Swift.String(describing: availabilityZones)), backtrackWindow: \(Swift.String(describing: backtrackWindow)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), databaseName: \(Swift.String(describing: databaseName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), engineMode: \(Swift.String(describing: engineMode)), engineVersion: \(Swift.String(describing: engineVersion)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), scalingConfiguration: \(Swift.String(describing: scalingConfiguration)), snapshotIdentifier: \(Swift.String(describing: snapshotIdentifier)), tags: \(Swift.String(describing: tags)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterFromSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterFromSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBClusterFromSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterFromSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

public struct RestoreDBClusterFromSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterFromSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDBClusterFromSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDBClusterFromSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterFromSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterFromSnapshotOutputError>
}

///
public struct RestoreDBClusterFromSnapshotInput: Swift.Equatable {
    /// Provides the list of Availability Zones (AZs) where instances in the restored DB
    ///             cluster can be created.
    public var availabilityZones: [Swift.String]?
    /// The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.
    ///
    ///             Currently, Backtrack is only supported for Aurora MySQL DB clusters.
    ///
    ///         Default: 0
    ///         Constraints:
    ///
    ///
    ///                If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    public var backtrackWindow: Swift.Int?
    /// A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The name of the DB cluster to create from the DB snapshot or DB cluster snapshot.
    ///             This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-snapshot-id
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the DB cluster parameter group to associate with this DB cluster. If this
    ///             argument is omitted, the default DB cluster parameter group for the specified engine is
    ///             used.
    ///         Constraints:
    ///
    ///
    ///                 If supplied, must match the name of an existing default DB cluster parameter group.
    ///
    ///
    ///                 Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                 First character must be a letter.
    ///
    ///
    ///                 Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    public var dBClusterParameterGroupName: Swift.String?
    /// The name of the DB subnet group to use for the new DB cluster.
    ///          Constraints: If supplied, must match the name of an existing DB subnet group.
    ///          Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// The database name for the restored DB cluster.
    public var databaseName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB cluster in.
    ///            The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///            Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///             Kerberos Authentication in the Amazon RDS User Guide.
    ///
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB cluster is to export to Amazon CloudWatch Logs.
    ///             The values in the list depend on the DB engine being used. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs  in the Amazon
    ///                 Aurora User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication in the Amazon Aurora User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The database engine to use for the new DB cluster.
    ///          Default: The same as source
    ///          Constraint: Must be compatible with the engine of the source
    /// This member is required.
    public var engine: Swift.String?
    /// The DB engine mode of the DB cluster, either provisioned, serverless,
    ///             parallelquery, global, or multimaster.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html">
    ///             CreateDBCluster.
    public var engineMode: Swift.String?
    /// The version of the database engine to use for the new DB cluster.
    ///          To list all of the available engine versions for aurora (for MySQL 5.6-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora --query "DBEngineVersions[].EngineVersion"
    ///
    ///          To list all of the available engine versions for aurora-mysql (for MySQL 5.7-compatible Aurora), use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-mysql --query "DBEngineVersions[].EngineVersion"
    ///
    ///          To list all of the available engine versions for aurora-postgresql, use the following command:
    ///
    ///             aws rds describe-db-engine-versions --engine aurora-postgresql --query "DBEngineVersions[].EngineVersion"
    ///
    ///
    ///             If you aren't using the default engine version, then you must specify the engine version.
    ///
    ///
    ///             Aurora MySQL
    ///
    ///          Example: 5.6.10a, 5.6.mysql_aurora.1.19.2, 5.7.12, 5.7.mysql_aurora.2.04.5
    ///
    ///
    ///             Aurora PostgreSQL
    ///
    ///          Example: 9.6.3, 10.7
    ///
    public var engineVersion: Swift.String?
    /// The Amazon Web Services KMS key identifier to use when restoring an encrypted DB cluster from a DB
    ///             snapshot or DB cluster snapshot.
    ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///           To use a CMK in a different Amazon Web Services account, specify the key ARN or alias ARN.
    ///         When you don't specify a value for the KmsKeyId parameter, then the
    ///             following occurs:
    ///
    ///
    ///                 If the DB snapshot or DB cluster snapshot in
    ///                         SnapshotIdentifier is encrypted, then the restored DB cluster
    ///                     is encrypted using the Amazon Web Services KMS CMK that was used to encrypt the DB snapshot or DB
    ///                     cluster snapshot.
    ///
    ///
    ///                 If the DB snapshot or DB cluster snapshot in
    ///                     SnapshotIdentifier isn't encrypted, then the restored DB cluster
    ///                     isn't encrypted.
    ///
    ///
    public var kmsKeyId: Swift.String?
    /// The name of the option group to use for the restored DB cluster.
    public var optionGroupName: Swift.String?
    /// The port number on which the new DB cluster accepts connections.
    ///          Constraints: This value must be 1150-65535
    ///
    ///          Default: The same port as the original DB cluster.
    public var port: Swift.Int?
    /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster.
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// The identifier for the DB snapshot or DB cluster snapshot to restore from.
    ///         You can use either the name or the Amazon Resource Name (ARN) to specify a DB
    ///             cluster snapshot. However, you can use only the ARN to specify a DB snapshot.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing Snapshot.
    ///
    ///
    /// This member is required.
    public var snapshotIdentifier: Swift.String?
    /// The tags to be assigned to the restored DB cluster.
    public var tags: [RdsClientTypes.Tag]?
    /// A list of VPC security groups that the new DB cluster will belong to.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        availabilityZones: [Swift.String]? = nil,
        backtrackWindow: Swift.Int? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineMode: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        snapshotIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.backtrackWindow = backtrackWindow
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.databaseName = databaseName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.engineMode = engineMode
        self.engineVersion = engineVersion
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.scalingConfiguration = scalingConfiguration
        self.snapshotIdentifier = snapshotIdentifier
        self.tags = tags
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterFromSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterFromSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterFromSnapshotOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterFromSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterFromSnapshotOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension RestoreDBClusterFromSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterFromSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterFromSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterFromSnapshotOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension RestoreDBClusterFromSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterFromSnapshotResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBClusterToPointInTimeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

extension RestoreDBClusterToPointInTimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterToPointInTimeInput(backtrackWindow: \(Swift.String(describing: backtrackWindow)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)), dBClusterParameterGroupName: \(Swift.String(describing: dBClusterParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engineMode: \(Swift.String(describing: engineMode)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), restoreToTime: \(Swift.String(describing: restoreToTime)), restoreType: \(Swift.String(describing: restoreType)), scalingConfiguration: \(Swift.String(describing: scalingConfiguration)), sourceDBClusterIdentifier: \(Swift.String(describing: sourceDBClusterIdentifier)), tags: \(Swift.String(describing: tags)), useLatestRestorableTime: \(Swift.String(describing: useLatestRestorableTime)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBClusterToPointInTimeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterParameterGroupName = dBClusterParameterGroupName {
            try container.encode(dBClusterParameterGroupName, forKey: ClientRuntime.Key("DBClusterParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let restoreToTime = restoreToTime {
            try container.encode(ClientRuntime.TimestampWrapper(restoreToTime, format: .dateTime), forKey: ClientRuntime.Key("restoreToTime"))
        }
        if let restoreType = restoreType {
            try container.encode(restoreType, forKey: ClientRuntime.Key("RestoreType"))
        }
        if let scalingConfiguration = scalingConfiguration {
            try container.encode(scalingConfiguration, forKey: ClientRuntime.Key("ScalingConfiguration"))
        }
        if let sourceDBClusterIdentifier = sourceDBClusterIdentifier {
            try container.encode(sourceDBClusterIdentifier, forKey: ClientRuntime.Key("SourceDBClusterIdentifier"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: ClientRuntime.Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBClusterToPointInTime", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBClusterToPointInTimeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBClusterToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

public struct RestoreDBClusterToPointInTimeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBClusterToPointInTimeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDBClusterToPointInTimeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDBClusterToPointInTimeInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBClusterToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBClusterToPointInTimeOutputError>
}

///
public struct RestoreDBClusterToPointInTimeInput: Swift.Equatable {
    /// The target backtrack window, in seconds. To disable backtracking, set this value to
    ///             0.
    ///
    ///             Currently, Backtrack is only supported for Aurora MySQL DB clusters.
    ///
    ///         Default: 0
    ///         Constraints:
    ///
    ///
    ///                If specified, this value must be set to a number from 0 to 259,200 (72 hours).
    ///
    ///
    public var backtrackWindow: Swift.Int?
    /// A value that indicates whether to copy all tags from the restored DB cluster to snapshots of the restored DB cluster. The default is not to copy them.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The name of the new DB cluster to be created.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?
    /// The name of the DB cluster parameter group to associate with this DB cluster.
    ///             If this argument is omitted, the default DB cluster parameter group for the specified engine is used.
    ///         Constraints:
    ///
    ///
    ///                 If supplied, must match the name of an existing DB cluster parameter group.
    ///
    ///
    ///                 Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                 First character must be a letter.
    ///
    ///
    ///                 Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    public var dBClusterParameterGroupName: Swift.String?
    /// The DB subnet group name to use for the new DB cluster.
    ///          Constraints: If supplied, must match the name of an existing DBSubnetGroup.
    ///          Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB cluster has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled.
    ///
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB cluster in.
    ///           The domain must be created prior to this operation.
    ///
    ///
    ///         For Amazon Aurora DB clusters, Amazon RDS can use Kerberos Authentication to authenticate users that connect to the DB cluster.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/kerberos-authentication.html">Kerberos Authentication
    ///         in the Amazon Aurora User Guide.
    ///
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB cluster is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon Aurora User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/UsingWithRDS.IAMDBAuth.html">
    ///                 IAM Database Authentication in the Amazon Aurora User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The engine mode of the new cluster. Specify provisioned or serverless,
    ///       depending on the type of the cluster you are creating. You can create an Aurora Serverless clone
    ///       from a provisioned cluster, or a provisioned clone from an Aurora Serverless cluster. To create a clone
    ///       that is an Aurora Serverless cluster, the original cluster must be an Aurora Serverless cluster or
    ///       an encrypted provisioned cluster.
    public var engineMode: Swift.String?
    /// The Amazon Web Services KMS key identifier to use when restoring an encrypted DB cluster from an encrypted DB cluster.
    ///          The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///           To use a CMK in a different Amazon Web Services account, specify the key ARN or alias ARN.
    ///          You can restore to a new DB cluster and encrypt the new DB cluster with a Amazon Web Services KMS CMK that is different than the
    ///       Amazon Web Services KMS key used to encrypt the source DB cluster. The new DB cluster is encrypted with the Amazon Web Services KMS CMK
    ///       identified by the KmsKeyId parameter.
    ///          If you don't specify a value for the KmsKeyId parameter, then the following occurs:
    ///
    ///
    ///                If the DB cluster is encrypted, then the restored DB cluster is encrypted using the Amazon Web Services KMS CMK that was used to encrypt the source DB cluster.
    ///
    ///
    ///                If the DB cluster isn't encrypted, then the restored DB cluster isn't encrypted.
    ///
    ///
    ///
    ///          If DBClusterIdentifier refers to a DB cluster that isn't encrypted, then the restore request
    ///       is rejected.
    public var kmsKeyId: Swift.String?
    /// The name of the option group for the new DB cluster.
    public var optionGroupName: Swift.String?
    /// The port number on which the new DB cluster accepts connections.
    ///          Constraints: A value from 1150-65535.
    ///
    ///          Default: The default port for the engine.
    public var port: Swift.Int?
    /// The date and time to restore the DB cluster to.
    ///          Valid Values: Value must be a time in Universal Coordinated Time (UTC) format
    ///          Constraints:
    ///
    ///
    ///                Must be before the latest restorable time for the DB instance
    ///
    ///
    ///                Must be specified if UseLatestRestorableTime parameter isn't provided
    ///
    ///
    ///                Can't be specified if the UseLatestRestorableTime parameter is enabled
    ///
    ///
    ///                Can't be specified if the RestoreType parameter is copy-on-write
    ///
    ///
    ///
    ///          Example: 2015-03-07T23:45:00Z
    ///
    public var restoreToTime: ClientRuntime.Date?
    /// The type of restore to be performed. You can specify one of the following values:
    ///
    ///
    ///
    ///                   full-copy - The new DB cluster is restored as a full copy of the
    ///                 source DB cluster.
    ///
    ///
    ///
    ///                   copy-on-write - The new DB cluster is restored as a clone of the
    ///                 source DB cluster.
    ///
    ///
    ///         Constraints: You can't specify copy-on-write if the engine version of the source DB cluster is earlier than 1.11.
    ///         If you don't specify a RestoreType value, then the new DB cluster is
    ///             restored as a full copy of the source DB cluster.
    public var restoreType: Swift.String?
    /// For DB clusters in serverless DB engine mode, the scaling properties of the DB cluster.
    public var scalingConfiguration: RdsClientTypes.ScalingConfiguration?
    /// The identifier of the source DB cluster from which to restore.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DBCluster.
    ///
    ///
    /// This member is required.
    public var sourceDBClusterIdentifier: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether to restore the DB cluster to the latest
    ///             restorable backup time. By default, the DB cluster isn't restored to the latest
    ///             restorable backup time.
    ///
    ///          Constraints: Can't be specified if RestoreToTime parameter is provided.
    public var useLatestRestorableTime: Swift.Bool
    /// A list of VPC security groups that the new DB cluster belongs to.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        backtrackWindow: Swift.Int? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBClusterIdentifier: Swift.String? = nil,
        dBClusterParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engineMode: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        restoreToTime: ClientRuntime.Date? = nil,
        restoreType: Swift.String? = nil,
        scalingConfiguration: RdsClientTypes.ScalingConfiguration? = nil,
        sourceDBClusterIdentifier: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        useLatestRestorableTime: Swift.Bool = false,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.backtrackWindow = backtrackWindow
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBClusterIdentifier = dBClusterIdentifier
        self.dBClusterParameterGroupName = dBClusterParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engineMode = engineMode
        self.kmsKeyId = kmsKeyId
        self.optionGroupName = optionGroupName
        self.port = port
        self.restoreToTime = restoreToTime
        self.restoreType = restoreType
        self.scalingConfiguration = scalingConfiguration
        self.sourceDBClusterIdentifier = sourceDBClusterIdentifier
        self.tags = tags
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBClusterToPointInTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBClusterToPointInTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterAlreadyExistsFault" : self = .dBClusterAlreadyExistsFault(try DBClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterParameterGroupNotFound" : self = .dBClusterParameterGroupNotFoundFault(try DBClusterParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterQuotaExceededFault" : self = .dBClusterQuotaExceededFault(try DBClusterQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBClusterCapacityFault" : self = .insufficientDBClusterCapacityFault(try InsufficientDBClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientStorageClusterCapacity" : self = .insufficientStorageClusterCapacityFault(try InsufficientStorageClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterSnapshotStateFault" : self = .invalidDBClusterSnapshotStateFault(try InvalidDBClusterSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBClusterToPointInTimeOutputError: Swift.Error, Swift.Equatable {
    case dBClusterAlreadyExistsFault(DBClusterAlreadyExistsFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBClusterParameterGroupNotFoundFault(DBClusterParameterGroupNotFoundFault)
    case dBClusterQuotaExceededFault(DBClusterQuotaExceededFault)
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case insufficientDBClusterCapacityFault(InsufficientDBClusterCapacityFault)
    case insufficientStorageClusterCapacityFault(InsufficientStorageClusterCapacityFault)
    case invalidDBClusterSnapshotStateFault(InvalidDBClusterSnapshotStateFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBClusterToPointInTimeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBClusterToPointInTimeOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension RestoreDBClusterToPointInTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBClusterToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct RestoreDBClusterToPointInTimeOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct RestoreDBClusterToPointInTimeOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension RestoreDBClusterToPointInTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBClusterToPointInTimeResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct RestoreDBInstanceFromDBSnapshotInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromDBSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

extension RestoreDBInstanceFromDBSnapshotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBInstanceFromDBSnapshotInput(autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBName: \(Swift.String(describing: dBName)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableCustomerOwnedIp: \(Swift.String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), iops: \(Swift.String(describing: iops)), licenseModel: \(Swift.String(describing: licenseModel)), multiAZ: \(Swift.String(describing: multiAZ)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), processorFeatures: \(Swift.String(describing: processorFeatures)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), storageType: \(Swift.String(describing: storageType)), tags: \(Swift.String(describing: tags)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), tdeCredentialPassword: \(Swift.String(describing: tdeCredentialPassword)), useDefaultProcessorFeatures: \(Swift.String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBInstanceFromDBSnapshotInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceFromDBSnapshot", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBInstanceFromDBSnapshotInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromDBSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

public struct RestoreDBInstanceFromDBSnapshotInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromDBSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceFromDBSnapshotInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

public struct RestoreDBInstanceFromDBSnapshotInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromDBSnapshotInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDBInstanceFromDBSnapshotInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDBInstanceFromDBSnapshotInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromDBSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromDBSnapshotOutputError>
}

///
public struct RestoreDBInstanceFromDBSnapshotInput: Swift.Equatable {
    /// A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the DB instance will be created.
    ///          Default: A random, system-chosen Availability Zone.
    ///          Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    ///          Example: us-east-1a
    ///
    public var availabilityZone: Swift.String?
    /// A value that indicates whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The compute and memory capacity of the Amazon RDS DB instance, for example, db.m4.large.
    ///           Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class in the Amazon RDS User Guide.
    ///
    ///          Default: The same DBInstanceClass as the original DB instance.
    public var dBInstanceClass: Swift.String?
    /// Name of the DB instance to create from the DB snapshot. This parameter isn't case-sensitive.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 numbers, letters, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    ///          Example: my-snapshot-id
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The database name for the restored DB instance.
    ///
    ///             This parameter doesn't apply to the MySQL, PostgreSQL, or MariaDB engines.
    ///
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance.
    ///         If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup
    ///             for the specified DB engine is used.
    ///         Constraints:
    ///
    ///
    ///                 If supplied, must match the name of an existing DBParameterGroup.
    ///
    ///
    ///                 Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                 First character must be a letter.
    ///
    ///
    ///                 Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    public var dBParameterGroupName: Swift.String?
    /// The identifier for the DB snapshot to restore from.
    ///          Constraints:
    ///
    ///
    ///               Must match the identifier of an existing DBSnapshot.
    ///
    ///
    ///               If you are restoring from a shared manual DB snapshot, the DBSnapshotIdentifier
    ///               must be the ARN of the shared DB snapshot.
    ///
    ///
    /// This member is required.
    public var dBSnapshotIdentifier: Swift.String?
    /// The DB subnet group name to use for the new instance.
    ///          Constraints: If supplied, must match the name of an existing DBSubnetGroup.
    ///          Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance.
    ///
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB instance in.
    ///            The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///            Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///            Kerberos Authentication in the Amazon RDS User Guide.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.
    ///         A CoIP provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.
    ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on Amazon Web Services Outposts
    ///             in the Amazon RDS User Guide.
    ///         For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses
    ///             in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///          For more information about IAM database authentication, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///               IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The database engine to use for the new instance.
    ///          Default: The same as source
    ///          Constraint: Must be compatible with the engine of the source. For example, you can restore a MariaDB 10.1 DB instance from a MySQL 5.6 snapshot.
    ///
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    public var engine: Swift.String?
    /// Specifies the amount of provisioned IOPS for the DB instance, expressed in I/O operations per second.
    ///           If this parameter isn't specified, the IOPS value is taken from the backup.
    ///           If this parameter is set to 0, the new instance is converted to a non-PIOPS instance.
    ///           The conversion takes additional time, though your DB instance is available for connections before the conversion starts.
    ///
    ///          The provisioned IOPS value must follow the requirements for your database engine.
    ///           For more information, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS">Amazon RDS Provisioned IOPS Storage to Improve Performance
    ///           in the Amazon RDS User Guide.
    ///
    ///          Constraints: Must be an integer greater than 1000.
    public var iops: Swift.Int?
    /// License model information for the restored DB instance.
    ///          Default: Same as source.
    ///
    ///             Valid values:  license-included | bring-your-own-license | general-public-license
    ///
    public var licenseModel: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment.
    ///          Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    public var multiAZ: Swift.Bool?
    /// The name of the option group to be used for the restored DB instance.
    ///
    ///          Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance
    public var optionGroupName: Swift.String?
    /// The port number on which the database accepts connections.
    ///          Default: The same port as the original DB instance
    ///          Constraints: Value must be 1150-65535
    ///
    public var port: Swift.Int?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible.
    ///          When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
    ///          When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
    ///          For more information, see CreateDBInstance.
    public var publiclyAccessible: Swift.Bool?
    /// Specifies the storage type to be associated with the DB instance.
    ///
    ///             Valid values: standard | gp2 | io1
    ///
    ///
    ///             If you specify io1, you must also include a value for the
    ///             Iops parameter.
    ///
    ///
    ///             Default: io1 if the Iops parameter
    ///             is specified, otherwise gp2
    ///
    public var storageType: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// The ARN from the key store with which to associate the instance for TDE encryption.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device.
    public var tdeCredentialPassword: Swift.String?
    /// A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.
    public var useDefaultProcessorFeatures: Swift.Bool?
    ///
    ///             A list of EC2 VPC security groups to associate with this DB instance.
    ///
    ///
    ///             Default: The default EC2 VPC security group for the DB subnet group's VPC.
    ///
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.iops = iops
        self.licenseModel = licenseModel
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.port = port
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.storageType = storageType
        self.tags = tags
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBInstanceFromDBSnapshotOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceFromDBSnapshotOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSnapshotState" : self = .invalidDBSnapshotStateFault(try InvalidDBSnapshotStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceFromDBSnapshotOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBSnapshotStateFault(InvalidDBSnapshotStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceFromDBSnapshotOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBInstanceFromDBSnapshotOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension RestoreDBInstanceFromDBSnapshotOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBInstanceFromDBSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceFromDBSnapshotOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceFromDBSnapshotOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension RestoreDBInstanceFromDBSnapshotOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBInstanceFromDBSnapshotResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct RestoreDBInstanceFromS3InputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromS3InputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceFromS3Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceFromS3Input>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromS3OutputError>
}

extension RestoreDBInstanceFromS3Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBInstanceFromS3Input(allocatedStorage: \(Swift.String(describing: allocatedStorage)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBName: \(Swift.String(describing: dBName)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBSecurityGroups: \(Swift.String(describing: dBSecurityGroups)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), enablePerformanceInsights: \(Swift.String(describing: enablePerformanceInsights)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), licenseModel: \(Swift.String(describing: licenseModel)), masterUserPassword: \(Swift.String(describing: masterUserPassword)), masterUsername: \(Swift.String(describing: masterUsername)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), monitoringInterval: \(Swift.String(describing: monitoringInterval)), monitoringRoleArn: \(Swift.String(describing: monitoringRoleArn)), multiAZ: \(Swift.String(describing: multiAZ)), optionGroupName: \(Swift.String(describing: optionGroupName)), performanceInsightsKMSKeyId: \(Swift.String(describing: performanceInsightsKMSKeyId)), performanceInsightsRetentionPeriod: \(Swift.String(describing: performanceInsightsRetentionPeriod)), port: \(Swift.String(describing: port)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), processorFeatures: \(Swift.String(describing: processorFeatures)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3IngestionRoleArn: \(Swift.String(describing: s3IngestionRoleArn)), s3Prefix: \(Swift.String(describing: s3Prefix)), sourceEngine: \(Swift.String(describing: sourceEngine)), sourceEngineVersion: \(Swift.String(describing: sourceEngineVersion)), storageEncrypted: \(Swift.String(describing: storageEncrypted)), storageType: \(Swift.String(describing: storageType)), tags: \(Swift.String(describing: tags)), useDefaultProcessorFeatures: \(Swift.String(describing: useDefaultProcessorFeatures)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBInstanceFromS3Input: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSecurityGroups = dBSecurityGroups {
            var dBSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBSecurityGroups"))
            for (index0, string0) in dBSecurityGroups.enumerated() {
                try dBSecurityGroupsContainer.encode(string0, forKey: ClientRuntime.Key("DBSecurityGroupName.\(index0.advanced(by: 1))"))
            }
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let enablePerformanceInsights = enablePerformanceInsights {
            try container.encode(enablePerformanceInsights, forKey: ClientRuntime.Key("EnablePerformanceInsights"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let masterUserPassword = masterUserPassword {
            try container.encode(masterUserPassword, forKey: ClientRuntime.Key("MasterUserPassword"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3IngestionRoleArn = s3IngestionRoleArn {
            try container.encode(s3IngestionRoleArn, forKey: ClientRuntime.Key("S3IngestionRoleArn"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let sourceEngine = sourceEngine {
            try container.encode(sourceEngine, forKey: ClientRuntime.Key("SourceEngine"))
        }
        if let sourceEngineVersion = sourceEngineVersion {
            try container.encode(sourceEngineVersion, forKey: ClientRuntime.Key("SourceEngineVersion"))
        }
        if let storageEncrypted = storageEncrypted {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceFromS3", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBInstanceFromS3InputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromS3InputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceFromS3Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceFromS3Input>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromS3OutputError>
}

public struct RestoreDBInstanceFromS3InputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromS3InputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceFromS3Input>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceFromS3Input>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromS3OutputError>
}

public struct RestoreDBInstanceFromS3InputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceFromS3InputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDBInstanceFromS3Input,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDBInstanceFromS3Input
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceFromS3OutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceFromS3OutputError>
}

public struct RestoreDBInstanceFromS3Input: Swift.Equatable {
    /// The amount of storage (in gigabytes) to allocate initially for the DB instance.
    ///             Follow the allocation rules specified in CreateDBInstance.
    ///
    ///
    ///
    ///             Be sure to allocate enough memory for your new DB instance
    ///                 so that the restore operation can succeed.
    ///                 You can also allocate additional memory for future growth.
    ///
    ///
    public var allocatedStorage: Swift.Int?
    /// A value that indicates whether minor engine upgrades are applied automatically
    ///             to the DB instance during the maintenance window. By default, minor engine upgrades
    ///             are not applied automatically.
    ///
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone that the DB instance is created in.
    ///             For information about Amazon Web Services Regions and Availability Zones, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html">Regions and Availability Zones in the Amazon RDS User Guide.
    ///
    ///         Default: A random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region.
    ///
    ///
    ///             Example: us-east-1d
    ///
    ///         Constraint: The AvailabilityZone parameter can't be specified if the DB instance is a Multi-AZ deployment.
    ///             The specified Availability Zone must be in the same Amazon Web Services Region as the current endpoint.
    ///
    public var availabilityZone: Swift.String?
    /// The number of days for which automated backups are retained.
    ///             Setting this parameter to a positive number enables backups.
    ///             For more information, see CreateDBInstance.
    ///
    public var backupRetentionPeriod: Swift.Int?
    /// A value that indicates whether to copy all tags from the DB instance to snapshots of the DB instance. By default, tags are not copied.
    ///
    public var copyTagsToSnapshot: Swift.Bool?
    /// The compute and memory capacity of the DB instance,
    ///             for example, db.m4.large.
    ///             Not all DB instance classes are available in all Amazon Web Services Regions,
    ///             or for all database engines.
    ///             For the full list of DB instance classes,
    ///             and availability for your engine, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class in the Amazon RDS User Guide.
    ///
    ///         Importing from Amazon S3 isn't supported on the db.t2.micro DB instance class.
    ///
    /// This member is required.
    public var dBInstanceClass: Swift.String?
    /// The DB instance identifier. This parameter is stored as a lowercase string.
    ///
    ///
    ///         Constraints:
    ///
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    ///
    ///         Example: mydbinstance
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    /// The name of the database to create when the DB instance is created.
    ///             Follow the naming rules specified in CreateDBInstance.
    ///
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance.
    ///         If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup
    ///             for the specified DB engine is used.
    public var dBParameterGroupName: Swift.String?
    /// A list of DB security groups to associate with this DB instance.
    ///         Default: The default DB security group for the database engine.
    public var dBSecurityGroups: [Swift.String]?
    /// A DB subnet group to associate with this DB instance.
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance.
    ///
    public var deletionProtection: Swift.Bool?
    /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///             Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///          For more information about IAM database authentication, see
    ///          <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///              IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// A value that indicates whether to enable Performance Insights for the DB instance.
    ///
    ///         For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PerfInsights.html">Using Amazon Performance Insights in the Amazon Relational Database Service
    ///                     User Guide.
    ///
    public var enablePerformanceInsights: Swift.Bool?
    /// The name of the database engine to be used for this instance.
    ///
    ///
    ///         Valid Values:  mysql
    ///
    /// This member is required.
    public var engine: Swift.String?
    /// The version number of the database engine to use.
    ///             Choose the latest minor version of your database engine.
    ///             For information about engine versions, see CreateDBInstance, or call DescribeDBEngineVersions.
    ///
    public var engineVersion: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second)
    ///             to allocate initially for the DB instance.
    ///             For information about valid Iops values, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_Storage.html#USER_PIOPS">Amazon RDS Provisioned IOPS Storage to Improve Performance
    ///             in the Amazon RDS User Guide.
    ///
    public var iops: Swift.Int?
    /// The Amazon Web Services KMS key identifier for an encrypted DB instance.
    ///
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///             To use a CMK in a different Amazon Web Services account, specify the key ARN or alias ARN.
    ///         If the StorageEncrypted parameter is enabled,
    ///             and you do not specify a value for the KmsKeyId parameter,
    ///             then Amazon RDS will use your default CMK.
    ///             There is a default CMK for your Amazon Web Services account.
    ///             Your Amazon Web Services account has a different default CMK for each Amazon Web Services Region.
    ///
    public var kmsKeyId: Swift.String?
    /// The license model for this DB instance.
    ///             Use general-public-license.
    ///
    public var licenseModel: Swift.String?
    /// The password for the master user.
    ///             The password can include any printable ASCII character except "/", """, or "@".
    ///
    ///
    ///         Constraints: Must contain from 8 to 41 characters.
    public var masterUserPassword: Swift.String?
    /// The name for the master user.
    ///
    ///
    ///         Constraints:
    ///
    ///
    ///
    ///                Must be 1 to 16 letters or numbers.
    ///
    ///
    ///                First character must be a letter.
    ///
    ///
    ///                Can't be a reserved word for the chosen database engine.
    ///
    ///
    public var masterUsername: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
    ///         For more information about this setting, including limitations that apply to it, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///                 Managing capacity automatically with Amazon RDS storage autoscaling
    ///             in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// The interval, in seconds,
    ///             between points when Enhanced Monitoring metrics are collected for the DB instance.
    ///             To disable collecting Enhanced Monitoring metrics, specify 0.
    ///
    ///
    ///         If MonitoringRoleArn is specified,
    ///             then you must also set MonitoringInterval to a value other than 0.
    ///
    ///
    ///         Valid Values: 0, 1, 5, 10, 15, 30, 60
    ///
    ///         Default: 0
    ///
    public var monitoringInterval: Swift.Int?
    /// The ARN for the IAM role that permits RDS
    ///             to send enhanced monitoring metrics to Amazon CloudWatch Logs.
    ///             For example, arn:aws:iam:123456789012:role/emaccess.
    ///             For information on creating a monitoring role, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Monitoring.OS.html#USER_Monitoring.OS.Enabling">Setting Up and Enabling Enhanced Monitoring
    ///             in the Amazon RDS User Guide.
    ///
    ///         If MonitoringInterval is set to a value other than 0,
    ///             then you must supply a MonitoringRoleArn value.
    ///
    public var monitoringRoleArn: Swift.String?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment.
    ///             If the DB instance is a Multi-AZ deployment, you can't set the AvailabilityZone parameter.
    ///
    public var multiAZ: Swift.Bool?
    /// The name of the option group to associate with this DB instance.
    ///             If this argument is omitted, the default option group for the specified engine is used.
    ///
    public var optionGroupName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of Performance Insights data.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///         If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon RDS
    ///             uses your default CMK. There is a default CMK for your Amazon Web Services account.
    ///             Your Amazon Web Services account has a different default CMK for each Amazon Web Services Region.
    public var performanceInsightsKMSKeyId: Swift.String?
    /// The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731 (2 years).
    public var performanceInsightsRetentionPeriod: Swift.Int?
    /// The port number on which the database accepts connections.
    ///
    ///         Type: Integer
    ///
    ///         Valid Values: 1150-65535
    ///
    ///         Default: 3306
    ///
    public var port: Swift.Int?
    /// The time range each day
    ///             during which automated backups are created
    ///             if automated backups are enabled.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow">Backup window in the Amazon RDS User Guide.
    ///
    ///
    ///         Constraints:
    ///
    ///
    ///                Must be in the format hh24:mi-hh24:mi.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred maintenance window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredBackupWindow: Swift.String?
    /// The time range each week during which system maintenance can occur,
    ///             in Universal Coordinated Time (UTC).
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance">Amazon RDS Maintenance Window in the Amazon RDS User Guide.
    ///
    ///
    ///         Constraints:
    ///
    ///
    ///                Must be in the format ddd:hh24:mi-ddd:hh24:mi.
    ///
    ///
    ///                Valid Days: Mon, Tue, Wed, Thu, Fri, Sat, Sun.
    ///
    ///
    ///                Must be in Universal Coordinated Time (UTC).
    ///
    ///
    ///                Must not conflict with the preferred backup window.
    ///
    ///
    ///                Must be at least 30 minutes.
    ///
    ///
    public var preferredMaintenanceWindow: Swift.String?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible.
    ///         When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///             and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///             and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
    ///         When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
    ///         For more information, see CreateDBInstance.
    public var publiclyAccessible: Swift.Bool?
    /// The name of your Amazon S3 bucket
    ///             that contains your database backup file.
    ///
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// An Amazon Web Services Identity and Access Management (IAM) role to allow Amazon RDS to access your Amazon S3 bucket.
    ///
    /// This member is required.
    public var s3IngestionRoleArn: Swift.String?
    /// The prefix of your Amazon S3 bucket.
    ///
    public var s3Prefix: Swift.String?
    /// The name of the engine of your source database.
    ///
    ///
    ///         Valid Values:  mysql
    ///
    /// This member is required.
    public var sourceEngine: Swift.String?
    /// The version of the database that the backup files were created from.
    ///         MySQL versions 5.6 and 5.7 are supported.
    ///
    ///         Example: 5.6.40
    ///
    /// This member is required.
    public var sourceEngineVersion: Swift.String?
    /// A value that indicates whether the new DB instance is encrypted or not.
    ///
    public var storageEncrypted: Swift.Bool?
    /// Specifies the storage type to be associated with the DB instance.
    ///
    ///         Valid values: standard | gp2 | io1
    ///
    ///         If you specify io1,
    ///             you must also include a value for the Iops parameter.
    ///
    ///         Default: io1
    ///             if the Iops parameter is specified;
    ///             otherwise gp2
    ///
    public var storageType: Swift.String?
    /// A list of tags to associate with this DB instance.
    ///             For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// A value that indicates whether the DB instance class of the DB instance uses its default
    ///             processor features.
    public var useDefaultProcessorFeatures: Swift.Bool?
    /// A list of VPC security groups to associate with this DB instance.
    ///
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        allocatedStorage: Swift.Int? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        backupRetentionPeriod: Swift.Int? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBInstanceIdentifier: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSecurityGroups: [Swift.String]? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        enablePerformanceInsights: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseModel: Swift.String? = nil,
        masterUserPassword: Swift.String? = nil,
        masterUsername: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        monitoringInterval: Swift.Int? = nil,
        monitoringRoleArn: Swift.String? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        performanceInsightsKMSKeyId: Swift.String? = nil,
        performanceInsightsRetentionPeriod: Swift.Int? = nil,
        port: Swift.Int? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        s3BucketName: Swift.String? = nil,
        s3IngestionRoleArn: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        sourceEngine: Swift.String? = nil,
        sourceEngineVersion: Swift.String? = nil,
        storageEncrypted: Swift.Bool? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.allocatedStorage = allocatedStorage
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.backupRetentionPeriod = backupRetentionPeriod
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSecurityGroups = dBSecurityGroups
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.enablePerformanceInsights = enablePerformanceInsights
        self.engine = engine
        self.engineVersion = engineVersion
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.licenseModel = licenseModel
        self.masterUserPassword = masterUserPassword
        self.masterUsername = masterUsername
        self.maxAllocatedStorage = maxAllocatedStorage
        self.monitoringInterval = monitoringInterval
        self.monitoringRoleArn = monitoringRoleArn
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.performanceInsightsKMSKeyId = performanceInsightsKMSKeyId
        self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
        self.port = port
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.s3BucketName = s3BucketName
        self.s3IngestionRoleArn = s3IngestionRoleArn
        self.s3Prefix = s3Prefix
        self.sourceEngine = sourceEngine
        self.sourceEngineVersion = sourceEngineVersion
        self.storageEncrypted = storageEncrypted
        self.storageType = storageType
        self.tags = tags
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBInstanceFromS3OutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceFromS3OutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceFromS3OutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceFromS3OutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBInstanceFromS3OutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension RestoreDBInstanceFromS3OutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBInstanceFromS3OutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceFromS3OutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceFromS3OutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension RestoreDBInstanceFromS3OutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBInstanceFromS3Result"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct RestoreDBInstanceToPointInTimeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceToPointInTimeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

extension RestoreDBInstanceToPointInTimeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBInstanceToPointInTimeInput(autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), availabilityZone: \(Swift.String(describing: availabilityZone)), copyTagsToSnapshot: \(Swift.String(describing: copyTagsToSnapshot)), dBInstanceClass: \(Swift.String(describing: dBInstanceClass)), dBName: \(Swift.String(describing: dBName)), dBParameterGroupName: \(Swift.String(describing: dBParameterGroupName)), dBSubnetGroupName: \(Swift.String(describing: dBSubnetGroupName)), deletionProtection: \(Swift.String(describing: deletionProtection)), domain: \(Swift.String(describing: domain)), domainIAMRoleName: \(Swift.String(describing: domainIAMRoleName)), enableCloudwatchLogsExports: \(Swift.String(describing: enableCloudwatchLogsExports)), enableCustomerOwnedIp: \(Swift.String(describing: enableCustomerOwnedIp)), enableIAMDatabaseAuthentication: \(Swift.String(describing: enableIAMDatabaseAuthentication)), engine: \(Swift.String(describing: engine)), iops: \(Swift.String(describing: iops)), licenseModel: \(Swift.String(describing: licenseModel)), maxAllocatedStorage: \(Swift.String(describing: maxAllocatedStorage)), multiAZ: \(Swift.String(describing: multiAZ)), optionGroupName: \(Swift.String(describing: optionGroupName)), port: \(Swift.String(describing: port)), processorFeatures: \(Swift.String(describing: processorFeatures)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), restoreTime: \(Swift.String(describing: restoreTime)), sourceDBInstanceAutomatedBackupsArn: \(Swift.String(describing: sourceDBInstanceAutomatedBackupsArn)), sourceDBInstanceIdentifier: \(Swift.String(describing: sourceDBInstanceIdentifier)), sourceDbiResourceId: \(Swift.String(describing: sourceDbiResourceId)), storageType: \(Swift.String(describing: storageType)), tags: \(Swift.String(describing: tags)), targetDBInstanceIdentifier: \(Swift.String(describing: targetDBInstanceIdentifier)), tdeCredentialArn: \(Swift.String(describing: tdeCredentialArn)), tdeCredentialPassword: \(Swift.String(describing: tdeCredentialPassword)), useDefaultProcessorFeatures: \(Swift.String(describing: useDefaultProcessorFeatures)), useLatestRestorableTime: \(Swift.String(describing: useLatestRestorableTime)), vpcSecurityGroupIds: \(Swift.String(describing: vpcSecurityGroupIds)))"}
}

extension RestoreDBInstanceToPointInTimeInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dBParameterGroupName = dBParameterGroupName {
            try container.encode(dBParameterGroupName, forKey: ClientRuntime.Key("DBParameterGroupName"))
        }
        if let dBSubnetGroupName = dBSubnetGroupName {
            try container.encode(dBSubnetGroupName, forKey: ClientRuntime.Key("DBSubnetGroupName"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domain = domain {
            try container.encode(domain, forKey: ClientRuntime.Key("Domain"))
        }
        if let domainIAMRoleName = domainIAMRoleName {
            try container.encode(domainIAMRoleName, forKey: ClientRuntime.Key("DomainIAMRoleName"))
        }
        if let enableCloudwatchLogsExports = enableCloudwatchLogsExports {
            var enableCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnableCloudwatchLogsExports"))
            for (index0, string0) in enableCloudwatchLogsExports.enumerated() {
                try enableCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let enableCustomerOwnedIp = enableCustomerOwnedIp {
            try container.encode(enableCustomerOwnedIp, forKey: ClientRuntime.Key("EnableCustomerOwnedIp"))
        }
        if let enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication {
            try container.encode(enableIAMDatabaseAuthentication, forKey: ClientRuntime.Key("EnableIAMDatabaseAuthentication"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let maxAllocatedStorage = maxAllocatedStorage {
            try container.encode(maxAllocatedStorage, forKey: ClientRuntime.Key("MaxAllocatedStorage"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let optionGroupName = optionGroupName {
            try container.encode(optionGroupName, forKey: ClientRuntime.Key("OptionGroupName"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProcessorFeatures"))
            for (index0, processorfeature0) in processorFeatures.enumerated() {
                try processorFeaturesContainer.encode(processorfeature0, forKey: ClientRuntime.Key("ProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let restoreTime = restoreTime {
            try container.encode(ClientRuntime.TimestampWrapper(restoreTime, format: .dateTime), forKey: ClientRuntime.Key("restoreTime"))
        }
        if let sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn {
            try container.encode(sourceDBInstanceAutomatedBackupsArn, forKey: ClientRuntime.Key("SourceDBInstanceAutomatedBackupsArn"))
        }
        if let sourceDBInstanceIdentifier = sourceDBInstanceIdentifier {
            try container.encode(sourceDBInstanceIdentifier, forKey: ClientRuntime.Key("SourceDBInstanceIdentifier"))
        }
        if let sourceDbiResourceId = sourceDbiResourceId {
            try container.encode(sourceDbiResourceId, forKey: ClientRuntime.Key("SourceDbiResourceId"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let targetDBInstanceIdentifier = targetDBInstanceIdentifier {
            try container.encode(targetDBInstanceIdentifier, forKey: ClientRuntime.Key("TargetDBInstanceIdentifier"))
        }
        if let tdeCredentialArn = tdeCredentialArn {
            try container.encode(tdeCredentialArn, forKey: ClientRuntime.Key("TdeCredentialArn"))
        }
        if let tdeCredentialPassword = tdeCredentialPassword {
            try container.encode(tdeCredentialPassword, forKey: ClientRuntime.Key("TdeCredentialPassword"))
        }
        if let useDefaultProcessorFeatures = useDefaultProcessorFeatures {
            try container.encode(useDefaultProcessorFeatures, forKey: ClientRuntime.Key("UseDefaultProcessorFeatures"))
        }
        if useLatestRestorableTime != false {
            try container.encode(useLatestRestorableTime, forKey: ClientRuntime.Key("UseLatestRestorableTime"))
        }
        if let vpcSecurityGroupIds = vpcSecurityGroupIds {
            var vpcSecurityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroupIds"))
            for (index0, string0) in vpcSecurityGroupIds.enumerated() {
                try vpcSecurityGroupIdsContainer.encode(string0, forKey: ClientRuntime.Key("VpcSecurityGroupId.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RestoreDBInstanceToPointInTime", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RestoreDBInstanceToPointInTimeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceToPointInTimeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

public struct RestoreDBInstanceToPointInTimeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceToPointInTimeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreDBInstanceToPointInTimeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreDBInstanceToPointInTimeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

public struct RestoreDBInstanceToPointInTimeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreDBInstanceToPointInTimeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RestoreDBInstanceToPointInTimeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RestoreDBInstanceToPointInTimeInput
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreDBInstanceToPointInTimeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreDBInstanceToPointInTimeOutputError>
}

///
public struct RestoreDBInstanceToPointInTimeInput: Swift.Equatable {
    /// A value that indicates whether minor version upgrades are applied automatically to the DB instance during the maintenance window.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The Availability Zone (AZ) where the DB instance will be created.
    ///          Default: A random, system-chosen Availability Zone.
    ///          Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    ///          Example: us-east-1a
    ///
    public var availabilityZone: Swift.String?
    /// A value that indicates whether to copy all tags from the restored DB instance to snapshots of the DB instance. By default, tags are not copied.
    public var copyTagsToSnapshot: Swift.Bool?
    /// The compute and memory capacity of the Amazon RDS DB instance, for example, db.m4.large.
    ///           Not all DB instance classes are available in all Amazon Web Services Regions, or for all database engines.
    ///           For the full list of DB instance classes,
    ///           and availability for your engine, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html">DB Instance Class in the Amazon RDS User Guide.
    ///
    ///          Default: The same DBInstanceClass as the original DB instance.
    public var dBInstanceClass: Swift.String?
    /// The database name for the restored DB instance.
    ///
    ///             This parameter isn't used for the MySQL or MariaDB engines.
    ///
    public var dBName: Swift.String?
    /// The name of the DB parameter group to associate with this DB instance.
    ///         If you do not specify a value for DBParameterGroupName, then the default DBParameterGroup
    ///                 for the specified DB engine is used.
    ///         Constraints:
    ///
    ///
    ///                 If supplied, must match the name of an existing DBParameterGroup.
    ///
    ///
    ///                 Must be 1 to 255 letters, numbers, or hyphens.
    ///
    ///
    ///                 First character must be a letter.
    ///
    ///
    ///                 Can't end with a hyphen or contain two consecutive hyphens.
    ///
    ///
    public var dBParameterGroupName: Swift.String?
    /// The DB subnet group name to use for the new instance.
    ///          Constraints: If supplied, must match the name of an existing DBSubnetGroup.
    ///          Example: mySubnetgroup
    ///
    public var dBSubnetGroupName: Swift.String?
    /// A value that indicates whether the DB instance has deletion protection enabled.
    ///             The database can't be deleted when deletion protection is enabled. By default,
    ///             deletion protection is disabled. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteInstance.html">
    ///                 Deleting a DB Instance.
    ///
    public var deletionProtection: Swift.Bool?
    /// Specify the Active Directory directory ID to restore the DB instance in.
    ///           The domain must be created prior to this operation. Currently, only MySQL, Microsoft SQL
    ///           Server, Oracle, and PostgreSQL DB instances can be created in an Active Directory Domain.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/kerberos-authentication.html">
    ///           Kerberos Authentication in the Amazon RDS User Guide.
    public var domain: Swift.String?
    /// Specify the name of the IAM role to be used when making API calls to the Directory Service.
    public var domainIAMRoleName: Swift.String?
    /// The list of logs that the restored DB instance is to export to CloudWatch Logs. The values
    ///             in the list depend on the DB engine being used. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_LogAccess.html#USER_LogAccess.Procedural.UploadtoCloudWatch">Publishing Database Logs to Amazon CloudWatch Logs in the Amazon RDS User Guide.
    public var enableCloudwatchLogsExports: [Swift.String]?
    /// A value that indicates whether to enable a customer-owned IP address (CoIP) for an RDS on Outposts DB instance.
    ///         A CoIP provides local or external connectivity to resources in
    ///             your Outpost subnets through your on-premises network. For some use cases, a CoIP can
    ///             provide lower latency for connections to the DB instance from outside of its virtual
    ///             private cloud (VPC) on your local network.
    ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Working with Amazon RDS on Amazon Web Services Outposts
    ///             in the Amazon RDS User Guide.
    ///         For more information about CoIPs, see <a href="https://docs.aws.amazon.com/outposts/latest/userguide/outposts-networking-components.html#ip-addressing">Customer-owned IP addresses
    ///             in the Amazon Web Services Outposts User Guide.
    public var enableCustomerOwnedIp: Swift.Bool?
    /// A value that indicates whether to enable mapping of Amazon Web Services Identity and Access
    ///           Management (IAM) accounts to database accounts. By default, mapping is disabled.
    ///
    ///          For more information about IAM database authentication, see
    ///         <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html">
    ///             IAM Database Authentication for MySQL and PostgreSQL in the Amazon RDS User Guide.
    ///
    public var enableIAMDatabaseAuthentication: Swift.Bool?
    /// The database engine to use for the new instance.
    ///          Default: The same as source
    ///          Constraint: Must be compatible with the engine of the source
    ///
    ///          Valid Values:
    ///
    ///
    ///
    ///
    ///                   mariadb
    ///
    ///
    ///
    ///
    ///                   mysql
    ///
    ///
    ///
    ///
    ///                   oracle-ee
    ///
    ///
    ///
    ///
    ///                   oracle-ee-cdb
    ///
    ///
    ///
    ///
    ///                   oracle-se2
    ///
    ///
    ///
    ///
    ///                   oracle-se2-cdb
    ///
    ///
    ///
    ///
    ///                   postgres
    ///
    ///
    ///
    ///
    ///                   sqlserver-ee
    ///
    ///
    ///
    ///
    ///                   sqlserver-se
    ///
    ///
    ///
    ///
    ///                   sqlserver-ex
    ///
    ///
    ///
    ///
    ///                   sqlserver-web
    ///
    ///
    ///
    public var engine: Swift.String?
    /// The amount of Provisioned IOPS (input/output operations per second) to be initially allocated for the DB instance.
    ///          Constraints: Must be an integer greater than 1000.
    ///
    ///             SQL Server
    ///
    ///          Setting the IOPS value for the SQL Server database engine isn't supported.
    public var iops: Swift.Int?
    /// License model information for the restored DB instance.
    ///          Default: Same as source.
    ///
    ///             Valid values:  license-included | bring-your-own-license | general-public-license
    ///
    public var licenseModel: Swift.String?
    /// The upper limit in gibibytes (GiB) to which Amazon RDS can automatically scale the storage of the DB instance.
    ///          For more information about this setting, including limitations that apply to it, see
    ///           <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIOPS.StorageTypes.html#USER_PIOPS.Autoscaling">
    ///               Managing capacity automatically with Amazon RDS storage autoscaling
    ///           in the Amazon RDS User Guide.
    public var maxAllocatedStorage: Swift.Int?
    /// A value that indicates whether the DB instance is a Multi-AZ deployment.
    ///          Constraint: You can't specify the AvailabilityZone parameter if the DB instance is a Multi-AZ deployment.
    public var multiAZ: Swift.Bool?
    /// The name of the option group to be used for the restored DB instance.
    ///
    ///          Permanent options, such as the TDE option for Oracle Advanced Security TDE, can't be removed from an option group, and that option group can't be removed from a DB instance once it is associated with a DB instance
    public var optionGroupName: Swift.String?
    /// The port number on which the database accepts connections.
    ///          Constraints: Value must be 1150-65535
    ///
    ///          Default: The same port as the original DB instance.
    public var port: Swift.Int?
    /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
    public var processorFeatures: [RdsClientTypes.ProcessorFeature]?
    /// A value that indicates whether the DB instance is publicly accessible.
    ///          When the DB instance is publicly accessible, its DNS endpoint resolves to the private IP address from within the DB instance's VPC,
    ///           and to the public IP address from outside of the DB instance's VPC. Access to the DB instance is ultimately controlled by the security group it uses,
    ///           and that public access is not permitted if the security group assigned to the DB instance doesn't permit it.
    ///          When the DB instance isn't publicly accessible, it is an internal DB instance with a DNS name that resolves to a private IP address.
    ///          For more information, see CreateDBInstance.
    public var publiclyAccessible: Swift.Bool?
    /// The date and time to restore from.
    ///          Valid Values: Value must be a time in Universal Coordinated Time (UTC) format
    ///          Constraints:
    ///
    ///
    ///                Must be before the latest restorable time for the DB instance
    ///
    ///
    ///                Can't be specified if the UseLatestRestorableTime parameter is enabled
    ///
    ///
    ///          Example: 2009-09-07T23:45:00Z
    ///
    public var restoreTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the replicated automated backups from which to restore, for example,
    ///             arn:aws:rds:useast-1:123456789012:auto-backup:ab-L2IJCEXJP7XQ7HOJ4SIEXAMPLE.
    public var sourceDBInstanceAutomatedBackupsArn: Swift.String?
    /// The identifier of the source DB instance from which to restore.
    ///          Constraints:
    ///
    ///
    ///                Must match the identifier of an existing DB instance.
    ///
    ///
    public var sourceDBInstanceIdentifier: Swift.String?
    /// The resource ID of the source DB instance from which to restore.
    public var sourceDbiResourceId: Swift.String?
    /// Specifies the storage type to be associated with the DB instance.
    ///
    ///             Valid values: standard | gp2 | io1
    ///
    ///
    ///             If you specify io1, you must also include a value for the
    ///             Iops parameter.
    ///
    ///
    ///             Default: io1 if the Iops parameter
    ///             is specified, otherwise gp2
    ///
    public var storageType: Swift.String?
    /// A list of tags.
    ///           For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Tagging.html">Tagging Amazon RDS Resources in the Amazon RDS User Guide.
    ///
    public var tags: [RdsClientTypes.Tag]?
    /// The name of the new DB instance to be created.
    ///          Constraints:
    ///
    ///
    ///                Must contain from 1 to 63 letters, numbers, or hyphens
    ///
    ///
    ///                First character must be a letter
    ///
    ///
    ///                Can't end with a hyphen or contain two consecutive hyphens
    ///
    ///
    /// This member is required.
    public var targetDBInstanceIdentifier: Swift.String?
    /// The ARN from the key store with which to associate the instance for TDE encryption.
    public var tdeCredentialArn: Swift.String?
    /// The password for the given ARN from the key store in order to access the device.
    public var tdeCredentialPassword: Swift.String?
    /// A value that indicates whether the DB instance class of the DB instance uses its default processor features.
    public var useDefaultProcessorFeatures: Swift.Bool?
    ///
    ///           A value that indicates whether the DB instance is restored from the latest backup time. By default, the DB instance
    ///           isn't restored from the latest backup time.
    ///
    ///          Constraints: Can't be specified if the RestoreTime parameter is provided.
    public var useLatestRestorableTime: Swift.Bool
    ///
    ///             A list of EC2 VPC security groups to associate with this DB instance.
    ///
    ///
    ///             Default: The default EC2 VPC security group for the DB subnet group's VPC.
    ///
    public var vpcSecurityGroupIds: [Swift.String]?

    public init (
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        availabilityZone: Swift.String? = nil,
        copyTagsToSnapshot: Swift.Bool? = nil,
        dBInstanceClass: Swift.String? = nil,
        dBName: Swift.String? = nil,
        dBParameterGroupName: Swift.String? = nil,
        dBSubnetGroupName: Swift.String? = nil,
        deletionProtection: Swift.Bool? = nil,
        domain: Swift.String? = nil,
        domainIAMRoleName: Swift.String? = nil,
        enableCloudwatchLogsExports: [Swift.String]? = nil,
        enableCustomerOwnedIp: Swift.Bool? = nil,
        enableIAMDatabaseAuthentication: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        iops: Swift.Int? = nil,
        licenseModel: Swift.String? = nil,
        maxAllocatedStorage: Swift.Int? = nil,
        multiAZ: Swift.Bool? = nil,
        optionGroupName: Swift.String? = nil,
        port: Swift.Int? = nil,
        processorFeatures: [RdsClientTypes.ProcessorFeature]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        restoreTime: ClientRuntime.Date? = nil,
        sourceDBInstanceAutomatedBackupsArn: Swift.String? = nil,
        sourceDBInstanceIdentifier: Swift.String? = nil,
        sourceDbiResourceId: Swift.String? = nil,
        storageType: Swift.String? = nil,
        tags: [RdsClientTypes.Tag]? = nil,
        targetDBInstanceIdentifier: Swift.String? = nil,
        tdeCredentialArn: Swift.String? = nil,
        tdeCredentialPassword: Swift.String? = nil,
        useDefaultProcessorFeatures: Swift.Bool? = nil,
        useLatestRestorableTime: Swift.Bool = false,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.availabilityZone = availabilityZone
        self.copyTagsToSnapshot = copyTagsToSnapshot
        self.dBInstanceClass = dBInstanceClass
        self.dBName = dBName
        self.dBParameterGroupName = dBParameterGroupName
        self.dBSubnetGroupName = dBSubnetGroupName
        self.deletionProtection = deletionProtection
        self.domain = domain
        self.domainIAMRoleName = domainIAMRoleName
        self.enableCloudwatchLogsExports = enableCloudwatchLogsExports
        self.enableCustomerOwnedIp = enableCustomerOwnedIp
        self.enableIAMDatabaseAuthentication = enableIAMDatabaseAuthentication
        self.engine = engine
        self.iops = iops
        self.licenseModel = licenseModel
        self.maxAllocatedStorage = maxAllocatedStorage
        self.multiAZ = multiAZ
        self.optionGroupName = optionGroupName
        self.port = port
        self.processorFeatures = processorFeatures
        self.publiclyAccessible = publiclyAccessible
        self.restoreTime = restoreTime
        self.sourceDBInstanceAutomatedBackupsArn = sourceDBInstanceAutomatedBackupsArn
        self.sourceDBInstanceIdentifier = sourceDBInstanceIdentifier
        self.sourceDbiResourceId = sourceDbiResourceId
        self.storageType = storageType
        self.tags = tags
        self.targetDBInstanceIdentifier = targetDBInstanceIdentifier
        self.tdeCredentialArn = tdeCredentialArn
        self.tdeCredentialPassword = tdeCredentialPassword
        self.useDefaultProcessorFeatures = useDefaultProcessorFeatures
        self.useLatestRestorableTime = useLatestRestorableTime
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

extension RestoreDBInstanceToPointInTimeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RestoreDBInstanceToPointInTimeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupPolicyNotFoundFault" : self = .backupPolicyNotFoundFault(try BackupPolicyNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAlreadyExists" : self = .dBInstanceAlreadyExistsFault(try DBInstanceAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceAutomatedBackupNotFound" : self = .dBInstanceAutomatedBackupNotFoundFault(try DBInstanceAutomatedBackupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBParameterGroupNotFound" : self = .dBParameterGroupNotFoundFault(try DBParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DomainNotFoundFault" : self = .domainNotFoundFault(try DomainNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InstanceQuotaExceeded" : self = .instanceQuotaExceededFault(try InstanceQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRestoreFault" : self = .invalidRestoreFault(try InvalidRestoreFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptionGroupNotFoundFault" : self = .optionGroupNotFoundFault(try OptionGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PointInTimeRestoreNotEnabled" : self = .pointInTimeRestoreNotEnabledFault(try PointInTimeRestoreNotEnabledFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedIopsNotAvailableInAZFault" : self = .provisionedIopsNotAvailableInAZFault(try ProvisionedIopsNotAvailableInAZFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageQuotaExceeded" : self = .storageQuotaExceededFault(try StorageQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDBInstanceToPointInTimeOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case backupPolicyNotFoundFault(BackupPolicyNotFoundFault)
    case dBInstanceAlreadyExistsFault(DBInstanceAlreadyExistsFault)
    case dBInstanceAutomatedBackupNotFoundFault(DBInstanceAutomatedBackupNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBParameterGroupNotFoundFault(DBParameterGroupNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case domainNotFoundFault(DomainNotFoundFault)
    case instanceQuotaExceededFault(InstanceQuotaExceededFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidRestoreFault(InvalidRestoreFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case optionGroupNotFoundFault(OptionGroupNotFoundFault)
    case pointInTimeRestoreNotEnabledFault(PointInTimeRestoreNotEnabledFault)
    case provisionedIopsNotAvailableInAZFault(ProvisionedIopsNotAvailableInAZFault)
    case storageQuotaExceededFault(StorageQuotaExceededFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDBInstanceToPointInTimeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDBInstanceToPointInTimeOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension RestoreDBInstanceToPointInTimeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreDBInstanceToPointInTimeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct RestoreDBInstanceToPointInTimeOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct RestoreDBInstanceToPointInTimeOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension RestoreDBInstanceToPointInTimeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RestoreDBInstanceToPointInTimeResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension RdsClientTypes.RestoreWindow: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case earliestTime = "EarliestTime"
        case latestTime = "LatestTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let earliestTime = earliestTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestTime, format: .dateTime), forKey: ClientRuntime.Key("earliestTime"))
        }
        if let latestTime = latestTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestTime, format: .dateTime), forKey: ClientRuntime.Key("latestTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let earliestTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestTime)
        var earliestTimeBuffer:ClientRuntime.Date? = nil
        if let earliestTimeDecoded = earliestTimeDecoded {
            earliestTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestTimeDecoded, format: .dateTime)
        }
        earliestTime = earliestTimeBuffer
        let latestTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestTime)
        var latestTimeBuffer:ClientRuntime.Date? = nil
        if let latestTimeDecoded = latestTimeDecoded {
            latestTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestTimeDecoded, format: .dateTime)
        }
        latestTime = latestTimeBuffer
    }
}

extension RdsClientTypes.RestoreWindow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreWindow(earliestTime: \(Swift.String(describing: earliestTime)), latestTime: \(Swift.String(describing: latestTime)))"}
}

extension RdsClientTypes {
    /// Earliest and latest time an instance can be restored to:
    public struct RestoreWindow: Swift.Equatable {
        /// The earliest time you can restore an instance to.
        public var earliestTime: ClientRuntime.Date?
        /// The latest time you can restore an instance to.
        public var latestTime: ClientRuntime.Date?

        public init (
            earliestTime: ClientRuntime.Date? = nil,
            latestTime: ClientRuntime.Date? = nil
        )
        {
            self.earliestTime = earliestTime
            self.latestTime = latestTime
        }
    }

}

public struct RevokeDBSecurityGroupIngressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDBSecurityGroupIngressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeDBSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDBSecurityGroupIngressOutputError>
}

extension RevokeDBSecurityGroupIngressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeDBSecurityGroupIngressInput(cIDRIP: \(Swift.String(describing: cIDRIP)), dBSecurityGroupName: \(Swift.String(describing: dBSecurityGroupName)), eC2SecurityGroupId: \(Swift.String(describing: eC2SecurityGroupId)), eC2SecurityGroupName: \(Swift.String(describing: eC2SecurityGroupName)), eC2SecurityGroupOwnerId: \(Swift.String(describing: eC2SecurityGroupOwnerId)))"}
}

extension RevokeDBSecurityGroupIngressInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let cIDRIP = cIDRIP {
            try container.encode(cIDRIP, forKey: ClientRuntime.Key("CIDRIP"))
        }
        if let dBSecurityGroupName = dBSecurityGroupName {
            try container.encode(dBSecurityGroupName, forKey: ClientRuntime.Key("DBSecurityGroupName"))
        }
        if let eC2SecurityGroupId = eC2SecurityGroupId {
            try container.encode(eC2SecurityGroupId, forKey: ClientRuntime.Key("EC2SecurityGroupId"))
        }
        if let eC2SecurityGroupName = eC2SecurityGroupName {
            try container.encode(eC2SecurityGroupName, forKey: ClientRuntime.Key("EC2SecurityGroupName"))
        }
        if let eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId {
            try container.encode(eC2SecurityGroupOwnerId, forKey: ClientRuntime.Key("EC2SecurityGroupOwnerId"))
        }
        try container.encode("RevokeDBSecurityGroupIngress", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct RevokeDBSecurityGroupIngressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDBSecurityGroupIngressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeDBSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDBSecurityGroupIngressOutputError>
}

public struct RevokeDBSecurityGroupIngressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDBSecurityGroupIngressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RevokeDBSecurityGroupIngressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RevokeDBSecurityGroupIngressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDBSecurityGroupIngressOutputError>
}

public struct RevokeDBSecurityGroupIngressInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RevokeDBSecurityGroupIngressInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RevokeDBSecurityGroupIngressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RevokeDBSecurityGroupIngressInput
    public typealias MOutput = ClientRuntime.OperationOutput<RevokeDBSecurityGroupIngressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RevokeDBSecurityGroupIngressOutputError>
}

///
public struct RevokeDBSecurityGroupIngressInput: Swift.Equatable {
    ///
    ///         The IP range to revoke access from.
    ///         Must be a valid CIDR range. If CIDRIP is specified,
    ///         EC2SecurityGroupName, EC2SecurityGroupId and EC2SecurityGroupOwnerId
    ///         can't be provided.
    ///
    public var cIDRIP: Swift.String?
    /// The name of the DB security group to revoke ingress from.
    /// This member is required.
    public var dBSecurityGroupName: Swift.String?
    ///
    ///         The id of the EC2 security group to revoke access from.
    ///         For VPC DB security groups, EC2SecurityGroupId must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    ///
    public var eC2SecurityGroupId: Swift.String?
    ///
    ///         The name of the EC2 security group to revoke access from.
    ///         For VPC DB security groups, EC2SecurityGroupId must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    ///
    public var eC2SecurityGroupName: Swift.String?
    ///
    ///         The Amazon Web Services account number of the owner of the EC2 security group
    ///         specified in the EC2SecurityGroupName parameter.
    ///         The Amazon Web Services access key ID isn't an acceptable value.
    ///         For VPC DB security groups, EC2SecurityGroupId must be provided.
    ///         Otherwise, EC2SecurityGroupOwnerId and either EC2SecurityGroupName or EC2SecurityGroupId must be provided.
    ///
    public var eC2SecurityGroupOwnerId: Swift.String?

    public init (
        cIDRIP: Swift.String? = nil,
        dBSecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupId: Swift.String? = nil,
        eC2SecurityGroupName: Swift.String? = nil,
        eC2SecurityGroupOwnerId: Swift.String? = nil
    )
    {
        self.cIDRIP = cIDRIP
        self.dBSecurityGroupName = dBSecurityGroupName
        self.eC2SecurityGroupId = eC2SecurityGroupId
        self.eC2SecurityGroupName = eC2SecurityGroupName
        self.eC2SecurityGroupOwnerId = eC2SecurityGroupOwnerId
    }
}

extension RevokeDBSecurityGroupIngressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RevokeDBSecurityGroupIngressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSecurityGroupNotFound" : self = .dBSecurityGroupNotFoundFault(try DBSecurityGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBSecurityGroupState" : self = .invalidDBSecurityGroupStateFault(try InvalidDBSecurityGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeDBSecurityGroupIngressOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBSecurityGroupNotFoundFault(DBSecurityGroupNotFoundFault)
    case invalidDBSecurityGroupStateFault(InvalidDBSecurityGroupStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeDBSecurityGroupIngressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RevokeDBSecurityGroupIngressOutputResponse(dBSecurityGroup: \(Swift.String(describing: dBSecurityGroup)))"}
}

extension RevokeDBSecurityGroupIngressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RevokeDBSecurityGroupIngressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBSecurityGroup = output.dBSecurityGroup
        } else {
            self.dBSecurityGroup = nil
        }
    }
}

public struct RevokeDBSecurityGroupIngressOutputResponse: Swift.Equatable {
    /// Contains the details for an Amazon RDS DB security group.
    ///
    ///          This data type is used as a response element
    ///           in the DescribeDBSecurityGroups action.
    ///
    public var dBSecurityGroup: RdsClientTypes.DBSecurityGroup?

    public init (
        dBSecurityGroup: RdsClientTypes.DBSecurityGroup? = nil
    )
    {
        self.dBSecurityGroup = dBSecurityGroup
    }
}

struct RevokeDBSecurityGroupIngressOutputResponseBody: Swift.Equatable {
    public let dBSecurityGroup: RdsClientTypes.DBSecurityGroup?
}

extension RevokeDBSecurityGroupIngressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBSecurityGroup = "DBSecurityGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("RevokeDBSecurityGroupIngressResult"))
        let dBSecurityGroupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBSecurityGroup.self, forKey: .dBSecurityGroup)
        dBSecurityGroup = dBSecurityGroupDecoded
    }
}

extension SNSInvalidTopicFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSInvalidTopicFault(message: \(Swift.String(describing: message)))"}
}

extension SNSInvalidTopicFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SNSInvalidTopicFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// SNS has responded that there is a problem with the SND topic specified.
public struct SNSInvalidTopicFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSInvalidTopicFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSInvalidTopicFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSNoAuthorizationFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSNoAuthorizationFault(message: \(Swift.String(describing: message)))"}
}

extension SNSNoAuthorizationFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SNSNoAuthorizationFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to publish to the SNS topic ARN.
public struct SNSNoAuthorizationFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSNoAuthorizationFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSNoAuthorizationFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SNSTopicArnNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SNSTopicArnNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SNSTopicArnNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SNSTopicArnNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The SNS topic ARN does not exist.
public struct SNSTopicArnNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SNSTopicArnNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SNSTopicArnNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.ScalingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoPause = "AutoPause"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case secondsUntilAutoPause = "SecondsUntilAutoPause"
        case timeoutAction = "TimeoutAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoPause = autoPause {
            try container.encode(autoPause, forKey: ClientRuntime.Key("AutoPause"))
        }
        if let maxCapacity = maxCapacity {
            try container.encode(maxCapacity, forKey: ClientRuntime.Key("MaxCapacity"))
        }
        if let minCapacity = minCapacity {
            try container.encode(minCapacity, forKey: ClientRuntime.Key("MinCapacity"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: ClientRuntime.Key("SecondsBeforeTimeout"))
        }
        if let secondsUntilAutoPause = secondsUntilAutoPause {
            try container.encode(secondsUntilAutoPause, forKey: ClientRuntime.Key("SecondsUntilAutoPause"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: ClientRuntime.Key("TimeoutAction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let autoPauseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoPause)
        autoPause = autoPauseDecoded
        let secondsUntilAutoPauseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsUntilAutoPause)
        secondsUntilAutoPause = secondsUntilAutoPauseDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
    }
}

extension RdsClientTypes.ScalingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScalingConfiguration(autoPause: \(Swift.String(describing: autoPause)), maxCapacity: \(Swift.String(describing: maxCapacity)), minCapacity: \(Swift.String(describing: minCapacity)), secondsBeforeTimeout: \(Swift.String(describing: secondsBeforeTimeout)), secondsUntilAutoPause: \(Swift.String(describing: secondsUntilAutoPause)), timeoutAction: \(Swift.String(describing: timeoutAction)))"}
}

extension RdsClientTypes {
    /// Contains the scaling configuration of an Aurora Serverless DB cluster.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless in the
    ///             Amazon Aurora User Guide.
    public struct ScalingConfiguration: Swift.Equatable {
        /// A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode.
        ///             A DB cluster can be paused only when it's idle (it has no connections).
        ///
        ///             If a DB cluster is paused for more than seven days, the DB cluster might be backed up with a snapshot.
        ///                 In this case, the DB cluster is restored when there is a request to connect to it.
        ///
        public var autoPause: Swift.Bool?
        /// The maximum capacity for an Aurora DB cluster in serverless DB engine mode.
        ///         For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
        ///         For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
        ///         The maximum capacity must be greater than or equal to the minimum capacity.
        public var maxCapacity: Swift.Int?
        /// The minimum capacity for an Aurora DB cluster in serverless DB engine mode.
        ///         For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
        ///         For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
        ///         The minimum capacity must be less than or equal to the maximum capacity.
        public var minCapacity: Swift.Int?
        /// The amount of time, in seconds, that Aurora Serverless tries to find a scaling point
        ///             to perform seamless scaling before enforcing the timeout action. The default is 300.
        ///         Specify a value between 60 and 600 seconds.
        public var secondsBeforeTimeout: Swift.Int?
        /// The time, in seconds, before an Aurora DB cluster in serverless mode is paused.
        ///         Specify a value between 300 and 86,400 seconds.
        public var secondsUntilAutoPause: Swift.Int?
        /// The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.
        ///
        ///             ForceApplyCapacityChange sets the capacity to the specified value as soon as possible.
        ///
        ///             RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period.
        ///
        ///             If you specify ForceApplyCapacityChange, connections that
        ///                 prevent Aurora Serverless from finding a scaling point might be dropped.
        ///
        ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.how-it-works.html#aurora-serverless.how-it-works.auto-scaling">
        ///                     Autoscaling for Aurora Serverless in the Amazon Aurora User Guide.
        public var timeoutAction: Swift.String?

        public init (
            autoPause: Swift.Bool? = nil,
            maxCapacity: Swift.Int? = nil,
            minCapacity: Swift.Int? = nil,
            secondsBeforeTimeout: Swift.Int? = nil,
            secondsUntilAutoPause: Swift.Int? = nil,
            timeoutAction: Swift.String? = nil
        )
        {
            self.autoPause = autoPause
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.secondsUntilAutoPause = secondsUntilAutoPause
            self.timeoutAction = timeoutAction
        }
    }

}

extension RdsClientTypes.ScalingConfigurationInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoPause = "AutoPause"
        case maxCapacity = "MaxCapacity"
        case minCapacity = "MinCapacity"
        case secondsBeforeTimeout = "SecondsBeforeTimeout"
        case secondsUntilAutoPause = "SecondsUntilAutoPause"
        case timeoutAction = "TimeoutAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoPause = autoPause {
            try container.encode(autoPause, forKey: ClientRuntime.Key("AutoPause"))
        }
        if let maxCapacity = maxCapacity {
            try container.encode(maxCapacity, forKey: ClientRuntime.Key("MaxCapacity"))
        }
        if let minCapacity = minCapacity {
            try container.encode(minCapacity, forKey: ClientRuntime.Key("MinCapacity"))
        }
        if let secondsBeforeTimeout = secondsBeforeTimeout {
            try container.encode(secondsBeforeTimeout, forKey: ClientRuntime.Key("SecondsBeforeTimeout"))
        }
        if let secondsUntilAutoPause = secondsUntilAutoPause {
            try container.encode(secondsUntilAutoPause, forKey: ClientRuntime.Key("SecondsUntilAutoPause"))
        }
        if let timeoutAction = timeoutAction {
            try container.encode(timeoutAction, forKey: ClientRuntime.Key("TimeoutAction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minCapacity)
        minCapacity = minCapacityDecoded
        let maxCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCapacity)
        maxCapacity = maxCapacityDecoded
        let autoPauseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoPause)
        autoPause = autoPauseDecoded
        let secondsUntilAutoPauseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsUntilAutoPause)
        secondsUntilAutoPause = secondsUntilAutoPauseDecoded
        let timeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeoutAction)
        timeoutAction = timeoutActionDecoded
        let secondsBeforeTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondsBeforeTimeout)
        secondsBeforeTimeout = secondsBeforeTimeoutDecoded
    }
}

extension RdsClientTypes.ScalingConfigurationInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScalingConfigurationInfo(autoPause: \(Swift.String(describing: autoPause)), maxCapacity: \(Swift.String(describing: maxCapacity)), minCapacity: \(Swift.String(describing: minCapacity)), secondsBeforeTimeout: \(Swift.String(describing: secondsBeforeTimeout)), secondsUntilAutoPause: \(Swift.String(describing: secondsUntilAutoPause)), timeoutAction: \(Swift.String(describing: timeoutAction)))"}
}

extension RdsClientTypes {
    /// Shows the scaling configuration for an Aurora DB cluster in serverless DB engine mode.
    ///         For more information, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-serverless.html">Using Amazon Aurora Serverless in the
    ///             Amazon Aurora User Guide.
    public struct ScalingConfigurationInfo: Swift.Equatable {
        /// A value that indicates whether automatic pause is allowed for the Aurora DB cluster
        ///             in serverless DB engine mode.
        ///         When the value is set to false for an Aurora Serverless DB cluster, the DB cluster automatically resumes.
        public var autoPause: Swift.Bool?
        /// The maximum capacity for an Aurora DB cluster in serverless DB engine mode.
        public var maxCapacity: Swift.Int?
        /// The maximum capacity for the Aurora DB cluster in serverless DB engine
        ///             mode.
        public var minCapacity: Swift.Int?
        /// The number of seconds before scaling times out. What happens when an attempted scaling action times out
        ///             is determined by the TimeoutAction setting.
        public var secondsBeforeTimeout: Swift.Int?
        /// The remaining amount of time, in seconds, before the Aurora DB cluster in
        ///                 serverless mode is paused. A DB cluster can be paused only when
        ///             it's idle (it has no connections).
        public var secondsUntilAutoPause: Swift.Int?
        /// The action that occurs when Aurora times out while attempting to change the capacity of an
        ///             Aurora Serverless cluster. The value is either ForceApplyCapacityChange or
        ///             RollbackCapacityChange.
        ///
        ///             ForceApplyCapacityChange, the default, sets the capacity to the specified value as soon as possible.
        ///
        ///             RollbackCapacityChange ignores the capacity change if a scaling point isn't found in the timeout period.
        public var timeoutAction: Swift.String?

        public init (
            autoPause: Swift.Bool? = nil,
            maxCapacity: Swift.Int? = nil,
            minCapacity: Swift.Int? = nil,
            secondsBeforeTimeout: Swift.Int? = nil,
            secondsUntilAutoPause: Swift.Int? = nil,
            timeoutAction: Swift.String? = nil
        )
        {
            self.autoPause = autoPause
            self.maxCapacity = maxCapacity
            self.minCapacity = minCapacity
            self.secondsBeforeTimeout = secondsBeforeTimeout
            self.secondsUntilAutoPause = secondsUntilAutoPause
            self.timeoutAction = timeoutAction
        }
    }

}

extension SharedSnapshotQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedSnapshotQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SharedSnapshotQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SharedSnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the maximum number of accounts that you can share a manual DB snapshot with.
public struct SharedSnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SharedSnapshotQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SharedSnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnapshotQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension SnapshotQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SnapshotQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed number of DB
///             snapshots.
public struct SnapshotQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SnapshotQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SnapshotQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SourceNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SourceNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested source could not be found.
public struct SourceNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SourceNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SourceNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.SourceRegion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case regionName = "RegionName"
        case status = "Status"
        case supportsDBInstanceAutomatedBackupsReplication = "SupportsDBInstanceAutomatedBackupsReplication"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let regionName = regionName {
            try container.encode(regionName, forKey: ClientRuntime.Key("RegionName"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if supportsDBInstanceAutomatedBackupsReplication != false {
            try container.encode(supportsDBInstanceAutomatedBackupsReplication, forKey: ClientRuntime.Key("SupportsDBInstanceAutomatedBackupsReplication"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsDBInstanceAutomatedBackupsReplicationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsDBInstanceAutomatedBackupsReplication)
        supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplicationDecoded
    }
}

extension RdsClientTypes.SourceRegion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceRegion(endpoint: \(Swift.String(describing: endpoint)), regionName: \(Swift.String(describing: regionName)), status: \(Swift.String(describing: status)), supportsDBInstanceAutomatedBackupsReplication: \(Swift.String(describing: supportsDBInstanceAutomatedBackupsReplication)))"}
}

extension RdsClientTypes {
    /// Contains an Amazon Web Services Region name as the result of a successful call to the DescribeSourceRegions action.
    public struct SourceRegion: Swift.Equatable {
        /// The endpoint for the source Amazon Web Services Region endpoint.
        public var endpoint: Swift.String?
        /// The name of the source Amazon Web Services Region.
        public var regionName: Swift.String?
        /// The status of the source Amazon Web Services Region.
        public var status: Swift.String?
        /// Whether the source Amazon Web Services Region supports replicating automated backups to the current Amazon Web Services Region.
        public var supportsDBInstanceAutomatedBackupsReplication: Swift.Bool

        public init (
            endpoint: Swift.String? = nil,
            regionName: Swift.String? = nil,
            status: Swift.String? = nil,
            supportsDBInstanceAutomatedBackupsReplication: Swift.Bool = false
        )
        {
            self.endpoint = endpoint
            self.regionName = regionName
            self.status = status
            self.supportsDBInstanceAutomatedBackupsReplication = supportsDBInstanceAutomatedBackupsReplication
        }
    }

}

extension RdsClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbCluster
        case dbClusterSnapshot
        case dbInstance
        case dbParameterGroup
        case dbSecurityGroup
        case dbSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .dbCluster,
                .dbClusterSnapshot,
                .dbInstance,
                .dbParameterGroup,
                .dbSecurityGroup,
                .dbSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbCluster: return "db-cluster"
            case .dbClusterSnapshot: return "db-cluster-snapshot"
            case .dbInstance: return "db-instance"
            case .dbParameterGroup: return "db-parameter-group"
            case .dbSecurityGroup: return "db-security-group"
            case .dbSnapshot: return "db-snapshot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

public struct StartActivityStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartActivityStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartActivityStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartActivityStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartActivityStreamOutputError>
}

extension StartActivityStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartActivityStreamInput(applyImmediately: \(Swift.String(describing: applyImmediately)), engineNativeAuditFieldsIncluded: \(Swift.String(describing: engineNativeAuditFieldsIncluded)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), mode: \(Swift.String(describing: mode)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension StartActivityStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyImmediately = applyImmediately {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded {
            try container.encode(engineNativeAuditFieldsIncluded, forKey: ClientRuntime.Key("EngineNativeAuditFieldsIncluded"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let mode = mode {
            try container.encode(mode, forKey: ClientRuntime.Key("Mode"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("StartActivityStream", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StartActivityStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartActivityStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartActivityStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartActivityStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartActivityStreamOutputError>
}

public struct StartActivityStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartActivityStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartActivityStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartActivityStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartActivityStreamOutputError>
}

public struct StartActivityStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartActivityStreamInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartActivityStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartActivityStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartActivityStreamOutputError>
}

public struct StartActivityStreamInput: Swift.Equatable {
    /// Specifies whether or not the database activity stream is to start as soon as possible,
    ///             regardless of the maintenance window for the database.
    public var applyImmediately: Swift.Bool?
    /// Specifies whether the database activity stream includes engine-native audit fields. This option only applies
    ///         to an Oracle DB instance. By default, no engine-native audit fields are included.
    public var engineNativeAuditFieldsIncluded: Swift.Bool?
    /// The Amazon Web Services KMS key identifier for encrypting messages in the database activity stream.
    ///             The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// Specifies the mode of the database activity stream.
    ///             Database events such as a change or access generate an activity stream event.
    ///             The database session can handle these events either synchronously or asynchronously.
    ///
    /// This member is required.
    public var mode: RdsClientTypes.ActivityStreamMode?
    /// The Amazon Resource Name (ARN) of the DB cluster,
    ///             for example, arn:aws:rds:us-east-1:12345667890:cluster:das-cluster.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        applyImmediately: Swift.Bool? = nil,
        engineNativeAuditFieldsIncluded: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        mode: RdsClientTypes.ActivityStreamMode? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
        self.kmsKeyId = kmsKeyId
        self.mode = mode
        self.resourceArn = resourceArn
    }
}

extension StartActivityStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartActivityStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartActivityStreamOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartActivityStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartActivityStreamOutputResponse(applyImmediately: \(Swift.String(describing: applyImmediately)), engineNativeAuditFieldsIncluded: \(Swift.String(describing: engineNativeAuditFieldsIncluded)), kinesisStreamName: \(Swift.String(describing: kinesisStreamName)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), mode: \(Swift.String(describing: mode)), status: \(Swift.String(describing: status)))"}
}

extension StartActivityStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartActivityStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applyImmediately = output.applyImmediately
            self.engineNativeAuditFieldsIncluded = output.engineNativeAuditFieldsIncluded
            self.kinesisStreamName = output.kinesisStreamName
            self.kmsKeyId = output.kmsKeyId
            self.mode = output.mode
            self.status = output.status
        } else {
            self.applyImmediately = false
            self.engineNativeAuditFieldsIncluded = nil
            self.kinesisStreamName = nil
            self.kmsKeyId = nil
            self.mode = nil
            self.status = nil
        }
    }
}

public struct StartActivityStreamOutputResponse: Swift.Equatable {
    /// Indicates whether or not the database activity stream will start as soon as possible,
    ///             regardless of the maintenance window for the database.
    public var applyImmediately: Swift.Bool
    /// Indicates whether engine-native audit fields are included in the database activity stream.
    public var engineNativeAuditFieldsIncluded: Swift.Bool?
    /// The name of the Amazon Kinesis data stream to be used for the database activity stream.
    public var kinesisStreamName: Swift.String?
    /// The Amazon Web Services KMS key identifier for encryption of messages in the database activity stream.
    public var kmsKeyId: Swift.String?
    /// The mode of the database activity stream.
    public var mode: RdsClientTypes.ActivityStreamMode?
    /// The status of the database activity stream.
    public var status: RdsClientTypes.ActivityStreamStatus?

    public init (
        applyImmediately: Swift.Bool = false,
        engineNativeAuditFieldsIncluded: Swift.Bool? = nil,
        kinesisStreamName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        mode: RdsClientTypes.ActivityStreamMode? = nil,
        status: RdsClientTypes.ActivityStreamStatus? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncluded
        self.kinesisStreamName = kinesisStreamName
        self.kmsKeyId = kmsKeyId
        self.mode = mode
        self.status = status
    }
}

struct StartActivityStreamOutputResponseBody: Swift.Equatable {
    public let kmsKeyId: Swift.String?
    public let kinesisStreamName: Swift.String?
    public let status: RdsClientTypes.ActivityStreamStatus?
    public let mode: RdsClientTypes.ActivityStreamMode?
    public let applyImmediately: Swift.Bool
    public let engineNativeAuditFieldsIncluded: Swift.Bool?
}

extension StartActivityStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyImmediately = "ApplyImmediately"
        case engineNativeAuditFieldsIncluded = "EngineNativeAuditFieldsIncluded"
        case kinesisStreamName = "KinesisStreamName"
        case kmsKeyId = "KmsKeyId"
        case mode = "Mode"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartActivityStreamResult"))
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamName)
        kinesisStreamName = kinesisStreamNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .status)
        status = statusDecoded
        let modeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .mode)
        mode = modeDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let engineNativeAuditFieldsIncludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .engineNativeAuditFieldsIncluded)
        engineNativeAuditFieldsIncluded = engineNativeAuditFieldsIncludedDecoded
    }
}

public struct StartDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

extension StartDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)))"}
}

extension StartDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("StartDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StartDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBClusterOutputError>
}

public struct StartDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier of the Amazon Aurora DB cluster to be started. This parameter is stored as
    ///         a lowercase string.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StartDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension StartDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StartDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StartDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension StartDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceAutomatedBackupsReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

extension StartDBInstanceAutomatedBackupsReplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBInstanceAutomatedBackupsReplicationInput(backupRetentionPeriod: \(Swift.String(describing: backupRetentionPeriod)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), preSignedUrl: \(Swift.String(describing: preSignedUrl)), sourceDBInstanceArn: \(Swift.String(describing: sourceDBInstanceArn)))"}
}

extension StartDBInstanceAutomatedBackupsReplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let preSignedUrl = preSignedUrl {
            try container.encode(preSignedUrl, forKey: ClientRuntime.Key("PreSignedUrl"))
        }
        if let sourceDBInstanceArn = sourceDBInstanceArn {
            try container.encode(sourceDBInstanceArn, forKey: ClientRuntime.Key("SourceDBInstanceArn"))
        }
        try container.encode("StartDBInstanceAutomatedBackupsReplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StartDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StartDBInstanceAutomatedBackupsReplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceAutomatedBackupsReplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartDBInstanceAutomatedBackupsReplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDBInstanceAutomatedBackupsReplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StartDBInstanceAutomatedBackupsReplicationInput: Swift.Equatable {
    /// The retention period for the replicated automated backups.
    public var backupRetentionPeriod: Swift.Int?
    /// The Amazon Web Services KMS key identifier for encryption of the replicated automated backups. The KMS key ID is the
    ///             Amazon Resource Name (ARN) for the KMS encryption key in the destination Amazon Web Services Region, for example,
    ///             arn:aws:kms:us-east-1:123456789012:key/AKIAIOSFODNN7EXAMPLE.
    public var kmsKeyId: Swift.String?
    /// A URL that contains a Signature Version 4 signed request for the StartDBInstanceAutomatedBackupsReplication action to be
    ///             called in the Amazon Web Services Region of the source DB instance. The presigned URL must be a valid request for the
    ///             StartDBInstanceAutomatedBackupsReplication API action that can be executed in the Amazon Web Services Region that contains
    ///             the source DB instance.
    public var preSignedUrl: Swift.String?
    /// The Amazon Resource Name (ARN) of the source DB instance for the replicated automated backups, for example,
    ///             arn:aws:rds:us-west-2:123456789012:db:mydatabase.
    /// This member is required.
    public var sourceDBInstanceArn: Swift.String?

    public init (
        backupRetentionPeriod: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        preSignedUrl: Swift.String? = nil,
        sourceDBInstanceArn: Swift.String? = nil
    )
    {
        self.backupRetentionPeriod = backupRetentionPeriod
        self.kmsKeyId = kmsKeyId
        self.preSignedUrl = preSignedUrl
        self.sourceDBInstanceArn = sourceDBInstanceArn
    }
}

extension StartDBInstanceAutomatedBackupsReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBInstanceAutomatedBackupsReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceAutomatedBackupQuotaExceeded" : self = .dBInstanceAutomatedBackupQuotaExceededFault(try DBInstanceAutomatedBackupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageTypeNotSupported" : self = .storageTypeNotSupportedFault(try StorageTypeNotSupportedFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBInstanceAutomatedBackupsReplicationOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceAutomatedBackupQuotaExceededFault(DBInstanceAutomatedBackupQuotaExceededFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case storageTypeNotSupportedFault(StorageTypeNotSupportedFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBInstanceAutomatedBackupsReplicationOutputResponse(dBInstanceAutomatedBackup: \(Swift.String(describing: dBInstanceAutomatedBackup)))"}
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBInstanceAutomatedBackupsReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct StartDBInstanceAutomatedBackupsReplicationOutputResponse: Swift.Equatable {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.
    public var dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct StartDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Equatable {
    public let dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?
}

extension StartDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBInstanceAutomatedBackupsReplicationResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

public struct StartDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceOutputError>
}

extension StartDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)))"}
}

extension StartDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        try container.encode("StartDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StartDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceOutputError>
}

public struct StartDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceOutputError>
}

public struct StartDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartDBInstanceOutputError>
}

public struct StartDBInstanceInput: Swift.Equatable {
    ///
    ///             The user-supplied instance identifier.
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
    }
}

extension StartDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationNotFound" : self = .authorizationNotFoundFault(try AuthorizationNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupDoesNotCoverEnoughAZs" : self = .dBSubnetGroupDoesNotCoverEnoughAZs(try DBSubnetGroupDoesNotCoverEnoughAZs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSubnetGroupNotFoundFault" : self = .dBSubnetGroupNotFoundFault(try DBSubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDBInstanceCapacity" : self = .insufficientDBInstanceCapacityFault(try InsufficientDBInstanceCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case authorizationNotFoundFault(AuthorizationNotFoundFault)
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSubnetGroupDoesNotCoverEnoughAZs(DBSubnetGroupDoesNotCoverEnoughAZs)
    case dBSubnetGroupNotFoundFault(DBSubnetGroupNotFoundFault)
    case insufficientDBInstanceCapacityFault(InsufficientDBInstanceCapacityFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case invalidSubnet(InvalidSubnet)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension StartDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct StartDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct StartDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension StartDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

public struct StartExportTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExportTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExportTaskOutputError>
}

extension StartExportTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartExportTaskInput(exportOnly: \(Swift.String(describing: exportOnly)), exportTaskIdentifier: \(Swift.String(describing: exportTaskIdentifier)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3Prefix: \(Swift.String(describing: s3Prefix)), sourceArn: \(Swift.String(describing: sourceArn)))"}
}

extension StartExportTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let exportOnly = exportOnly {
            var exportOnlyContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportOnly"))
            for (index0, string0) in exportOnly.enumerated() {
                try exportOnlyContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let exportTaskIdentifier = exportTaskIdentifier {
            try container.encode(exportTaskIdentifier, forKey: ClientRuntime.Key("ExportTaskIdentifier"))
        }
        if let iamRoleArn = iamRoleArn {
            try container.encode(iamRoleArn, forKey: ClientRuntime.Key("IamRoleArn"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let s3BucketName = s3BucketName {
            try container.encode(s3BucketName, forKey: ClientRuntime.Key("S3BucketName"))
        }
        if let s3Prefix = s3Prefix {
            try container.encode(s3Prefix, forKey: ClientRuntime.Key("S3Prefix"))
        }
        if let sourceArn = sourceArn {
            try container.encode(sourceArn, forKey: ClientRuntime.Key("SourceArn"))
        }
        try container.encode("StartExportTask", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StartExportTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExportTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExportTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartExportTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartExportTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExportTaskInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartExportTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExportTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartExportTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartExportTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExportTaskOutputError>
}

public struct StartExportTaskInput: Swift.Equatable {
    /// The data to be exported from the snapshot.
    ///             If this parameter is not provided, all the snapshot data is exported.
    ///             Valid values are the following:
    ///
    ///
    ///
    ///                   database - Export all the data from a specified database.
    ///
    ///
    ///
    ///                   database.table
    ///                   table-name -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
    ///
    ///
    ///
    ///                   database.schema
    ///                   schema-name - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    ///
    ///
    ///                   database.schema.table
    ///                   table-name - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    ///
    public var exportOnly: [Swift.String]?
    /// A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is to be exported to.
    /// This member is required.
    public var exportTaskIdentifier: Swift.String?
    /// The name of the IAM role to use for writing to the Amazon S3 bucket
    ///             when exporting a snapshot.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The ID of the Amazon Web Services KMS customer master key (CMK) to use to encrypt the snapshot exported to Amazon S3. The Amazon Web Services KMS
    ///             key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    ///             The caller of this operation must be authorized to
    ///             execute the following operations. These can be set in the Amazon Web Services KMS key policy:
    ///
    ///
    ///                GrantOperation.Encrypt
    ///
    ///
    ///                GrantOperation.Decrypt
    ///
    ///
    ///                GrantOperation.GenerateDataKey
    ///
    ///
    ///                GrantOperation.GenerateDataKeyWithoutPlaintext
    ///
    ///
    ///                GrantOperation.ReEncryptFrom
    ///
    ///
    ///                GrantOperation.ReEncryptTo
    ///
    ///
    ///                GrantOperation.CreateGrant
    ///
    ///
    ///                GrantOperation.DescribeKey
    ///
    ///
    ///                GrantOperation.RetireGrant
    ///
    ///
    /// This member is required.
    public var kmsKeyId: Swift.String?
    /// The name of the Amazon S3 bucket to export the snapshot to.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The Amazon S3 bucket prefix to use as the file name and path of the exported snapshot.
    public var s3Prefix: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to export to Amazon S3.
    /// This member is required.
    public var sourceArn: Swift.String?

    public init (
        exportOnly: [Swift.String]? = nil,
        exportTaskIdentifier: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
        self.sourceArn = sourceArn
    }
}

extension StartExportTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StartExportTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterSnapshotNotFoundFault" : self = .dBClusterSnapshotNotFoundFault(try DBClusterSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotNotFound" : self = .dBSnapshotNotFoundFault(try DBSnapshotNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExportTaskAlreadyExists" : self = .exportTaskAlreadyExistsFault(try ExportTaskAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IamRoleMissingPermissions" : self = .iamRoleMissingPermissionsFault(try IamRoleMissingPermissionsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IamRoleNotFound" : self = .iamRoleNotFoundFault(try IamRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportOnly" : self = .invalidExportOnlyFault(try InvalidExportOnlyFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportSourceState" : self = .invalidExportSourceStateFault(try InvalidExportSourceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketFault" : self = .invalidS3BucketFault(try InvalidS3BucketFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSKeyNotAccessibleFault" : self = .kMSKeyNotAccessibleFault(try KMSKeyNotAccessibleFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExportTaskOutputError: Swift.Error, Swift.Equatable {
    case dBClusterSnapshotNotFoundFault(DBClusterSnapshotNotFoundFault)
    case dBSnapshotNotFoundFault(DBSnapshotNotFoundFault)
    case exportTaskAlreadyExistsFault(ExportTaskAlreadyExistsFault)
    case iamRoleMissingPermissionsFault(IamRoleMissingPermissionsFault)
    case iamRoleNotFoundFault(IamRoleNotFoundFault)
    case invalidExportOnlyFault(InvalidExportOnlyFault)
    case invalidExportSourceStateFault(InvalidExportSourceStateFault)
    case invalidS3BucketFault(InvalidS3BucketFault)
    case kMSKeyNotAccessibleFault(KMSKeyNotAccessibleFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExportTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartExportTaskOutputResponse(exportOnly: \(Swift.String(describing: exportOnly)), exportTaskIdentifier: \(Swift.String(describing: exportTaskIdentifier)), failureCause: \(Swift.String(describing: failureCause)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), percentProgress: \(Swift.String(describing: percentProgress)), s3Bucket: \(Swift.String(describing: s3Bucket)), s3Prefix: \(Swift.String(describing: s3Prefix)), snapshotTime: \(Swift.String(describing: snapshotTime)), sourceArn: \(Swift.String(describing: sourceArn)), status: \(Swift.String(describing: status)), taskEndTime: \(Swift.String(describing: taskEndTime)), taskStartTime: \(Swift.String(describing: taskStartTime)), totalExtractedDataInGB: \(Swift.String(describing: totalExtractedDataInGB)), warningMessage: \(Swift.String(describing: warningMessage)))"}
}

extension StartExportTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportOnly = output.exportOnly
            self.exportTaskIdentifier = output.exportTaskIdentifier
            self.failureCause = output.failureCause
            self.iamRoleArn = output.iamRoleArn
            self.kmsKeyId = output.kmsKeyId
            self.percentProgress = output.percentProgress
            self.s3Bucket = output.s3Bucket
            self.s3Prefix = output.s3Prefix
            self.snapshotTime = output.snapshotTime
            self.sourceArn = output.sourceArn
            self.status = output.status
            self.taskEndTime = output.taskEndTime
            self.taskStartTime = output.taskStartTime
            self.totalExtractedDataInGB = output.totalExtractedDataInGB
            self.warningMessage = output.warningMessage
        } else {
            self.exportOnly = nil
            self.exportTaskIdentifier = nil
            self.failureCause = nil
            self.iamRoleArn = nil
            self.kmsKeyId = nil
            self.percentProgress = 0
            self.s3Bucket = nil
            self.s3Prefix = nil
            self.snapshotTime = nil
            self.sourceArn = nil
            self.status = nil
            self.taskEndTime = nil
            self.taskStartTime = nil
            self.totalExtractedDataInGB = 0
            self.warningMessage = nil
        }
    }
}

/// Contains the details of a snapshot export to Amazon S3.
///
///         This data type is used as a response element in the DescribeExportTasks action.
///
public struct StartExportTaskOutputResponse: Swift.Equatable {
    /// The data exported from the snapshot. Valid values are the following:
    ///
    ///
    ///
    ///                   database - Export all the data from a specified database.
    ///
    ///
    ///
    ///                   database.table
    ///                   table-name -
    ///                 Export a table of the snapshot. This format is valid only for RDS for MySQL, RDS for MariaDB, and Aurora MySQL.
    ///
    ///
    ///
    ///                   database.schema
    ///                   schema-name - Export a database schema of the snapshot.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    ///
    ///
    ///                   database.schema.table
    ///                   table-name - Export a table of the database schema.
    ///                 This format is valid only for RDS for PostgreSQL and Aurora PostgreSQL.
    ///
    ///
    public var exportOnly: [Swift.String]?
    /// A unique identifier for the snapshot export task. This ID isn't an identifier for
    ///             the Amazon S3 bucket where the snapshot is exported to.
    public var exportTaskIdentifier: Swift.String?
    /// The reason the export failed, if it failed.
    public var failureCause: Swift.String?
    /// The name of the IAM role that is used to write to Amazon S3 when exporting a snapshot.
    public var iamRoleArn: Swift.String?
    /// The key identifier of the Amazon Web Services KMS customer master key (CMK) that is used to encrypt the snapshot when it's exported to
    ///             Amazon S3. The Amazon Web Services KMS CMK identifier is its key ARN, key ID, alias ARN, or alias name. The IAM role used for the snapshot export
    ///             must have encryption and decryption permissions to use this Amazon Web Services KMS CMK.
    public var kmsKeyId: Swift.String?
    /// The progress of the snapshot export task as a percentage.
    public var percentProgress: Swift.Int
    /// The Amazon S3 bucket that the snapshot is exported to.
    public var s3Bucket: Swift.String?
    /// The Amazon S3 bucket prefix that is the file name and path of the exported snapshot.
    public var s3Prefix: Swift.String?
    /// The time that the snapshot was created.
    public var snapshotTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the snapshot exported to Amazon S3.
    public var sourceArn: Swift.String?
    /// The progress status of the export task.
    public var status: Swift.String?
    /// The time that the snapshot export task completed.
    public var taskEndTime: ClientRuntime.Date?
    /// The time that the snapshot export task started.
    public var taskStartTime: ClientRuntime.Date?
    /// The total amount of data exported, in gigabytes.
    public var totalExtractedDataInGB: Swift.Int
    /// A warning about the snapshot export task.
    public var warningMessage: Swift.String?

    public init (
        exportOnly: [Swift.String]? = nil,
        exportTaskIdentifier: Swift.String? = nil,
        failureCause: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        percentProgress: Swift.Int = 0,
        s3Bucket: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        snapshotTime: ClientRuntime.Date? = nil,
        sourceArn: Swift.String? = nil,
        status: Swift.String? = nil,
        taskEndTime: ClientRuntime.Date? = nil,
        taskStartTime: ClientRuntime.Date? = nil,
        totalExtractedDataInGB: Swift.Int = 0,
        warningMessage: Swift.String? = nil
    )
    {
        self.exportOnly = exportOnly
        self.exportTaskIdentifier = exportTaskIdentifier
        self.failureCause = failureCause
        self.iamRoleArn = iamRoleArn
        self.kmsKeyId = kmsKeyId
        self.percentProgress = percentProgress
        self.s3Bucket = s3Bucket
        self.s3Prefix = s3Prefix
        self.snapshotTime = snapshotTime
        self.sourceArn = sourceArn
        self.status = status
        self.taskEndTime = taskEndTime
        self.taskStartTime = taskStartTime
        self.totalExtractedDataInGB = totalExtractedDataInGB
        self.warningMessage = warningMessage
    }
}

struct StartExportTaskOutputResponseBody: Swift.Equatable {
    public let exportTaskIdentifier: Swift.String?
    public let sourceArn: Swift.String?
    public let exportOnly: [Swift.String]?
    public let snapshotTime: ClientRuntime.Date?
    public let taskStartTime: ClientRuntime.Date?
    public let taskEndTime: ClientRuntime.Date?
    public let s3Bucket: Swift.String?
    public let s3Prefix: Swift.String?
    public let iamRoleArn: Swift.String?
    public let kmsKeyId: Swift.String?
    public let status: Swift.String?
    public let percentProgress: Swift.Int
    public let totalExtractedDataInGB: Swift.Int
    public let failureCause: Swift.String?
    public let warningMessage: Swift.String?
}

extension StartExportTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportOnly = "ExportOnly"
        case exportTaskIdentifier = "ExportTaskIdentifier"
        case failureCause = "FailureCause"
        case iamRoleArn = "IamRoleArn"
        case kmsKeyId = "KmsKeyId"
        case percentProgress = "PercentProgress"
        case s3Bucket = "S3Bucket"
        case s3Prefix = "S3Prefix"
        case snapshotTime = "SnapshotTime"
        case sourceArn = "SourceArn"
        case status = "Status"
        case taskEndTime = "TaskEndTime"
        case taskStartTime = "TaskStartTime"
        case totalExtractedDataInGB = "TotalExtractedDataInGB"
        case warningMessage = "WarningMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StartExportTaskResult"))
        let exportTaskIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportTaskIdentifier)
        exportTaskIdentifier = exportTaskIdentifierDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.exportOnly) {
            struct KeyVal0{struct member{}}
            let exportOnlyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportOnly)
            if let exportOnlyWrappedContainer = exportOnlyWrappedContainer {
                let exportOnlyContainer = try exportOnlyWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportOnlyBuffer:[Swift.String]? = nil
                if let exportOnlyContainer = exportOnlyContainer {
                    exportOnlyBuffer = [Swift.String]()
                    for stringContainer0 in exportOnlyContainer {
                        exportOnlyBuffer?.append(stringContainer0)
                    }
                }
                exportOnly = exportOnlyBuffer
            } else {
                exportOnly = []
            }
        } else {
            exportOnly = nil
        }
        let snapshotTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotTime)
        var snapshotTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotTimeDecoded = snapshotTimeDecoded {
            snapshotTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotTimeDecoded, format: .dateTime)
        }
        snapshotTime = snapshotTimeBuffer
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskStartTime)
        var taskStartTimeBuffer:ClientRuntime.Date? = nil
        if let taskStartTimeDecoded = taskStartTimeDecoded {
            taskStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskStartTimeDecoded, format: .dateTime)
        }
        taskStartTime = taskStartTimeBuffer
        let taskEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskEndTime)
        var taskEndTimeBuffer:ClientRuntime.Date? = nil
        if let taskEndTimeDecoded = taskEndTimeDecoded {
            taskEndTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(taskEndTimeDecoded, format: .dateTime)
        }
        taskEndTime = taskEndTimeBuffer
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let percentProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let totalExtractedDataInGBDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalExtractedDataInGB)
        totalExtractedDataInGB = totalExtractedDataInGBDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
        let warningMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warningMessage)
        warningMessage = warningMessageDecoded
    }
}

public struct StopActivityStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopActivityStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopActivityStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopActivityStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopActivityStreamOutputError>
}

extension StopActivityStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopActivityStreamInput(applyImmediately: \(Swift.String(describing: applyImmediately)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension StopActivityStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let applyImmediately = applyImmediately {
            try container.encode(applyImmediately, forKey: ClientRuntime.Key("ApplyImmediately"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("StopActivityStream", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StopActivityStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopActivityStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopActivityStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopActivityStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopActivityStreamOutputError>
}

public struct StopActivityStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopActivityStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopActivityStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopActivityStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopActivityStreamOutputError>
}

public struct StopActivityStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopActivityStreamInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopActivityStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopActivityStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopActivityStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopActivityStreamOutputError>
}

public struct StopActivityStreamInput: Swift.Equatable {
    /// Specifies whether or not the database activity stream is to stop as soon as possible,
    ///             regardless of the maintenance window for the database.
    public var applyImmediately: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the DB cluster for the database activity stream.
    ///             For example, arn:aws:rds:us-east-1:12345667890:cluster:das-cluster.
    ///
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        applyImmediately: Swift.Bool? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.applyImmediately = applyImmediately
        self.resourceArn = resourceArn
    }
}

extension StopActivityStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopActivityStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundFault" : self = .resourceNotFoundFault(try ResourceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopActivityStreamOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case resourceNotFoundFault(ResourceNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopActivityStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopActivityStreamOutputResponse(kinesisStreamName: \(Swift.String(describing: kinesisStreamName)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), status: \(Swift.String(describing: status)))"}
}

extension StopActivityStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopActivityStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.kinesisStreamName = output.kinesisStreamName
            self.kmsKeyId = output.kmsKeyId
            self.status = output.status
        } else {
            self.kinesisStreamName = nil
            self.kmsKeyId = nil
            self.status = nil
        }
    }
}

public struct StopActivityStreamOutputResponse: Swift.Equatable {
    /// The name of the Amazon Kinesis data stream used for the database activity stream.
    public var kinesisStreamName: Swift.String?
    /// The Amazon Web Services KMS key identifier used for encrypting messages in the database activity stream.
    ///         The Amazon Web Services KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the Amazon Web Services KMS customer master key (CMK).
    public var kmsKeyId: Swift.String?
    /// The status of the database activity stream.
    public var status: RdsClientTypes.ActivityStreamStatus?

    public init (
        kinesisStreamName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        status: RdsClientTypes.ActivityStreamStatus? = nil
    )
    {
        self.kinesisStreamName = kinesisStreamName
        self.kmsKeyId = kmsKeyId
        self.status = status
    }
}

struct StopActivityStreamOutputResponseBody: Swift.Equatable {
    public let kmsKeyId: Swift.String?
    public let kinesisStreamName: Swift.String?
    public let status: RdsClientTypes.ActivityStreamStatus?
}

extension StopActivityStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamName = "KinesisStreamName"
        case kmsKeyId = "KmsKeyId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopActivityStreamResult"))
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let kinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kinesisStreamName)
        kinesisStreamName = kinesisStreamNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct StopDBClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

extension StopDBClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBClusterInput(dBClusterIdentifier: \(Swift.String(describing: dBClusterIdentifier)))"}
}

extension StopDBClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        try container.encode("StopDBCluster", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StopDBClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBClusterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopDBClusterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopDBClusterInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBClusterOutputError>
}

public struct StopDBClusterInput: Swift.Equatable {
    /// The DB cluster identifier of the Amazon Aurora DB cluster to be stopped. This parameter is stored as
    ///         a lowercase string.
    /// This member is required.
    public var dBClusterIdentifier: Swift.String?

    public init (
        dBClusterIdentifier: Swift.String? = nil
    )
    {
        self.dBClusterIdentifier = dBClusterIdentifier
    }
}

extension StopDBClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBClusterNotFoundFault" : self = .dBClusterNotFoundFault(try DBClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBClusterOutputError: Swift.Error, Swift.Equatable {
    case dBClusterNotFoundFault(DBClusterNotFoundFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBClusterOutputResponse(dBCluster: \(Swift.String(describing: dBCluster)))"}
}

extension StopDBClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBCluster = output.dBCluster
        } else {
            self.dBCluster = nil
        }
    }
}

public struct StopDBClusterOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon Aurora DB cluster.
    ///
    ///          This data type is used as a response element in the DescribeDBClusters,
    ///         StopDBCluster, and StartDBCluster actions.
    ///
    public var dBCluster: RdsClientTypes.DBCluster?

    public init (
        dBCluster: RdsClientTypes.DBCluster? = nil
    )
    {
        self.dBCluster = dBCluster
    }
}

struct StopDBClusterOutputResponseBody: Swift.Equatable {
    public let dBCluster: RdsClientTypes.DBCluster?
}

extension StopDBClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBCluster = "DBCluster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBClusterResult"))
        let dBClusterDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBCluster.self, forKey: .dBCluster)
        dBCluster = dBClusterDecoded
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceAutomatedBackupsReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

extension StopDBInstanceAutomatedBackupsReplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBInstanceAutomatedBackupsReplicationInput(sourceDBInstanceArn: \(Swift.String(describing: sourceDBInstanceArn)))"}
}

extension StopDBInstanceAutomatedBackupsReplicationInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let sourceDBInstanceArn = sourceDBInstanceArn {
            try container.encode(sourceDBInstanceArn, forKey: ClientRuntime.Key("SourceDBInstanceArn"))
        }
        try container.encode("StopDBInstanceAutomatedBackupsReplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceAutomatedBackupsReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StopDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceAutomatedBackupsReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBInstanceAutomatedBackupsReplicationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StopDBInstanceAutomatedBackupsReplicationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceAutomatedBackupsReplicationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopDBInstanceAutomatedBackupsReplicationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopDBInstanceAutomatedBackupsReplicationInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceAutomatedBackupsReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceAutomatedBackupsReplicationOutputError>
}

public struct StopDBInstanceAutomatedBackupsReplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the source DB instance for which to stop replicating automated backups, for example,
    ///             arn:aws:rds:us-west-2:123456789012:db:mydatabase.
    /// This member is required.
    public var sourceDBInstanceArn: Swift.String?

    public init (
        sourceDBInstanceArn: Swift.String? = nil
    )
    {
        self.sourceDBInstanceArn = sourceDBInstanceArn
    }
}

extension StopDBInstanceAutomatedBackupsReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBInstanceAutomatedBackupsReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBInstanceAutomatedBackupsReplicationOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBInstanceAutomatedBackupsReplicationOutputResponse(dBInstanceAutomatedBackup: \(Swift.String(describing: dBInstanceAutomatedBackup)))"}
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBInstanceAutomatedBackupsReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstanceAutomatedBackup = output.dBInstanceAutomatedBackup
        } else {
            self.dBInstanceAutomatedBackup = nil
        }
    }
}

public struct StopDBInstanceAutomatedBackupsReplicationOutputResponse: Swift.Equatable {
    /// An automated backup of a DB instance. It consists of system backups, transaction logs, and the database instance properties that
    ///             existed at the time you deleted the source instance.
    public var dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?

    public init (
        dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup? = nil
    )
    {
        self.dBInstanceAutomatedBackup = dBInstanceAutomatedBackup
    }
}

struct StopDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Equatable {
    public let dBInstanceAutomatedBackup: RdsClientTypes.DBInstanceAutomatedBackup?
}

extension StopDBInstanceAutomatedBackupsReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstanceAutomatedBackup = "DBInstanceAutomatedBackup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBInstanceAutomatedBackupsReplicationResult"))
        let dBInstanceAutomatedBackupDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstanceAutomatedBackup.self, forKey: .dBInstanceAutomatedBackup)
        dBInstanceAutomatedBackup = dBInstanceAutomatedBackupDecoded
    }
}

public struct StopDBInstanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceOutputError>
}

extension StopDBInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBInstanceInput(dBInstanceIdentifier: \(Swift.String(describing: dBInstanceIdentifier)), dBSnapshotIdentifier: \(Swift.String(describing: dBSnapshotIdentifier)))"}
}

extension StopDBInstanceInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dBInstanceIdentifier = dBInstanceIdentifier {
            try container.encode(dBInstanceIdentifier, forKey: ClientRuntime.Key("DBInstanceIdentifier"))
        }
        if let dBSnapshotIdentifier = dBSnapshotIdentifier {
            try container.encode(dBSnapshotIdentifier, forKey: ClientRuntime.Key("DBSnapshotIdentifier"))
        }
        try container.encode("StopDBInstance", forKey:ClientRuntime.Key("Action"))
        try container.encode("2014-10-31", forKey:ClientRuntime.Key("Version"))
    }
}

public struct StopDBInstanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceOutputError>
}

public struct StopDBInstanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopDBInstanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopDBInstanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceOutputError>
}

public struct StopDBInstanceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopDBInstanceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopDBInstanceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopDBInstanceInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopDBInstanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopDBInstanceOutputError>
}

public struct StopDBInstanceInput: Swift.Equatable {
    ///
    ///             The user-supplied instance identifier.
    ///
    /// This member is required.
    public var dBInstanceIdentifier: Swift.String?
    ///
    ///             The user-supplied instance identifier of the DB Snapshot created immediately before the DB instance is stopped.
    ///
    public var dBSnapshotIdentifier: Swift.String?

    public init (
        dBInstanceIdentifier: Swift.String? = nil,
        dBSnapshotIdentifier: Swift.String? = nil
    )
    {
        self.dBInstanceIdentifier = dBInstanceIdentifier
        self.dBSnapshotIdentifier = dBSnapshotIdentifier
    }
}

extension StopDBInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension StopDBInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DBInstanceNotFound" : self = .dBInstanceNotFoundFault(try DBInstanceNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DBSnapshotAlreadyExists" : self = .dBSnapshotAlreadyExistsFault(try DBSnapshotAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBClusterStateFault" : self = .invalidDBClusterStateFault(try InvalidDBClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDBInstanceState" : self = .invalidDBInstanceStateFault(try InvalidDBInstanceStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SnapshotQuotaExceeded" : self = .snapshotQuotaExceededFault(try SnapshotQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDBInstanceOutputError: Swift.Error, Swift.Equatable {
    case dBInstanceNotFoundFault(DBInstanceNotFoundFault)
    case dBSnapshotAlreadyExistsFault(DBSnapshotAlreadyExistsFault)
    case invalidDBClusterStateFault(InvalidDBClusterStateFault)
    case invalidDBInstanceStateFault(InvalidDBInstanceStateFault)
    case snapshotQuotaExceededFault(SnapshotQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDBInstanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopDBInstanceOutputResponse(dBInstance: \(Swift.String(describing: dBInstance)))"}
}

extension StopDBInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDBInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dBInstance = output.dBInstance
        } else {
            self.dBInstance = nil
        }
    }
}

public struct StopDBInstanceOutputResponse: Swift.Equatable {
    /// Contains the details of an Amazon RDS DB instance.
    ///
    ///          This data type is used as a response element in the DescribeDBInstances action.
    ///
    public var dBInstance: RdsClientTypes.DBInstance?

    public init (
        dBInstance: RdsClientTypes.DBInstance? = nil
    )
    {
        self.dBInstance = dBInstance
    }
}

struct StopDBInstanceOutputResponseBody: Swift.Equatable {
    public let dBInstance: RdsClientTypes.DBInstance?
}

extension StopDBInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBInstance = "DBInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("StopDBInstanceResult"))
        let dBInstanceDecoded = try containerValues.decodeIfPresent(RdsClientTypes.DBInstance.self, forKey: .dBInstance)
        dBInstance = dBInstanceDecoded
    }
}

extension StorageQuotaExceededFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageQuotaExceededFault(message: \(Swift.String(describing: message)))"}
}

extension StorageQuotaExceededFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StorageQuotaExceededFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would result in the user exceeding the allowed amount of storage
///             available across all DB instances.
public struct StorageQuotaExceededFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageQuotaExceededFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StorageQuotaExceededFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageTypeNotSupportedFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StorageTypeNotSupportedFault(message: \(Swift.String(describing: message)))"}
}

extension StorageTypeNotSupportedFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<StorageTypeNotSupportedFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Storage of the StorageType specified can't be associated
///             with the DB instance.
public struct StorageTypeNotSupportedFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageTypeNotSupportedFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StorageTypeNotSupportedFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.Subnet: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetOutpost = "SubnetOutpost"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try container.encode(subnetAvailabilityZone, forKey: ClientRuntime.Key("SubnetAvailabilityZone"))
        }
        if let subnetIdentifier = subnetIdentifier {
            try container.encode(subnetIdentifier, forKey: ClientRuntime.Key("SubnetIdentifier"))
        }
        if let subnetOutpost = subnetOutpost {
            try container.encode(subnetOutpost, forKey: ClientRuntime.Key("SubnetOutpost"))
        }
        if let subnetStatus = subnetStatus {
            try container.encode(subnetStatus, forKey: ClientRuntime.Key("SubnetStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetOutpostDecoded = try containerValues.decodeIfPresent(RdsClientTypes.Outpost.self, forKey: .subnetOutpost)
        subnetOutpost = subnetOutpostDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension RdsClientTypes.Subnet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subnet(subnetAvailabilityZone: \(Swift.String(describing: subnetAvailabilityZone)), subnetIdentifier: \(Swift.String(describing: subnetIdentifier)), subnetOutpost: \(Swift.String(describing: subnetOutpost)), subnetStatus: \(Swift.String(describing: subnetStatus)))"}
}

extension RdsClientTypes {
    ///
    ///         This data type is used as a response element for the DescribeDBSubnetGroups operation.
    ///
    public struct Subnet: Swift.Equatable {
        /// Contains Availability Zone information.
        ///          This data type is used as an element in the OrderableDBInstanceOption
        ///             data type.
        public var subnetAvailabilityZone: RdsClientTypes.AvailabilityZone?
        /// The identifier of the subnet.
        public var subnetIdentifier: Swift.String?
        /// If the subnet is associated with an Outpost, this value specifies the Outpost.
        ///         For more information about RDS on Outposts, see <a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-on-outposts.html">Amazon RDS on Amazon Web Services Outposts
        ///             in the Amazon RDS User Guide.
        ///
        public var subnetOutpost: RdsClientTypes.Outpost?
        /// The status of the subnet.
        public var subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: RdsClientTypes.AvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetOutpost: RdsClientTypes.Outpost? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetOutpost = subnetOutpost
            self.subnetStatus = subnetStatus
        }
    }

}

extension SubnetAlreadyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubnetAlreadyInUse(message: \(Swift.String(describing: message)))"}
}

extension SubnetAlreadyInUse {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubnetAlreadyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The DB subnet is already in use in the Availability Zone.
public struct SubnetAlreadyInUse: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetAlreadyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubnetAlreadyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionAlreadyExistFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionAlreadyExistFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionAlreadyExistFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionAlreadyExistFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied subscription name already exists.
public struct SubscriptionAlreadyExistFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionAlreadyExistFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionAlreadyExistFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionCategoryNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionCategoryNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionCategoryNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionCategoryNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied category does not exist.
public struct SubscriptionCategoryNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionCategoryNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionCategoryNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubscriptionNotFoundFault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubscriptionNotFoundFault(message: \(Swift.String(describing: message)))"}
}

extension SubscriptionNotFoundFault {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AWSClientRuntime.ErrorResponseContainer<SubscriptionNotFoundFaultBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The subscription name does not exist.
public struct SubscriptionNotFoundFault: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SubscriptionNotFoundFaultBody: Swift.Equatable {
    public let message: Swift.String?
}

extension SubscriptionNotFoundFaultBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RdsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension RdsClientTypes {
    /// Metadata assigned to an Amazon RDS resource consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// A key is the required name of the tag. The string value can be from 1 to 128 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        public var key: Swift.String?
        /// A value is the optional value of the tag. The string value can be from 1 to 256 Unicode characters in length and can't be prefixed with aws: or rds:. The string can only contain only the set of Unicode letters, digits, white-space, '_', '.', ':', '/', '=', '+', '-', '@' (Java regex: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$").
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RdsClientTypes.TargetHealth: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case reason = "Reason"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: ClientRuntime.Key("Reason"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetState.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RdsClientTypes.TargetHealthReason.self, forKey: .reason)
        reason = reasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RdsClientTypes.TargetHealth: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetHealth(description: \(Swift.String(describing: description)), reason: \(Swift.String(describing: reason)), state: \(Swift.String(describing: state)))"}
}

extension RdsClientTypes {
    /// Information about the connection health of an RDS Proxy target.
    public struct TargetHealth: Swift.Equatable {
        /// A description of the health of the RDS Proxy target.
        ///             If the State is AVAILABLE, a description is not included.
        public var description: Swift.String?
        /// The reason for the current health State of the RDS Proxy target.
        public var reason: RdsClientTypes.TargetHealthReason?
        /// The current state of the connection health lifecycle for the RDS Proxy target.
        ///            The following is a typical lifecycle example for the states of an RDS Proxy target:
        ///
        ///
        ///             registering > unavailable > available > unavailable > available
        ///
        public var state: RdsClientTypes.TargetState?

        public init (
            description: Swift.String? = nil,
            reason: RdsClientTypes.TargetHealthReason? = nil,
            state: RdsClientTypes.TargetState? = nil
        )
        {
            self.description = description
            self.reason = reason
            self.state = state
        }
    }

}

extension RdsClientTypes {
    public enum TargetHealthReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authFailure
        case connectionFailed
        case invalidReplicationState
        case pendingProxyCapacity
        case unreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetHealthReason] {
            return [
                .authFailure,
                .connectionFailed,
                .invalidReplicationState,
                .pendingProxyCapacity,
                .unreachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authFailure: return "AUTH_FAILURE"
            case .connectionFailed: return "CONNECTION_FAILED"
            case .invalidReplicationState: return "INVALID_REPLICATION_STATE"
            case .pendingProxyCapacity: return "PENDING_PROXY_CAPACITY"
            case .unreachable: return "UNREACHABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetHealthReason(rawValue: rawValue) ?? TargetHealthReason.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum TargetRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case readOnly
        case readWrite
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetRole] {
            return [
                .readOnly,
                .readWrite,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .readOnly: return "READ_ONLY"
            case .readWrite: return "READ_WRITE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetRole(rawValue: rawValue) ?? TargetRole.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum TargetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case registering
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetState] {
            return [
                .available,
                .registering,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .registering: return "REGISTERING"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetState(rawValue: rawValue) ?? TargetState.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rdsInstance
        case rdsServerlessEndpoint
        case trackedCluster
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .rdsInstance,
                .rdsServerlessEndpoint,
                .trackedCluster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rdsInstance: return "RDS_INSTANCE"
            case .rdsServerlessEndpoint: return "RDS_SERVERLESS_ENDPOINT"
            case .trackedCluster: return "TRACKED_CLUSTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension RdsClientTypes.Timezone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timezoneName = "TimezoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let timezoneName = timezoneName {
            try container.encode(timezoneName, forKey: ClientRuntime.Key("TimezoneName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timezoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezoneName)
        timezoneName = timezoneNameDecoded
    }
}

extension RdsClientTypes.Timezone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Timezone(timezoneName: \(Swift.String(describing: timezoneName)))"}
}

extension RdsClientTypes {
    /// A time zone associated with a
    ///             DBInstance
    ///             or a DBSnapshot.
    ///             This data type is an element in the response to
    ///             the DescribeDBInstances,
    ///             the DescribeDBSnapshots,
    ///             and the DescribeDBEngineVersions
    ///             actions.
    ///
    public struct Timezone: Swift.Equatable {
        /// The name of the time zone.
        public var timezoneName: Swift.String?

        public init (
            timezoneName: Swift.String? = nil
        )
        {
            self.timezoneName = timezoneName
        }
    }

}

extension RdsClientTypes.UpgradeTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpgrade = "AutoUpgrade"
        case description = "Description"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case isMajorVersionUpgrade = "IsMajorVersionUpgrade"
        case supportedEngineModes = "SupportedEngineModes"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsParallelQuery = "SupportsParallelQuery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if autoUpgrade != false {
            try container.encode(autoUpgrade, forKey: ClientRuntime.Key("AutoUpgrade"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if isMajorVersionUpgrade != false {
            try container.encode(isMajorVersionUpgrade, forKey: ClientRuntime.Key("IsMajorVersionUpgrade"))
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportsGlobalDatabases = supportsGlobalDatabases {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if let supportsParallelQuery = supportsParallelQuery {
            try container.encode(supportsParallelQuery, forKey: ClientRuntime.Key("SupportsParallelQuery"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let autoUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoUpgrade)
        autoUpgrade = autoUpgradeDecoded
        let isMajorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMajorVersionUpgrade)
        isMajorVersionUpgrade = isMajorVersionUpgradeDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsParallelQueryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
    }
}

extension RdsClientTypes.UpgradeTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpgradeTarget(autoUpgrade: \(Swift.String(describing: autoUpgrade)), description: \(Swift.String(describing: description)), engine: \(Swift.String(describing: engine)), engineVersion: \(Swift.String(describing: engineVersion)), isMajorVersionUpgrade: \(Swift.String(describing: isMajorVersionUpgrade)), supportedEngineModes: \(Swift.String(describing: supportedEngineModes)), supportsGlobalDatabases: \(Swift.String(describing: supportsGlobalDatabases)), supportsParallelQuery: \(Swift.String(describing: supportsParallelQuery)))"}
}

extension RdsClientTypes {
    /// The version of the database engine that a DB instance can be upgraded to.
    public struct UpgradeTarget: Swift.Equatable {
        /// A value that indicates whether the target version is applied to any source DB instances that have AutoMinorVersionUpgrade set to true.
        public var autoUpgrade: Swift.Bool
        /// The version of the database engine that a DB instance can be upgraded to.
        public var description: Swift.String?
        /// The name of the upgrade target database engine.
        public var engine: Swift.String?
        /// The version number of the upgrade target database engine.
        public var engineVersion: Swift.String?
        /// A value that indicates whether upgrading to the target version requires upgrading the major version of the database engine.
        public var isMajorVersionUpgrade: Swift.Bool
        /// A list of the supported DB engine modes for the target engine version.
        public var supportedEngineModes: [Swift.String]?
        /// A value that indicates whether you can use Aurora global databases with the target engine version.
        public var supportsGlobalDatabases: Swift.Bool?
        /// A value that indicates whether you can use Aurora parallel query with the target engine version.
        public var supportsParallelQuery: Swift.Bool?

        public init (
            autoUpgrade: Swift.Bool = false,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            isMajorVersionUpgrade: Swift.Bool = false,
            supportedEngineModes: [Swift.String]? = nil,
            supportsGlobalDatabases: Swift.Bool? = nil,
            supportsParallelQuery: Swift.Bool? = nil
        )
        {
            self.autoUpgrade = autoUpgrade
            self.description = description
            self.engine = engine
            self.engineVersion = engineVersion
            self.isMajorVersionUpgrade = isMajorVersionUpgrade
            self.supportedEngineModes = supportedEngineModes
            self.supportsGlobalDatabases = supportsGlobalDatabases
            self.supportsParallelQuery = supportsParallelQuery
        }
    }

}

extension RdsClientTypes.UserAuthConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authScheme = "AuthScheme"
        case description = "Description"
        case iAMAuth = "IAMAuth"
        case secretArn = "SecretArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authScheme = authScheme {
            try container.encode(authScheme, forKey: ClientRuntime.Key("AuthScheme"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let iAMAuth = iAMAuth {
            try container.encode(iAMAuth, forKey: ClientRuntime.Key("IAMAuth"))
        }
        if let secretArn = secretArn {
            try container.encode(secretArn, forKey: ClientRuntime.Key("SecretArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authSchemeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AuthScheme.self, forKey: .authScheme)
        authScheme = authSchemeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let iAMAuthDecoded = try containerValues.decodeIfPresent(RdsClientTypes.IAMAuthMode.self, forKey: .iAMAuth)
        iAMAuth = iAMAuthDecoded
    }
}

extension RdsClientTypes.UserAuthConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserAuthConfig(authScheme: \(Swift.String(describing: authScheme)), description: \(Swift.String(describing: description)), iAMAuth: \(Swift.String(describing: iAMAuth)), secretArn: \(Swift.String(describing: secretArn)), userName: \(Swift.String(describing: userName)))"}
}

extension RdsClientTypes {
    /// Specifies the details of authentication used by a proxy to log in as a specific database user.
    public struct UserAuthConfig: Swift.Equatable {
        /// The type of authentication that the proxy uses for connections from the proxy to the underlying database.
        public var authScheme: RdsClientTypes.AuthScheme?
        /// A user-specified description about the authentication used by a proxy to log in as a specific database user.
        public var description: Swift.String?
        /// Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy.
        public var iAMAuth: RdsClientTypes.IAMAuthMode?
        /// The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate
        ///         to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
        public var secretArn: Swift.String?
        /// The name of the database user to which the proxy connects.
        public var userName: Swift.String?

        public init (
            authScheme: RdsClientTypes.AuthScheme? = nil,
            description: Swift.String? = nil,
            iAMAuth: RdsClientTypes.IAMAuthMode? = nil,
            secretArn: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authScheme = authScheme
            self.description = description
            self.iAMAuth = iAMAuth
            self.secretArn = secretArn
            self.userName = userName
        }
    }

}

extension RdsClientTypes.UserAuthConfigInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authScheme = "AuthScheme"
        case description = "Description"
        case iAMAuth = "IAMAuth"
        case secretArn = "SecretArn"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authScheme = authScheme {
            try container.encode(authScheme, forKey: ClientRuntime.Key("AuthScheme"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let iAMAuth = iAMAuth {
            try container.encode(iAMAuth, forKey: ClientRuntime.Key("IAMAuth"))
        }
        if let secretArn = secretArn {
            try container.encode(secretArn, forKey: ClientRuntime.Key("SecretArn"))
        }
        if let userName = userName {
            try container.encode(userName, forKey: ClientRuntime.Key("UserName"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authSchemeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.AuthScheme.self, forKey: .authScheme)
        authScheme = authSchemeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let iAMAuthDecoded = try containerValues.decodeIfPresent(RdsClientTypes.IAMAuthMode.self, forKey: .iAMAuth)
        iAMAuth = iAMAuthDecoded
    }
}

extension RdsClientTypes.UserAuthConfigInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserAuthConfigInfo(authScheme: \(Swift.String(describing: authScheme)), description: \(Swift.String(describing: description)), iAMAuth: \(Swift.String(describing: iAMAuth)), secretArn: \(Swift.String(describing: secretArn)), userName: \(Swift.String(describing: userName)))"}
}

extension RdsClientTypes {
    /// Returns the details of authentication used by a proxy to log in as a specific database user.
    public struct UserAuthConfigInfo: Swift.Equatable {
        /// The type of authentication that the proxy uses for connections from the proxy to the underlying database.
        public var authScheme: RdsClientTypes.AuthScheme?
        /// A user-specified description about the authentication used by a proxy to log in as a specific database user.
        public var description: Swift.String?
        /// Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy.
        public var iAMAuth: RdsClientTypes.IAMAuthMode?
        /// The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate
        ///         to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager.
        public var secretArn: Swift.String?
        /// The name of the database user to which the proxy connects.
        public var userName: Swift.String?

        public init (
            authScheme: RdsClientTypes.AuthScheme? = nil,
            description: Swift.String? = nil,
            iAMAuth: RdsClientTypes.IAMAuthMode? = nil,
            secretArn: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authScheme = authScheme
            self.description = description
            self.iAMAuth = iAMAuth
            self.secretArn = secretArn
            self.userName = userName
        }
    }

}

extension RdsClientTypes.ValidDBInstanceModificationsMessage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storage = "Storage"
        case validProcessorFeatures = "ValidProcessorFeatures"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let storage = storage {
            var storageContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Storage"))
            for (index0, validstorageoptions0) in storage.enumerated() {
                try storageContainer.encode(validstorageoptions0, forKey: ClientRuntime.Key("ValidStorageOptions.\(index0.advanced(by: 1))"))
            }
        }
        if let validProcessorFeatures = validProcessorFeatures {
            var validProcessorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValidProcessorFeatures"))
            for (index0, availableprocessorfeature0) in validProcessorFeatures.enumerated() {
                try validProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: ClientRuntime.Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.storage) {
            struct KeyVal0{struct ValidStorageOptions{}}
            let storageWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ValidStorageOptions>.CodingKeys.self, forKey: .storage)
            if let storageWrappedContainer = storageWrappedContainer {
                let storageContainer = try storageWrappedContainer.decodeIfPresent([RdsClientTypes.ValidStorageOptions].self, forKey: .member)
                var storageBuffer:[RdsClientTypes.ValidStorageOptions]? = nil
                if let storageContainer = storageContainer {
                    storageBuffer = [RdsClientTypes.ValidStorageOptions]()
                    for structureContainer0 in storageContainer {
                        storageBuffer?.append(structureContainer0)
                    }
                }
                storage = storageBuffer
            } else {
                storage = []
            }
        } else {
            storage = nil
        }
        if containerValues.contains(.validProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let validProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .validProcessorFeatures)
            if let validProcessorFeaturesWrappedContainer = validProcessorFeaturesWrappedContainer {
                let validProcessorFeaturesContainer = try validProcessorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailableProcessorFeature].self, forKey: .member)
                var validProcessorFeaturesBuffer:[RdsClientTypes.AvailableProcessorFeature]? = nil
                if let validProcessorFeaturesContainer = validProcessorFeaturesContainer {
                    validProcessorFeaturesBuffer = [RdsClientTypes.AvailableProcessorFeature]()
                    for structureContainer0 in validProcessorFeaturesContainer {
                        validProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                validProcessorFeatures = validProcessorFeaturesBuffer
            } else {
                validProcessorFeatures = []
            }
        } else {
            validProcessorFeatures = nil
        }
    }
}

extension RdsClientTypes.ValidDBInstanceModificationsMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidDBInstanceModificationsMessage(storage: \(Swift.String(describing: storage)), validProcessorFeatures: \(Swift.String(describing: validProcessorFeatures)))"}
}

extension RdsClientTypes {
    /// Information about valid modifications that you can make to your DB instance.
    ///             Contains the result of a successful call to the
    ///             DescribeValidDBInstanceModifications action.
    ///             You can use this information when you call
    ///             ModifyDBInstance.
    ///
    public struct ValidDBInstanceModificationsMessage: Swift.Equatable {
        /// Valid storage options for your DB instance.
        ///
        public var storage: [RdsClientTypes.ValidStorageOptions]?
        /// Valid processor features for your DB instance.
        ///
        public var validProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]?

        public init (
            storage: [RdsClientTypes.ValidStorageOptions]? = nil,
            validProcessorFeatures: [RdsClientTypes.AvailableProcessorFeature]? = nil
        )
        {
            self.storage = storage
            self.validProcessorFeatures = validProcessorFeatures
        }
    }

}

extension RdsClientTypes.ValidStorageOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iopsToStorageRatio = "IopsToStorageRatio"
        case provisionedIops = "ProvisionedIops"
        case storageSize = "StorageSize"
        case storageType = "StorageType"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let iopsToStorageRatio = iopsToStorageRatio {
            var iopsToStorageRatioContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IopsToStorageRatio"))
            for (index0, doublerange0) in iopsToStorageRatio.enumerated() {
                try iopsToStorageRatioContainer.encode(doublerange0, forKey: ClientRuntime.Key("DoubleRange.\(index0.advanced(by: 1))"))
            }
        }
        if let provisionedIops = provisionedIops {
            var provisionedIopsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProvisionedIops"))
            for (index0, range0) in provisionedIops.enumerated() {
                try provisionedIopsContainer.encode(range0, forKey: ClientRuntime.Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageSize = storageSize {
            var storageSizeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("StorageSize"))
            for (index0, range0) in storageSize.enumerated() {
                try storageSizeContainer.encode(range0, forKey: ClientRuntime.Key("Range.\(index0.advanced(by: 1))"))
            }
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if supportsStorageAutoscaling != false {
            try container.encode(supportsStorageAutoscaling, forKey: ClientRuntime.Key("SupportsStorageAutoscaling"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        if containerValues.contains(.storageSize) {
            struct KeyVal0{struct Range{}}
            let storageSizeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .storageSize)
            if let storageSizeWrappedContainer = storageSizeWrappedContainer {
                let storageSizeContainer = try storageSizeWrappedContainer.decodeIfPresent([RdsClientTypes.Range].self, forKey: .member)
                var storageSizeBuffer:[RdsClientTypes.Range]? = nil
                if let storageSizeContainer = storageSizeContainer {
                    storageSizeBuffer = [RdsClientTypes.Range]()
                    for structureContainer0 in storageSizeContainer {
                        storageSizeBuffer?.append(structureContainer0)
                    }
                }
                storageSize = storageSizeBuffer
            } else {
                storageSize = []
            }
        } else {
            storageSize = nil
        }
        if containerValues.contains(.provisionedIops) {
            struct KeyVal0{struct Range{}}
            let provisionedIopsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Range>.CodingKeys.self, forKey: .provisionedIops)
            if let provisionedIopsWrappedContainer = provisionedIopsWrappedContainer {
                let provisionedIopsContainer = try provisionedIopsWrappedContainer.decodeIfPresent([RdsClientTypes.Range].self, forKey: .member)
                var provisionedIopsBuffer:[RdsClientTypes.Range]? = nil
                if let provisionedIopsContainer = provisionedIopsContainer {
                    provisionedIopsBuffer = [RdsClientTypes.Range]()
                    for structureContainer0 in provisionedIopsContainer {
                        provisionedIopsBuffer?.append(structureContainer0)
                    }
                }
                provisionedIops = provisionedIopsBuffer
            } else {
                provisionedIops = []
            }
        } else {
            provisionedIops = nil
        }
        if containerValues.contains(.iopsToStorageRatio) {
            struct KeyVal0{struct DoubleRange{}}
            let iopsToStorageRatioWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DoubleRange>.CodingKeys.self, forKey: .iopsToStorageRatio)
            if let iopsToStorageRatioWrappedContainer = iopsToStorageRatioWrappedContainer {
                let iopsToStorageRatioContainer = try iopsToStorageRatioWrappedContainer.decodeIfPresent([RdsClientTypes.DoubleRange].self, forKey: .member)
                var iopsToStorageRatioBuffer:[RdsClientTypes.DoubleRange]? = nil
                if let iopsToStorageRatioContainer = iopsToStorageRatioContainer {
                    iopsToStorageRatioBuffer = [RdsClientTypes.DoubleRange]()
                    for structureContainer0 in iopsToStorageRatioContainer {
                        iopsToStorageRatioBuffer?.append(structureContainer0)
                    }
                }
                iopsToStorageRatio = iopsToStorageRatioBuffer
            } else {
                iopsToStorageRatio = []
            }
        } else {
            iopsToStorageRatio = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
    }
}

extension RdsClientTypes.ValidStorageOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidStorageOptions(iopsToStorageRatio: \(Swift.String(describing: iopsToStorageRatio)), provisionedIops: \(Swift.String(describing: provisionedIops)), storageSize: \(Swift.String(describing: storageSize)), storageType: \(Swift.String(describing: storageType)), supportsStorageAutoscaling: \(Swift.String(describing: supportsStorageAutoscaling)))"}
}

extension RdsClientTypes {
    /// Information about valid modifications that you can make to your DB instance.
    ///             Contains the result of a successful call to the
    ///             DescribeValidDBInstanceModifications action.
    ///
    public struct ValidStorageOptions: Swift.Equatable {
        /// The valid range of Provisioned IOPS to gibibytes of storage multiplier.
        ///             For example, 3-10,
        ///             which means that provisioned IOPS can be between 3 and 10 times storage.
        ///
        public var iopsToStorageRatio: [RdsClientTypes.DoubleRange]?
        /// The valid range of provisioned IOPS.
        ///             For example, 1000-20000.
        ///
        public var provisionedIops: [RdsClientTypes.Range]?
        /// The valid range of storage in gibibytes (GiB).
        ///             For example, 100 to 16384.
        ///
        public var storageSize: [RdsClientTypes.Range]?
        /// The valid storage types for your DB instance.
        ///             For example, gp2, io1.
        ///
        public var storageType: Swift.String?
        /// Whether or not Amazon RDS can automatically scale storage for DB instances that use the new instance class.
        public var supportsStorageAutoscaling: Swift.Bool

        public init (
            iopsToStorageRatio: [RdsClientTypes.DoubleRange]? = nil,
            provisionedIops: [RdsClientTypes.Range]? = nil,
            storageSize: [RdsClientTypes.Range]? = nil,
            storageType: Swift.String? = nil,
            supportsStorageAutoscaling: Swift.Bool = false
        )
        {
            self.iopsToStorageRatio = iopsToStorageRatio
            self.provisionedIops = provisionedIops
            self.storageSize = storageSize
            self.storageType = storageType
            self.supportsStorageAutoscaling = supportsStorageAutoscaling
        }
    }

}

extension RdsClientTypes.VpcSecurityGroupMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let vpcSecurityGroupId = vpcSecurityGroupId {
            try container.encode(vpcSecurityGroupId, forKey: ClientRuntime.Key("VpcSecurityGroupId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RdsClientTypes.VpcSecurityGroupMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpcSecurityGroupMembership(status: \(Swift.String(describing: status)), vpcSecurityGroupId: \(Swift.String(describing: vpcSecurityGroupId)))"}
}

extension RdsClientTypes {
    /// This data type is used as a response element for queries on VPC security group membership.
    public struct VpcSecurityGroupMembership: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The name of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension RdsClientTypes.VpnDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpnGatewayIp = "VpnGatewayIp"
        case vpnId = "VpnId"
        case vpnName = "VpnName"
        case vpnPSK = "VpnPSK"
        case vpnState = "VpnState"
        case vpnTunnelOriginatorIP = "VpnTunnelOriginatorIP"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let vpnGatewayIp = vpnGatewayIp {
            try container.encode(vpnGatewayIp, forKey: ClientRuntime.Key("VpnGatewayIp"))
        }
        if let vpnId = vpnId {
            try container.encode(vpnId, forKey: ClientRuntime.Key("VpnId"))
        }
        if let vpnName = vpnName {
            try container.encode(vpnName, forKey: ClientRuntime.Key("VpnName"))
        }
        if let vpnPSK = vpnPSK {
            try container.encode(vpnPSK, forKey: ClientRuntime.Key("VpnPSK"))
        }
        if let vpnState = vpnState {
            try container.encode(vpnState, forKey: ClientRuntime.Key("VpnState"))
        }
        if let vpnTunnelOriginatorIP = vpnTunnelOriginatorIP {
            try container.encode(vpnTunnelOriginatorIP, forKey: ClientRuntime.Key("VpnTunnelOriginatorIP"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpnIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnId)
        vpnId = vpnIdDecoded
        let vpnTunnelOriginatorIPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnTunnelOriginatorIP)
        vpnTunnelOriginatorIP = vpnTunnelOriginatorIPDecoded
        let vpnGatewayIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnGatewayIp)
        vpnGatewayIp = vpnGatewayIpDecoded
        let vpnPSKDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnPSK)
        vpnPSK = vpnPSKDecoded
        let vpnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnName)
        vpnName = vpnNameDecoded
        let vpnStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnState)
        vpnState = vpnStateDecoded
    }
}

extension RdsClientTypes.VpnDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VpnDetails(vpnGatewayIp: \(Swift.String(describing: vpnGatewayIp)), vpnId: \(Swift.String(describing: vpnId)), vpnName: \(Swift.String(describing: vpnName)), vpnPSK: \(Swift.String(describing: vpnPSK)), vpnState: \(Swift.String(describing: vpnState)), vpnTunnelOriginatorIP: \(Swift.String(describing: vpnTunnelOriginatorIP)))"}
}

extension RdsClientTypes {
    /// Information about the virtual private network (VPN) between the VMware vSphere cluster and the Amazon Web Services website.
    ///         For more information about RDS on VMware, see the
    ///             <a href="https://docs.aws.amazon.com/AmazonRDS/latest/RDSonVMwareUserGuide/rds-on-vmware.html">
    ///                 RDS on VMware User Guide.
    ///
    public struct VpnDetails: Swift.Equatable {
        /// The IP address of network traffic from Amazon Web Services to your on-premises data center.
        public var vpnGatewayIp: Swift.String?
        /// The ID of the VPN.
        public var vpnId: Swift.String?
        /// The name of the VPN.
        public var vpnName: Swift.String?
        /// The preshared key (PSK) for the VPN.
        public var vpnPSK: Swift.String?
        /// The state of the VPN.
        public var vpnState: Swift.String?
        /// The IP address of network traffic from your on-premises data center. A custom AZ receives the network traffic.
        public var vpnTunnelOriginatorIP: Swift.String?

        public init (
            vpnGatewayIp: Swift.String? = nil,
            vpnId: Swift.String? = nil,
            vpnName: Swift.String? = nil,
            vpnPSK: Swift.String? = nil,
            vpnState: Swift.String? = nil,
            vpnTunnelOriginatorIP: Swift.String? = nil
        )
        {
            self.vpnGatewayIp = vpnGatewayIp
            self.vpnId = vpnId
            self.vpnName = vpnName
            self.vpnPSK = vpnPSK
            self.vpnState = vpnState
            self.vpnTunnelOriginatorIP = vpnTunnelOriginatorIP
        }
    }

}

extension RdsClientTypes {
    public enum WriteForwardingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [WriteForwardingStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .disabling: return "disabling"
            case .enabled: return "enabled"
            case .enabling: return "enabling"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WriteForwardingStatus(rawValue: rawValue) ?? WriteForwardingStatus.sdkUnknown(rawValue)
        }
    }
}
