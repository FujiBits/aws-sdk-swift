// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDenied: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDenied(message: \(Swift.String(describing: message)))"}
}

extension AccessDenied: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<AccessDeniedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access denied.</p>
public struct AccessDenied: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for kgkeypairids0 in items {
                try itemsContainer.encode(kgkeypairids0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KGKeyPairIds].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KGKeyPairIds]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KGKeyPairIds]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveTrustedKeyGroups(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ActiveTrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of key groups, and the public keys in each key group,
    /// 			that CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
    public struct ActiveTrustedKeyGroups: Swift.Equatable {
        /// <p>This field is <code>true</code> if any of the key groups have public keys that CloudFront can use
        /// 			to verify the signatures of signed URLs and signed cookies. If not, this field is
        /// 			<code>false</code>.</p>
        public let enabled: Swift.Bool?
        /// <p>A list of key groups, including the identifiers of the public keys in each key group that
        /// 			CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
        public let items: [CloudFrontClientTypes.KGKeyPairIds]?
        /// <p>The number of key groups in the list.</p>
        public let quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.KGKeyPairIds]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ActiveTrustedSigners: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for signer0 in items {
                try itemsContainer.encode(signer0, forKey: ClientRuntime.Key("Signer"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Signer{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Signer>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Signer].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Signer]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Signer]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ActiveTrustedSigners: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveTrustedSigners(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ActiveTrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of AWS accounts and the active CloudFront key pairs in each account that CloudFront can use
    /// 			to verify the signatures of signed URLs and signed cookies.</p>
    public struct ActiveTrustedSigners: Swift.Equatable {
        /// <p>This field is <code>true</code> if any of the AWS accounts in the list have active CloudFront
        /// 			key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies.
        /// 			If not, this field is <code>false</code>.</p>
        public let enabled: Swift.Bool?
        /// <p>A list of AWS accounts and the identifiers of active CloudFront key pairs in each account that
        /// 			CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
        public let items: [CloudFrontClientTypes.Signer]?
        /// <p>The number of AWS accounts in the list.</p>
        public let quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.Signer]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AliasICPRecordal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cNAME = "CNAME"
        case iCPRecordalStatus = "ICPRecordalStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cNAME = cNAME {
            try container.encode(cNAME, forKey: ClientRuntime.Key("CNAME"))
        }
        if let iCPRecordalStatus = iCPRecordalStatus {
            try container.encode(iCPRecordalStatus, forKey: ClientRuntime.Key("ICPRecordalStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cNAMEDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let iCPRecordalStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ICPRecordalStatus.self, forKey: .iCPRecordalStatus)
        iCPRecordalStatus = iCPRecordalStatusDecoded
    }
}

extension CloudFrontClientTypes.AliasICPRecordal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AliasICPRecordal(cNAME: \(Swift.String(describing: cNAME)), iCPRecordalStatus: \(Swift.String(describing: iCPRecordalStatus)))"}
}

extension CloudFrontClientTypes.AliasICPRecordal: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
    /// 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
    /// 			recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure
    /// 			it yourself.</p>
    /// 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
    /// 			Signup, Accounts, and Credentials</a> in <i>Getting Started with AWS services in China</i>.</p>
    public struct AliasICPRecordal: Swift.Equatable {
        /// <p>A domain name associated with a distribution. </p>
        public let cNAME: Swift.String?
        /// <p>The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to
        /// 			APPROVED for all CNAMEs (aliases) in regions outside of China. </p>
        /// 		       <p>The status values returned are the following:</p>
        /// 		       <ul>
        ///             <li>
        ///                <p>
        ///                   <b>APPROVED</b> indicates that the associated CNAME has a valid ICP recordal number.
        /// 			Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as
        /// 			APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>SUSPENDED</b> indicates that the associated CNAME does not have a valid ICP recordal
        /// 				number.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>PENDING</b> indicates that CloudFront can't determine the ICP recordal status of the
        /// 				CNAME associated with the distribution because there was an error in trying to determine the status. You can try again
        /// 				to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.</p>
        ///             </li>
        ///          </ul>
        public let iCPRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus?

        public init (
            cNAME: Swift.String? = nil,
            iCPRecordalStatus: CloudFrontClientTypes.ICPRecordalStatus? = nil
        )
        {
            self.cNAME = cNAME
            self.iCPRecordalStatus = iCPRecordalStatus
        }
    }

}

extension CloudFrontClientTypes.Aliases: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("CNAME"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CNAME{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CNAME>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Aliases: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Aliases(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Aliases: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
    /// 			for this distribution. </p>
    public struct Aliases: Swift.Equatable {
        /// <p>A complex type that contains the CNAME aliases, if any, that you want to associate with
        /// 			this distribution.</p>
        public let items: [Swift.String]?
        /// <p>The number of CNAME aliases, if any, that you want to associate with this
        /// 			distribution.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.AllowedMethods: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachedMethods = "CachedMethods"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachedMethods = cachedMethods {
            try container.encode(cachedMethods, forKey: ClientRuntime.Key("CachedMethods"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let cachedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachedMethods.self, forKey: .cachedMethods)
        cachedMethods = cachedMethodsDecoded
    }
}

extension CloudFrontClientTypes.AllowedMethods: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllowedMethods(cachedMethods: \(Swift.String(describing: cachedMethods)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.AllowedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
    /// 			Amazon S3 bucket or your custom origin. There are three choices:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
    /// 					requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
    /// 						<code>DELETE</code> requests.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
    /// 			to your custom origin so users can't perform operations that you don't want them to. For
    /// 			example, you might not want users to have permissions to delete objects from your
    /// 			origin.</p>
    public struct AllowedMethods: Swift.Equatable {
        /// <p>A complex type that controls whether CloudFront caches the response to requests using the
        /// 			specified HTTP methods. There are two choices:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>CloudFront caches responses to <code>GET</code> and <code>HEAD</code> requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>CloudFront caches responses to <code>GET</code>, <code>HEAD</code>, and
        /// 						<code>OPTIONS</code> requests.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>If you pick the second choice for your Amazon S3 Origin, you may need to forward
        /// 			Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the
        /// 			responses to be cached correctly. </p>
        public let cachedMethods: CloudFrontClientTypes.CachedMethods?
        /// <p>A complex type that contains the HTTP methods that you want CloudFront to process and forward
        /// 			to your origin.</p>
        public let items: [CloudFrontClientTypes.Method]?
        /// <p>The number of HTTP methods that you want CloudFront to forward to your origin. Valid values
        /// 			are 2 (for <code>GET</code> and <code>HEAD</code> requests), 3 (for <code>GET</code>,
        /// 				<code>HEAD</code>, and <code>OPTIONS</code> requests) and 7 (for <code>GET, HEAD, OPTIONS,
        /// 				PUT, PATCH, POST</code>, and <code>DELETE</code> requests).</p>
        public let quantity: Swift.Int?

        public init (
            cachedMethods: CloudFrontClientTypes.CachedMethods? = nil,
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.cachedMethods = cachedMethods
            self.items = items
            self.quantity = quantity
        }
    }

}

extension BatchTooLarge: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchTooLarge(message: \(Swift.String(describing: message)))"}
}

extension BatchTooLarge: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<BatchTooLargeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Invalidation batch specified is too large.</p>
public struct BatchTooLarge: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BatchTooLargeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BatchTooLargeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CNAMEAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CNAMEAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension CNAMEAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CNAMEAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CNAME specified is already defined for CloudFront.</p>
public struct CNAMEAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CNAMEAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CNAMEAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case pathPattern = "PathPattern"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let pathPattern = pathPattern {
            try container.encode(pathPattern, forKey: ClientRuntime.Key("PathPattern"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPattern)
        pathPattern = pathPatternDecoded
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.CacheBehavior: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CacheBehavior(allowedMethods: \(Swift.String(describing: allowedMethods)), cachePolicyId: \(Swift.String(describing: cachePolicyId)), compress: \(Swift.String(describing: compress)), defaultTTL: \(Swift.String(describing: defaultTTL)), fieldLevelEncryptionId: \(Swift.String(describing: fieldLevelEncryptionId)), forwardedValues: \(Swift.String(describing: forwardedValues)), functionAssociations: \(Swift.String(describing: functionAssociations)), lambdaFunctionAssociations: \(Swift.String(describing: lambdaFunctionAssociations)), maxTTL: \(Swift.String(describing: maxTTL)), minTTL: \(Swift.String(describing: minTTL)), originRequestPolicyId: \(Swift.String(describing: originRequestPolicyId)), pathPattern: \(Swift.String(describing: pathPattern)), realtimeLogConfigArn: \(Swift.String(describing: realtimeLogConfigArn)), smoothStreaming: \(Swift.String(describing: smoothStreaming)), targetOriginId: \(Swift.String(describing: targetOriginId)), trustedKeyGroups: \(Swift.String(describing: trustedKeyGroups)), trustedSigners: \(Swift.String(describing: trustedSigners)), viewerProtocolPolicy: \(Swift.String(describing: viewerProtocolPolicy)))"}
}

extension CloudFrontClientTypes.CacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that describes how CloudFront processes requests.</p>
    /// 		       <p>You must create at least as many cache behaviors (including the default cache behavior) as
    /// 			you have origins if you want CloudFront to serve objects from all of the origins. Each cache
    /// 			behavior specifies the one origin from which you want CloudFront to get objects. If you have
    /// 			two origins and only the default cache behavior, the default cache behavior will cause
    /// 			CloudFront to get objects from one of the origins, but the other origin is never used.</p>
    /// 		       <p>For the current quota (formerly known as limit) on the number of cache behaviors that you
    /// 			can add to a distribution, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you don’t want to specify any cache behaviors, include only an empty
    /// 			<code>CacheBehaviors</code> element. Don’t include an empty <code>CacheBehavior</code>
    /// 			element because this is invalid.</p>
    /// 		       <p>To delete all cache behaviors in an existing distribution, update the distribution
    /// 			configuration and include only an empty <code>CacheBehaviors</code> element.</p>
    /// 		       <p>To add, change, or remove one or more cache behaviors, update the distribution
    /// 			configuration and specify all of the cache behaviors that you want to include in the updated
    /// 			distribution.</p>
    /// 		       <p>For more information about cache behaviors, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior">Cache Behavior Settings</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public struct CacheBehavior: Swift.Equatable {
        /// <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
        /// 			Amazon S3 bucket or your custom origin. There are three choices:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
        /// 					requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
        /// 						<code>DELETE</code> requests.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
        /// 			to your custom origin so users can't perform operations that you don't want them to. For
        /// 			example, you might not want users to have permissions to delete objects from your
        /// 			origin.</p>
        public let allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// <p>The unique identifier of the cache policy that is attached to this cache behavior. For more
        /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        ///             <i>Amazon CloudFront Developer Guide</i>.</p>
        ///         <p>A <code>CacheBehavior</code> must include either a
        ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
        ///             use a <code>CachePolicyId</code>.</p>
        public let cachePolicyId: Swift.String?
        /// <p>Whether you want CloudFront to automatically compress certain files for this cache behavior.
        /// 			If so, specify true; if not, specify false. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">Serving Compressed Files</a> in the
        /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
        public let compress: Swift.Bool?
        /// <p>This field is deprecated. We recommend that you use the <code>DefaultTTL</code> field in a
        /// 			cache policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The default amount of time that you want objects to stay in CloudFront caches before CloudFront
        /// 			forwards another request to your origin to determine whether the object has been updated. The
        /// 			value that you specify applies only when your origin does not add HTTP headers such as
        /// 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
        /// 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
        /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        @available(*, deprecated)
        public let defaultTTL: Swift.Int?
        /// <p>The value of <code>ID</code> for the field-level encryption configuration that you want CloudFront
        /// 			to use for encrypting specific fields of data for this cache behavior.</p>
        public let fieldLevelEncryptionId: Swift.String?
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html">Working with policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to include values in the cache key, use a cache policy. For more
        /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send values to the origin but not include them in the cache key, use an
        /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
        ///             <i>Amazon CloudFront Developer Guide</i>.</p>
        ///         <p>A <code>CacheBehavior</code> must include either a
        ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
        ///             use a <code>CachePolicyId</code>.</p>
        /// 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
        @available(*, deprecated)
        public let forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// <p>A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must
        /// 			be published to the <code>LIVE</code> stage to associate them with a cache
        /// 			behavior.</p>
        public let functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// <p>A complex type that contains zero or more Lambda function associations for a cache
        /// 			behavior.</p>
        public let lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// <p>This field is deprecated. We recommend that you use the <code>MaxTTL</code> field in a cache
        /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront
        /// 			forwards another request to your origin to determine whether the object has been updated. The
        /// 			value that you specify applies only when your origin adds HTTP headers such as
        /// 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
        /// 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
        /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        @available(*, deprecated)
        public let maxTTL: Swift.Int?
        /// <p>This field is deprecated. We recommend that you use the <code>MinTTL</code> field in a cache
        /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront
        /// 			forwards another request to your origin to determine whether the object has been updated. For
        /// 			more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">
        /// 				Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the <i>
        /// 				Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>You must specify <code>0</code> for <code>MinTTL</code> if you configure CloudFront to
        /// 			forward all headers to your origin (under <code>Headers</code>, if you specify <code>1</code>
        /// 			for <code>Quantity</code> and <code>*</code> for <code>Name</code>).</p>
        @available(*, deprecated)
        public let minTTL: Swift.Int?
        /// <p>The unique identifier of the origin request policy that is attached to this cache behavior.
        /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originRequestPolicyId: Swift.String?
        /// <p>The pattern (for example, <code>images/*.jpg</code>) that specifies which requests to
        /// 			apply the behavior to. When CloudFront receives a viewer request, the requested path is compared
        /// 			with path patterns in the order in which cache behaviors are listed in the
        /// 			distribution.</p>
        /// 		       <note>
        /// 			         <p>You can optionally include a slash (<code>/</code>) at the beginning of the path
        /// 				pattern. For example, <code>/images/*.jpg</code>. CloudFront behavior is the same with or without
        /// 				the leading <code>/</code>.</p>
        /// 		       </note>
        /// 		       <p>The path pattern for the default cache behavior is <code>*</code> and cannot be
        /// 			changed. If the request for an object does not match the path pattern for any cache behaviors,
        /// 			CloudFront applies the behavior in the default cache behavior.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern">Path
        /// 				Pattern</a> in the <i> Amazon CloudFront Developer Guide</i>.</p>
        public let pathPattern: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this
        /// 			cache behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let realtimeLogConfigArn: Swift.String?
        /// <p>Indicates whether you want to distribute media files in the Microsoft Smooth Streaming
        /// 			format using the origin that is associated with this cache behavior. If so, specify
        /// 				<code>true</code>; if not, specify <code>false</code>. If you specify <code>true</code> for
        /// 				<code>SmoothStreaming</code>, you can still distribute other content using this cache
        /// 			behavior if the content matches the value of <code>PathPattern</code>. </p>
        public let smoothStreaming: Swift.Bool?
        /// <p>The value of <code>ID</code> for the origin that you want CloudFront to route requests to
        /// 			when they match this cache behavior.</p>
        public let targetOriginId: Swift.String?
        /// <p>A list of key groups that CloudFront can use to validate signed URLs or signed cookies.</p>
        /// 		       <p>When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed
        /// 			cookies for all requests that match the cache behavior. The URLs or cookies must be
        /// 			signed with a private key whose corresponding public key is in the key group. The signed
        /// 			URL or cookie contains information about which public key CloudFront should use to verify the
        /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// <important>
        /// 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
        /// 				<code>TrustedSigners</code>.</p>
        /// 		       </important>
        /// 		       <p>A list of AWS account IDs whose public keys CloudFront can use to validate signed URLs or signed
        /// 			cookies.</p>
        /// 		       <p>When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies
        /// 			for all requests that match the cache behavior. The URLs or cookies must be signed with
        /// 			the private key of a CloudFront key pair in the trusted signer’s AWS account. The signed URL
        /// 			or cookie contains information about which public key CloudFront should use to verify the
        /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// <p>The protocol that viewers can use to access the files in the origin specified by
        /// 				<code>TargetOriginId</code> when a request matches the path pattern in
        /// 				<code>PathPattern</code>. You can specify the following options:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>allow-all</code>: Viewers can use HTTP or HTTPS.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>redirect-to-https</code>: If a viewer submits an HTTP request, CloudFront returns
        /// 					an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The
        /// 					viewer then resubmits the request using the new URL. </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>https-only</code>: If a viewer sends an HTTP request, CloudFront returns an HTTP
        /// 					status code of 403 (Forbidden). </p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information about requiring the HTTPS protocol, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html">Requiring HTTPS Between Viewers and CloudFront</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <note>
        /// 			         <p>The only way to guarantee that viewers retrieve an object that was fetched from the origin
        /// 				using HTTPS is never to use any other protocol to fetch the object. If you have
        /// 				recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache
        /// 				because cached objects are protocol agnostic. That means that an edge location will
        /// 				return an object from the cache regardless of whether the current request protocol
        /// 				matches the protocol used previously. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing Cache Expiration</a> in the
        /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       </note>
        public let viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init (
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            pathPattern: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.pathPattern = pathPattern
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension CloudFrontClientTypes.CacheBehaviors: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachebehavior0 in items {
                try itemsContainer.encode(cachebehavior0, forKey: ClientRuntime.Key("CacheBehavior"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CacheBehavior{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheBehavior>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CacheBehavior].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CacheBehavior]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CacheBehavior]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CacheBehaviors: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CacheBehaviors(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CacheBehaviors: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains zero or more <code>CacheBehavior</code> elements.
    /// 		</p>
    public struct CacheBehaviors: Swift.Equatable {
        /// <p>Optional: A complex type that contains cache behaviors for this distribution. If
        /// 				<code>Quantity</code> is <code>0</code>, you can omit <code>Items</code>.</p>
        public let items: [CloudFrontClientTypes.CacheBehavior]?
        /// <p>The number of cache behaviors for this distribution. </p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CacheBehavior]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CachePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.CachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicy(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.CachePolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A cache policy.</p>
    /// 		       <p>When it’s attached to a cache behavior, the cache policy determines the
    /// 			following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The values that CloudFront includes in the cache key. These values can include HTTP headers,
    /// 					cookies, and URL query strings. CloudFront uses the cache key to find an object in its
    /// 					cache that it can return to the viewer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
    /// 					in the CloudFront cache.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
    /// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
    /// 			find a valid object in its cache that matches the request’s cache key. If you want to
    /// 			send values to the origin but <i>not</i> include them in the cache key,
    /// 			use <code>OriginRequestPolicy</code>.</p>
    public struct CachePolicy: Swift.Equatable {
        /// <p>The cache policy configuration.</p>
        public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
        /// <p>The unique identifier for the cache policy.</p>
        public let id: Swift.String?
        /// <p>The date and time when the cache policy was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?

        public init (
            cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.cachePolicyConfig = cachePolicyConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CachePolicyAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension CachePolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CachePolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A cache policy with this name already exists. You must provide a unique name. To
/// 			modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
public struct CachePolicyAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CachePolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case defaultTTL = "DefaultTTL"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case name = "Name"
        case parametersInCacheKeyAndForwardedToOrigin = "ParametersInCacheKeyAndForwardedToOrigin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin {
            try container.encode(parametersInCacheKeyAndForwardedToOrigin, forKey: ClientRuntime.Key("ParametersInCacheKeyAndForwardedToOrigin"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let parametersInCacheKeyAndForwardedToOriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin.self, forKey: .parametersInCacheKeyAndForwardedToOrigin)
        parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOriginDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyConfig(comment: \(Swift.String(describing: comment)), defaultTTL: \(Swift.String(describing: defaultTTL)), maxTTL: \(Swift.String(describing: maxTTL)), minTTL: \(Swift.String(describing: minTTL)), name: \(Swift.String(describing: name)), parametersInCacheKeyAndForwardedToOrigin: \(Swift.String(describing: parametersInCacheKeyAndForwardedToOrigin)))"}
}

extension CloudFrontClientTypes.CachePolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A cache policy configuration.</p>
    /// 		       <p>This configuration determines the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The values that CloudFront includes in the cache key. These values can include HTTP headers,
    /// 					cookies, and URL query strings. CloudFront uses the cache key to find an object in its
    /// 					cache that it can return to the viewer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
    /// 					in the CloudFront cache.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
    /// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
    /// 			find a valid object in its cache that matches the request’s cache key. If you want to
    /// 			send values to the origin but <i>not</i> include them in the cache key,
    /// 			use <code>OriginRequestPolicy</code>.</p>
    public struct CachePolicyConfig: Swift.Equatable {
        /// <p>A comment to describe the cache policy. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>The default amount of time, in seconds, that you want objects to stay in the CloudFront
        /// 			cache before CloudFront sends another request to the origin to see if the object has been
        /// 			updated. CloudFront uses this value as the object’s time to live (TTL) only when the origin
        /// 			does <i>not</i> send <code>Cache-Control</code> or <code>Expires</code>
        /// 			headers with the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The default value for this field is 86400 seconds (one day). If the value of
        /// 			<code>MinTTL</code> is more than 86400 seconds, then the default value for this field is
        /// 			the same as the value of <code>MinTTL</code>.</p>
        public let defaultTTL: Swift.Int?
        /// <p>The maximum amount of time, in seconds, that objects stay in the CloudFront cache
        /// 			before CloudFront sends another request to the origin to see if the object has been updated.
        /// 			CloudFront uses this value only when the origin sends <code>Cache-Control</code> or
        /// 			<code>Expires</code> headers with the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The default value for this field is 31536000 seconds (one year). If the value of
        /// 			<code>MinTTL</code> or <code>DefaultTTL</code> is more than 31536000 seconds, then the
        /// 			default value for this field is the same as the value of <code>DefaultTTL</code>.</p>
        public let maxTTL: Swift.Int?
        /// <p>The minimum amount of time, in seconds, that you want objects to stay in the CloudFront
        /// 			cache before CloudFront sends another request to the origin to see if the object has been
        /// 			updated. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let minTTL: Swift.Int?
        /// <p>A unique name to identify the cache policy.</p>
        public let name: Swift.String?
        /// <p>The HTTP headers, cookies, and URL query strings to include in the cache key. The
        /// 			values included in the cache key are automatically included in requests that CloudFront sends
        /// 			to the origin.</p>
        public let parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin?

        public init (
            comment: Swift.String? = nil,
            defaultTTL: Swift.Int? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            name: Swift.String? = nil,
            parametersInCacheKeyAndForwardedToOrigin: CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin? = nil
        )
        {
            self.comment = comment
            self.defaultTTL = defaultTTL
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.name = name
            self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyCookieBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyCookieBehavior(rawValue: rawValue) ?? CachePolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyCookiesConfig(cookieBehavior: \(Swift.String(describing: cookieBehavior)), cookies: \(Swift.String(describing: cookies)))"}
}

extension CloudFrontClientTypes.CachePolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
    /// 			are included in the cache key and automatically included in requests that CloudFront sends to
    /// 			the origin.</p>
    public struct CachePolicyCookiesConfig: Swift.Equatable {
        /// <p>Determines whether any cookies in viewer requests are included in the cache key and
        /// 			automatically included in requests that CloudFront sends to the origin. Valid values
        /// 			are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code> – Cookies in viewer requests are not included in the cache key and are
        /// 					not automatically included in requests that CloudFront sends to the origin. Even when
        /// 					this field is set to <code>none</code>, any cookies that are listed in an
        /// 					<code>OriginRequestPolicy</code>
        ///                   <i>are</i> included in origin
        /// 					requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code> – The cookies in viewer requests that are listed in the
        /// 					<code>CookieNames</code> type are included in the cache key and automatically
        /// 					included in requests that CloudFront sends to the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>allExcept</code> – All cookies in viewer requests that are <i>
        ///                      <b>not</b>
        ///                   </i> listed in the <code>CookieNames</code>
        /// 					type are included in the cache key and automatically included in requests that
        /// 					CloudFront sends to the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>all</code> – All cookies in viewer requests are included in the cache key and are
        /// 					automatically included in requests that CloudFront sends to the origin.</p>
        /// 			         </li>
        ///          </ul>
        public let cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior?
        /// <p>Contains a list of cookie names.</p>
        public let cookies: CloudFrontClientTypes.CookieNames?

        public init (
            cookieBehavior: CloudFrontClientTypes.CachePolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyHeaderBehavior] {
            return [
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyHeaderBehavior(rawValue: rawValue) ?? CachePolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyHeadersConfig(headerBehavior: \(Swift.String(describing: headerBehavior)), headers: \(Swift.String(describing: headers)))"}
}

extension CloudFrontClientTypes.CachePolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An object that determines whether any HTTP headers (and if so, which headers) are included
    /// 			in the cache key and automatically included in requests that CloudFront sends to the
    /// 			origin.</p>
    public struct CachePolicyHeadersConfig: Swift.Equatable {
        /// <p>Determines whether any HTTP headers are included in the cache key and automatically
        /// 			included in requests that CloudFront sends to the origin. Valid values are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code> – HTTP headers are not included in the cache key and are not
        /// 					automatically included in requests that CloudFront sends to the origin. Even when this
        /// 					field is set to <code>none</code>, any headers that are listed in an
        /// 					<code>OriginRequestPolicy</code>
        ///                   <i>are</i> included in origin
        /// 					requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code> – The HTTP headers that are listed in the <code>Headers</code> type
        /// 					are included in the cache key and are automatically included in requests that
        /// 					CloudFront sends to the origin.</p>
        /// 			         </li>
        ///          </ul>
        public let headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior?
        /// <p>Contains a list of HTTP header names.</p>
        public let headers: CloudFrontClientTypes.Headers?

        public init (
            headerBehavior: CloudFrontClientTypes.CachePolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension CachePolicyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyInUse(message: \(Swift.String(describing: message)))"}
}

extension CachePolicyInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CachePolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the cache policy because it is attached to one or more cache
/// 			behaviors.</p>
public struct CachePolicyInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CachePolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cachepolicysummary0 in items {
                try itemsContainer.encode(cachepolicysummary0, forKey: ClientRuntime.Key("CachePolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CachePolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CachePolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CachePolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CachePolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CachePolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachePolicyList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CachePolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of cache policies.</p>
    public struct CachePolicyList: Swift.Equatable {
        /// <p>Contains the cache policies in the list.</p>
        public let items: [CloudFrontClientTypes.CachePolicySummary]?
        /// <p>The maximum number of cache policies requested.</p>
        public let maxItems: Swift.Int?
        /// <p>If there are more items in the list than are in this response, this element is
        /// 			present. It contains the value that you should use in the <code>Marker</code> field of a
        /// 			subsequent request to continue listing cache policies where you left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The total number of cache policies returned in the response.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CachePolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case allexcept
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyQueryStringBehavior] {
            return [
                .all,
                .allexcept,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .allexcept: return "allExcept"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyQueryStringBehavior(rawValue: rawValue) ?? CachePolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicyQueryStringsConfig(queryStringBehavior: \(Swift.String(describing: queryStringBehavior)), queryStrings: \(Swift.String(describing: queryStrings)))"}
}

extension CloudFrontClientTypes.CachePolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An object that determines whether any URL query strings in viewer requests (and if so, which
    /// 			query strings) are included in the cache key and automatically included in requests that
    /// 			CloudFront sends to the origin.</p>
    public struct CachePolicyQueryStringsConfig: Swift.Equatable {
        /// <p>Determines whether any URL query strings in viewer requests are included in the cache key
        /// 			and automatically included in requests that CloudFront sends to the origin. Valid values
        /// 			are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code> – Query strings in viewer requests are not included in the cache key and
        /// 					are not automatically included in requests that CloudFront sends to the origin. Even
        /// 					when this field is set to <code>none</code>, any query strings that are listed
        /// 					in an <code>OriginRequestPolicy</code>
        ///                   <i>are</i> included in
        /// 					origin requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code> – The query strings in viewer requests that are listed in the
        /// 					<code>QueryStringNames</code> type are included in the cache key and
        /// 					automatically included in requests that CloudFront sends to the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>allExcept</code> – All query strings in viewer requests that are <i>
        ///                      <b>not</b>
        ///                   </i> listed in the
        /// 					<code>QueryStringNames</code> type are included in the cache key and
        /// 					automatically included in requests that CloudFront sends to the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>all</code> – All query strings in viewer requests are included in the cache key and
        /// 					are automatically included in requests that CloudFront sends to the origin.</p>
        /// 			         </li>
        ///          </ul>
        public let queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior?
        /// <p>Contains the specific query strings in viewer requests that either <i>
        ///                <b>are</b>
        ///             </i> or <i>
        ///                <b>are
        /// 			not</b>
        ///             </i> included in the cache key and automatically included in
        /// 			requests that CloudFront sends to the origin. The behavior depends on whether the
        /// 			<code>QueryStringBehavior</code> field in the <code>CachePolicyQueryStringsConfig</code>
        /// 			type is set to <code>whitelist</code> (the listed query strings <i>
        ///                <b>are</b>
        ///             </i> included) or <code>allExcept</code> (the listed
        /// 			query strings <i>
        ///                <b>are not</b>
        ///             </i> included,
        /// 			but all other query strings are).</p>
        public let queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init (
            queryStringBehavior: CloudFrontClientTypes.CachePolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.CachePolicySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicy = cachePolicy {
            try container.encode(cachePolicy, forKey: ClientRuntime.Key("CachePolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyType.self, forKey: .type)
        type = typeDecoded
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension CloudFrontClientTypes.CachePolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachePolicySummary(cachePolicy: \(Swift.String(describing: cachePolicy)), type: \(Swift.String(describing: type)))"}
}

extension CloudFrontClientTypes.CachePolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains a cache policy.</p>
    public struct CachePolicySummary: Swift.Equatable {
        /// <p>The cache policy.</p>
        public let cachePolicy: CloudFrontClientTypes.CachePolicy?
        /// <p>The type of cache policy, either <code>managed</code> (created by AWS) or
        /// 			<code>custom</code> (created in this AWS account).</p>
        public let type: CloudFrontClientTypes.CachePolicyType?

        public init (
            cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
            type: CloudFrontClientTypes.CachePolicyType? = nil
        )
        {
            self.cachePolicy = cachePolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum CachePolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [CachePolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CachePolicyType(rawValue: rawValue) ?? CachePolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: ClientRuntime.Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Method].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CachedMethods: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CachedMethods(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CachedMethods: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls whether CloudFront caches the response to requests using the
    /// 			specified HTTP methods. There are two choices:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>CloudFront caches responses to <code>GET</code> and <code>HEAD</code> requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront caches responses to <code>GET</code>, <code>HEAD</code>, and
    /// 						<code>OPTIONS</code> requests.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you pick the second choice for your Amazon S3 Origin, you may need to forward
    /// 			Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the
    /// 			responses to be cached correctly. </p>
    public struct CachedMethods: Swift.Equatable {
        /// <p>A complex type that contains the HTTP methods that you want CloudFront to cache responses
        /// 			to.</p>
        public let items: [CloudFrontClientTypes.Method]?
        /// <p>The number of HTTP methods for which you want CloudFront to cache responses. Valid values are
        /// 				<code>2</code> (for caching responses to <code>GET</code> and <code>HEAD</code> requests)
        /// 			and <code>3</code> (for caching responses to <code>GET</code>, <code>HEAD</code>, and
        /// 				<code>OPTIONS</code> requests).</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.Method]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CannotChangeImmutablePublicKeyFields: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CannotChangeImmutablePublicKeyFields(message: \(Swift.String(describing: message)))"}
}

extension CannotChangeImmutablePublicKeyFields: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CannotChangeImmutablePublicKeyFieldsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't change the value of a public key.</p>
public struct CannotChangeImmutablePublicKeyFields: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CannotChangeImmutablePublicKeyFieldsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CannotChangeImmutablePublicKeyFieldsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum CertificateSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acm
        case cloudfront
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateSource] {
            return [
                .acm,
                .cloudfront,
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acm: return "acm"
            case .cloudfront: return "cloudfront"
            case .iam: return "iam"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateSource(rawValue: rawValue) ?? CertificateSource.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentity(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)), id: \(Swift.String(describing: id)), s3CanonicalUserId: \(Swift.String(describing: s3CanonicalUserId)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>CloudFront origin access identity.</p>
    public struct CloudFrontOriginAccessIdentity: Swift.Equatable {
        /// <p>The current configuration information for the identity. </p>
        public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
        /// <p>The ID for the origin access identity, for example, <code>E74FTE3AJFJ256A</code>.
        /// 		</p>
        public let id: Swift.String?
        /// <p>The Amazon S3 canonical user ID for the origin access identity, used when giving the origin
        /// 			access identity read permission to an object in Amazon S3. </p>
        public let s3CanonicalUserId: Swift.String?

        public init (
            cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontOriginAccessIdentityAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension CloudFrontOriginAccessIdentityAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CloudFrontOriginAccessIdentityAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content
/// 			of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a
/// 			<code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
public struct CloudFrontOriginAccessIdentityAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Origin access identity configuration. Send a <code>GET</code> request to the
    /// 					<code>/<i>CloudFront API version</i>/CloudFront/identity ID/config</code> resource.
    /// 		</p>
    public struct CloudFrontOriginAccessIdentityConfig: Swift.Equatable {
        /// <p>A unique value (for example, a date-time stamp) that ensures that the request can't be replayed.</p>
        /// 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
        /// 			<code>CloudFrontOriginAccessIdentityConfig</code> object), a new origin access identity is
        /// 			created.</p>
        /// 		       <p>If the <code>CallerReference</code> is a value already sent in a previous identity
        /// 			request, and the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is identical
        /// 			to the original request (ignoring white space), the response includes the same information
        /// 			returned to the original request. </p>
        /// 		       <p>If the <code>CallerReference</code> is a value you already sent in a previous request
        /// 			to create an identity, but the content of the
        /// 			<code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request,
        /// 			CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
        public let callerReference: Swift.String?
        /// <p>A comment to describe the origin access identity. The comment cannot be longer
        /// 			than 128 characters.</p>
        public let comment: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
        }
    }

}

extension CloudFrontOriginAccessIdentityInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityInUse(message: \(Swift.String(describing: message)))"}
}

extension CloudFrontOriginAccessIdentityInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<CloudFrontOriginAccessIdentityInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Origin Access Identity specified is already in use.</p>
public struct CloudFrontOriginAccessIdentityInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CloudFrontOriginAccessIdentityInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for cloudfrontoriginaccessidentitysummary0 in items {
                try itemsContainer.encode(cloudfrontoriginaccessidentitysummary0, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentitySummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CloudFrontOriginAccessIdentitySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CloudFrontOriginAccessIdentitySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentityList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentityList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Lists the origin access identities for CloudFront.Send a <code>GET</code> request to the
    /// 					<code>/<i>CloudFront API version</i>/origin-access-identity/cloudfront</code>
    /// 			resource. The response includes a <code>CloudFrontOriginAccessIdentityList</code> element with
    /// 			zero or more <code>CloudFrontOriginAccessIdentitySummary</code> child elements. By default,
    /// 			your entire list of origin access identities is returned in one single page. If the list is
    /// 			long, you can paginate it using the <code>MaxItems</code> and <code>Marker</code>
    /// 			parameters.</p>
    public struct CloudFrontOriginAccessIdentityList: Swift.Equatable {
        /// <p>A flag that indicates whether more origin access identities remain to be listed. If
        /// 			your results were truncated, you can make a follow-up pagination request using the
        /// 				<code>Marker</code> request parameter to retrieve more items in the list.</p>
        public let isTruncated: Swift.Bool?
        /// <p>A complex type that contains one <code>CloudFrontOriginAccessIdentitySummary</code>
        /// 			element for each origin access identity that was created by the current AWS
        /// 			account.</p>
        public let items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]?
        /// <p>Use this when paginating results to indicate where to begin in your list of origin
        /// 			access identities. The results include identities in the list that occur after the marker. To
        /// 			get the next page of results, set the <code>Marker</code> to the value of the
        /// 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
        /// 			identity on that page). </p>
        public let marker: Swift.String?
        /// <p>The maximum number of origin access identities you want in the response body.
        /// 		</p>
        public let maxItems: Swift.Int?
        /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
        /// 			the value you can use for the <code>Marker</code> request parameter to continue listing your
        /// 			origin access identities where they left off. </p>
        public let nextMarker: Swift.String?
        /// <p>The number of CloudFront origin access identities that were created by the current AWS
        /// 			account. </p>
        public let quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: ClientRuntime.Key("S3CanonicalUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudFrontOriginAccessIdentitySummary(comment: \(Swift.String(describing: comment)), id: \(Swift.String(describing: id)), s3CanonicalUserId: \(Swift.String(describing: s3CanonicalUserId)))"}
}

extension CloudFrontClientTypes.CloudFrontOriginAccessIdentitySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Summary of the information about a CloudFront origin access identity.</p>
    public struct CloudFrontOriginAccessIdentitySummary: Swift.Equatable {
        /// <p>The comment for this origin access identity, as originally specified when
        /// 			created.</p>
        public let comment: Swift.String?
        /// <p>The ID for the origin access identity. For example:
        /// 			<code>E74FTE3AJFJ256A</code>.</p>
        public let id: Swift.String?
        /// <p>The Amazon S3 canonical user ID for the origin access identity, which you use when giving
        /// 			the origin access identity read permission to an object in Amazon S3.</p>
        public let s3CanonicalUserId: Swift.String?

        public init (
            comment: Swift.String? = nil,
            id: Swift.String? = nil,
            s3CanonicalUserId: Swift.String? = nil
        )
        {
            self.comment = comment
            self.id = id
            self.s3CanonicalUserId = s3CanonicalUserId
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case format = "Format"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: ClientRuntime.Key("ContentType"))
        }
        if let format = format {
            try container.encode(format, forKey: ClientRuntime.Key("Format"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentTypeProfile(contentType: \(Swift.String(describing: contentType)), format: \(Swift.String(describing: format)), profileId: \(Swift.String(describing: profileId)))"}
}

extension CloudFrontClientTypes.ContentTypeProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A field-level encryption content type profile. </p>
    public struct ContentTypeProfile: Swift.Equatable {
        /// <p>The content type for a field-level encryption content type-profile mapping. </p>
        public let contentType: Swift.String?
        /// <p>The format for a field-level encryption content type-profile mapping. </p>
        public let format: CloudFrontClientTypes.Format?
        /// <p>The profile ID for a field-level encryption content type-profile mapping. </p>
        public let profileId: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            format: CloudFrontClientTypes.Format? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.format = format
            self.profileId = profileId
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentTypeProfiles = "ContentTypeProfiles"
        case forwardWhenContentTypeIsUnknown = "ForwardWhenContentTypeIsUnknown"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let contentTypeProfiles = contentTypeProfiles {
            try container.encode(contentTypeProfiles, forKey: ClientRuntime.Key("ContentTypeProfiles"))
        }
        if let forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown {
            try container.encode(forwardWhenContentTypeIsUnknown, forKey: ClientRuntime.Key("ForwardWhenContentTypeIsUnknown"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenContentTypeIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenContentTypeIsUnknown)
        forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknownDecoded
        let contentTypeProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfiles.self, forKey: .contentTypeProfiles)
        contentTypeProfiles = contentTypeProfilesDecoded
    }
}

extension CloudFrontClientTypes.ContentTypeProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentTypeProfileConfig(contentTypeProfiles: \(Swift.String(describing: contentTypeProfiles)), forwardWhenContentTypeIsUnknown: \(Swift.String(describing: forwardWhenContentTypeIsUnknown)))"}
}

extension CloudFrontClientTypes.ContentTypeProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>The configuration for a field-level encryption content type-profile mapping. </p>
    public struct ContentTypeProfileConfig: Swift.Equatable {
        /// <p>The configuration for a field-level encryption content type-profile. </p>
        public let contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles?
        /// <p>The setting in a field-level encryption content type-profile mapping that specifies what to do
        /// 			when an unknown content type is provided for the profile. If true, content is
        /// 			forwarded without being encrypted when the content type is unknown. If false (the
        /// 			default), an error is returned when the content type is unknown. </p>
        public let forwardWhenContentTypeIsUnknown: Swift.Bool?

        public init (
            contentTypeProfiles: CloudFrontClientTypes.ContentTypeProfiles? = nil,
            forwardWhenContentTypeIsUnknown: Swift.Bool? = nil
        )
        {
            self.contentTypeProfiles = contentTypeProfiles
            self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
        }
    }

}

extension CloudFrontClientTypes.ContentTypeProfiles: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for contenttypeprofile0 in items {
                try itemsContainer.encode(contenttypeprofile0, forKey: ClientRuntime.Key("ContentTypeProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ContentTypeProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ContentTypeProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.ContentTypeProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.ContentTypeProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.ContentTypeProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.ContentTypeProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentTypeProfiles(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.ContentTypeProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Field-level encryption content type-profile. </p>
    public struct ContentTypeProfiles: Swift.Equatable {
        /// <p>Items in a field-level encryption content type-profile mapping. </p>
        public let items: [CloudFrontClientTypes.ContentTypeProfile]?
        /// <p>The number of field-level encryption content type-profile mappings. </p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.ContentTypeProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookieNames: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CookieNames: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CookieNames(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CookieNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains a list of cookie names.</p>
    public struct CookieNames: Swift.Equatable {
        /// <p>A list of cookie names.</p>
        public let items: [Swift.String]?
        /// <p>The number of cookie names in the <code>Items</code> list.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CookiePreference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forward = "Forward"
        case whitelistedNames = "WhitelistedNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forward = forward {
            try container.encode(forward, forKey: ClientRuntime.Key("Forward"))
        }
        if let whitelistedNames = whitelistedNames {
            try container.encode(whitelistedNames, forKey: ClientRuntime.Key("WhitelistedNames"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ItemSelection.self, forKey: .forward)
        forward = forwardDecoded
        let whitelistedNamesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .whitelistedNames)
        whitelistedNames = whitelistedNamesDecoded
    }
}

extension CloudFrontClientTypes.CookiePreference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CookiePreference(forward: \(Swift.String(describing: forward)), whitelistedNames: \(Swift.String(describing: whitelistedNames)))"}
}

extension CloudFrontClientTypes.CookiePreference: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include cookies in the cache key, use <code>CookiesConfig</code> in a
    /// 			cache policy. See <code>CachePolicy</code>.</p>
    /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use
    /// 			<code>CookiesConfig</code> in an origin request policy. See
    /// 			<code>OriginRequestPolicy</code>.</p>
    /// 		       <p>A complex type that specifies whether you want CloudFront to forward cookies to the origin
    /// 			and, if so, which ones. For more information about forwarding cookies to the origin, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html">Caching Content
    /// 				Based on Cookies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public struct CookiePreference: Swift.Equatable {
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field.</p>
        /// 		       <p>If you want to include cookies in the cache key, use a cache policy. For more information,
        /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use origin
        /// 			request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>Specifies which cookies to forward to the origin for this cache behavior: all, none, or
        /// 			the list of cookies specified in the <code>WhitelistedNames</code> complex type.</p>
        /// 		       <p>Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an
        /// 			Amazon S3 origin, specify none for the <code>Forward</code> element.</p>
        public let forward: CloudFrontClientTypes.ItemSelection?
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field.</p>
        /// 		       <p>If you want to include cookies in the cache key, use a cache policy. For more information,
        /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use an
        /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>Required if you specify <code>whitelist</code> for the value of <code>Forward</code>.
        /// 			A complex type that specifies how many different cookies you want CloudFront to forward to the
        /// 			origin for this cache behavior and, if you want to forward selected cookies, the names of
        /// 			those cookies.</p>
        /// 		       <p>If you specify <code>all</code> or <code>none</code> for the value of <code>Forward</code>, omit
        /// 				<code>WhitelistedNames</code>. If you change the value of <code>Forward</code> from
        /// 			<code>whitelist</code> to <code>all</code> or <code>none</code> and you don't delete the <code>WhitelistedNames</code>
        /// 			element and its child elements, CloudFront deletes them automatically.</p>
        /// 		       <p>For the current limit on the number of cookie names that you can whitelist for each
        /// 			cache behavior, see <a href="https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront">
        /// 				CloudFront Limits</a> in the <i>AWS General Reference</i>.</p>
        public let whitelistedNames: CloudFrontClientTypes.CookieNames?

        public init (
            forward: CloudFrontClientTypes.ItemSelection? = nil,
            whitelistedNames: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.forward = forward
            self.whitelistedNames = whitelistedNames
        }
    }

}

public struct CreateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
            do {
                let encoder = context.getEncoder()
                let cachePolicyConfigdata = try encoder.encode(cachePolicyConfig)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

extension CreateCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCachePolicyInput(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)))"}
}

extension CreateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

public struct CreateCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInput: Swift.Equatable {
    /// <p>A cache policy configuration.</p>
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

struct CreateCachePolicyInputBody: Swift.Equatable {
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension CreateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CreateCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCachePolicies" : self = .tooManyCachePolicies(try TooManyCachePolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case tooManyCachePolicies(TooManyCachePolicies)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCachePolicyOutputResponse(cachePolicy: \(Swift.String(describing: cachePolicy)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct CreateCachePolicyOutputResponse: Swift.Equatable {
    /// <p>A cache policy.</p>
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// <p>The current version of the cache policy.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the cache policy just created.</p>
    public let location: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCachePolicyOutputResponseBody: Swift.Equatable {
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension CreateCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
            do {
                let encoder = context.getEncoder()
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

extension CreateCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFrontOriginAccessIdentityInput(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)))"}
}

extension CreateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

public struct CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

/// <p>The request to create a new origin access identity (OAI). An origin access identity is a
/// 			special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or
/// 			just some of your Amazon S3 content. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html">
/// 			Restricting Access to Amazon S3 Content by Using an Origin Access Identity</a> in the
/// 			<i>Amazon CloudFront Developer Guide</i>. </p>
public struct CreateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// <p>The current configuration information for the identity.</p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

struct CreateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension CreateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudFrontOriginAccessIdentityAlreadyExists" : self = .cloudFrontOriginAccessIdentityAlreadyExists(try CloudFrontOriginAccessIdentityAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCloudFrontOriginAccessIdentities" : self = .tooManyCloudFrontOriginAccessIdentities(try TooManyCloudFrontOriginAccessIdentities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case cloudFrontOriginAccessIdentityAlreadyExists(CloudFrontOriginAccessIdentityAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case tooManyCloudFrontOriginAccessIdentities(TooManyCloudFrontOriginAccessIdentities)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(Swift.String(describing: cloudFrontOriginAccessIdentity)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// <p>The origin access identity's information.</p>
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// <p>The current version of the origin access identity created.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the new origin access identity just created.</p>
    public let location: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension CreateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct CreateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfig = input.operationInput.distributionConfig {
            do {
                let encoder = context.getEncoder()
                let distributionConfigdata = try encoder.encode(distributionConfig)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

extension CreateDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionInput(distributionConfig: \(Swift.String(describing: distributionConfig)))"}
}

extension CreateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

public struct CreateDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

public struct CreateDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionOutputError>
}

/// <p>The request to create a new distribution.</p>
public struct CreateDistributionInput: Swift.Equatable {
    /// <p>The distribution's configuration information.</p>
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

struct CreateDistributionInputBody: Swift.Equatable {
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension CreateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension CreateDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateDistributionOutputResponse: Swift.Equatable {
    /// <p>The distribution's information.</p>
    public let distribution: CloudFrontClientTypes.Distribution?
    /// <p>The current version of the distribution created.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the new distribution resource just created.</p>
    public let location: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigWithTags = input.operationInput.distributionConfigWithTags {
            do {
                let encoder = context.getEncoder()
                let distributionConfigWithTagsdata = try encoder.encode(distributionConfigWithTags)
                let distributionConfigWithTagsbody = ClientRuntime.HttpBody.data(distributionConfigWithTagsdata)
                input.builder.withBody(distributionConfigWithTagsbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

extension CreateDistributionWithTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionWithTagsInput(distributionConfigWithTags: \(Swift.String(describing: distributionConfigWithTags)))"}
}

extension CreateDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionWithTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfigWithTags = distributionConfigWithTags {
            try container.encode(distributionConfigWithTags, forKey: ClientRuntime.Key("DistributionConfigWithTags"))
        }
    }
}

public struct CreateDistributionWithTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

public struct CreateDistributionWithTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionWithTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionWithTagsOutputError>
}

/// <p>The request to create a new distribution with tags. </p>
public struct CreateDistributionWithTagsInput: Swift.Equatable {
    /// <p>The distribution's configuration information. </p>
    public let distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?

    public init (
        distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

struct CreateDistributionWithTagsInputBody: Swift.Equatable {
    public let distributionConfigWithTags: CloudFrontClientTypes.DistributionConfigWithTags?
}

extension CreateDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfigWithTags.self, forKey: .distributionConfigWithTags)
        distributionConfigWithTags = distributionConfigWithTagsDecoded
    }
}

extension CreateDistributionWithTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionWithTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionWithTagsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTagging(InvalidTagging)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionWithTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionWithTagsOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)))"}
}

extension CreateDistributionWithTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct CreateDistributionWithTagsOutputResponse: Swift.Equatable {
    /// <p>The distribution's information. </p>
    public let distribution: CloudFrontClientTypes.Distribution?
    /// <p>The current version of the distribution created.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the new distribution resource just created.</p>
    public let location: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil,
        location: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionWithTagsOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension CreateDistributionWithTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionConfigdata = try encoder.encode(fieldLevelEncryptionConfig)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

extension CreateFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionConfigInput(fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)))"}
}

extension CreateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

public struct CreateFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// <p>The request to create a new field-level encryption configuration.</p>
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init (
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct CreateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension CreateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CreateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionConfigAlreadyExists" : self = .fieldLevelEncryptionConfigAlreadyExists(try FieldLevelEncryptionConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionConfigs" : self = .tooManyFieldLevelEncryptionConfigs(try TooManyFieldLevelEncryptionConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case fieldLevelEncryptionConfigAlreadyExists(FieldLevelEncryptionConfigAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionConfigs(TooManyFieldLevelEncryptionConfigs)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryption: \(Swift.String(describing: fieldLevelEncryption)), location: \(Swift.String(describing: location)))"}
}

extension CreateFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Returned when you create a new field-level encryption configuration.</p>
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
    /// <p>The fully qualified URI of the new configuration resource just created.</p>
    public let location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

struct CreateFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension CreateFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct CreateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

extension CreateFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionProfileInput(fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)))"}
}

extension CreateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

public struct CreateFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// <p>The request to create a field-level encryption profile.</p>
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init (
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct CreateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension CreateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CreateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionProfiles" : self = .tooManyFieldLevelEncryptionProfiles(try TooManyFieldLevelEncryptionProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchPublicKey(NoSuchPublicKey)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case tooManyFieldLevelEncryptionProfiles(TooManyFieldLevelEncryptionProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFieldLevelEncryptionProfileOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfile: \(Swift.String(describing: fieldLevelEncryptionProfile)), location: \(Swift.String(describing: location)))"}
}

extension CreateFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// <p>The current version of the field level encryption profile. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Returned when you create a new field-level encryption profile.</p>
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
    /// <p>The fully qualified URI of the new profile resource just created.</p>
    public let location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

struct CreateFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension CreateFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

public struct CreateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionInput(functionCode: \(Swift.String(describing: functionCode)), functionConfig: \(Swift.String(describing: functionConfig)), name: \(Swift.String(describing: name)))"}
}

extension CreateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Swift.Equatable {
    /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
    /// 			code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let functionCode: ClientRuntime.Data?
    /// <p>Configuration information about the function, including an optional comment and the
    /// 			function’s runtime.</p>
    public let functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// <p>A name to identify the function.</p>
    public let name: Swift.String?

    public init (
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

struct CreateFunctionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let functionConfig: CloudFrontClientTypes.FunctionConfig?
    public let functionCode: ClientRuntime.Data?
}

extension CreateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension CreateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionAlreadyExists" : self = .functionAlreadyExists(try FunctionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctions" : self = .tooManyFunctions(try TooManyFunctions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionAlreadyExists(FunctionAlreadyExists)
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case tooManyFunctions(TooManyFunctions)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFunctionOutputResponse(eTag: \(Swift.String(describing: eTag)), functionSummary: \(Swift.String(describing: functionSummary)), location: \(Swift.String(describing: location)))"}
}

extension CreateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Swift.Equatable {
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: Swift.String?
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
    /// <p>The URL of the CloudFront function. Use the URL to manage the function with the CloudFront
    /// 			API.</p>
    public let location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

struct CreateFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension CreateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct CreateInvalidationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let invalidationBatch = input.operationInput.invalidationBatch {
            do {
                let encoder = context.getEncoder()
                let invalidationBatchdata = try encoder.encode(invalidationBatch)
                let invalidationBatchbody = ClientRuntime.HttpBody.data(invalidationBatchdata)
                input.builder.withBody(invalidationBatchbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

extension CreateInvalidationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInvalidationInput(distributionId: \(Swift.String(describing: distributionId)), invalidationBatch: \(Swift.String(describing: invalidationBatch)))"}
}

extension CreateInvalidationInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateInvalidationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
    }
}

public struct CreateInvalidationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

public struct CreateInvalidationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInvalidationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInvalidationOutputError>
}

/// <p>The request to create an invalidation.</p>
public struct CreateInvalidationInput: Swift.Equatable {
    /// <p>The distribution's id.</p>
    public let distributionId: Swift.String?
    /// <p>The batch information for the invalidation.</p>
    public let invalidationBatch: CloudFrontClientTypes.InvalidationBatch?

    public init (
        distributionId: Swift.String? = nil,
        invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

struct CreateInvalidationInputBody: Swift.Equatable {
    public let invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
}

extension CreateInvalidationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CreateInvalidationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateInvalidationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchTooLarge" : self = .batchTooLarge(try BatchTooLarge(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyInvalidationsInProgress" : self = .tooManyInvalidationsInProgress(try TooManyInvalidationsInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInvalidationOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case batchTooLarge(BatchTooLarge)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case noSuchDistribution(NoSuchDistribution)
    case tooManyInvalidationsInProgress(TooManyInvalidationsInProgress)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInvalidationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInvalidationOutputResponse(invalidation: \(Swift.String(describing: invalidation)), location: \(Swift.String(describing: location)))"}
}

extension CreateInvalidationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateInvalidationOutputResponse: Swift.Equatable {
    /// <p>The invalidation's information.</p>
    public let invalidation: CloudFrontClientTypes.Invalidation?
    /// <p>The fully qualified URI of the distribution and invalidation batch request, including
    /// 			the <code>Invalidation ID</code>.</p>
    public let location: Swift.String?

    public init (
        invalidation: CloudFrontClientTypes.Invalidation? = nil,
        location: Swift.String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

struct CreateInvalidationOutputResponseBody: Swift.Equatable {
    public let invalidation: CloudFrontClientTypes.Invalidation?
}

extension CreateInvalidationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

public struct CreateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyGroupConfig = input.operationInput.keyGroupConfig {
            do {
                let encoder = context.getEncoder()
                let keyGroupConfigdata = try encoder.encode(keyGroupConfig)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

extension CreateKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKeyGroupInput(keyGroupConfig: \(Swift.String(describing: keyGroupConfig)))"}
}

extension CreateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

public struct CreateKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInput: Swift.Equatable {
    /// <p>A key group configuration.</p>
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

struct CreateKeyGroupInputBody: Swift.Equatable {
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension CreateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CreateKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroups" : self = .tooManyKeyGroups(try TooManyKeyGroups(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case tooManyKeyGroups(TooManyKeyGroups)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKeyGroupOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroup: \(Swift.String(describing: keyGroup)), location: \(Swift.String(describing: location)))"}
}

extension CreateKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct CreateKeyGroupOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: Swift.String?
    /// <p>The key group that was just created.</p>
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
    /// <p>The URL of the key group.</p>
    public let location: Swift.String?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil,
        location: Swift.String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

struct CreateKeyGroupOutputResponseBody: Swift.Equatable {
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension CreateKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct CreateMonitoringSubscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let monitoringSubscription = input.operationInput.monitoringSubscription {
            do {
                let encoder = context.getEncoder()
                let monitoringSubscriptiondata = try encoder.encode(monitoringSubscription)
                let monitoringSubscriptionbody = ClientRuntime.HttpBody.data(monitoringSubscriptiondata)
                input.builder.withBody(monitoringSubscriptionbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

extension CreateMonitoringSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMonitoringSubscriptionInput(distributionId: \(Swift.String(describing: distributionId)), monitoringSubscription: \(Swift.String(describing: monitoringSubscription)))"}
}

extension CreateMonitoringSubscriptionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateMonitoringSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let monitoringSubscription = monitoringSubscription {
            try container.encode(monitoringSubscription, forKey: ClientRuntime.Key("MonitoringSubscription"))
        }
    }
}

public struct CreateMonitoringSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInput: Swift.Equatable {
    /// <p>The ID of the distribution that you are enabling metrics for.</p>
    public let distributionId: Swift.String?
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        distributionId: Swift.String? = nil,
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionInputBody: Swift.Equatable {
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension CreateMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMonitoringSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMonitoringSubscriptionOutputResponse(monitoringSubscription: \(Swift.String(describing: monitoringSubscription)))"}
}

extension CreateMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct CreateMonitoringSubscriptionOutputResponse: Swift.Equatable {
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension CreateMonitoringSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

public struct CreateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
            do {
                let encoder = context.getEncoder()
                let originRequestPolicyConfigdata = try encoder.encode(originRequestPolicyConfig)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

extension CreateOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOriginRequestPolicyInput(originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension CreateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

public struct CreateOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInput: Swift.Equatable {
    /// <p>An origin request policy configuration.</p>
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct CreateOriginRequestPolicyInputBody: Swift.Equatable {
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension CreateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CreateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginRequestPolicies" : self = .tooManyOriginRequestPolicies(try TooManyOriginRequestPolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyOriginRequestPolicies(TooManyOriginRequestPolicies)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOriginRequestPolicyOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), originRequestPolicy: \(Swift.String(describing: originRequestPolicy)))"}
}

extension CreateOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct CreateOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the origin request policy just created.</p>
    public let location: Swift.String?
    /// <p>An origin request policy.</p>
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

struct CreateOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension CreateOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct CreatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicKeyConfig = input.operationInput.publicKeyConfig {
            do {
                let encoder = context.getEncoder()
                let publicKeyConfigdata = try encoder.encode(publicKeyConfig)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

extension CreatePublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicKeyInput(publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension CreatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreatePublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

public struct CreatePublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInput: Swift.Equatable {
    /// <p>A CloudFront public key configuration.</p>
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

struct CreatePublicKeyInputBody: Swift.Equatable {
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension CreatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CreatePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyAlreadyExists" : self = .publicKeyAlreadyExists(try PublicKeyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeys" : self = .tooManyPublicKeys(try TooManyPublicKeys(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case publicKeyAlreadyExists(PublicKeyAlreadyExists)
    case tooManyPublicKeys(TooManyPublicKeys)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePublicKeyOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), publicKey: \(Swift.String(describing: publicKey)))"}
}

extension CreatePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct CreatePublicKeyOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the public key.</p>
    public let eTag: Swift.String?
    /// <p>The URL of the public key.</p>
    public let location: Swift.String?
    /// <p>The public key.</p>
    public let publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

struct CreatePublicKeyOutputResponseBody: Swift.Equatable {
    public let publicKey: CloudFrontClientTypes.PublicKey?
}

extension CreatePublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct CreateRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

extension CreateRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRealtimeLogConfigInput(endPoints: \(Swift.String(describing: endPoints)), fields: \(Swift.String(describing: fields)), name: \(Swift.String(describing: name)), samplingRate: \(Swift.String(describing: samplingRate)))"}
}

extension CreateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

public struct CreateRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInput: Swift.Equatable {
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
    /// 			log data.</p>
    public let endPoints: [CloudFrontClientTypes.EndPoint]?
    /// <p>A list of fields to include in each real-time log record.</p>
    /// 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let fields: [Swift.String]?
    /// <p>A unique name to identify this real-time log configuration.</p>
    public let name: Swift.String?
    /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
    /// 			percentage of viewer requests that are represented in the real-time log data. You must
    /// 			provide an integer between 1 and 100, inclusive.</p>
    public let samplingRate: Swift.Int?

    public init (
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct CreateRealtimeLogConfigInputBody: Swift.Equatable {
    public let endPoints: [CloudFrontClientTypes.EndPoint]?
    public let fields: [Swift.String]?
    public let name: Swift.String?
    public let samplingRate: Swift.Int?
}

extension CreateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension CreateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigAlreadyExists" : self = .realtimeLogConfigAlreadyExists(try RealtimeLogConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRealtimeLogConfigs" : self = .tooManyRealtimeLogConfigs(try TooManyRealtimeLogConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case realtimeLogConfigAlreadyExists(RealtimeLogConfigAlreadyExists)
    case tooManyRealtimeLogConfigs(TooManyRealtimeLogConfigs)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRealtimeLogConfigOutputResponse(realtimeLogConfig: \(Swift.String(describing: realtimeLogConfig)))"}
}

extension CreateRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct CreateRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// <p>A real-time log configuration.</p>
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct CreateRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension CreateRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct CreateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
            do {
                let encoder = context.getEncoder()
                let streamingDistributionConfigdata = try encoder.encode(streamingDistributionConfig)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

extension CreateStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionInput(streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension CreateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

public struct CreateStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

public struct CreateStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionOutputError>
}

/// <p>The request to create a new streaming distribution.</p>
public struct CreateStreamingDistributionInput: Swift.Equatable {
    /// <p>The streaming distribution's configuration information.</p>
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct CreateStreamingDistributionInputBody: Swift.Equatable {
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension CreateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CreateStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension CreateStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateStreamingDistributionOutputResponse: Swift.Equatable {
    /// <p>The current version of the streaming distribution created.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the new streaming distribution resource just created.</p>
    public let location: Swift.String?
    /// <p>The streaming distribution's information.</p>
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

public struct CreateStreamingDistributionWithTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfigWithTags = input.operationInput.streamingDistributionConfigWithTags {
            do {
                let encoder = context.getEncoder()
                let streamingDistributionConfigWithTagsdata = try encoder.encode(streamingDistributionConfigWithTags)
                let streamingDistributionConfigWithTagsbody = ClientRuntime.HttpBody.data(streamingDistributionConfigWithTagsdata)
                input.builder.withBody(streamingDistributionConfigWithTagsbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

extension CreateStreamingDistributionWithTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionWithTagsInput(streamingDistributionConfigWithTags: \(Swift.String(describing: streamingDistributionConfigWithTags)))"}
}

extension CreateStreamingDistributionWithTagsInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionWithTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfigWithTags = streamingDistributionConfigWithTags {
            try container.encode(streamingDistributionConfigWithTags, forKey: ClientRuntime.Key("StreamingDistributionConfigWithTags"))
        }
    }
}

public struct CreateStreamingDistributionWithTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

public struct CreateStreamingDistributionWithTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingDistributionWithTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "WithTags", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingDistributionWithTagsOutputError>
}

/// <p>The request to create a new streaming distribution with tags.</p>
public struct CreateStreamingDistributionWithTagsInput: Swift.Equatable {
    /// <p> The streaming distribution's configuration information. </p>
    public let streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?

    public init (
        streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

struct CreateStreamingDistributionWithTagsInputBody: Swift.Equatable {
    public let streamingDistributionConfigWithTags: CloudFrontClientTypes.StreamingDistributionConfigWithTags?
}

extension CreateStreamingDistributionWithTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfigWithTags.self, forKey: .streamingDistributionConfigWithTags)
        streamingDistributionConfigWithTags = streamingDistributionConfigWithTagsDecoded
    }
}

extension CreateStreamingDistributionWithTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionWithTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionWithTagsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidTagging(InvalidTagging)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionWithTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingDistributionWithTagsOutputResponse(eTag: \(Swift.String(describing: eTag)), location: \(Swift.String(describing: location)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension CreateStreamingDistributionWithTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct CreateStreamingDistributionWithTagsOutputResponse: Swift.Equatable {
    /// <p>The current version of the distribution created.</p>
    public let eTag: Swift.String?
    /// <p>The fully qualified URI of the new streaming distribution resource just created.</p>
    public let location: Swift.String?
    /// <p>The streaming distribution's information. </p>
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        location: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionWithTagsOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension CreateStreamingDistributionWithTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCachingMinTTL = "ErrorCachingMinTTL"
        case errorCode = "ErrorCode"
        case responseCode = "ResponseCode"
        case responsePagePath = "ResponsePagePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let errorCachingMinTTL = errorCachingMinTTL {
            try container.encode(errorCachingMinTTL, forKey: ClientRuntime.Key("ErrorCachingMinTTL"))
        }
        if let errorCode = errorCode {
            try container.encode(errorCode, forKey: ClientRuntime.Key("ErrorCode"))
        }
        if let responseCode = responseCode {
            try container.encode(responseCode, forKey: ClientRuntime.Key("ResponseCode"))
        }
        if let responsePagePath = responsePagePath {
            try container.encode(responsePagePath, forKey: ClientRuntime.Key("ResponsePagePath"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let responsePagePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responsePagePath)
        responsePagePath = responsePagePathDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let errorCachingMinTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCachingMinTTL)
        errorCachingMinTTL = errorCachingMinTTLDecoded
    }
}

extension CloudFrontClientTypes.CustomErrorResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomErrorResponse(errorCachingMinTTL: \(Swift.String(describing: errorCachingMinTTL)), errorCode: \(Swift.String(describing: errorCode)), responseCode: \(Swift.String(describing: responseCode)), responsePagePath: \(Swift.String(describing: responsePagePath)))"}
}

extension CloudFrontClientTypes.CustomErrorResponse: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
    /// 					messages before returning the response to the viewer. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public struct CustomErrorResponse: Swift.Equatable {
        /// <p>The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status
        /// 			code specified in <code>ErrorCode</code>. When this time period has elapsed, CloudFront queries your
        /// 			origin to see whether the problem that caused the error has been resolved and the requested
        /// 			object is now available.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing
        /// 				Error Responses</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let errorCachingMinTTL: Swift.Int?
        /// <p>The HTTP status code for which you want to specify a custom error page and/or a caching
        /// 			duration.</p>
        public let errorCode: Swift.Int?
        /// <p>The HTTP status code that you want CloudFront to return to the viewer along with the custom
        /// 			error page. There are a variety of reasons that you might want CloudFront to return a status code
        /// 			different from the status code that your origin returned to CloudFront, for example:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>Some Internet devices (some firewalls and corporate proxies, for example) intercept
        /// 					HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you
        /// 					substitute <code>200</code>, the response typically won't be intercepted.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>If you don't care about distinguishing among different client errors or server
        /// 					errors, you can specify <code>400</code> or <code>500</code> as the
        /// 						<code>ResponseCode</code> for all 4xx or 5xx errors.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>You might want to return a <code>200</code> status code (OK) and static website so
        /// 					your customers don't know that your website is down.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>If you specify a value for <code>ResponseCode</code>, you must also specify a value for
        /// 			<code>ResponsePagePath</code>.</p>
        public let responseCode: Swift.String?
        /// <p>The path to the custom error page that you want CloudFront to return to a viewer when your
        /// 			origin returns the HTTP status code specified by <code>ErrorCode</code>, for example,
        /// 				<code>/4xx-errors/403-forbidden.html</code>. If you want to store your objects and your
        /// 			custom error pages in different locations, your distribution must include a cache behavior for
        /// 			which the following is true:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>The value of <code>PathPattern</code> matches the path to your custom error
        /// 					messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3
        /// 					bucket in a directory named <code>/4xx-errors</code>. Your distribution must include a
        /// 					cache behavior for which the path pattern routes requests for your custom error pages to
        /// 					that location, for example, <code>/4xx-errors/*</code>. </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>The value of <code>TargetOriginId</code> specifies the value of the <code>ID</code>
        /// 					element for the origin that contains your custom error pages.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>If you specify a value for <code>ResponsePagePath</code>, you must also specify a value
        /// 			for <code>ResponseCode</code>.</p>
        /// 		       <p>We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom
        /// 			error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the
        /// 			files that you want to return to viewers because the origin server is unavailable.</p>
        public let responsePagePath: Swift.String?

        public init (
            errorCachingMinTTL: Swift.Int? = nil,
            errorCode: Swift.Int? = nil,
            responseCode: Swift.String? = nil,
            responsePagePath: Swift.String? = nil
        )
        {
            self.errorCachingMinTTL = errorCachingMinTTL
            self.errorCode = errorCode
            self.responseCode = responseCode
            self.responsePagePath = responsePagePath
        }
    }

}

extension CloudFrontClientTypes.CustomErrorResponses: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for customerrorresponse0 in items {
                try itemsContainer.encode(customerrorresponse0, forKey: ClientRuntime.Key("CustomErrorResponse"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CustomErrorResponse{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomErrorResponse>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.CustomErrorResponse].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.CustomErrorResponse]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.CustomErrorResponse]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomErrorResponses: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomErrorResponses(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CustomErrorResponses: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
    /// 					messages before returning the response to the viewer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public struct CustomErrorResponses: Swift.Equatable {
        /// <p>A complex type that contains a <code>CustomErrorResponse</code> element for each HTTP
        /// 			status code for which you want to specify a custom error page and/or a caching duration.
        /// 		</p>
        public let items: [CloudFrontClientTypes.CustomErrorResponse]?
        /// <p>The number of HTTP status codes for which you want to specify a custom error page
        /// 			and/or a caching duration. If <code>Quantity</code> is <code>0</code>, you can omit
        /// 				<code>Items</code>.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.CustomErrorResponse]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomHeaders: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origincustomheader0 in items {
                try itemsContainer.encode(origincustomheader0, forKey: ClientRuntime.Key("OriginCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginCustomHeader].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.CustomHeaders: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomHeaders(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.CustomHeaders: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains the list of Custom Headers for each origin. </p>
    public struct CustomHeaders: Swift.Equatable {
        /// <p>
        ///             <b>Optional</b>: A list that contains one
        /// 				<code>OriginCustomHeader</code> element for each custom header that you want CloudFront to forward
        /// 			to the origin. If Quantity is <code>0</code>, omit <code>Items</code>.</p>
        public let items: [CloudFrontClientTypes.OriginCustomHeader]?
        /// <p>The number of custom headers, if any, for this distribution.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginCustomHeader]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.CustomOriginConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hTTPPort = "HTTPPort"
        case hTTPSPort = "HTTPSPort"
        case originKeepaliveTimeout = "OriginKeepaliveTimeout"
        case originProtocolPolicy = "OriginProtocolPolicy"
        case originReadTimeout = "OriginReadTimeout"
        case originSslProtocols = "OriginSslProtocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let hTTPPort = hTTPPort {
            try container.encode(hTTPPort, forKey: ClientRuntime.Key("HTTPPort"))
        }
        if let hTTPSPort = hTTPSPort {
            try container.encode(hTTPSPort, forKey: ClientRuntime.Key("HTTPSPort"))
        }
        if let originKeepaliveTimeout = originKeepaliveTimeout {
            try container.encode(originKeepaliveTimeout, forKey: ClientRuntime.Key("OriginKeepaliveTimeout"))
        }
        if let originProtocolPolicy = originProtocolPolicy {
            try container.encode(originProtocolPolicy, forKey: ClientRuntime.Key("OriginProtocolPolicy"))
        }
        if let originReadTimeout = originReadTimeout {
            try container.encode(originReadTimeout, forKey: ClientRuntime.Key("OriginReadTimeout"))
        }
        if let originSslProtocols = originSslProtocols {
            try container.encode(originSslProtocols, forKey: ClientRuntime.Key("OriginSslProtocols"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hTTPPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hTTPPort)
        hTTPPort = hTTPPortDecoded
        let hTTPSPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hTTPSPort)
        hTTPSPort = hTTPSPortDecoded
        let originProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginProtocolPolicy.self, forKey: .originProtocolPolicy)
        originProtocolPolicy = originProtocolPolicyDecoded
        let originSslProtocolsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginSslProtocols.self, forKey: .originSslProtocols)
        originSslProtocols = originSslProtocolsDecoded
        let originReadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originReadTimeout)
        originReadTimeout = originReadTimeoutDecoded
        let originKeepaliveTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originKeepaliveTimeout)
        originKeepaliveTimeout = originKeepaliveTimeoutDecoded
    }
}

extension CloudFrontClientTypes.CustomOriginConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomOriginConfig(hTTPPort: \(Swift.String(describing: hTTPPort)), hTTPSPort: \(Swift.String(describing: hTTPSPort)), originKeepaliveTimeout: \(Swift.String(describing: originKeepaliveTimeout)), originProtocolPolicy: \(Swift.String(describing: originProtocolPolicy)), originReadTimeout: \(Swift.String(describing: originReadTimeout)), originSslProtocols: \(Swift.String(describing: originSslProtocols)))"}
}

extension CloudFrontClientTypes.CustomOriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A custom origin. A custom origin is any origin that is <i>not</i> an Amazon S3
    /// 			bucket, with one exception. An Amazon S3 bucket that is <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">configured with
    /// 			static website hosting</a>
    ///             <i>is</i> a custom origin.</p>
    public struct CustomOriginConfig: Swift.Equatable {
        /// <p>The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin
        /// 			listens on.</p>
        public let hTTPPort: Swift.Int?
        /// <p>The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the
        /// 			origin listens on.</p>
        public let hTTPSPort: Swift.Int?
        /// <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum
        /// 			timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify
        /// 			otherwise) is 5 seconds.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout">Origin Keep-alive Timeout</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originKeepaliveTimeout: Swift.Int?
        /// <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values
        /// 			are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>http-only</code> – CloudFront always uses HTTP to connect to the
        /// 					origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>match-viewer</code> – CloudFront connects to the origin using the same
        /// 					protocol that the viewer used to connect to CloudFront.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>https-only</code> – CloudFront always uses HTTPS to connect to the
        /// 					origin.</p>
        /// 			         </li>
        ///          </ul>
        public let originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy?
        /// <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also
        /// 			known as the <i>origin response timeout</i>. The minimum timeout is 1
        /// 			second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is
        /// 			30 seconds.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout">Origin Response Timeout</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originReadTimeout: Swift.Int?
        /// <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over
        /// 			HTTPS. Valid values include <code>SSLv3</code>, <code>TLSv1</code>,
        /// 			<code>TLSv1.1</code>, and <code>TLSv1.2</code>.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols">Minimum Origin SSL Protocol</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originSslProtocols: CloudFrontClientTypes.OriginSslProtocols?

        public init (
            hTTPPort: Swift.Int? = nil,
            hTTPSPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: CloudFrontClientTypes.OriginProtocolPolicy? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: CloudFrontClientTypes.OriginSslProtocols? = nil
        )
        {
            self.hTTPPort = hTTPPort
            self.hTTPSPort = hTTPSPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension CloudFrontClientTypes.DefaultCacheBehavior: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: ClientRuntime.Key("AllowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: ClientRuntime.Key("CachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: ClientRuntime.Key("Compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: ClientRuntime.Key("DefaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: ClientRuntime.Key("FieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: ClientRuntime.Key("ForwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: ClientRuntime.Key("FunctionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: ClientRuntime.Key("LambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: ClientRuntime.Key("MaxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: ClientRuntime.Key("MinTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: ClientRuntime.Key("OriginRequestPolicyId"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: ClientRuntime.Key("SmoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: ClientRuntime.Key("TargetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: ClientRuntime.Key("TrustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: ClientRuntime.Key("ViewerProtocolPolicy"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CloudFrontClientTypes.DefaultCacheBehavior: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultCacheBehavior(allowedMethods: \(Swift.String(describing: allowedMethods)), cachePolicyId: \(Swift.String(describing: cachePolicyId)), compress: \(Swift.String(describing: compress)), defaultTTL: \(Swift.String(describing: defaultTTL)), fieldLevelEncryptionId: \(Swift.String(describing: fieldLevelEncryptionId)), forwardedValues: \(Swift.String(describing: forwardedValues)), functionAssociations: \(Swift.String(describing: functionAssociations)), lambdaFunctionAssociations: \(Swift.String(describing: lambdaFunctionAssociations)), maxTTL: \(Swift.String(describing: maxTTL)), minTTL: \(Swift.String(describing: minTTL)), originRequestPolicyId: \(Swift.String(describing: originRequestPolicyId)), realtimeLogConfigArn: \(Swift.String(describing: realtimeLogConfigArn)), smoothStreaming: \(Swift.String(describing: smoothStreaming)), targetOriginId: \(Swift.String(describing: targetOriginId)), trustedKeyGroups: \(Swift.String(describing: trustedKeyGroups)), trustedSigners: \(Swift.String(describing: trustedSigners)), viewerProtocolPolicy: \(Swift.String(describing: viewerProtocolPolicy)))"}
}

extension CloudFrontClientTypes.DefaultCacheBehavior: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that describes the default cache behavior if you don’t specify a
    /// 			<code>CacheBehavior</code> element or if request URLs don’t match any of the values of
    /// 			<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly
    /// 			one default cache behavior.</p>
    public struct DefaultCacheBehavior: Swift.Equatable {
        /// <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
        /// 			Amazon S3 bucket or your custom origin. There are three choices:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
        /// 					requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
        /// 						<code>DELETE</code> requests.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
        /// 			to your custom origin so users can't perform operations that you don't want them to. For
        /// 			example, you might not want users to have permissions to delete objects from your
        /// 			origin.</p>
        public let allowedMethods: CloudFrontClientTypes.AllowedMethods?
        /// <p>The unique identifier of the cache policy that is attached to the default cache behavior.
        /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        ///             <i>Amazon CloudFront Developer Guide</i>.</p>
        ///         <p>A <code>DefaultCacheBehavior</code> must include either a
        ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
        ///             use a <code>CachePolicyId</code>.</p>
        public let cachePolicyId: Swift.String?
        /// <p>Whether you want CloudFront to automatically compress certain files for this cache behavior.
        /// 			If so, specify <code>true</code>; if not, specify <code>false</code>. For more information,
        /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">Serving Compressed Files</a> in
        /// 			the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let compress: Swift.Bool?
        /// <p>This field is deprecated. We recommend that you use the <code>DefaultTTL</code> field in a
        /// 			cache policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The default amount of time that you want objects to stay in CloudFront caches before CloudFront
        /// 			forwards another request to your origin to determine whether the object has been updated. The
        /// 			value that you specify applies only when your origin does not add HTTP headers such as
        /// 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
        /// 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
        /// 					in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        @available(*, deprecated)
        public let defaultTTL: Swift.Int?
        /// <p>The value of <code>ID</code> for the field-level encryption configuration that you want CloudFront
        /// 			to use for encrypting specific fields of data for the default cache behavior.</p>
        public let fieldLevelEncryptionId: Swift.String?
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin request
        /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html">Working with policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to include values in the cache key, use a cache policy. For more information,
        /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send values to the origin but not include them in the cache key, use an
        /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
        ///             <i>Amazon CloudFront Developer Guide</i>.</p>
        ///         <p>A <code>DefaultCacheBehavior</code> must include either a
        ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
        ///             use a <code>CachePolicyId</code>.</p>
        /// 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
        @available(*, deprecated)
        public let forwardedValues: CloudFrontClientTypes.ForwardedValues?
        /// <p>A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must
        /// 			be published to the <code>LIVE</code> stage to associate them with a cache
        /// 			behavior.</p>
        public let functionAssociations: CloudFrontClientTypes.FunctionAssociations?
        /// <p>A complex type that contains zero or more Lambda function associations for a cache
        /// 			behavior.</p>
        public let lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations?
        /// <p>This field is deprecated. We recommend that you use the <code>MaxTTL</code> field in a cache
        /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront
        /// 			forwards another request to your origin to determine whether the object has been updated. The
        /// 			value that you specify applies only when your origin adds HTTP headers such as
        /// 			<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
        /// 			<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
        /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        @available(*, deprecated)
        public let maxTTL: Swift.Int?
        /// <p>This field is deprecated. We recommend that you use the <code>MinTTL</code> field in a cache
        /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront
        /// 			forwards another request to your origin to determine whether the object has been updated. For
        /// 			more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
        /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>You must specify <code>0</code> for <code>MinTTL</code> if you configure CloudFront to
        /// 			forward all headers to your origin (under <code>Headers</code>, if you specify <code>1</code>
        /// 			for <code>Quantity</code> and <code>*</code> for <code>Name</code>).</p>
        @available(*, deprecated)
        public let minTTL: Swift.Int?
        /// <p>The unique identifier of the origin request policy that is attached to the default cache
        /// 			behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originRequestPolicyId: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this
        /// 			cache behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let realtimeLogConfigArn: Swift.String?
        /// <p>Indicates whether you want to distribute media files in the Microsoft Smooth Streaming
        /// 			format using the origin that is associated with this cache behavior. If so, specify
        /// 				<code>true</code>; if not, specify <code>false</code>. If you specify <code>true</code> for
        /// 				<code>SmoothStreaming</code>, you can still distribute other content using this cache
        /// 			behavior if the content matches the value of <code>PathPattern</code>. </p>
        public let smoothStreaming: Swift.Bool?
        /// <p>The value of <code>ID</code> for the origin that you want CloudFront to route requests to when
        /// 			they use the default cache behavior.</p>
        public let targetOriginId: Swift.String?
        /// <p>A list of key groups that CloudFront can use to validate signed URLs or signed cookies.</p>
        /// 		       <p>When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed
        /// 			cookies for all requests that match the cache behavior. The URLs or cookies must be
        /// 			signed with a private key whose corresponding public key is in the key group. The signed
        /// 			URL or cookie contains information about which public key CloudFront should use to verify the
        /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups?
        /// <important>
        /// 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
        /// 				<code>TrustedSigners</code>.</p>
        /// 		       </important>
        /// 		       <p>A list of AWS account IDs whose public keys CloudFront can use to validate signed URLs or signed
        /// 			cookies.</p>
        /// 		       <p>When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies
        /// 			for all requests that match the cache behavior. The URLs or cookies must be signed with
        /// 			the private key of a CloudFront key pair in a trusted signer’s AWS account. The signed URL or
        /// 			cookie contains information about which public key CloudFront should use to verify the
        /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let trustedSigners: CloudFrontClientTypes.TrustedSigners?
        /// <p>The protocol that viewers can use to access the files in the origin specified by
        /// 				<code>TargetOriginId</code> when a request matches the path pattern in
        /// 				<code>PathPattern</code>. You can specify the following options:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>allow-all</code>: Viewers can use HTTP or HTTPS.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>redirect-to-https</code>: If a viewer submits an HTTP request, CloudFront returns
        /// 					an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The
        /// 					viewer then resubmits the request using the new URL.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>https-only</code>: If a viewer sends an HTTP request, CloudFront returns an HTTP
        /// 					status code of 403 (Forbidden).</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information about requiring the HTTPS protocol, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html">Requiring HTTPS Between Viewers and CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <note>
        /// 			         <p>The only way to guarantee that viewers retrieve an object that was fetched from
        /// 				the origin using HTTPS is never to use any other protocol to fetch the object. If
        /// 				you have recently changed from HTTP to HTTPS, we recommend that you clear your
        /// 				objects’ cache because cached objects are protocol agnostic. That means that an edge
        /// 				location will return an object from the cache regardless of whether the current
        /// 				request protocol matches the protocol used previously. For more information, see
        /// 				<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing Cache
        /// 				Expiration</a> in the
        /// 					<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       </note>
        public let viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy?

        public init (
            allowedMethods: CloudFrontClientTypes.AllowedMethods? = nil,
            cachePolicyId: Swift.String? = nil,
            compress: Swift.Bool? = nil,
            defaultTTL: Swift.Int? = nil,
            fieldLevelEncryptionId: Swift.String? = nil,
            forwardedValues: CloudFrontClientTypes.ForwardedValues? = nil,
            functionAssociations: CloudFrontClientTypes.FunctionAssociations? = nil,
            lambdaFunctionAssociations: CloudFrontClientTypes.LambdaFunctionAssociations? = nil,
            maxTTL: Swift.Int? = nil,
            minTTL: Swift.Int? = nil,
            originRequestPolicyId: Swift.String? = nil,
            realtimeLogConfigArn: Swift.String? = nil,
            smoothStreaming: Swift.Bool? = nil,
            targetOriginId: Swift.String? = nil,
            trustedKeyGroups: CloudFrontClientTypes.TrustedKeyGroups? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil,
            viewerProtocolPolicy: CloudFrontClientTypes.ViewerProtocolPolicy? = nil
        )
        {
            self.allowedMethods = allowedMethods
            self.cachePolicyId = cachePolicyId
            self.compress = compress
            self.defaultTTL = defaultTTL
            self.fieldLevelEncryptionId = fieldLevelEncryptionId
            self.forwardedValues = forwardedValues
            self.functionAssociations = functionAssociations
            self.lambdaFunctionAssociations = lambdaFunctionAssociations
            self.maxTTL = maxTTL
            self.minTTL = minTTL
            self.originRequestPolicyId = originRequestPolicyId
            self.realtimeLogConfigArn = realtimeLogConfigArn
            self.smoothStreaming = smoothStreaming
            self.targetOriginId = targetOriginId
            self.trustedKeyGroups = trustedKeyGroups
            self.trustedSigners = trustedSigners
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension DeleteCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCachePolicyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInput: Swift.Equatable {
    /// <p>The unique identifier for the cache policy that you are deleting. To get the
    /// 			identifier, you can use <code>ListCachePolicies</code>.</p>
    public let id: Swift.String?
    /// <p>The version of the cache policy that you are deleting. The version is the cache
    /// 			policy’s <code>ETag</code> value, which you can get using
    /// 			<code>ListCachePolicies</code>, <code>GetCachePolicy</code>, or
    /// 			<code>GetCachePolicyConfig</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCachePolicyInputBody: Swift.Equatable {
}

extension DeleteCachePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyInUse" : self = .cachePolicyInUse(try CachePolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyInUse(CachePolicyInUse)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCachePolicyOutputResponse()"}
}

extension DeleteCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCachePolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCachePolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteCachePolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCloudFrontOriginAccessIdentityInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

public struct DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

/// <p>Deletes a origin access identity.</p>
public struct DeleteCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// <p>The origin access identity's ID.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header you received from a previous <code>GET</code>
    /// 			or <code>PUT</code> request. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudFrontOriginAccessIdentityInUse" : self = .cloudFrontOriginAccessIdentityInUse(try CloudFrontOriginAccessIdentityInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cloudFrontOriginAccessIdentityInUse(CloudFrontOriginAccessIdentityInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCloudFrontOriginAccessIdentityOutputResponse()"}
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDistributionInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionOutputError>
}

public struct DeleteDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionOutputError>
}

/// <p>This action deletes a web distribution. To delete a web distribution using the CloudFront
/// 			API, perform the following steps.</p>
/// 		       <p>
/// 			         <b>To delete a web distribution using the CloudFront API:</b>
/// 		       </p>
/// 		       <ol>
///             <li>
/// 				           <p>Disable the web distribution </p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>GET Distribution Config</code> request to get the current
/// 					configuration and the <code>Etag</code> header for the distribution.</p>
/// 			         </li>
///             <li>
/// 				           <p>Update the XML document that was returned in the response to your <code>GET
/// 						Distribution Config</code> request to change the value of <code>Enabled</code> to
/// 						<code>false</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>PUT Distribution Config</code> request to update the configuration
/// 					for your distribution. In the request body, include the XML document that you updated in
/// 					Step 3. Set the value of the HTTP <code>If-Match</code> header to the value of the
/// 						<code>ETag</code> header that CloudFront returned when you submitted the <code>GET
/// 						Distribution Config</code> request in Step 2.</p>
/// 			         </li>
///             <li>
/// 				           <p>Review the response to the <code>PUT Distribution Config</code> request to confirm
/// 					that the distribution was successfully disabled.</p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>GET Distribution</code> request to confirm that your changes have
/// 					propagated. When propagation is complete, the value of <code>Status</code> is
/// 						<code>Deployed</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>DELETE Distribution</code> request. Set the value of the HTTP
/// 						<code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
/// 					returned when you submitted the <code>GET Distribution Config</code> request in Step
/// 					6.</p>
/// 			         </li>
///             <li>
/// 				           <p>Review the response to your <code>DELETE Distribution</code> request to confirm
/// 					that the distribution was successfully deleted.</p>
/// 			         </li>
///          </ol>
/// 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
/// 				<i>Amazon CloudFront Developer Guide</i>.</p>
public struct DeleteDistributionInput: Swift.Equatable {
    /// <p>The distribution ID. </p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when you disabled the
    /// 			distribution. For example: <code>E2QWRUHAPOMQZL</code>. </p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteDistributionInputBody: Swift.Equatable {
}

extension DeleteDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionNotDisabled" : self = .distributionNotDisabled(try DistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case distributionNotDisabled(DistributionNotDisabled)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchDistribution(NoSuchDistribution)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDistributionOutputResponse()"}
}

extension DeleteDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDistributionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDistributionOutputResponseBody: Swift.Equatable {
}

extension DeleteDistributionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionConfigInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// <p>The ID of the configuration you want to delete from CloudFront.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			configuration identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionConfigInUse" : self = .fieldLevelEncryptionConfigInUse(try FieldLevelEncryptionConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionConfigInUse(FieldLevelEncryptionConfigInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionConfigOutputResponse()"}
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionProfileInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// <p>Request the ID of the profile you want to delete from CloudFront.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			profile to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileInUse" : self = .fieldLevelEncryptionProfileInUse(try FieldLevelEncryptionProfileInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileInUse(FieldLevelEncryptionProfileInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFieldLevelEncryptionProfileOutputResponse()"}
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
}

extension DeleteFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)))"}
}

extension DeleteFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Swift.Equatable {
    /// <p>The current version (<code>ETag</code> value) of the function that you are deleting, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>The name of the function that you are deleting.</p>
    public let name: Swift.String?

    public init (
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct DeleteFunctionInputBody: Swift.Equatable {
}

extension DeleteFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionInUse" : self = .functionInUse(try FunctionInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionInUse(FunctionInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Swift.Equatable {
}

extension DeleteFunctionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteKeyGroupInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInput: Swift.Equatable {
    /// <p>The identifier of the key group that you are deleting. To get the identifier, use
    /// 			<code>ListKeyGroups</code>.</p>
    public let id: Swift.String?
    /// <p>The version of the key group that you are deleting. The version is the key group’s
    /// 			<code>ETag</code> value. To get the <code>ETag</code>, use <code>GetKeyGroup</code> or
    /// 			<code>GetKeyGroupConfig</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteKeyGroupInputBody: Swift.Equatable {
}

extension DeleteKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteKeyGroupOutputResponse()"}
}

extension DeleteKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKeyGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteKeyGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteKeyGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMonitoringSubscriptionInput(distributionId: \(Swift.String(describing: distributionId)))"}
}

extension DeleteMonitoringSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteMonitoringSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInput: Swift.Equatable {
    /// <p>The ID of the distribution that you are disabling metrics for.</p>
    public let distributionId: Swift.String?

    public init (
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct DeleteMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension DeleteMonitoringSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMonitoringSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMonitoringSubscriptionOutputResponse()"}
}

extension DeleteMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMonitoringSubscriptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
}

extension DeleteMonitoringSubscriptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOriginRequestPolicyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInput: Swift.Equatable {
    /// <p>The unique identifier for the origin request policy that you are deleting. To get the
    /// 			identifier, you can use <code>ListOriginRequestPolicies</code>.</p>
    public let id: Swift.String?
    /// <p>The version of the origin request policy that you are deleting. The version is the origin
    /// 			request policy’s <code>ETag</code> value, which you can get using
    /// 			<code>ListOriginRequestPolicies</code>, <code>GetOriginRequestPolicy</code>, or
    /// 			<code>GetOriginRequestPolicyConfig</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteOriginRequestPolicyInputBody: Swift.Equatable {
}

extension DeleteOriginRequestPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyInUse" : self = .originRequestPolicyInUse(try OriginRequestPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyInUse(OriginRequestPolicyInUse)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOriginRequestPolicyOutputResponse()"}
}

extension DeleteOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginRequestPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOriginRequestPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteOriginRequestPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePublicKeyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeletePublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInput: Swift.Equatable {
    /// <p>The ID of the public key you want to remove from CloudFront.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			public key identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeletePublicKeyInputBody: Swift.Equatable {
}

extension DeletePublicKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyInUse" : self = .publicKeyInUse(try PublicKeyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case publicKeyInUse(PublicKeyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePublicKeyOutputResponse()"}
}

extension DeletePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicKeyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePublicKeyOutputResponseBody: Swift.Equatable {
}

extension DeletePublicKeyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

extension DeleteRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRealtimeLogConfigInput(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension DeleteRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

public struct DeleteRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to delete.</p>
    public let aRN: Swift.String?
    /// <p>The name of the real-time log configuration to delete.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteRealtimeLogConfigInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let aRN: Swift.String?
}

extension DeleteRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension DeleteRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigInUse" : self = .realtimeLogConfigInUse(try RealtimeLogConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigInUse(RealtimeLogConfigInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRealtimeLogConfigOutputResponse()"}
}

extension DeleteRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRealtimeLogConfigOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRealtimeLogConfigOutputResponseBody: Swift.Equatable {
}

extension DeleteRealtimeLogConfigOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingDistributionInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension DeleteStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingDistributionOutputError>
}

public struct DeleteStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingDistributionOutputError>
}

/// <p>The request to delete a streaming distribution.</p>
public struct DeleteStreamingDistributionInput: Swift.Equatable {
    /// <p>The distribution ID. </p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when you disabled the
    /// 			streaming distribution. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteStreamingDistributionInputBody: Swift.Equatable {
}

extension DeleteStreamingDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionNotDisabled" : self = .streamingDistributionNotDisabled(try StreamingDistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case streamingDistributionNotDisabled(StreamingDistributionNotDisabled)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingDistributionOutputResponse()"}
}

extension DeleteStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamingDistributionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStreamingDistributionOutputResponseBody: Swift.Equatable {
}

extension DeleteStreamingDistributionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFunctionInput(name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)))"}
}

extension DescribeFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInput: Swift.Equatable {
    /// <p>The name of the function that you are getting information about.</p>
    public let name: Swift.String?
    /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    public let stage: CloudFrontClientTypes.FunctionStage?

    public init (
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct DescribeFunctionInputBody: Swift.Equatable {
}

extension DescribeFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFunctionOutputError: Swift.Error, Swift.Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFunctionOutputResponse(eTag: \(Swift.String(describing: eTag)), functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension DescribeFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct DescribeFunctionOutputResponse: Swift.Equatable {
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: Swift.String?
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct DescribeFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension DescribeFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension CloudFrontClientTypes.Distribution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case activeTrustedKeyGroups = "ActiveTrustedKeyGroups"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case aliasICPRecordals = "AliasICPRecordals"
        case distributionConfig = "DistributionConfig"
        case domainName = "DomainName"
        case id = "Id"
        case inProgressInvalidationBatches = "InProgressInvalidationBatches"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedKeyGroups = activeTrustedKeyGroups {
            try container.encode(activeTrustedKeyGroups, forKey: ClientRuntime.Key("ActiveTrustedKeyGroups"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let inProgressInvalidationBatches = inProgressInvalidationBatches {
            try container.encode(inProgressInvalidationBatches, forKey: ClientRuntime.Key("InProgressInvalidationBatches"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let inProgressInvalidationBatchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgressInvalidationBatches)
        inProgressInvalidationBatches = inProgressInvalidationBatchesDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let activeTrustedKeyGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedKeyGroups.self, forKey: .activeTrustedKeyGroups)
        activeTrustedKeyGroups = activeTrustedKeyGroupsDecoded
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.Distribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Distribution(aRN: \(Swift.String(describing: aRN)), activeTrustedKeyGroups: \(Swift.String(describing: activeTrustedKeyGroups)), activeTrustedSigners: \(Swift.String(describing: activeTrustedSigners)), aliasICPRecordals: \(Swift.String(describing: aliasICPRecordals)), distributionConfig: \(Swift.String(describing: distributionConfig)), domainName: \(Swift.String(describing: domainName)), id: \(Swift.String(describing: id)), inProgressInvalidationBatches: \(Swift.String(describing: inProgressInvalidationBatches)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.Distribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A distribution tells CloudFront where you want content to be delivered from, and the details about how to
    /// 			track and manage content delivery.</p>
    public struct Distribution: Swift.Equatable {
        /// <p>The ARN (Amazon Resource Name) for the distribution. For example:
        /// 				<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
        /// 				<code>123456789012</code> is your AWS account ID.</p>
        public let aRN: Swift.String?
        /// <p>CloudFront automatically adds this field to the response if you’ve configured a cache
        /// 			behavior in this distribution to serve private content using key groups. This field
        /// 			contains a list of key groups and the public keys in each key group that CloudFront can use to
        /// 			verify the signatures of signed URLs or signed cookies.</p>
        public let activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups?
        /// <important>
        /// 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
        /// 				<code>TrustedSigners</code>.</p>
        /// 		       </important>
        /// 		       <p>CloudFront automatically adds this field to the response if you’ve configured a cache behavior in
        /// 			this distribution to serve private content using trusted signers. This field contains a
        /// 			list of AWS account IDs and the active CloudFront key pairs in each account that CloudFront can use
        /// 			to verify the signatures of signed URLs or signed cookies.</p>
        public let activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// <p>AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
        /// 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
        /// 			recordal status for CNAMEs associated with distributions.</p>
        /// 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
        /// 			Signup, Accounts, and Credentials</a> in <i>Getting Started with AWS services in China</i>.</p>
        public let aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// <p>The current configuration information for the distribution. Send a <code>GET</code>
        /// 			request to the <code>/<i>CloudFront API version</i>/distribution ID/config</code>
        /// 			resource.</p>
        public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// <p>The domain name corresponding to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>. </p>
        public let domainName: Swift.String?
        /// <p>The identifier for the distribution. For example: <code>EDFDVBD632BHDS5</code>.
        /// 		</p>
        public let id: Swift.String?
        /// <p>The number of invalidation batches currently in progress. </p>
        public let inProgressInvalidationBatches: Swift.Int?
        /// <p>The date and time the distribution was last modified. </p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>This response element indicates the current status of the distribution. When the status
        /// 			is <code>Deployed</code>, the distribution's information is fully propagated to all CloudFront edge
        /// 			locations. </p>
        public let status: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            activeTrustedKeyGroups: CloudFrontClientTypes.ActiveTrustedKeyGroups? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            inProgressInvalidationBatches: Swift.Int? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.activeTrustedKeyGroups = activeTrustedKeyGroups
            self.activeTrustedSigners = activeTrustedSigners
            self.aliasICPRecordals = aliasICPRecordals
            self.distributionConfig = distributionConfig
            self.domainName = domainName
            self.id = id
            self.inProgressInvalidationBatches = inProgressInvalidationBatches
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

extension DistributionAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension DistributionAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
public struct DistributionAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case isIPV6Enabled = "IsIPV6Enabled"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let defaultRootObject = defaultRootObject {
            try container.encode(defaultRootObject, forKey: ClientRuntime.Key("DefaultRootObject"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.LoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfig(aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), defaultRootObject: \(Swift.String(describing: defaultRootObject)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), logging: \(Swift.String(describing: logging)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)))"}
}

extension CloudFrontClientTypes.DistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A distribution configuration.</p>
    public struct DistributionConfig: Swift.Equatable {
        /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
        /// 			for this distribution.</p>
        public let aliases: CloudFrontClientTypes.Aliases?
        /// <p>A complex type that contains zero or more <code>CacheBehavior</code> elements.
        /// 		</p>
        public let cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// <p>A unique value (for example, a date-time stamp) that ensures that the request can't be
        /// 			replayed.</p>
        /// 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
        /// 				<code>DistributionConfig</code> object), CloudFront creates a new distribution.</p>
        /// 		       <p>If <code>CallerReference</code> is a value that you already sent in a previous request to
        /// 			create a distribution, CloudFront returns a <code>DistributionAlreadyExists</code> error.</p>
        public let callerReference: Swift.String?
        /// <p>An optional comment to describe the distribution. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>A complex type that controls the following:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
        /// 					messages before returning the response to the viewer.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
        /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
        public let customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// <p>A complex type that describes the default cache behavior if you don't specify a
        /// 				<code>CacheBehavior</code> element or if files don't match any of the values of
        /// 				<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly one
        /// 			default cache behavior.</p>
        public let defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// <p>The object that you want CloudFront to request from your origin (for example,
        /// 				<code>index.html</code>) when a viewer requests the root URL for your distribution
        /// 				(<code>http://www.example.com</code>) instead of an object in your distribution
        /// 				(<code>http://www.example.com/product-description.html</code>). Specifying a default root
        /// 			object avoids exposing the contents of your distribution.</p>
        /// 		       <p>Specify only the object name, for example, <code>index.html</code>. Don't add a
        /// 				<code>/</code> before the object name.</p>
        /// 		       <p>If you don't want to specify a default root object when you create a distribution,
        /// 			include an empty <code>DefaultRootObject</code> element.</p>
        /// 		       <p>To delete the default root object from an existing distribution, update the
        /// 			distribution configuration and include an empty <code>DefaultRootObject</code>
        /// 			element.</p>
        /// 		       <p>To replace the default root object, update the distribution configuration and specify
        /// 			the new object.</p>
        /// 		       <p>For more information about the default root object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html">Creating a Default Root Object</a> in the
        /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
        public let defaultRootObject: Swift.String?
        /// <p>From this field, you can enable or disable the selected distribution.</p>
        public let enabled: Swift.Bool?
        /// <p>(Optional) Specify the maximum HTTP version that you want viewers to use to communicate
        /// 			with CloudFront. The default value for new web distributions is http2. Viewers that don't support
        /// 			HTTP/2 automatically use an earlier HTTP version.</p>
        /// 		       <p>For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must
        /// 			support Server Name Identification (SNI).</p>
        /// 		       <p>In general, configuring CloudFront to communicate with viewers using HTTP/2 reduces latency.
        /// 			You can improve performance by optimizing for HTTP/2. For more information, do an Internet
        /// 			search for "http/2 optimization." </p>
        public let httpVersion: CloudFrontClientTypes.HttpVersion?
        /// <p>If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your
        /// 			distribution, specify <code>true</code>. If you specify <code>false</code>, CloudFront responds to
        /// 			IPv6 DNS requests with the DNS response code <code>NOERROR</code> and with no IP addresses.
        /// 			This allows viewers to submit a second request, for an IPv4 address for your distribution. </p>
        /// 		       <p>In general, you should enable IPv6 if you have users on IPv6 networks who want to
        /// 			access your content. However, if you're using signed URLs or signed cookies to restrict access
        /// 			to your content, and if you're using a custom policy that includes the <code>IpAddress</code>
        /// 			parameter to restrict the IP addresses that can access your content, don't enable IPv6. If
        /// 			you want to restrict access to some content by IP address and not restrict access to other
        /// 			content (or restrict access but not by IP address), you can create two distributions. For more
        /// 			information, see
        /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html">Creating a Signed URL Using a Custom Policy</a> in the <i>Amazon CloudFront Developer
        /// 				Guide</i>.</p>
        /// 		       <p>If you're using an Amazon Route 53 alias resource record set to route traffic to your CloudFront
        /// 			distribution, you need to create a second alias resource record set when both of the following
        /// 			are true:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>You enable IPv6 for the distribution</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>You're using alternate domain names in the URLs for your objects</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html">Routing Traffic
        /// 				to an Amazon CloudFront Web Distribution by Using Your Domain Name</a> in the <i>Amazon Route 53
        /// 				Developer Guide</i>.</p>
        /// 		       <p>If you created a CNAME resource record set, either with Amazon Route 53 or with another DNS
        /// 			service, you don't need to make any changes. A CNAME record will route traffic to your
        /// 			distribution regardless of the IP address format of the viewer request.</p>
        public let isIPV6Enabled: Swift.Bool?
        /// <p>A complex type that controls whether access logs are written for the
        /// 			distribution.</p>
        /// 		       <p>For more information about logging, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html">Access
        /// 				Logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let logging: CloudFrontClientTypes.LoggingConfig?
        /// <p> A complex type that contains information about origin groups for this
        /// 			distribution.</p>
        public let originGroups: CloudFrontClientTypes.OriginGroups?
        /// <p>A complex type that contains information about origins for this distribution.
        /// 		</p>
        public let origins: CloudFrontClientTypes.Origins?
        /// <p>The price class that corresponds with the maximum price that you want to pay for CloudFront
        /// 			service. If you specify <code>PriceClass_All</code>, CloudFront responds to requests for your
        /// 			objects from all CloudFront edge locations.</p>
        /// 		       <p>If you specify a price class other than <code>PriceClass_All</code>, CloudFront serves your
        /// 			objects from the CloudFront edge location that has the lowest latency among the edge locations in
        /// 			your price class. Viewers who are in or near regions that are excluded from your specified
        /// 			price class may encounter slower performance.</p>
        /// 		       <p>For more information about price classes, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html">Choosing the Price Class
        /// 			for a CloudFront Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>. For
        /// 			information about CloudFront pricing, including how price classes (such as Price Class 100)
        /// 			map to CloudFront regions, see <a href="http://aws.amazon.com/cloudfront/pricing/">Amazon CloudFront
        /// 			Pricing</a>.</p>
        public let priceClass: CloudFrontClientTypes.PriceClass?
        /// <p>A complex type that identifies ways in which you want to restrict distribution of your
        /// 			content.</p>
        public let restrictions: CloudFrontClientTypes.Restrictions?
        /// <p>A complex type that determines the distribution’s SSL/TLS configuration for
        /// 			communicating with viewers.</p>
        public let viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// <p>A unique identifier that specifies the AWS WAF web ACL, if any, to associate
        /// 			with this distribution. To specify a web ACL created using the latest version of AWS
        /// 			WAF, use the ACL ARN, for example
        /// 			<code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>.
        /// 			To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example
        /// 			<code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
        /// 		       <p>AWS WAF is a web application firewall that lets you monitor the HTTP and HTTPS
        /// 			requests that are forwarded to CloudFront, and lets you control access to your content. Based on
        /// 			conditions that you specify, such as the IP addresses that requests originate from or the
        /// 			values of query strings, CloudFront responds to requests either with the requested content or with
        /// 			an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page
        /// 			when a request is blocked. For more information about AWS WAF, see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html">AWS WAF
        /// 				Developer Guide</a>. </p>
        public let webACLId: Swift.String?

        public init (
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.LoggingConfig? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.callerReference = callerReference
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.isIPV6Enabled = isIPV6Enabled
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.DistributionConfigWithTags: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.DistributionConfigWithTags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfigWithTags(distributionConfig: \(Swift.String(describing: distributionConfig)), tags: \(Swift.String(describing: tags)))"}
}

extension CloudFrontClientTypes.DistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A distribution Configuration and a list of tags to be associated with the
    /// 			distribution.</p>
    public struct DistributionConfigWithTags: Swift.Equatable {
        /// <p>A distribution configuration.</p>
        public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
        /// <p>A complex type that contains zero or more <code>Tag</code> elements.</p>
        public let tags: CloudFrontClientTypes.Tags?

        public init (
            distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.distributionConfig = distributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.DistributionIdList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("DistributionId"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionIdList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionIdList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.DistributionIdList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of distribution IDs.</p>
    public struct DistributionIdList: Swift.Equatable {
        /// <p>A flag that indicates whether more distribution IDs remain to be listed. If your
        /// 			results were truncated, you can make a subsequent request using the <code>Marker</code>
        /// 			request field to retrieve more distribution IDs in the list.</p>
        public let isTruncated: Swift.Bool?
        /// <p>Contains the distribution IDs in the list.</p>
        public let items: [Swift.String]?
        /// <p>The value provided in the <code>Marker</code> request field.</p>
        public let marker: Swift.String?
        /// <p>The maximum number of distribution IDs requested.</p>
        public let maxItems: Swift.Int?
        /// <p>Contains the value that you should use in the <code>Marker</code> field of a
        /// 			subsequent request to continue listing distribution IDs where you left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The total number of distribution IDs returned in the response.</p>
        public let quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.DistributionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for distributionsummary0 in items {
                try itemsContainer.encode(distributionsummary0, forKey: ClientRuntime.Key("DistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.DistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.DistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.DistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.DistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A distribution list.</p>
    public struct DistributionList: Swift.Equatable {
        /// <p>A flag that indicates whether more distributions remain to be listed. If your results
        /// 			were truncated, you can make a follow-up pagination request using the <code>Marker</code>
        /// 			request parameter to retrieve more distributions in the list.</p>
        public let isTruncated: Swift.Bool?
        /// <p>A complex type that contains one <code>DistributionSummary</code> element for each
        /// 			distribution that was created by the current AWS account.</p>
        public let items: [CloudFrontClientTypes.DistributionSummary]?
        /// <p>The value you provided for the <code>Marker</code> request parameter.</p>
        public let marker: Swift.String?
        /// <p>The value you provided for the <code>MaxItems</code> request parameter.</p>
        public let maxItems: Swift.Int?
        /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
        /// 			the value you can use for the <code>Marker</code> request parameter to continue listing your
        /// 			distributions where they left off. </p>
        public let nextMarker: Swift.String?
        /// <p>The number of distributions that were created by the current AWS account. </p>
        public let quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.DistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension DistributionNotDisabled: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionNotDisabled(message: \(Swift.String(describing: message)))"}
}

extension DistributionNotDisabled: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<DistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CloudFront distribution is not disabled. You must disable
/// 			the distribution before you can delete it.</p>
public struct DistributionNotDisabled: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionNotDisabledBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.DistributionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case aliasICPRecordals = "AliasICPRecordals"
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case id = "Id"
        case isIPV6Enabled = "IsIPV6Enabled"
        case lastModifiedTime = "LastModifiedTime"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case status = "Status"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: ClientRuntime.Key("AliasICPRecordal"))
            }
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: ClientRuntime.Key("CacheBehaviors"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: ClientRuntime.Key("CustomErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: ClientRuntime.Key("DefaultCacheBehavior"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: ClientRuntime.Key("HttpVersion"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: ClientRuntime.Key("IsIPV6Enabled"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: ClientRuntime.Key("OriginGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: ClientRuntime.Key("Origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: ClientRuntime.Key("Restrictions"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: ClientRuntime.Key("ViewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: ClientRuntime.Key("WebACLId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let originsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[CloudFrontClientTypes.AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [CloudFrontClientTypes.AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension CloudFrontClientTypes.DistributionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionSummary(aRN: \(Swift.String(describing: aRN)), aliasICPRecordals: \(Swift.String(describing: aliasICPRecordals)), aliases: \(Swift.String(describing: aliases)), cacheBehaviors: \(Swift.String(describing: cacheBehaviors)), comment: \(Swift.String(describing: comment)), customErrorResponses: \(Swift.String(describing: customErrorResponses)), defaultCacheBehavior: \(Swift.String(describing: defaultCacheBehavior)), domainName: \(Swift.String(describing: domainName)), enabled: \(Swift.String(describing: enabled)), httpVersion: \(Swift.String(describing: httpVersion)), id: \(Swift.String(describing: id)), isIPV6Enabled: \(Swift.String(describing: isIPV6Enabled)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), originGroups: \(Swift.String(describing: originGroups)), origins: \(Swift.String(describing: origins)), priceClass: \(Swift.String(describing: priceClass)), restrictions: \(Swift.String(describing: restrictions)), status: \(Swift.String(describing: status)), viewerCertificate: \(Swift.String(describing: viewerCertificate)), webACLId: \(Swift.String(describing: webACLId)))"}
}

extension CloudFrontClientTypes.DistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A summary of the information about a CloudFront distribution.</p>
    public struct DistributionSummary: Swift.Equatable {
        /// <p>The ARN (Amazon Resource Name) for the distribution. For example:
        /// 				<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
        /// 				<code>123456789012</code> is your AWS account ID.</p>
        public let aRN: Swift.String?
        /// <p>AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
        /// 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
        /// 			recordal status for CNAMEs associated with distributions.</p>
        /// 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
        /// 			Signup, Accounts, and Credentials</a> in <i>Getting Started with AWS services in China</i>.</p>
        public let aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]?
        /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
        /// 			for this distribution.</p>
        public let aliases: CloudFrontClientTypes.Aliases?
        /// <p>A complex type that contains zero or more <code>CacheBehavior</code>
        /// 			elements.</p>
        public let cacheBehaviors: CloudFrontClientTypes.CacheBehaviors?
        /// <p>The comment originally specified when this distribution was created.</p>
        public let comment: Swift.String?
        /// <p>A complex type that contains zero or more <code>CustomErrorResponses</code>
        /// 			elements.</p>
        public let customErrorResponses: CloudFrontClientTypes.CustomErrorResponses?
        /// <p>A complex type that describes the default cache behavior if you don't specify a
        /// 				<code>CacheBehavior</code> element or if files don't match any of the values of
        /// 				<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly one
        /// 			default cache behavior.</p>
        public let defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior?
        /// <p>The domain name that corresponds to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>.</p>
        public let domainName: Swift.String?
        /// <p>Whether the distribution is enabled to accept user requests for content.</p>
        public let enabled: Swift.Bool?
        /// <p> Specify the maximum HTTP version that you want viewers to use to communicate with
        /// 			CloudFront. The default value for new web distributions is <code>http2</code>. Viewers that don't
        /// 			support <code>HTTP/2</code> will automatically use an earlier version.</p>
        public let httpVersion: CloudFrontClientTypes.HttpVersion?
        /// <p>The identifier for the distribution. For example:
        /// 			<code>EDFDVBD632BHDS5</code>.</p>
        public let id: Swift.String?
        /// <p>Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your
        /// 			distribution.</p>
        public let isIPV6Enabled: Swift.Bool?
        /// <p>The date and time the distribution was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p> A complex type that contains information about origin groups for this
        /// 			distribution.</p>
        public let originGroups: CloudFrontClientTypes.OriginGroups?
        /// <p>A complex type that contains information about origins for this distribution.</p>
        public let origins: CloudFrontClientTypes.Origins?
        /// <p>A complex type that contains information about price class for this streaming
        /// 			distribution. </p>
        public let priceClass: CloudFrontClientTypes.PriceClass?
        /// <p>A complex type that identifies ways in which you want to restrict distribution of your
        /// 			content.</p>
        public let restrictions: CloudFrontClientTypes.Restrictions?
        /// <p>The current status of the distribution. When the status is <code>Deployed</code>, the
        /// 			distribution's information is propagated to all CloudFront edge locations.</p>
        public let status: Swift.String?
        /// <p>A complex type that determines the distribution’s SSL/TLS configuration for
        /// 			communicating with viewers.</p>
        public let viewerCertificate: CloudFrontClientTypes.ViewerCertificate?
        /// <p>The Web ACL Id (if any) associated with the distribution.</p>
        public let webACLId: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            aliasICPRecordals: [CloudFrontClientTypes.AliasICPRecordal]? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            cacheBehaviors: CloudFrontClientTypes.CacheBehaviors? = nil,
            comment: Swift.String? = nil,
            customErrorResponses: CloudFrontClientTypes.CustomErrorResponses? = nil,
            defaultCacheBehavior: CloudFrontClientTypes.DefaultCacheBehavior? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            httpVersion: CloudFrontClientTypes.HttpVersion? = nil,
            id: Swift.String? = nil,
            isIPV6Enabled: Swift.Bool? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originGroups: CloudFrontClientTypes.OriginGroups? = nil,
            origins: CloudFrontClientTypes.Origins? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            restrictions: CloudFrontClientTypes.Restrictions? = nil,
            status: Swift.String? = nil,
            viewerCertificate: CloudFrontClientTypes.ViewerCertificate? = nil,
            webACLId: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.aliasICPRecordals = aliasICPRecordals
            self.aliases = aliases
            self.cacheBehaviors = cacheBehaviors
            self.comment = comment
            self.customErrorResponses = customErrorResponses
            self.defaultCacheBehavior = defaultCacheBehavior
            self.domainName = domainName
            self.enabled = enabled
            self.httpVersion = httpVersion
            self.id = id
            self.isIPV6Enabled = isIPV6Enabled
            self.lastModifiedTime = lastModifiedTime
            self.originGroups = originGroups
            self.origins = origins
            self.priceClass = priceClass
            self.restrictions = restrictions
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webACLId = webACLId
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntities: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for encryptionentity0 in items {
                try itemsContainer.encode(encryptionentity0, forKey: ClientRuntime.Key("EncryptionEntity"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct EncryptionEntity{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EncryptionEntity>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EncryptionEntity].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.EncryptionEntity]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.EncryptionEntity]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.EncryptionEntities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionEntities(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.EncryptionEntities: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Complex data type for field-level encryption profiles that includes all of the encryption entities. </p>
    public struct EncryptionEntities: Swift.Equatable {
        /// <p>An array of field patterns in a field-level encryption content type-profile mapping. </p>
        public let items: [CloudFrontClientTypes.EncryptionEntity]?
        /// <p>Number of field pattern items in a field-level encryption content type-profile mapping. </p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.EncryptionEntity]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.EncryptionEntity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldPatterns = "FieldPatterns"
        case providerId = "ProviderId"
        case publicKeyId = "PublicKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldPatterns = fieldPatterns {
            try container.encode(fieldPatterns, forKey: ClientRuntime.Key("FieldPatterns"))
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: ClientRuntime.Key("ProviderId"))
        }
        if let publicKeyId = publicKeyId {
            try container.encode(publicKeyId, forKey: ClientRuntime.Key("PublicKeyId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyId)
        publicKeyId = publicKeyIdDecoded
        let providerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerId)
        providerId = providerIdDecoded
        let fieldPatternsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldPatterns.self, forKey: .fieldPatterns)
        fieldPatterns = fieldPatternsDecoded
    }
}

extension CloudFrontClientTypes.EncryptionEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionEntity(fieldPatterns: \(Swift.String(describing: fieldPatterns)), providerId: \(Swift.String(describing: providerId)), publicKeyId: \(Swift.String(describing: publicKeyId)))"}
}

extension CloudFrontClientTypes.EncryptionEntity: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications. </p>
    public struct EncryptionEntity: Swift.Equatable {
        /// <p>Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the
        /// 			full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have
        /// 			both ABC* and AB*. Note that field patterns are case-sensitive. </p>
        public let fieldPatterns: CloudFrontClientTypes.FieldPatterns?
        /// <p>The provider associated with the public key being used for encryption. This value must also be provided with the private key
        /// 		for applications to be able to decrypt data.</p>
        public let providerId: Swift.String?
        /// <p>The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match
        /// 			the patterns. </p>
        public let publicKeyId: Swift.String?

        public init (
            fieldPatterns: CloudFrontClientTypes.FieldPatterns? = nil,
            providerId: Swift.String? = nil,
            publicKeyId: Swift.String? = nil
        )
        {
            self.fieldPatterns = fieldPatterns
            self.providerId = providerId
            self.publicKeyId = publicKeyId
        }
    }

}

extension CloudFrontClientTypes.EndPoint: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisStreamConfig = "KinesisStreamConfig"
        case streamType = "StreamType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try container.encode(kinesisStreamConfig, forKey: ClientRuntime.Key("KinesisStreamConfig"))
        }
        if let streamType = streamType {
            try container.encode(streamType, forKey: ClientRuntime.Key("StreamType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamType)
        streamType = streamTypeDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
    }
}

extension CloudFrontClientTypes.EndPoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndPoint(kinesisStreamConfig: \(Swift.String(describing: kinesisStreamConfig)), streamType: \(Swift.String(describing: streamType)))"}
}

extension CloudFrontClientTypes.EndPoint: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
    /// 			log data in a real-time log configuration.</p>
    public struct EndPoint: Swift.Equatable {
        /// <p>Contains information about the Amazon Kinesis data stream where you are sending
        /// 			real-time log data.</p>
        public let kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig?
        /// <p>The type of data stream where you are sending real-time log data. The only valid value is
        /// 			<code>Kinesis</code>.</p>
        public let streamType: Swift.String?

        public init (
            kinesisStreamConfig: CloudFrontClientTypes.KinesisStreamConfig? = nil,
            streamType: Swift.String? = nil
        )
        {
            self.kinesisStreamConfig = kinesisStreamConfig
            self.streamType = streamType
        }
    }

}

extension CloudFrontClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case originRequest
        case originResponse
        case viewerRequest
        case viewerResponse
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .originRequest,
                .originResponse,
                .viewerRequest,
                .viewerResponse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .originRequest: return "origin-request"
            case .originResponse: return "origin-response"
            case .viewerRequest: return "viewer-request"
            case .viewerResponse: return "viewer-response"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryption(fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryption: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type that includes the profile configurations and other options specified for field-level encryption. </p>
    public struct FieldLevelEncryption: Swift.Equatable {
        /// <p>A complex data type that includes the profile configurations specified for field-level encryption. </p>
        public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
        /// <p>The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain
        /// 		selected data fields to be encrypted by specific public keys.</p>
        public let id: Swift.String?
        /// <p>The last time the field-level encryption configuration was changed. </p>
        public let lastModifiedTime: ClientRuntime.Date?

        public init (
            fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), contentTypeProfileConfig: \(Swift.String(describing: contentTypeProfileConfig)), queryArgProfileConfig: \(Swift.String(describing: queryArgProfileConfig)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type that includes the profile configurations specified for field-level encryption. </p>
    public struct FieldLevelEncryptionConfig: Swift.Equatable {
        /// <p>A unique number that ensures the request can't be replayed.</p>
        public let callerReference: Swift.String?
        /// <p>An optional comment about the configuration. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default
        /// 			in a request if a query argument doesn't specify a profile to use.</p>
        public let contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// <p>A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a
        /// 			query argument in a request.</p>
        public let queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension FieldLevelEncryptionConfigAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionConfigAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionConfigAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FieldLevelEncryptionConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption already exists.</p>
public struct FieldLevelEncryptionConfigAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionConfigInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionConfigInUse(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionConfigInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FieldLevelEncryptionConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption is in use.</p>
public struct FieldLevelEncryptionConfigInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionsummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionsummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>List of field-level encrpytion configurations.</p>
    public struct FieldLevelEncryptionList: Swift.Equatable {
        /// <p>An array of field-level encryption items.</p>
        public let items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]?
        /// <p>The maximum number of elements you want in the response body. </p>
        public let maxItems: Swift.Int?
        /// <p>If there are more elements to be listed, this element is present and contains
        /// 			the value that you can use for the <code>Marker</code> request parameter to continue
        /// 			listing your configurations where you left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The number of field-level encryption items.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FieldLevelEncryptionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfile(fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type for field-level encryption profiles.</p>
    public struct FieldLevelEncryptionProfile: Swift.Equatable {
        /// <p>A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.</p>
        public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
        /// <p>The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain
        /// 			selected data fields to be encrypted by specific public keys.</p>
        public let id: Swift.String?
        /// <p>The last time the field-level encryption profile was updated.</p>
        public let lastModifiedTime: ClientRuntime.Date?

        public init (
            fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension FieldLevelEncryptionProfileAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionProfileAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FieldLevelEncryptionProfileAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified profile for field-level encryption already exists.</p>
public struct FieldLevelEncryptionProfileAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionProfileAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), encryptionEntities: \(Swift.String(describing: encryptionEntities)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type of profiles for the field-level encryption.</p>
    public struct FieldLevelEncryptionProfileConfig: Swift.Equatable {
        /// <p>A unique number that ensures that the request can't be replayed.</p>
        public let callerReference: Swift.String?
        /// <p>An optional comment for the field-level encryption profile. The comment cannot be longer
        /// 			than 128 characters.</p>
        public let comment: Swift.String?
        /// <p>A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and
        /// 			field patterns for specifying which fields to encrypt with this key.</p>
        public let encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// <p>Profile name for the field-level encryption profile.</p>
        public let name: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.name = name
        }
    }

}

extension FieldLevelEncryptionProfileInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileInUse(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionProfileInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FieldLevelEncryptionProfileInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified profile for field-level encryption is in use.</p>
public struct FieldLevelEncryptionProfileInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionProfileInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for fieldlevelencryptionprofilesummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionprofilesummary0, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionProfileSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionProfileSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FieldLevelEncryptionProfileSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>List of field-level encryption profiles.</p>
    public struct FieldLevelEncryptionProfileList: Swift.Equatable {
        /// <p>The field-level encryption profile items.</p>
        public let items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]?
        /// <p>The maximum number of field-level encryption profiles you want in the response body. </p>
        public let maxItems: Swift.Int?
        /// <p>If there are more elements to be listed, this element is present and contains
        /// 			the value that you can use for the <code>Marker</code> request parameter to continue
        /// 			listing your profiles where you left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The number of field-level encryption profiles.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FieldLevelEncryptionProfileSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension FieldLevelEncryptionProfileSizeExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileSizeExceeded(message: \(Swift.String(describing: message)))"}
}

extension FieldLevelEncryptionProfileSizeExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FieldLevelEncryptionProfileSizeExceededBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
public struct FieldLevelEncryptionProfileSizeExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileSizeExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FieldLevelEncryptionProfileSizeExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: ClientRuntime.Key("EncryptionEntities"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionProfileSummary(comment: \(Swift.String(describing: comment)), encryptionEntities: \(Swift.String(describing: encryptionEntities)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionProfileSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>The field-level encryption profile summary.</p>
    public struct FieldLevelEncryptionProfileSummary: Swift.Equatable {
        /// <p>An optional comment for the field-level encryption profile summary. The comment cannot be
        /// 			longer than 128 characters.</p>
        public let comment: Swift.String?
        /// <p>A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and
        /// 			field patterns for specifying which fields to encrypt with this key.</p>
        public let encryptionEntities: CloudFrontClientTypes.EncryptionEntities?
        /// <p>ID for the field-level encryption profile summary.</p>
        public let id: Swift.String?
        /// <p>The time when the the field-level encryption profile summary was last updated.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>Name for the field-level encryption profile summary.</p>
        public let name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            encryptionEntities: CloudFrontClientTypes.EncryptionEntities? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encryptionEntities = encryptionEntities
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: ClientRuntime.Key("ContentTypeProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: ClientRuntime.Key("QueryArgProfileConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldLevelEncryptionSummary(comment: \(Swift.String(describing: comment)), contentTypeProfileConfig: \(Swift.String(describing: contentTypeProfileConfig)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), queryArgProfileConfig: \(Swift.String(describing: queryArgProfileConfig)))"}
}

extension CloudFrontClientTypes.FieldLevelEncryptionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A summary of a field-level encryption item.</p>
    public struct FieldLevelEncryptionSummary: Swift.Equatable {
        /// <p>An optional comment about the field-level encryption item. The comment cannot be longer than
        /// 			128 characters.</p>
        public let comment: Swift.String?
        /// <p>
        /// 			A summary of a content type-profile mapping.
        /// 		</p>
        public let contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig?
        /// <p>The unique ID of a field-level encryption item.</p>
        public let id: Swift.String?
        /// <p>The last time that the summary of field-level encryption items was modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>
        /// 			A summary of a query argument-profile mapping.
        /// 		</p>
        public let queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig?

        public init (
            comment: Swift.String? = nil,
            contentTypeProfileConfig: CloudFrontClientTypes.ContentTypeProfileConfig? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            queryArgProfileConfig: CloudFrontClientTypes.QueryArgProfileConfig? = nil
        )
        {
            self.comment = comment
            self.contentTypeProfileConfig = contentTypeProfileConfig
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.queryArgProfileConfig = queryArgProfileConfig
        }
    }

}

extension CloudFrontClientTypes.FieldPatterns: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("FieldPattern"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldPattern{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldPattern>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FieldPatterns: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FieldPatterns(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FieldPatterns: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type that includes the field patterns to match for field-level encryption.</p>
    public struct FieldPatterns: Swift.Equatable {
        /// <p>An array of the field-level encryption field patterns.</p>
        public let items: [Swift.String]?
        /// <p>The number of field-level encryption field patterns.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case urlencoded
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .urlencoded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .urlencoded: return "URLEncoded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.ForwardedValues: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookies = "Cookies"
        case headers = "Headers"
        case queryString = "QueryString"
        case queryStringCacheKeys = "QueryStringCacheKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
        if let queryString = queryString {
            try container.encode(queryString, forKey: ClientRuntime.Key("QueryString"))
        }
        if let queryStringCacheKeys = queryStringCacheKeys {
            try container.encode(queryStringCacheKeys, forKey: ClientRuntime.Key("QueryStringCacheKeys"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .queryString)
        queryString = queryStringDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookiePreference.self, forKey: .cookies)
        cookies = cookiesDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
        let queryStringCacheKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringCacheKeys.self, forKey: .queryStringCacheKeys)
        queryStringCacheKeys = queryStringCacheKeysDecoded
    }
}

extension CloudFrontClientTypes.ForwardedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForwardedValues(cookies: \(Swift.String(describing: cookies)), headers: \(Swift.String(describing: headers)), queryString: \(Swift.String(describing: queryString)), queryStringCacheKeys: \(Swift.String(describing: queryStringCacheKeys)))"}
}

extension CloudFrontClientTypes.ForwardedValues: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include values in the cache key, use a cache policy. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send values to the origin but not include them in the cache key, use an
    /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
    public struct ForwardedValues: Swift.Equatable {
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field.</p>
        /// 		       <p>If you want to include cookies in the cache key, use a cache policy. For more
        /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use an
        /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>A complex type that specifies whether you want CloudFront to forward cookies to the origin
        /// 			and, if so, which ones. For more information about forwarding cookies to the origin, see
        /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html">How CloudFront Forwards, Caches, and Logs Cookies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let cookies: CloudFrontClientTypes.CookiePreference?
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field.</p>
        /// 		       <p>If you want to include headers in the cache key, use a cache policy. For more information,
        /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send headers to the origin but not include them in the cache key, use an
        /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>A complex type that specifies the <code>Headers</code>, if any, that you want CloudFront to forward to the
        /// 			origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches
        /// 			separate versions of a specified object that is based on the header values in viewer requests.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html">
        /// 			Caching Content Based on Request Headers</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let headers: CloudFrontClientTypes.Headers?
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field.</p>
        /// 		       <p>If you want to include query strings in the cache key, use a cache policy. For more
        /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send query strings to the origin but not include them in the cache key, use
        /// 			an origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>Indicates whether you want CloudFront to forward query strings to the origin that is
        /// 			associated with this cache behavior and cache based on the query string parameters. CloudFront
        /// 			behavior depends on the value of <code>QueryString</code> and on the values that you specify
        /// 			for <code>QueryStringCacheKeys</code>, if any:</p>
        /// 		       <p>If you specify true for <code>QueryString</code> and you don't specify any values for
        /// 				<code>QueryStringCacheKeys</code>, CloudFront forwards all query string parameters to the origin
        /// 			and caches based on all query string parameters. Depending on how many query string parameters
        /// 			and values you have, this can adversely affect performance because CloudFront must forward more
        /// 			requests to the origin.</p>
        /// 		       <p>If you specify true for <code>QueryString</code> and you specify one or more values for
        /// 				<code>QueryStringCacheKeys</code>, CloudFront forwards all query string parameters to the origin,
        /// 			but it only caches based on the query string parameters that you specify.</p>
        /// 		       <p>If you specify false for <code>QueryString</code>, CloudFront doesn't forward any query
        /// 			string parameters to the origin, and doesn't cache based on query string parameters.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html">Configuring CloudFront to Cache Based on Query String Parameters</a> in the
        /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
        public let queryString: Swift.Bool?
        /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
        /// 			request policy instead of this field.</p>
        /// 		       <p>If you want to include query strings in the cache key, use a cache policy. For more
        /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you want to send query strings to the origin but not include them in the cache key, use
        /// 			an origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>A complex type that contains information about the query string parameters that you
        /// 			want CloudFront to use for caching for this cache behavior.</p>
        public let queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys?

        public init (
            cookies: CloudFrontClientTypes.CookiePreference? = nil,
            headers: CloudFrontClientTypes.Headers? = nil,
            queryString: Swift.Bool? = nil,
            queryStringCacheKeys: CloudFrontClientTypes.QueryStringCacheKeys? = nil
        )
        {
            self.cookies = cookies
            self.headers = headers
            self.queryString = queryString
            self.queryStringCacheKeys = queryStringCacheKeys
        }
    }

}

extension FunctionAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension FunctionAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FunctionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A function with the same name already exists in this AWS account. To create a
/// 			function, you must provide a unique name. To update an existing function, use
/// 			<code>UpdateFunction</code>.</p>
public struct FunctionAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FunctionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case functionARN = "FunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
    }
}

extension CloudFrontClientTypes.FunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionAssociation(eventType: \(Swift.String(describing: eventType)), functionARN: \(Swift.String(describing: functionARN)))"}
}

extension CloudFrontClientTypes.FunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A CloudFront function that is associated with a cache behavior in a CloudFront
    /// 			distribution.</p>
    public struct FunctionAssociation: Swift.Equatable {
        /// <p>The event type of the function, either <code>viewer-request</code> or
        /// 			<code>viewer-response</code>. You cannot use origin-facing event types
        /// 			(<code>origin-request</code> and <code>origin-response</code>) with a CloudFront
        /// 			function.</p>
        public let eventType: CloudFrontClientTypes.EventType?
        /// <p>The Amazon Resource Name (ARN) of the function.</p>
        public let functionARN: Swift.String?

        public init (
            eventType: CloudFrontClientTypes.EventType? = nil,
            functionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.functionARN = functionARN
        }
    }

}

extension CloudFrontClientTypes.FunctionAssociations: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionassociation0 in items {
                try itemsContainer.encode(functionassociation0, forKey: ClientRuntime.Key("FunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionAssociations(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution.
    /// 			CloudFront functions must be published to the <code>LIVE</code> stage to associate them with a
    /// 			cache behavior.</p>
    public struct FunctionAssociations: Swift.Equatable {
        /// <p>The CloudFront functions that are associated with a cache behavior in a CloudFront distribution.  CloudFront
        /// 			functions must be published to the <code>LIVE</code> stage to associate them with a
        /// 			cache behavior.</p>
        public let items: [CloudFrontClientTypes.FunctionAssociation]?
        /// <p>The number of CloudFront functions in the list.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case runtime = "Runtime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let runtime = runtime {
            try container.encode(runtime, forKey: ClientRuntime.Key("Runtime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
    }
}

extension CloudFrontClientTypes.FunctionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionConfig(comment: \(Swift.String(describing: comment)), runtime: \(Swift.String(describing: runtime)))"}
}

extension CloudFrontClientTypes.FunctionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains configuration information about a CloudFront function.</p>
    public struct FunctionConfig: Swift.Equatable {
        /// <p>A comment to describe the function.</p>
        public let comment: Swift.String?
        /// <p>The function’s runtime environment. The only valid value is
        /// 			<code>cloudfront-js-1.0</code>.</p>
        public let runtime: CloudFrontClientTypes.FunctionRuntime?

        public init (
            comment: Swift.String? = nil,
            runtime: CloudFrontClientTypes.FunctionRuntime? = nil
        )
        {
            self.comment = comment
            self.runtime = runtime
        }
    }

}

extension FunctionInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionInUse(message: \(Swift.String(describing: message)))"}
}

extension FunctionInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FunctionInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the function because it’s attached to one or more cache
/// 			behaviors.</p>
public struct FunctionInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FunctionInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.FunctionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for functionsummary0 in items {
                try itemsContainer.encode(functionsummary0, forKey: ClientRuntime.Key("FunctionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.FunctionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.FunctionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.FunctionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.FunctionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.FunctionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of CloudFront functions.</p>
    public struct FunctionList: Swift.Equatable {
        /// <p>Contains the functions in the list.</p>
        public let items: [CloudFrontClientTypes.FunctionSummary]?
        /// <p>The maximum number of functions requested.</p>
        public let maxItems: Swift.Int?
        /// <p>If there are more items in the list than are in this response, this element is
        /// 			present. It contains the value that you should use in the <code>Marker</code> field of a
        /// 			subsequent request to continue listing functions where you left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The number of functions returned in the response.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.FunctionSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.FunctionMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case functionARN = "FunctionARN"
        case lastModifiedTime = "LastModifiedTime"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: ClientRuntime.Key("FunctionARN"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
    }
}

extension CloudFrontClientTypes.FunctionMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionMetadata(createdTime: \(Swift.String(describing: createdTime)), functionARN: \(Swift.String(describing: functionARN)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), stage: \(Swift.String(describing: stage)))"}
}

extension CloudFrontClientTypes.FunctionMetadata: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains metadata about a CloudFront function.</p>
    public struct FunctionMetadata: Swift.Equatable {
        /// <p>The date and time when the function was created.</p>
        public let createdTime: ClientRuntime.Date?
        /// <p>The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the
        /// 			function.</p>
        public let functionARN: Swift.String?
        /// <p>The date and time when the function was most recently updated.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The stage that the function is in, either <code>DEVELOPMENT</code> or
        /// 			<code>LIVE</code>.</p>
        /// 		       <p>When a function is in the <code>DEVELOPMENT</code> stage, you can test the function with
        /// 				<code>TestFunction</code>, and update it with <code>UpdateFunction</code>.</p>
        /// 		       <p>When a function is in the <code>LIVE</code> stage, you can attach the function to a
        /// 			distribution’s cache behavior, using the function’s ARN.</p>
        public let stage: CloudFrontClientTypes.FunctionStage?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            functionARN: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            stage: CloudFrontClientTypes.FunctionStage? = nil
        )
        {
            self.createdTime = createdTime
            self.functionARN = functionARN
            self.lastModifiedTime = lastModifiedTime
            self.stage = stage
        }
    }

}

extension CloudFrontClientTypes {
    public enum FunctionRuntime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudfrontJs10
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionRuntime] {
            return [
                .cloudfrontJs10,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudfrontJs10: return "cloudfront-js-1.0"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionRuntime(rawValue: rawValue) ?? FunctionRuntime.sdkUnknown(rawValue)
        }
    }
}

extension FunctionSizeLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionSizeLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension FunctionSizeLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<FunctionSizeLimitExceededBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct FunctionSizeLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionSizeLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FunctionSizeLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum FunctionStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionStage] {
            return [
                .development,
                .live,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionStage(rawValue: rawValue) ?? FunctionStage.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.FunctionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionConfig = "FunctionConfig"
        case functionMetadata = "FunctionMetadata"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
        if let functionMetadata = functionMetadata {
            try container.encode(functionMetadata, forKey: ClientRuntime.Key("FunctionMetadata"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        let functionMetadataDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionMetadata.self, forKey: .functionMetadata)
        functionMetadata = functionMetadataDecoded
    }
}

extension CloudFrontClientTypes.FunctionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FunctionSummary(functionConfig: \(Swift.String(describing: functionConfig)), functionMetadata: \(Swift.String(describing: functionMetadata)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.FunctionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public struct FunctionSummary: Swift.Equatable {
        /// <p>Contains configuration information about a CloudFront function.</p>
        public let functionConfig: CloudFrontClientTypes.FunctionConfig?
        /// <p>Contains metadata about a CloudFront function.</p>
        public let functionMetadata: CloudFrontClientTypes.FunctionMetadata?
        /// <p>The name of the CloudFront function.</p>
        public let name: Swift.String?
        /// <p>The status of the CloudFront function.</p>
        public let status: Swift.String?

        public init (
            functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
            functionMetadata: CloudFrontClientTypes.FunctionMetadata? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.functionConfig = functionConfig
            self.functionMetadata = functionMetadata
            self.name = name
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.GeoRestriction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
        case restrictionType = "RestrictionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Location"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
        if let restrictionType = restrictionType {
            try container.encode(restrictionType, forKey: ClientRuntime.Key("RestrictionType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestrictionType.self, forKey: .restrictionType)
        restrictionType = restrictionTypeDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Location{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Location>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.GeoRestriction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GeoRestriction(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)), restrictionType: \(Swift.String(describing: restrictionType)))"}
}

extension CloudFrontClientTypes.GeoRestriction: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls the countries in which your content is distributed. CloudFront
    /// 			determines the location of your users using <code>MaxMind</code> GeoIP databases. </p>
    public struct GeoRestriction: Swift.Equatable {
        /// <p> A complex type that contains a <code>Location</code> element for each country in which
        /// 			you want CloudFront either to distribute your content (<code>whitelist</code>) or not distribute
        /// 			your content (<code>blacklist</code>).</p>
        /// 		       <p>The <code>Location</code> element is a two-letter, uppercase country code for a country
        /// 			that you want to include in your <code>blacklist</code> or <code>whitelist</code>. Include one
        /// 				<code>Location</code> element for each country.</p>
        /// 		       <p>CloudFront and <code>MaxMind</code> both use <code>ISO 3166</code> country codes. For the
        /// 			current list of countries and the corresponding codes, see <code>ISO 3166-1-alpha-2</code>
        /// 			code on the <i>International Organization for Standardization</i> website. You
        /// 			can also refer to the country list on the CloudFront console, which includes both country names and
        /// 			codes.</p>
        public let items: [Swift.String]?
        /// <p>When geo restriction is <code>enabled</code>, this is the number of countries in your
        /// 				<code>whitelist</code> or <code>blacklist</code>. Otherwise, when it is not enabled,
        /// 				<code>Quantity</code> is <code>0</code>, and you can omit <code>Items</code>.</p>
        public let quantity: Swift.Int?
        /// <p>The method that you want to use to restrict distribution of your content by
        /// 			country:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code>: No geo restriction is enabled, meaning access to content is not
        /// 					restricted by client geo location.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>blacklist</code>: The <code>Location</code> elements specify the countries in
        /// 					which you don't want CloudFront to distribute your content.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code>: The <code>Location</code> elements specify the countries in
        /// 					which you want CloudFront to distribute your content.</p>
        /// 			         </li>
        ///          </ul>
        public let restrictionType: CloudFrontClientTypes.GeoRestrictionType?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil,
            restrictionType: CloudFrontClientTypes.GeoRestrictionType? = nil
        )
        {
            self.items = items
            self.quantity = quantity
            self.restrictionType = restrictionType
        }
    }

}

extension CloudFrontClientTypes {
    public enum GeoRestrictionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklist
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoRestrictionType] {
            return [
                .blacklist,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklist: return "blacklist"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoRestrictionType(rawValue: rawValue) ?? GeoRestrictionType.sdkUnknown(rawValue)
        }
    }
}

extension GetCachePolicyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetCachePolicyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCachePolicyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInput: Swift.Equatable {
    /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
    /// 			distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
    /// 			not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyConfigInputBody: Swift.Equatable {
}

extension GetCachePolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyConfigOutputResponse(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCachePolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicyConfig = try responseDecoder.decode(responseBody: data)
                self.cachePolicyConfig = output
            } else {
                self.cachePolicyConfig = nil
            }
        } else {
            self.cachePolicyConfig = nil
        }
    }
}

public struct GetCachePolicyConfigOutputResponse: Swift.Equatable {
    /// <p>The cache policy configuration.</p>
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// <p>The current version of the cache policy.</p>
    public let eTag: Swift.String?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

struct GetCachePolicyConfigOutputResponseBody: Swift.Equatable {
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension GetCachePolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension GetCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyInput(id: \(Swift.String(describing: id)))"}
}

extension GetCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInput: Swift.Equatable {
    /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
    /// 			distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
    /// 			not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyInputBody: Swift.Equatable {
}

extension GetCachePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCachePolicyOutputResponse(cachePolicy: \(Swift.String(describing: cachePolicy)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct GetCachePolicyOutputResponse: Swift.Equatable {
    /// <p>The cache policy.</p>
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// <p>The current version of the cache policy.</p>
    public let eTag: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct GetCachePolicyOutputResponseBody: Swift.Equatable {
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension GetCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetCloudFrontOriginAccessIdentityConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

public struct GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

/// <p>The origin access identity's configuration information. For more information, see
/// 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html">CloudFrontOriginAccessIdentityConfig</a>.</p>
public struct GetCloudFrontOriginAccessIdentityConfigInput: Swift.Equatable {
    /// <p>The identity's ID. </p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityConfigOutputResponse(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentityConfig = output
            } else {
                self.cloudFrontOriginAccessIdentityConfig = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityConfig = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetCloudFrontOriginAccessIdentityConfigOutputResponse: Swift.Equatable {
    /// <p>The origin access identity's configuration information. </p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityInput(id: \(Swift.String(describing: id)))"}
}

extension GetCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

public struct GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

/// <p>The request to get an origin access identity's information.</p>
public struct GetCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// <p>The identity's ID.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
}

extension GetCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(Swift.String(describing: cloudFrontOriginAccessIdentity)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// <p>The origin access identity's information.</p>
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// <p>The current version of the origin access identity's information. For example:
    /// 				<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension GetCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

extension GetDistributionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetDistributionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDistributionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigOutputError>
}

public struct GetDistributionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigOutputError>
}

/// <p>The request to get a distribution configuration.</p>
public struct GetDistributionConfigInput: Swift.Equatable {
    /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionConfigInputBody: Swift.Equatable {
}

extension GetDistributionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionConfigOutputResponse(distributionConfig: \(Swift.String(describing: distributionConfig)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetDistributionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionConfig = try responseDecoder.decode(responseBody: data)
                self.distributionConfig = output
            } else {
                self.distributionConfig = nil
            }
        } else {
            self.distributionConfig = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetDistributionConfigOutputResponse: Swift.Equatable {
    /// <p>The distribution's configuration information.</p>
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

struct GetDistributionConfigOutputResponseBody: Swift.Equatable {
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension GetDistributionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension GetDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionInput(id: \(Swift.String(describing: id)))"}
}

extension GetDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionOutputError>
}

public struct GetDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionOutputError>
}

/// <p>The request to get a distribution's information.</p>
public struct GetDistributionInput: Swift.Equatable {
    /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionInputBody: Swift.Equatable {
}

extension GetDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)))"}
}

extension GetDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetDistributionOutputResponse: Swift.Equatable {
    /// <p>The distribution's information.</p>
    public let distribution: CloudFrontClientTypes.Distribution?
    /// <p>The current version of the distribution's information. For example:
    /// 				<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct GetDistributionOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension GetDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

extension GetFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// <p>Request the ID for the field-level encryption configuration information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)))"}
}

extension GetFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionConfig = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionConfig = output
            } else {
                self.fieldLevelEncryptionConfig = nil
            }
        } else {
            self.fieldLevelEncryptionConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Return the field-level encryption configuration information.</p>
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct GetFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension GetFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension GetFieldLevelEncryptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInput: Swift.Equatable {
    /// <p>Request the ID for the field-level encryption configuration information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryption: \(Swift.String(describing: fieldLevelEncryption)))"}
}

extension GetFieldLevelEncryptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct GetFieldLevelEncryptionOutputResponse: Swift.Equatable {
    /// <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Return the field-level encryption configuration information.</p>
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct GetFieldLevelEncryptionOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension GetFieldLevelEncryptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

extension GetFieldLevelEncryptionProfileConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionProfileConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInput: Swift.Equatable {
    /// <p>Get the ID for the field-level encryption profile configuration information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileConfigInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)))"}
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfileConfig = output
            } else {
                self.fieldLevelEncryptionProfileConfig = nil
            }
        } else {
            self.fieldLevelEncryptionProfileConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutputResponse: Swift.Equatable {
    /// <p>The current version of the field-level encryption profile configuration result. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Return the field-level encryption profile configuration information.</p>
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct GetFieldLevelEncryptionProfileConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension GetFieldLevelEncryptionProfileConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension GetFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileInput(id: \(Swift.String(describing: id)))"}
}

extension GetFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// <p>Get the ID for the field-level encryption profile information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileInputBody: Swift.Equatable {
}

extension GetFieldLevelEncryptionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFieldLevelEncryptionProfileOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfile: \(Swift.String(describing: fieldLevelEncryptionProfile)))"}
}

extension GetFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// <p>The current version of the field level encryption profile. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Return the field-level encryption profile information.</p>
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct GetFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension GetFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

extension GetFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionInput(name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)))"}
}

extension GetFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Swift.Equatable {
    /// <p>The name of the function whose code you are getting.</p>
    public let name: Swift.String?
    /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    public let stage: CloudFrontClientTypes.FunctionStage?

    public init (
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct GetFunctionInputBody: Swift.Equatable {
}

extension GetFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Swift.Error, Swift.Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFunctionOutputResponse(contentType: \(Swift.String(describing: contentType)), eTag: \(Swift.String(describing: eTag)), functionCode: \(Swift.String(describing: functionCode)))"}
}

extension GetFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.functionCode = data
        } else {
            self.functionCode = nil
        }
    }
}

public struct GetFunctionOutputResponse: Swift.Equatable {
    /// <p>The content type (media type) of the response.</p>
    public let contentType: Swift.String?
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: Swift.String?
    /// <p>The function code of a CloudFront function.</p>
    public let functionCode: ClientRuntime.Data?

    public init (
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        functionCode: ClientRuntime.Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

struct GetFunctionOutputResponseBody: Swift.Equatable {
    public let functionCode: ClientRuntime.Data?
}

extension GetFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension GetInvalidationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInvalidationInput(distributionId: \(Swift.String(describing: distributionId)), id: \(Swift.String(describing: id)))"}
}

extension GetInvalidationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetInvalidationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInvalidationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInvalidationOutputError>
}

public struct GetInvalidationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInvalidationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInvalidationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInvalidationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInvalidationOutputError>
}

/// <p>The request to get an invalidation's information. </p>
public struct GetInvalidationInput: Swift.Equatable {
    /// <p>The distribution's ID.</p>
    public let distributionId: Swift.String?
    /// <p>The identifier for the invalidation request, for example,
    /// 			<code>IDFDVBD632BHDS5</code>.</p>
    public let id: Swift.String?

    public init (
        distributionId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

struct GetInvalidationInputBody: Swift.Equatable {
}

extension GetInvalidationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvalidationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetInvalidationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchInvalidation" : self = .noSuchInvalidation(try NoSuchInvalidation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvalidationOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchInvalidation(NoSuchInvalidation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvalidationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInvalidationOutputResponse(invalidation: \(Swift.String(describing: invalidation)))"}
}

extension GetInvalidationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Invalidation = try responseDecoder.decode(responseBody: data)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetInvalidationOutputResponse: Swift.Equatable {
    /// <p>The invalidation's information. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html">Invalidation Complex Type</a>. </p>
    public let invalidation: CloudFrontClientTypes.Invalidation?

    public init (
        invalidation: CloudFrontClientTypes.Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

struct GetInvalidationOutputResponseBody: Swift.Equatable {
    public let invalidation: CloudFrontClientTypes.Invalidation?
}

extension GetInvalidationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

extension GetKeyGroupConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetKeyGroupConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetKeyGroupConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInput: Swift.Equatable {
    /// <p>The identifier of the key group whose configuration you are getting. To get the
    /// 			identifier, use <code>ListKeyGroups</code>.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupConfigInputBody: Swift.Equatable {
}

extension GetKeyGroupConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupConfigOutputError: Swift.Error, Swift.Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroupConfig: \(Swift.String(describing: keyGroupConfig)))"}
}

extension GetKeyGroupConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroupConfig = try responseDecoder.decode(responseBody: data)
                self.keyGroupConfig = output
            } else {
                self.keyGroupConfig = nil
            }
        } else {
            self.keyGroupConfig = nil
        }
    }
}

public struct GetKeyGroupConfigOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: Swift.String?
    /// <p>The key group configuration.</p>
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        eTag: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

struct GetKeyGroupConfigOutputResponseBody: Swift.Equatable {
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension GetKeyGroupConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension GetKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupInput(id: \(Swift.String(describing: id)))"}
}

extension GetKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInput: Swift.Equatable {
    /// <p>The identifier of the key group that you are getting. To get the identifier, use
    /// 			<code>ListKeyGroups</code>.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupInputBody: Swift.Equatable {
}

extension GetKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyGroupOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroup: \(Swift.String(describing: keyGroup)))"}
}

extension GetKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct GetKeyGroupOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: Swift.String?
    /// <p>The key group.</p>
    public let keyGroup: CloudFrontClientTypes.KeyGroup?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct GetKeyGroupOutputResponseBody: Swift.Equatable {
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension GetKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension GetMonitoringSubscriptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMonitoringSubscriptionInput(distributionId: \(Swift.String(describing: distributionId)))"}
}

extension GetMonitoringSubscriptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetMonitoringSubscriptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMonitoringSubscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInput: Swift.Equatable {
    /// <p>The ID of the distribution that you are getting metrics information for.</p>
    public let distributionId: Swift.String?

    public init (
        distributionId: Swift.String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct GetMonitoringSubscriptionInputBody: Swift.Equatable {
}

extension GetMonitoringSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMonitoringSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetMonitoringSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMonitoringSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMonitoringSubscriptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMonitoringSubscriptionOutputResponse(monitoringSubscription: \(Swift.String(describing: monitoringSubscription)))"}
}

extension GetMonitoringSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.MonitoringSubscription = try responseDecoder.decode(responseBody: data)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct GetMonitoringSubscriptionOutputResponse: Swift.Equatable {
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?

    public init (
        monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct GetMonitoringSubscriptionOutputResponseBody: Swift.Equatable {
    public let monitoringSubscription: CloudFrontClientTypes.MonitoringSubscription?
}

extension GetMonitoringSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension GetOriginRequestPolicyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetOriginRequestPolicyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOriginRequestPolicyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInput: Swift.Equatable {
    /// <p>The unique identifier for the origin request policy. If the origin request policy is
    /// 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
    /// 			policy is not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListOriginRequestPolicies</code>.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyConfigInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension GetOriginRequestPolicyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicyConfig = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicyConfig = output
            } else {
                self.originRequestPolicyConfig = nil
            }
        } else {
            self.originRequestPolicyConfig = nil
        }
    }
}

public struct GetOriginRequestPolicyConfigOutputResponse: Swift.Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: Swift.String?
    /// <p>The origin request policy configuration.</p>
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct GetOriginRequestPolicyConfigOutputResponseBody: Swift.Equatable {
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension GetOriginRequestPolicyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension GetOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyInput(id: \(Swift.String(describing: id)))"}
}

extension GetOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInput: Swift.Equatable {
    /// <p>The unique identifier for the origin request policy. If the origin request policy is
    /// 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
    /// 			policy is not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListOriginRequestPolicies</code>.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyInputBody: Swift.Equatable {
}

extension GetOriginRequestPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOriginRequestPolicyOutputResponse(eTag: \(Swift.String(describing: eTag)), originRequestPolicy: \(Swift.String(describing: originRequestPolicy)))"}
}

extension GetOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct GetOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: Swift.String?
    /// <p>The origin request policy.</p>
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct GetOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension GetOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension GetPublicKeyConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetPublicKeyConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPublicKeyConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInput: Swift.Equatable {
    /// <p>The identifier of the public key whose configuration you are getting.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyConfigInputBody: Swift.Equatable {
}

extension GetPublicKeyConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension GetPublicKeyConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKeyConfig = try responseDecoder.decode(responseBody: data)
                self.publicKeyConfig = output
            } else {
                self.publicKeyConfig = nil
            }
        } else {
            self.publicKeyConfig = nil
        }
    }
}

public struct GetPublicKeyConfigOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the public key configuration.</p>
    public let eTag: Swift.String?
    /// <p>A public key configuration.</p>
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        eTag: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

struct GetPublicKeyConfigOutputResponseBody: Swift.Equatable {
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension GetPublicKeyConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension GetPublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyInput(id: \(Swift.String(describing: id)))"}
}

extension GetPublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInput: Swift.Equatable {
    /// <p>The identifier of the public key you are getting.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyInputBody: Swift.Equatable {
}

extension GetPublicKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPublicKeyOutputResponse(eTag: \(Swift.String(describing: eTag)), publicKey: \(Swift.String(describing: publicKey)))"}
}

extension GetPublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct GetPublicKeyOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the public key.</p>
    public let eTag: Swift.String?
    /// <p>The public key.</p>
    public let publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct GetPublicKeyOutputResponseBody: Swift.Equatable {
    public let publicKey: CloudFrontClientTypes.PublicKey?
}

extension GetPublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct GetRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

extension GetRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRealtimeLogConfigInput(aRN: \(Swift.String(describing: aRN)), name: \(Swift.String(describing: name)))"}
}

extension GetRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension GetRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }
}

public struct GetRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to get.</p>
    public let aRN: Swift.String?
    /// <p>The name of the real-time log configuration to get.</p>
    public let name: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct GetRealtimeLogConfigInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let aRN: Swift.String?
}

extension GetRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension GetRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRealtimeLogConfigOutputResponse(realtimeLogConfig: \(Swift.String(describing: realtimeLogConfig)))"}
}

extension GetRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct GetRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// <p>A real-time log configuration.</p>
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct GetRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension GetRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

extension GetStreamingDistributionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionConfigInput(id: \(Swift.String(describing: id)))"}
}

extension GetStreamingDistributionConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingDistributionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionConfigOutputError>
}

public struct GetStreamingDistributionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionConfigOutputError>
}

/// <p>To request to get a streaming distribution configuration.</p>
public struct GetStreamingDistributionConfigInput: Swift.Equatable {
    /// <p>The streaming distribution's ID.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionConfigInputBody: Swift.Equatable {
}

extension GetStreamingDistributionConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension GetStreamingDistributionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistributionConfig = try responseDecoder.decode(responseBody: data)
                self.streamingDistributionConfig = output
            } else {
                self.streamingDistributionConfig = nil
            }
        } else {
            self.streamingDistributionConfig = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetStreamingDistributionConfigOutputResponse: Swift.Equatable {
    /// <p>The current version of the configuration. For example: <code>E2QWRUHAPOMQZL</code>.
    /// 		</p>
    public let eTag: Swift.String?
    /// <p>The streaming distribution's configuration information.</p>
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        eTag: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct GetStreamingDistributionConfigOutputResponseBody: Swift.Equatable {
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension GetStreamingDistributionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension GetStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionInput(id: \(Swift.String(describing: id)))"}
}

extension GetStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionOutputError>
}

public struct GetStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingDistributionOutputError>
}

/// <p>The request to get a streaming distribution's information.</p>
public struct GetStreamingDistributionInput: Swift.Equatable {
    /// <p>The streaming distribution's ID.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionInputBody: Swift.Equatable {
}

extension GetStreamingDistributionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingDistributionOutputResponse(eTag: \(Swift.String(describing: eTag)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension GetStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetStreamingDistributionOutputResponse: Swift.Equatable {
    /// <p>The current version of the streaming distribution's information. For example:
    /// 				<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>The streaming distribution's information.</p>
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct GetStreamingDistributionOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension GetStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.Headers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Headers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Headers(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Headers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains a list of HTTP header names.</p>
    public struct Headers: Swift.Equatable {
        /// <p>A list of HTTP header names.</p>
        public let items: [Swift.String]?
        /// <p>The number of header names in the <code>Items</code> list.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum HttpVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http11
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpVersion] {
            return [
                .http11,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http11: return "http1.1"
            case .http2: return "http2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HttpVersion(rawValue: rawValue) ?? HttpVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum ICPRecordalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [ICPRecordalStatus] {
            return [
                .approved,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICPRecordalStatus(rawValue: rawValue) ?? ICPRecordalStatus.sdkUnknown(rawValue)
        }
    }
}

extension IllegalDelete: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalDelete(message: \(Swift.String(describing: message)))"}
}

extension IllegalDelete: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IllegalDeleteBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot delete a managed policy.</p>
public struct IllegalDelete: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalDeleteBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalDeleteBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(message: \(Swift.String(describing: message)))"}
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalUpdate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IllegalUpdate(message: \(Swift.String(describing: message)))"}
}

extension IllegalUpdate: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IllegalUpdateBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The update contains modifications that are not allowed.</p>
public struct IllegalUpdate: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalUpdateBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IllegalUpdateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InconsistentQuantities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InconsistentQuantities(message: \(Swift.String(describing: message)))"}
}

extension InconsistentQuantities: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InconsistentQuantitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
public struct InconsistentQuantities: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InconsistentQuantitiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InconsistentQuantitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgument(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgument: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidArgumentBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An argument is invalid.</p>
public struct InvalidArgument: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgumentBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefaultRootObject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDefaultRootObject(message: \(Swift.String(describing: message)))"}
}

extension InvalidDefaultRootObject: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidDefaultRootObjectBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The default root object file name is too big or contains an invalid character.</p>
public struct InvalidDefaultRootObject: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDefaultRootObjectBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDefaultRootObjectBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidErrorCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidErrorCode(message: \(Swift.String(describing: message)))"}
}

extension InvalidErrorCode: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidErrorCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid error code was specified.</p>
public struct InvalidErrorCode: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidErrorCodeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidErrorCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidForwardCookies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidForwardCookies(message: \(Swift.String(describing: message)))"}
}

extension InvalidForwardCookies: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidForwardCookiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code>
/// 			list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
public struct InvalidForwardCookies: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidForwardCookiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidForwardCookiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidFunctionAssociation(message: \(Swift.String(describing: message)))"}
}

extension InvalidFunctionAssociation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A CloudFront function association is invalid.</p>
public struct InvalidFunctionAssociation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFunctionAssociationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGeoRestrictionParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidGeoRestrictionParameter(message: \(Swift.String(describing: message)))"}
}

extension InvalidGeoRestrictionParameter: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidGeoRestrictionParameterBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified geo restriction parameter is not valid.</p>
public struct InvalidGeoRestrictionParameter: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGeoRestrictionParameterBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidGeoRestrictionParameterBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHeadersForS3Origin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidHeadersForS3Origin(message: \(Swift.String(describing: message)))"}
}

extension InvalidHeadersForS3Origin: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidHeadersForS3OriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The headers specified are not valid for an Amazon S3 origin.</p>
public struct InvalidHeadersForS3Origin: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHeadersForS3OriginBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidHeadersForS3OriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIfMatchVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidIfMatchVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidIfMatchVersion: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidIfMatchVersionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>If-Match</code> version is missing or not valid.</p>
public struct InvalidIfMatchVersion: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIfMatchVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidIfMatchVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLambdaFunctionAssociation(message: \(Swift.String(describing: message)))"}
}

extension InvalidLambdaFunctionAssociation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidLambdaFunctionAssociationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Lambda function association is invalid.</p>
public struct InvalidLambdaFunctionAssociation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaFunctionAssociationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLambdaFunctionAssociationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLocationCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLocationCode(message: \(Swift.String(describing: message)))"}
}

extension InvalidLocationCode: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidLocationCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The location code specified is not valid.</p>
public struct InvalidLocationCode: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLocationCodeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLocationCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMinimumProtocolVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidMinimumProtocolVersion(message: \(Swift.String(describing: message)))"}
}

extension InvalidMinimumProtocolVersion: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidMinimumProtocolVersionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The minimum protocol version specified is not valid.</p>
public struct InvalidMinimumProtocolVersion: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMinimumProtocolVersionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidMinimumProtocolVersionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOrigin(message: \(Swift.String(describing: message)))"}
}

extension InvalidOrigin: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidOriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
public struct InvalidOrigin: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension InvalidOriginAccessIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOriginAccessIdentity(message: \(Swift.String(describing: message)))"}
}

extension InvalidOriginAccessIdentity: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The origin access identity is not valid or doesn't exist.</p>
public struct InvalidOriginAccessIdentity: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginAccessIdentityBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct InvalidOriginBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginKeepaliveTimeout: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOriginKeepaliveTimeout(message: \(Swift.String(describing: message)))"}
}

extension InvalidOriginKeepaliveTimeout: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidOriginKeepaliveTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The keep alive timeout specified for the origin is not valid.</p>
public struct InvalidOriginKeepaliveTimeout: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginKeepaliveTimeoutBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginKeepaliveTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginReadTimeout: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidOriginReadTimeout(message: \(Swift.String(describing: message)))"}
}

extension InvalidOriginReadTimeout: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidOriginReadTimeoutBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The read timeout specified for the origin is not valid.</p>
public struct InvalidOriginReadTimeout: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginReadTimeoutBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidOriginReadTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProtocolSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidProtocolSettings(message: \(Swift.String(describing: message)))"}
}

extension InvalidProtocolSettings: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidProtocolSettingsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support
/// 			Server Name Indication (SNI).</p>
public struct InvalidProtocolSettings: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidProtocolSettingsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidProtocolSettingsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStringParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidQueryStringParameters(message: \(Swift.String(describing: message)))"}
}

extension InvalidQueryStringParameters: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The query string parameters specified are not valid.</p>
public struct InvalidQueryStringParameters: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryStringParametersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativePath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRelativePath(message: \(Swift.String(describing: message)))"}
}

extension InvalidRelativePath: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidRelativePathBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
public struct InvalidRelativePath: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRelativePathBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRelativePathBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequiredProtocol: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequiredProtocol(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequiredProtocol: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidRequiredProtocolBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the
/// 			<code>RequiredProtocols</code> element from your distribution configuration.</p>
public struct InvalidRequiredProtocol: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequiredProtocolBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequiredProtocolBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseCode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResponseCode(message: \(Swift.String(describing: message)))"}
}

extension InvalidResponseCode: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidResponseCodeBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A response code is not valid.</p>
public struct InvalidResponseCode: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResponseCodeBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResponseCodeBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTTLOrder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTTLOrder(message: \(Swift.String(describing: message)))"}
}

extension InvalidTTLOrder: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidTTLOrderBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The TTL order specified is not valid.</p>
public struct InvalidTTLOrder: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTTLOrderBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTTLOrderBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagging: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagging(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagging: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidTaggingBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tagging specified is not valid.</p>
public struct InvalidTagging: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaggingBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTaggingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidViewerCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidViewerCertificate(message: \(Swift.String(describing: message)))"}
}

extension InvalidViewerCertificate: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidViewerCertificateBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A viewer certificate specified is not valid.</p>
public struct InvalidViewerCertificate: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidViewerCertificateBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidViewerCertificateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebACLId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidWebACLId(message: \(Swift.String(describing: message)))"}
}

extension InvalidWebACLId: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidWebACLIdBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest
/// 			version of AWS WAF, use the ACL ARN, for example
/// 			<code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>.
/// 			To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example
/// 			<code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
public struct InvalidWebACLId: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebACLIdBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidWebACLIdBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case invalidationBatch = "InvalidationBatch"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: ClientRuntime.Key("InvalidationBatch"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CloudFrontClientTypes.Invalidation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Invalidation(createTime: \(Swift.String(describing: createTime)), id: \(Swift.String(describing: id)), invalidationBatch: \(Swift.String(describing: invalidationBatch)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.Invalidation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An invalidation. </p>
    public struct Invalidation: Swift.Equatable {
        /// <p>The date and time the invalidation request was first made. </p>
        public let createTime: ClientRuntime.Date?
        /// <p>The identifier for the invalidation request. For example:
        /// 			<code>IDFDVBD632BHDS5</code>.</p>
        public let id: Swift.String?
        /// <p>The current invalidation information for the batch request. </p>
        public let invalidationBatch: CloudFrontClientTypes.InvalidationBatch?
        /// <p>The status of the invalidation request. When the invalidation batch is finished, the
        /// 			status is <code>Completed</code>.</p>
        public let status: Swift.String?

        public init (
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            invalidationBatch: CloudFrontClientTypes.InvalidationBatch? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.invalidationBatch = invalidationBatch
            self.status = status
        }
    }

}

extension CloudFrontClientTypes.InvalidationBatch: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case paths = "Paths"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let paths = paths {
            try container.encode(paths, forKey: ClientRuntime.Key("Paths"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Paths.self, forKey: .paths)
        paths = pathsDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
    }
}

extension CloudFrontClientTypes.InvalidationBatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidationBatch(callerReference: \(Swift.String(describing: callerReference)), paths: \(Swift.String(describing: paths)))"}
}

extension CloudFrontClientTypes.InvalidationBatch: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An invalidation batch.</p>
    public struct InvalidationBatch: Swift.Equatable {
        /// <p>A value that you specify to uniquely identify an invalidation request. CloudFront uses the
        /// 			value to prevent you from accidentally resubmitting an identical request. Whenever you create
        /// 			a new invalidation request, you must specify a new value for <code>CallerReference</code> and
        /// 			change other values in the request as applicable. One way to ensure that the value of
        /// 				<code>CallerReference</code> is unique is to use a <code>timestamp</code>, for example,
        /// 				<code>20120301090000</code>.</p>
        /// 		       <p>If you make a second invalidation request with the same value for
        /// 				<code>CallerReference</code>, and if the rest of the request is the same, CloudFront doesn't
        /// 			create a new invalidation request. Instead, CloudFront returns information about the invalidation
        /// 			request that you previously created with the same <code>CallerReference</code>.</p>
        /// 		       <p>If <code>CallerReference</code> is a value you already sent in a previous invalidation
        /// 			batch request but the content of any <code>Path</code> is different from the original request,
        /// 			CloudFront returns an <code>InvalidationBatchAlreadyExists</code> error.</p>
        public let callerReference: Swift.String?
        /// <p>A complex type that contains information about the objects that you want to invalidate.
        /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects">Specifying the Objects
        /// 				to Invalidate</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
        public let paths: CloudFrontClientTypes.Paths?

        public init (
            callerReference: Swift.String? = nil,
            paths: CloudFrontClientTypes.Paths? = nil
        )
        {
            self.callerReference = callerReference
            self.paths = paths
        }
    }

}

extension CloudFrontClientTypes.InvalidationList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for invalidationsummary0 in items {
                try itemsContainer.encode(invalidationsummary0, forKey: ClientRuntime.Key("InvalidationSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct InvalidationSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InvalidationSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.InvalidationSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.InvalidationSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.InvalidationSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.InvalidationList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidationList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.InvalidationList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>The <code>InvalidationList</code> complex type describes the list of invalidation
    /// 			objects. For more information about invalidation, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">Invalidating Objects (Web Distributions Only)</a> in
    /// 			the <i>Amazon CloudFront Developer Guide</i>.</p>
    public struct InvalidationList: Swift.Equatable {
        /// <p>A flag that indicates whether more invalidation batch requests remain to be listed. If
        /// 			your results were truncated, you can make a follow-up pagination request using the
        /// 				<code>Marker</code> request parameter to retrieve more invalidation batches in the
        /// 			list.</p>
        public let isTruncated: Swift.Bool?
        /// <p>A complex type that contains one <code>InvalidationSummary</code> element for each
        /// 			invalidation batch created by the current AWS account.</p>
        public let items: [CloudFrontClientTypes.InvalidationSummary]?
        /// <p>The value that you provided for the <code>Marker</code> request parameter.</p>
        public let marker: Swift.String?
        /// <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
        public let maxItems: Swift.Int?
        /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
        /// 			the value that you can use for the <code>Marker</code> request parameter to continue listing
        /// 			your invalidation batches where they left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The number of invalidation batches that were created by the current AWS account.
        /// 		</p>
        public let quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.InvalidationSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.InvalidationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("CreateTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudFrontClientTypes.InvalidationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidationSummary(createTime: \(Swift.String(describing: createTime)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)))"}
}

extension CloudFrontClientTypes.InvalidationSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A summary of an invalidation request.</p>
    public struct InvalidationSummary: Swift.Equatable {
        /// <p>The time that an invalidation request was created.</p>
        public let createTime: ClientRuntime.Date?
        /// <p>The unique ID for an invalidation request.</p>
        public let id: Swift.String?
        /// <p>The status of an invalidation request.</p>
        public let status: Swift.String?

        public init (
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.status = status
        }
    }

}

extension CloudFrontClientTypes {
    public enum ItemSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [ItemSelection] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ItemSelection(rawValue: rawValue) ?? ItemSelection.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupId = "KeyGroupId"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupId = keyGroupId {
            try container.encode(keyGroupId, forKey: ClientRuntime.Key("KeyGroupId"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyGroupId)
        keyGroupId = keyGroupIdDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.KGKeyPairIds: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KGKeyPairIds(keyGroupId: \(Swift.String(describing: keyGroupId)), keyPairIds: \(Swift.String(describing: keyPairIds)))"}
}

extension CloudFrontClientTypes.KGKeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of identifiers for the public keys that CloudFront can use to verify the
    /// 			signatures of signed URLs and signed cookies.</p>
    public struct KGKeyPairIds: Swift.Equatable {
        /// <p>The identifier of the key group that contains the public keys.</p>
        public let keyGroupId: Swift.String?
        /// <p>A list of CloudFront key pair identifiers.</p>
        public let keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init (
            keyGroupId: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.keyGroupId = keyGroupId
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes.KeyGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case keyGroupConfig = "KeyGroupConfig"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CloudFrontClientTypes.KeyGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroup(id: \(Swift.String(describing: id)), keyGroupConfig: \(Swift.String(describing: keyGroupConfig)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)))"}
}

extension CloudFrontClientTypes.KeyGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A key group.</p>
    /// 		       <p>A key group contains a list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
    public struct KeyGroup: Swift.Equatable {
        /// <p>The identifier for the key group.</p>
        public let id: Swift.String?
        /// <p>The key group configuration.</p>
        public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
        /// <p>The date and time when the key group was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?

        public init (
            id: Swift.String? = nil,
            keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil
        )
        {
            self.id = id
            self.keyGroupConfig = keyGroupConfig
            self.lastModifiedTime = lastModifiedTime
        }
    }

}

extension KeyGroupAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension KeyGroupAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<KeyGroupAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A key group with this name already exists. You must provide a unique name. To modify an
/// 			existing key group, use <code>UpdateKeyGroup</code>.</p>
public struct KeyGroupAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KeyGroupAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KeyGroupAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case items = "Items"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("PublicKey"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKey{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKey>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupConfig(comment: \(Swift.String(describing: comment)), items: \(Swift.String(describing: items)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.KeyGroupConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A key group configuration.</p>
    /// 		       <p>A key group contains a list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
    public struct KeyGroupConfig: Swift.Equatable {
        /// <p>A comment to describe the key group. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>A list of the identifiers of the public keys in the key group.</p>
        public let items: [Swift.String]?
        /// <p>A name to identify the key group.</p>
        public let name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            items: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.items = items
            self.name = name
        }
    }

}

extension CloudFrontClientTypes.KeyGroupList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for keygroupsummary0 in items {
                try itemsContainer.encode(keygroupsummary0, forKey: ClientRuntime.Key("KeyGroupSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroupSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroupSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.KeyGroupSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.KeyGroupSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.KeyGroupSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyGroupList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.KeyGroupList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of key groups.</p>
    public struct KeyGroupList: Swift.Equatable {
        /// <p>A list of key groups.</p>
        public let items: [CloudFrontClientTypes.KeyGroupSummary]?
        /// <p>The maximum number of key groups requested.</p>
        public let maxItems: Swift.Int?
        /// <p>If there are more items in the list than are in this response, this element is present. It
        /// 			contains the value that you should use in the <code>Marker</code> field of a subsequent
        /// 			request to continue listing key groups.</p>
        public let nextMarker: Swift.String?
        /// <p>The number of key groups returned in the response.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.KeyGroupSummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KeyGroupSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroup = keyGroup {
            try container.encode(keyGroup, forKey: ClientRuntime.Key("KeyGroup"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension CloudFrontClientTypes.KeyGroupSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyGroupSummary(keyGroup: \(Swift.String(describing: keyGroup)))"}
}

extension CloudFrontClientTypes.KeyGroupSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains information about a key group.</p>
    public struct KeyGroupSummary: Swift.Equatable {
        /// <p>A key group.</p>
        public let keyGroup: CloudFrontClientTypes.KeyGroup?

        public init (
            keyGroup: CloudFrontClientTypes.KeyGroup? = nil
        )
        {
            self.keyGroup = keyGroup
        }
    }

}

extension CloudFrontClientTypes.KeyPairIds: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyPairId"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyPairId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyPairId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.KeyPairIds: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyPairIds(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.KeyPairIds: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of CloudFront key pair identifiers.</p>
    public struct KeyPairIds: Swift.Equatable {
        /// <p>A list of CloudFront key pair identifiers.</p>
        public let items: [Swift.String]?
        /// <p>The number of key pair identifiers in the list.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.KinesisStreamConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleARN = "RoleARN"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: ClientRuntime.Key("RoleARN"))
        }
        if let streamARN = streamARN {
            try container.encode(streamARN, forKey: ClientRuntime.Key("StreamARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension CloudFrontClientTypes.KinesisStreamConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisStreamConfig(roleARN: \(Swift.String(describing: roleARN)), streamARN: \(Swift.String(describing: streamARN)))"}
}

extension CloudFrontClientTypes.KinesisStreamConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending
    /// 			real-time log data.</p>
    public struct KinesisStreamConfig: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that
        /// 			CloudFront can use to send real-time log data to your Kinesis data stream.</p>
        /// 		       <p>For more information the IAM role, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role">Real-time log configuration IAM role</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let roleARN: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time
        /// 			log data.</p>
        public let streamARN: Swift.String?

        public init (
            roleARN: Swift.String? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.roleARN = roleARN
            self.streamARN = streamARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType = "EventType"
        case includeBody = "IncludeBody"
        case lambdaFunctionARN = "LambdaFunctionARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: ClientRuntime.Key("EventType"))
        }
        if let includeBody = includeBody {
            try container.encode(includeBody, forKey: ClientRuntime.Key("IncludeBody"))
        }
        if let lambdaFunctionARN = lambdaFunctionARN {
            try container.encode(lambdaFunctionARN, forKey: ClientRuntime.Key("LambdaFunctionARN"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionARN)
        lambdaFunctionARN = lambdaFunctionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let includeBodyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeBody)
        includeBody = includeBodyDecoded
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionAssociation(eventType: \(Swift.String(describing: eventType)), includeBody: \(Swift.String(describing: includeBody)), lambdaFunctionARN: \(Swift.String(describing: lambdaFunctionARN)))"}
}

extension CloudFrontClientTypes.LambdaFunctionAssociation: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains a Lambda function association.</p>
    public struct LambdaFunctionAssociation: Swift.Equatable {
        /// <p>Specifies the event type that triggers a Lambda function invocation. You can specify the following values:</p>
        /// 		       <ul>
        ///             <li>
        ///                <p>
        ///                   <code>viewer-request</code>: The function executes when CloudFront receives a request from a viewer
        /// 				and before it checks to see whether the requested object is in the edge cache. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>origin-request</code>: The function executes only when CloudFront sends a request to your
        /// 					origin. When the requested object is in the edge cache, the function doesn't
        /// 					execute.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>origin-response</code>: The function executes after CloudFront receives a response from the origin and
        /// 				before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.</p>
        /// 			         </li>
        ///             <li>
        ///                <p>
        ///                   <code>viewer-response</code>: The function executes before CloudFront returns the requested object to the viewer.
        /// 				The function executes regardless of whether the object was already in the edge cache.</p>
        /// 				           <p>If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.</p>
        /// 			         </li>
        ///          </ul>
        public let eventType: CloudFrontClientTypes.EventType?
        /// <p>A flag that allows a Lambda function to have read access to the body content. For more information,
        /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html">Accessing the Request Body by Choosing the
        /// 				Include Body Option</a> in the Amazon CloudFront Developer Guide.</p>
        public let includeBody: Swift.Bool?
        /// <p>The ARN of the Lambda function. You must specify the ARN of a function version; you can't specify a Lambda alias
        /// 			or $LATEST.</p>
        public let lambdaFunctionARN: Swift.String?

        public init (
            eventType: CloudFrontClientTypes.EventType? = nil,
            includeBody: Swift.Bool? = nil,
            lambdaFunctionARN: Swift.String? = nil
        )
        {
            self.eventType = eventType
            self.includeBody = includeBody
            self.lambdaFunctionARN = lambdaFunctionARN
        }
    }

}

extension CloudFrontClientTypes.LambdaFunctionAssociations: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for lambdafunctionassociation0 in items {
                try itemsContainer.encode(lambdafunctionassociation0, forKey: ClientRuntime.Key("LambdaFunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct LambdaFunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LambdaFunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.LambdaFunctionAssociation].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.LambdaFunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.LambdaFunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.LambdaFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionAssociations(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.LambdaFunctionAssociations: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that specifies a list of Lambda functions associations for a cache
    /// 			behavior.</p>
    ///
    /// 		       <p>If you want to invoke one or more Lambda functions triggered by requests that match the
    /// 				<code>PathPattern</code> of the cache behavior, specify the applicable values for
    /// 				<code>Quantity</code> and <code>Items</code>. Note that there can be up to 4
    /// 				<code>LambdaFunctionAssociation</code> items in this list (one for each possible value of
    /// 				<code>EventType</code>) and each <code>EventType</code> can be associated with the Lambda
    /// 			function only once.</p>
    ///
    /// 		       <p>If you don't want to invoke any Lambda functions for the requests that match
    /// 				<code>PathPattern</code>, specify <code>0</code> for <code>Quantity</code> and omit
    /// 				<code>Items</code>. </p>
    public struct LambdaFunctionAssociations: Swift.Equatable {
        /// <p>
        ///             <b>Optional</b>: A complex type that contains <code>LambdaFunctionAssociation</code> items
        /// 			for this cache behavior. If <code>Quantity</code> is <code>0</code>, you can omit <code>Items</code>.</p>
        public let items: [CloudFrontClientTypes.LambdaFunctionAssociation]?
        /// <p>The number of Lambda function associations for this cache behavior.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.LambdaFunctionAssociation]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension ListCachePoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCachePoliciesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), type: \(Swift.String(describing: type)))"}
}

extension ListCachePoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCachePoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCachePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCachePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCachePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCachePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCachePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCachePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			cache policies. The response includes cache policies in the list that occur after the
    /// 			marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of cache policies that you want in the response.</p>
    public let maxItems: Swift.Int?
    /// <p>A filter to return only the specified kinds of cache policies. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>managed</code> – Returns only the managed policies created by AWS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>custom</code> – Returns only the custom policies created in your AWS
    /// 					account.</p>
    /// 			         </li>
    ///          </ul>
    public let type: CloudFrontClientTypes.CachePolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListCachePoliciesInputBody: Swift.Equatable {
}

extension ListCachePoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCachePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCachePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCachePoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCachePoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCachePoliciesOutputResponse(cachePolicyList: \(Swift.String(describing: cachePolicyList)))"}
}

extension ListCachePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicyList = try responseDecoder.decode(responseBody: data)
                self.cachePolicyList = output
            } else {
                self.cachePolicyList = nil
            }
        } else {
            self.cachePolicyList = nil
        }
    }
}

public struct ListCachePoliciesOutputResponse: Swift.Equatable {
    /// <p>A list of cache policies.</p>
    public let cachePolicyList: CloudFrontClientTypes.CachePolicyList?

    public init (
        cachePolicyList: CloudFrontClientTypes.CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

struct ListCachePoliciesOutputResponseBody: Swift.Equatable {
    public let cachePolicyList: CloudFrontClientTypes.CachePolicyList?
}

extension ListCachePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyList = "CachePolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyList.self, forKey: .cachePolicyList)
        cachePolicyList = cachePolicyListDecoded
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCloudFrontOriginAccessIdentitiesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListCloudFrontOriginAccessIdentitiesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

public struct ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

/// <p>The request to list origin access identities. </p>
public struct ListCloudFrontOriginAccessIdentitiesInput: Swift.Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of origin
    /// 			access identities. The results include identities in the list that occur after the marker. To
    /// 			get the next page of results, set the <code>Marker</code> to the value of the
    /// 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
    /// 			identity on that page).</p>
    public let marker: Swift.String?
    /// <p>The maximum number of origin access identities you want in the response body.
    /// 		</p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Equatable {
}

extension ListCloudFrontOriginAccessIdentitiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCloudFrontOriginAccessIdentitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCloudFrontOriginAccessIdentitiesOutputResponse(cloudFrontOriginAccessIdentityList: \(Swift.String(describing: cloudFrontOriginAccessIdentityList)))"}
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentityList = output
            } else {
                self.cloudFrontOriginAccessIdentityList = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListCloudFrontOriginAccessIdentitiesOutputResponse: Swift.Equatable {
    /// <p>The <code>CloudFrontOriginAccessIdentityList</code> type. </p>
    public let cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?

    public init (
        cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

struct ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityList: CloudFrontClientTypes.CloudFrontOriginAccessIdentityList?
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityList = "CloudFrontOriginAccessIdentityList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityList.self, forKey: .cloudFrontOriginAccessIdentityList)
        cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityListDecoded
    }
}

extension ListDistributionsByCachePolicyIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByCachePolicyIdInput(cachePolicyId: \(Swift.String(describing: cachePolicyId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListDistributionsByCachePolicyIdInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByCachePolicyIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByCachePolicyIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByCachePolicyIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByCachePolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInput: Swift.Equatable {
    /// <p>The ID of the cache policy whose associated distribution IDs you want to list.</p>
    public let cachePolicyId: Swift.String?
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distribution IDs. The response includes distribution IDs in the list that occur after
    /// 			the marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of distribution IDs that you want in the response.</p>
    public let maxItems: Swift.Int?

    public init (
        cachePolicyId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByCachePolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByCachePolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByCachePolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByCachePolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByCachePolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByCachePolicyIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByCachePolicyIdOutputResponse(distributionIdList: \(Swift.String(describing: distributionIdList)))"}
}

extension ListDistributionsByCachePolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutputResponse: Swift.Equatable {
    /// <p>A list of distribution IDs.</p>
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByCachePolicyIdOutputResponseBody: Swift.Equatable {
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByCachePolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByKeyGroupInput(keyGroupId: \(Swift.String(describing: keyGroupId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListDistributionsByKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInput: Swift.Equatable {
    /// <p>The ID of the key group whose associated distribution IDs you are listing.</p>
    public let keyGroupId: Swift.String?
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distribution IDs. The response includes distribution IDs in the list that occur after
    /// 			the marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of distribution IDs that you want in the response.</p>
    public let maxItems: Swift.Int?

    public init (
        keyGroupId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByKeyGroupInputBody: Swift.Equatable {
}

extension ListDistributionsByKeyGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByKeyGroupOutputResponse(distributionIdList: \(Swift.String(describing: distributionIdList)))"}
}

extension ListDistributionsByKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByKeyGroupOutputResponse: Swift.Equatable {
    /// <p>A list of distribution IDs.</p>
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByKeyGroupOutputResponseBody: Swift.Equatable {
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByOriginRequestPolicyIdInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), originRequestPolicyId: \(Swift.String(describing: originRequestPolicyId)))"}
}

extension ListDistributionsByOriginRequestPolicyIdInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distribution IDs. The response includes distribution IDs in the list that occur after
    /// 			the marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of distribution IDs that you want in the response.</p>
    public let maxItems: Swift.Int?
    /// <p>The ID of the origin request policy whose associated distribution IDs you want to
    /// 			list.</p>
    public let originRequestPolicyId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        originRequestPolicyId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

struct ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Equatable {
}

extension ListDistributionsByOriginRequestPolicyIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByOriginRequestPolicyIdOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByOriginRequestPolicyIdOutputResponse(distributionIdList: \(Swift.String(describing: distributionIdList)))"}
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionIdList = try responseDecoder.decode(responseBody: data)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutputResponse: Swift.Equatable {
    /// <p>A list of distribution IDs.</p>
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?

    public init (
        distributionIdList: CloudFrontClientTypes.DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Swift.Equatable {
    public let distributionIdList: CloudFrontClientTypes.DistributionIdList?
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

public struct ListDistributionsByRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

extension ListDistributionsByRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByRealtimeLogConfigInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), realtimeLogConfigArn: \(Swift.String(describing: realtimeLogConfigArn)), realtimeLogConfigName: \(Swift.String(describing: realtimeLogConfigName)))"}
}

extension ListDistributionsByRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension ListDistributionsByRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: ClientRuntime.Key("RealtimeLogConfigArn"))
        }
        if let realtimeLogConfigName = realtimeLogConfigName {
            try container.encode(realtimeLogConfigName, forKey: ClientRuntime.Key("RealtimeLogConfigName"))
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distributions. The response includes distributions in the list that occur after the
    /// 			marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of distributions that you want in the response.</p>
    public let maxItems: Swift.Int?
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration whose associated
    /// 			distributions you want to list.</p>
    public let realtimeLogConfigArn: Swift.String?
    /// <p>The name of the real-time log configuration whose associated distributions you want to
    /// 			list.</p>
    public let realtimeLogConfigName: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        realtimeLogConfigArn: Swift.String? = nil,
        realtimeLogConfigName: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

struct ListDistributionsByRealtimeLogConfigInputBody: Swift.Equatable {
    public let marker: Swift.String?
    public let maxItems: Swift.Int?
    public let realtimeLogConfigName: Swift.String?
    public let realtimeLogConfigArn: Swift.String?
}

extension ListDistributionsByRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let realtimeLogConfigNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigName)
        realtimeLogConfigName = realtimeLogConfigNameDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByRealtimeLogConfigOutputResponse(distributionList: \(Swift.String(describing: distributionList)))"}
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// <p>A distribution list.</p>
    public let distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsByWebACLIdInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByWebACLIdInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), webACLId: \(Swift.String(describing: webACLId)))"}
}

extension ListDistributionsByWebACLIdInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsByWebACLIdInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByWebACLIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByWebACLIdOutputError>
}

public struct ListDistributionsByWebACLIdInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsByWebACLIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsByWebACLIdInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsByWebACLIdOutputError>
}

/// <p>The request to list distributions that are associated with a specified AWS WAF web
/// 			ACL. </p>
public struct ListDistributionsByWebACLIdInput: Swift.Equatable {
    /// <p>Use <code>Marker</code> and <code>MaxItems</code> to control pagination of results. If
    /// 			you have more than <code>MaxItems</code> distributions that satisfy the request, the response
    /// 			includes a <code>NextMarker</code> element. To get the next page of results, submit another
    /// 			request. For the value of <code>Marker</code>, specify the value of <code>NextMarker</code>
    /// 			from the last response. (For the first request, omit <code>Marker</code>.) </p>
    public let marker: Swift.String?
    /// <p>The maximum number of distributions that you want CloudFront to return in the response body.
    /// 			The maximum and default values are both 100.</p>
    public let maxItems: Swift.Int?
    /// <p>The ID of the AWS WAF web ACL that you want to list the associated distributions.
    /// 			If you specify "null" for the ID, the request returns a list of the distributions that aren't
    /// 			associated with a web ACL. </p>
    public let webACLId: Swift.String?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        webACLId: Swift.String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

struct ListDistributionsByWebACLIdInputBody: Swift.Equatable {
}

extension ListDistributionsByWebACLIdInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsByWebACLIdOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByWebACLIdOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByWebACLIdOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidWebACLId(InvalidWebACLId)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByWebACLIdOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsByWebACLIdOutputResponse(distributionList: \(Swift.String(describing: distributionList)))"}
}

extension ListDistributionsByWebACLIdOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// <p>The response to a request to list the distributions that are associated with a
/// 			specified AWS WAF web ACL. </p>
public struct ListDistributionsByWebACLIdOutputResponse: Swift.Equatable {
    /// <p>The <code>DistributionList</code> type. </p>
    public let distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByWebACLIdOutputResponseBody: Swift.Equatable {
    public let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsByWebACLIdOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListDistributionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDistributionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsOutputError>
}

public struct ListDistributionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionsOutputError>
}

/// <p>The request to list your distributions. </p>
public struct ListDistributionsInput: Swift.Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of
    /// 			distributions. The results include distributions in the list that occur after the marker. To
    /// 			get the next page of results, set the <code>Marker</code> to the value of the
    /// 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
    /// 			distribution on that page).</p>
    public let marker: Swift.String?
    /// <p>The maximum number of distributions you want in the response body.</p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsInputBody: Swift.Equatable {
}

extension ListDistributionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDistributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionsOutputResponse(distributionList: \(Swift.String(describing: distributionList)))"}
}

extension ListDistributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.DistributionList = try responseDecoder.decode(responseBody: data)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListDistributionsOutputResponse: Swift.Equatable {
    /// <p>The <code>DistributionList</code> type. </p>
    public let distributionList: CloudFrontClientTypes.DistributionList?

    public init (
        distributionList: CloudFrontClientTypes.DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsOutputResponseBody: Swift.Equatable {
    public let distributionList: CloudFrontClientTypes.DistributionList?
}

extension ListDistributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListFieldLevelEncryptionConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionConfigsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFieldLevelEncryptionConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFieldLevelEncryptionConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInput: Swift.Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that
    /// 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
    /// 			<code>NextMarker</code> from the current page's response (which is also the ID of the last configuration on that page). </p>
    public let marker: Swift.String?
    /// <p>The maximum number of field-level encryption configurations you want in the response body. </p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionConfigsInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionConfigsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionConfigsOutputResponse(fieldLevelEncryptionList: \(Swift.String(describing: fieldLevelEncryptionList)))"}
}

extension ListFieldLevelEncryptionConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionList = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionList = output
            } else {
                self.fieldLevelEncryptionList = nil
            }
        } else {
            self.fieldLevelEncryptionList = nil
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutputResponse: Swift.Equatable {
    /// <p>Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.</p>
    public let fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?

    public init (
        fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

struct ListFieldLevelEncryptionConfigsOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionList: CloudFrontClientTypes.FieldLevelEncryptionList?
}

extension ListFieldLevelEncryptionConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionList = "FieldLevelEncryptionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionList.self, forKey: .fieldLevelEncryptionList)
        fieldLevelEncryptionList = fieldLevelEncryptionListDecoded
    }
}

extension ListFieldLevelEncryptionProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionProfilesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListFieldLevelEncryptionProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFieldLevelEncryptionProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFieldLevelEncryptionProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFieldLevelEncryptionProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInput: Swift.Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that
    /// 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
    /// 			<code>NextMarker</code> from the current page's response (which is also the ID of the last profile on that page). </p>
    public let marker: Swift.String?
    /// <p>The maximum number of field-level encryption profiles you want in the response body. </p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionProfilesInputBody: Swift.Equatable {
}

extension ListFieldLevelEncryptionProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldLevelEncryptionProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionProfilesOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFieldLevelEncryptionProfilesOutputResponse(fieldLevelEncryptionProfileList: \(Swift.String(describing: fieldLevelEncryptionProfileList)))"}
}

extension ListFieldLevelEncryptionProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfileList = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfileList = output
            } else {
                self.fieldLevelEncryptionProfileList = nil
            }
        } else {
            self.fieldLevelEncryptionProfileList = nil
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutputResponse: Swift.Equatable {
    /// <p>Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.</p>
    public let fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?

    public init (
        fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

struct ListFieldLevelEncryptionProfilesOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileList: CloudFrontClientTypes.FieldLevelEncryptionProfileList?
}

extension ListFieldLevelEncryptionProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileList = "FieldLevelEncryptionProfileList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileList.self, forKey: .fieldLevelEncryptionProfileList)
        fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileListDecoded
    }
}

extension ListFunctionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), stage: \(Swift.String(describing: stage)))"}
}

extension ListFunctionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = ClientRuntime.URLQueryItem(name: "Stage".urlPercentEncoding(), value: Swift.String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			functions. The response includes functions in the list that occur after the marker. To
    /// 			get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of functions that you want in the response.</p>
    public let maxItems: Swift.Int?
    /// <p>An optional filter to return only the functions that are in the specified stage,
    /// 			either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    public let stage: CloudFrontClientTypes.FunctionStage?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

struct ListFunctionsInputBody: Swift.Equatable {
}

extension ListFunctionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFunctionsOutputResponse(functionList: \(Swift.String(describing: functionList)))"}
}

extension ListFunctionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionList = try responseDecoder.decode(responseBody: data)
                self.functionList = output
            } else {
                self.functionList = nil
            }
        } else {
            self.functionList = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Swift.Equatable {
    /// <p>A list of CloudFront functions.</p>
    public let functionList: CloudFrontClientTypes.FunctionList?

    public init (
        functionList: CloudFrontClientTypes.FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

struct ListFunctionsOutputResponseBody: Swift.Equatable {
    public let functionList: CloudFrontClientTypes.FunctionList?
}

extension ListFunctionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionList = "FunctionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionList.self, forKey: .functionList)
        functionList = functionListDecoded
    }
}

extension ListInvalidationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvalidationsInput(distributionId: \(Swift.String(describing: distributionId)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListInvalidationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListInvalidationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvalidationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvalidationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvalidationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvalidationsOutputError>
}

public struct ListInvalidationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvalidationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvalidationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvalidationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvalidationsOutputError>
}

/// <p>The request to list invalidations. </p>
public struct ListInvalidationsInput: Swift.Equatable {
    /// <p>The distribution's ID.</p>
    public let distributionId: Swift.String?
    /// <p>Use this parameter when paginating results to indicate where to begin in your list of
    /// 			invalidation batches. Because the results are returned in decreasing order from most recent to
    /// 			oldest, the most recent results are on the first page, the second page will contain earlier
    /// 			results, and so on. To get the next page of results, set <code>Marker</code> to the value of
    /// 			the <code>NextMarker</code> from the current page's response. This value is the same as the ID
    /// 			of the last invalidation batch on that page. </p>
    public let marker: Swift.String?
    /// <p>The maximum number of invalidation batches that you want in the response
    /// 			body.</p>
    public let maxItems: Swift.Int?

    public init (
        distributionId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInvalidationsInputBody: Swift.Equatable {
}

extension ListInvalidationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInvalidationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInvalidationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvalidationsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvalidationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvalidationsOutputResponse(invalidationList: \(Swift.String(describing: invalidationList)))"}
}

extension ListInvalidationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.InvalidationList = try responseDecoder.decode(responseBody: data)
                self.invalidationList = output
            } else {
                self.invalidationList = nil
            }
        } else {
            self.invalidationList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListInvalidationsOutputResponse: Swift.Equatable {
    /// <p>Information about invalidation batches. </p>
    public let invalidationList: CloudFrontClientTypes.InvalidationList?

    public init (
        invalidationList: CloudFrontClientTypes.InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

struct ListInvalidationsOutputResponseBody: Swift.Equatable {
    public let invalidationList: CloudFrontClientTypes.InvalidationList?
}

extension ListInvalidationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidationList = "InvalidationList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.InvalidationList.self, forKey: .invalidationList)
        invalidationList = invalidationListDecoded
    }
}

extension ListKeyGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKeyGroupsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListKeyGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListKeyGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKeyGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKeyGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKeyGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKeyGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKeyGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKeyGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of key
    /// 			groups. The response includes key groups in the list that occur after the marker. To get
    /// 			the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of key groups that you want in the response.</p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListKeyGroupsInputBody: Swift.Equatable {
}

extension ListKeyGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKeyGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListKeyGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeyGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKeyGroupsOutputResponse(keyGroupList: \(Swift.String(describing: keyGroupList)))"}
}

extension ListKeyGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroupList = try responseDecoder.decode(responseBody: data)
                self.keyGroupList = output
            } else {
                self.keyGroupList = nil
            }
        } else {
            self.keyGroupList = nil
        }
    }
}

public struct ListKeyGroupsOutputResponse: Swift.Equatable {
    /// <p>A list of key groups.</p>
    public let keyGroupList: CloudFrontClientTypes.KeyGroupList?

    public init (
        keyGroupList: CloudFrontClientTypes.KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

struct ListKeyGroupsOutputResponseBody: Swift.Equatable {
    public let keyGroupList: CloudFrontClientTypes.KeyGroupList?
}

extension ListKeyGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupList = "KeyGroupList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupList.self, forKey: .keyGroupList)
        keyGroupList = keyGroupListDecoded
    }
}

extension ListOriginRequestPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginRequestPoliciesInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), type: \(Swift.String(describing: type)))"}
}

extension ListOriginRequestPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListOriginRequestPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginRequestPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOriginRequestPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOriginRequestPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			origin request policies. The response includes origin request policies in the list that
    /// 			occur after the marker. To get the next page of the list, set this field’s value to the
    /// 			value of <code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of origin request policies that you want in the response.</p>
    public let maxItems: Swift.Int?
    /// <p>A filter to return only the specified kinds of origin request policies. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>managed</code> – Returns only the managed policies created by AWS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>custom</code> – Returns only the custom policies created in your AWS
    /// 					account.</p>
    /// 			         </li>
    ///          </ul>
    public let type: CloudFrontClientTypes.OriginRequestPolicyType?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListOriginRequestPoliciesInputBody: Swift.Equatable {
}

extension ListOriginRequestPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOriginRequestPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginRequestPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginRequestPoliciesOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginRequestPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOriginRequestPoliciesOutputResponse(originRequestPolicyList: \(Swift.String(describing: originRequestPolicyList)))"}
}

extension ListOriginRequestPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicyList = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicyList = output
            } else {
                self.originRequestPolicyList = nil
            }
        } else {
            self.originRequestPolicyList = nil
        }
    }
}

public struct ListOriginRequestPoliciesOutputResponse: Swift.Equatable {
    /// <p>A list of origin request policies.</p>
    public let originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?

    public init (
        originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

struct ListOriginRequestPoliciesOutputResponseBody: Swift.Equatable {
    public let originRequestPolicyList: CloudFrontClientTypes.OriginRequestPolicyList?
}

extension ListOriginRequestPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyList = "OriginRequestPolicyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyList.self, forKey: .originRequestPolicyList)
        originRequestPolicyList = originRequestPolicyListDecoded
    }
}

extension ListPublicKeysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPublicKeysInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListPublicKeysInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPublicKeysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublicKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPublicKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInput: Swift.Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that
    /// 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
    /// 			<code>NextMarker</code> from the current page's response (which is also the ID of the last public key on that page). </p>
    public let marker: Swift.String?
    /// <p>The maximum number of public keys you want in the response body. </p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
}

extension ListPublicKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPublicKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublicKeysOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPublicKeysOutputResponse(publicKeyList: \(Swift.String(describing: publicKeyList)))"}
}

extension ListPublicKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKeyList = try responseDecoder.decode(responseBody: data)
                self.publicKeyList = output
            } else {
                self.publicKeyList = nil
            }
        } else {
            self.publicKeyList = nil
        }
    }
}

public struct ListPublicKeysOutputResponse: Swift.Equatable {
    /// <p>Returns a list of all public keys that have been added to CloudFront for this account.</p>
    public let publicKeyList: CloudFrontClientTypes.PublicKeyList?

    public init (
        publicKeyList: CloudFrontClientTypes.PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Swift.Equatable {
    public let publicKeyList: CloudFrontClientTypes.PublicKeyList?
}

extension ListPublicKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyList.self, forKey: .publicKeyList)
        publicKeyList = publicKeyListDecoded
    }
}

extension ListRealtimeLogConfigsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRealtimeLogConfigsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListRealtimeLogConfigsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRealtimeLogConfigsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRealtimeLogConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRealtimeLogConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRealtimeLogConfigsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInput: Swift.Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of real-time
    /// 			log configurations. The response includes real-time log configurations in the list that
    /// 			occur after the marker. To get the next page of the list, set this field’s value to the
    /// 			value of <code>NextMarker</code> from the current page’s response.</p>
    public let marker: Swift.String?
    /// <p>The maximum number of real-time log configurations that you want in the response.</p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListRealtimeLogConfigsInputBody: Swift.Equatable {
}

extension ListRealtimeLogConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRealtimeLogConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRealtimeLogConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRealtimeLogConfigsOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRealtimeLogConfigsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRealtimeLogConfigsOutputResponse(realtimeLogConfigs: \(Swift.String(describing: realtimeLogConfigs)))"}
}

extension ListRealtimeLogConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.RealtimeLogConfigs = try responseDecoder.decode(responseBody: data)
                self.realtimeLogConfigs = output
            } else {
                self.realtimeLogConfigs = nil
            }
        } else {
            self.realtimeLogConfigs = nil
        }
    }
}

public struct ListRealtimeLogConfigsOutputResponse: Swift.Equatable {
    /// <p>A list of real-time log configurations.</p>
    public let realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?

    public init (
        realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

struct ListRealtimeLogConfigsOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfigs: CloudFrontClientTypes.RealtimeLogConfigs?
}

extension ListRealtimeLogConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfigs = "RealtimeLogConfigs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfigs.self, forKey: .realtimeLogConfigs)
        realtimeLogConfigs = realtimeLogConfigsDecoded
    }
}

extension ListStreamingDistributionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingDistributionsInput(marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)))"}
}

extension ListStreamingDistributionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStreamingDistributionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingDistributionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingDistributionsOutputError>
}

public struct ListStreamingDistributionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingDistributionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingDistributionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingDistributionsOutputError>
}

/// <p>The request to list your streaming distributions. </p>
public struct ListStreamingDistributionsInput: Swift.Equatable {
    /// <p>The value that you provided for the <code>Marker</code> request parameter.</p>
    public let marker: Swift.String?
    /// <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
    public let maxItems: Swift.Int?

    public init (
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListStreamingDistributionsInputBody: Swift.Equatable {
}

extension ListStreamingDistributionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingDistributionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStreamingDistributionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingDistributionsOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingDistributionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingDistributionsOutputResponse(streamingDistributionList: \(Swift.String(describing: streamingDistributionList)))"}
}

extension ListStreamingDistributionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistributionList = try responseDecoder.decode(responseBody: data)
                self.streamingDistributionList = output
            } else {
                self.streamingDistributionList = nil
            }
        } else {
            self.streamingDistributionList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListStreamingDistributionsOutputResponse: Swift.Equatable {
    /// <p>The <code>StreamingDistributionList</code> type. </p>
    public let streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?

    public init (
        streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

struct ListStreamingDistributionsOutputResponseBody: Swift.Equatable {
    public let streamingDistributionList: CloudFrontClientTypes.StreamingDistributionList?
}

extension ListStreamingDistributionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionList = "StreamingDistributionList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionListDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionList.self, forKey: .streamingDistributionList)
        streamingDistributionList = streamingDistributionListDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resource: \(Swift.String(describing: resource)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resource = input.operationInput.resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// <p> The request to list tags for a CloudFront resource.</p>
public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p> An ARN of a CloudFront resource.</p>
    public let resource: Swift.String?

    public init (
        resource: Swift.String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Tags = try responseDecoder.decode(responseBody: data)
                self.tags = output
            } else {
                self.tags = nil
            }
        } else {
            self.tags = nil
        }
    }
}

/// <p> The returned result of the corresponding request.</p>
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
    public let tags: CloudFrontClientTypes.Tags?

    public init (
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: CloudFrontClientTypes.Tags?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let includeCookies = includeCookies {
            try container.encode(includeCookies, forKey: ClientRuntime.Key("IncludeCookies"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCookies)
        includeCookies = includeCookiesDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension CloudFrontClientTypes.LoggingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingConfig(bucket: \(Swift.String(describing: bucket)), enabled: \(Swift.String(describing: enabled)), includeCookies: \(Swift.String(describing: includeCookies)), prefix: \(Swift.String(describing: prefix)))"}
}

extension CloudFrontClientTypes.LoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls whether access logs are written for the
    /// 			distribution.</p>
    public struct LoggingConfig: Swift.Equatable {
        /// <p>The Amazon S3 bucket to store the access logs in, for example,
        /// 				<code>myawslogbucket.s3.amazonaws.com</code>.</p>
        public let bucket: Swift.String?
        /// <p>Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't
        /// 			want to enable logging when you create a distribution or if you want to disable logging for an
        /// 			existing distribution, specify <code>false</code> for <code>Enabled</code>, and specify empty
        /// 				<code>Bucket</code> and <code>Prefix</code> elements. If you specify <code>false</code> for
        /// 				<code>Enabled</code> but you specify values for <code>Bucket</code>, <code>prefix</code>,
        /// 			and <code>IncludeCookies</code>, the values are automatically deleted.</p>
        public let enabled: Swift.Bool?
        /// <p>Specifies whether you want CloudFront to include cookies in access logs, specify
        /// 				<code>true</code> for <code>IncludeCookies</code>. If you choose to include cookies in logs,
        /// 			CloudFront logs all cookies regardless of how you configure the cache behaviors for this
        /// 			distribution. If you don't want to include cookies when you create a distribution or if you
        /// 			want to disable include cookies for an existing distribution, specify <code>false</code> for
        /// 				<code>IncludeCookies</code>.</p>
        public let includeCookies: Swift.Bool?
        /// <p>An optional string that you want CloudFront to prefix to the access log
        /// 				<code>filenames</code> for this distribution, for example, <code>myprefix/</code>. If you
        /// 			want to enable logging, but you don't want to specify a prefix, you still must include an
        /// 			empty <code>Prefix</code> element in the <code>Logging</code> element.</p>
        public let prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.prefix = prefix
        }
    }

}

extension CloudFrontClientTypes {
    public enum Method: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `get`
        case head
        case options
        case patch
        case post
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [Method] {
            return [
                .delete,
                .get,
                .head,
                .options,
                .patch,
                .post,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .get: return "GET"
            case .head: return "HEAD"
            case .options: return "OPTIONS"
            case .patch: return "PATCH"
            case .post: return "POST"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Method(rawValue: rawValue) ?? Method.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes {
    public enum MinimumProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv112016
        case tlsv12016
        case tlsv122018
        case tlsv122019
        case sdkUnknown(Swift.String)

        public static var allCases: [MinimumProtocolVersion] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv112016,
                .tlsv12016,
                .tlsv122018,
                .tlsv122019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv112016: return "TLSv1.1_2016"
            case .tlsv12016: return "TLSv1_2016"
            case .tlsv122018: return "TLSv1.2_2018"
            case .tlsv122019: return "TLSv1.2_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MinimumProtocolVersion(rawValue: rawValue) ?? MinimumProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension MissingBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingBody(message: \(Swift.String(describing: message)))"}
}

extension MissingBody: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<MissingBodyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
public struct MissingBody: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingBodyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MissingBodyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionConfig = "RealtimeMetricsSubscriptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig {
            try container.encode(realtimeMetricsSubscriptionConfig, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig.self, forKey: .realtimeMetricsSubscriptionConfig)
        realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfigDecoded
    }
}

extension CloudFrontClientTypes.MonitoringSubscription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MonitoringSubscription(realtimeMetricsSubscriptionConfig: \(Swift.String(describing: realtimeMetricsSubscriptionConfig)))"}
}

extension CloudFrontClientTypes.MonitoringSubscription: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public struct MonitoringSubscription: Swift.Equatable {
        /// <p>A subscription configuration for additional CloudWatch metrics.</p>
        public let realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig?

        public init (
            realtimeMetricsSubscriptionConfig: CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig? = nil
        )
        {
            self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
        }
    }

}

extension NoSuchCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension NoSuchCachePolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cache policy does not exist.</p>
public struct NoSuchCachePolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchCloudFrontOriginAccessIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchCloudFrontOriginAccessIdentity(message: \(Swift.String(describing: message)))"}
}

extension NoSuchCloudFrontOriginAccessIdentity: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchCloudFrontOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified origin access identity does not exist.</p>
public struct NoSuchCloudFrontOriginAccessIdentity: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCloudFrontOriginAccessIdentityBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchCloudFrontOriginAccessIdentityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchDistribution(message: \(Swift.String(describing: message)))"}
}

extension NoSuchDistribution: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified distribution does not exist.</p>
public struct NoSuchDistribution: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchFieldLevelEncryptionConfig(message: \(Swift.String(describing: message)))"}
}

extension NoSuchFieldLevelEncryptionConfig: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption doesn't exist.</p>
public struct NoSuchFieldLevelEncryptionConfig: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchFieldLevelEncryptionProfile(message: \(Swift.String(describing: message)))"}
}

extension NoSuchFieldLevelEncryptionProfile: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchFieldLevelEncryptionProfileBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified profile for field-level encryption doesn't exist.</p>
public struct NoSuchFieldLevelEncryptionProfile: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionProfileBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchFieldLevelEncryptionProfileBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFunctionExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchFunctionExists(message: \(Swift.String(describing: message)))"}
}

extension NoSuchFunctionExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchFunctionExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function does not exist.</p>
public struct NoSuchFunctionExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFunctionExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchFunctionExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchInvalidation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchInvalidation(message: \(Swift.String(describing: message)))"}
}

extension NoSuchInvalidation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchInvalidationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified invalidation does not exist.</p>
public struct NoSuchInvalidation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchInvalidationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchInvalidationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchOrigin(message: \(Swift.String(describing: message)))"}
}

extension NoSuchOrigin: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchOriginBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No origin exists with the specified <code>Origin Id</code>. </p>
public struct NoSuchOrigin: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchOriginBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension NoSuchOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The origin request policy does not exist.</p>
public struct NoSuchOriginRequestPolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchPublicKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchPublicKey(message: \(Swift.String(describing: message)))"}
}

extension NoSuchPublicKey: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchPublicKeyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified public key doesn't exist.</p>
public struct NoSuchPublicKey: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchPublicKeyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchPublicKeyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRealtimeLogConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchRealtimeLogConfig(message: \(Swift.String(describing: message)))"}
}

extension NoSuchRealtimeLogConfig: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchRealtimeLogConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The real-time log configuration does not exist.</p>
public struct NoSuchRealtimeLogConfig: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRealtimeLogConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchRealtimeLogConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchResource(message: \(Swift.String(describing: message)))"}
}

extension NoSuchResource: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchResourceBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that was specified is not valid.</p>
public struct NoSuchResource: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResourceBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchResourceBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchStreamingDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NoSuchStreamingDistribution(message: \(Swift.String(describing: message)))"}
}

extension NoSuchStreamingDistribution: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<NoSuchStreamingDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified streaming distribution does not exist.</p>
public struct NoSuchStreamingDistribution: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchStreamingDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NoSuchStreamingDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Origin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAttempts = "ConnectionAttempts"
        case connectionTimeout = "ConnectionTimeout"
        case customHeaders = "CustomHeaders"
        case customOriginConfig = "CustomOriginConfig"
        case domainName = "DomainName"
        case id = "Id"
        case originPath = "OriginPath"
        case originShield = "OriginShield"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let connectionAttempts = connectionAttempts {
            try container.encode(connectionAttempts, forKey: ClientRuntime.Key("ConnectionAttempts"))
        }
        if let connectionTimeout = connectionTimeout {
            try container.encode(connectionTimeout, forKey: ClientRuntime.Key("ConnectionTimeout"))
        }
        if let customHeaders = customHeaders {
            try container.encode(customHeaders, forKey: ClientRuntime.Key("CustomHeaders"))
        }
        if let customOriginConfig = customOriginConfig {
            try container.encode(customOriginConfig, forKey: ClientRuntime.Key("CustomOriginConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let originPath = originPath {
            try container.encode(originPath, forKey: ClientRuntime.Key("OriginPath"))
        }
        if let originShield = originShield {
            try container.encode(originShield, forKey: ClientRuntime.Key("OriginShield"))
        }
        if let s3OriginConfig = s3OriginConfig {
            try container.encode(s3OriginConfig, forKey: ClientRuntime.Key("S3OriginConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originPath)
        originPath = originPathDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomHeaders.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
        let customOriginConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CustomOriginConfig.self, forKey: .customOriginConfig)
        customOriginConfig = customOriginConfigDecoded
        let connectionAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionAttempts)
        connectionAttempts = connectionAttemptsDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let originShieldDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginShield.self, forKey: .originShield)
        originShield = originShieldDecoded
    }
}

extension CloudFrontClientTypes.Origin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Origin(connectionAttempts: \(Swift.String(describing: connectionAttempts)), connectionTimeout: \(Swift.String(describing: connectionTimeout)), customHeaders: \(Swift.String(describing: customHeaders)), customOriginConfig: \(Swift.String(describing: customOriginConfig)), domainName: \(Swift.String(describing: domainName)), id: \(Swift.String(describing: id)), originPath: \(Swift.String(describing: originPath)), originShield: \(Swift.String(describing: originShield)), s3OriginConfig: \(Swift.String(describing: s3OriginConfig)))"}
}

extension CloudFrontClientTypes.Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An origin.</p>
    /// 		       <p>An origin is the location where content is stored, and from which CloudFront gets content to
    /// 			serve to viewers. To specify an origin:</p>
    /// 		       <ul>
    ///             <li>
    ///                 <p>Use <code>S3OriginConfig</code> to specify an Amazon S3 bucket that is not
    /// 					configured with static website hosting.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Use <code>CustomOriginConfig</code> to specify all other kinds of origins,
    /// 					including:</p>
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>An Amazon S3 bucket that is configured with static website hosting</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>An Elastic Load Balancing load balancer</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>An AWS Elemental MediaPackage endpoint</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>An AWS Elemental MediaStore container</p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>Any other HTTP server, running on an Amazon EC2 instance or any other
    /// 							kind of host</p>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For the current maximum number of origins that you can specify per distribution, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions">General Quotas on Web Distributions</a> in the <i>Amazon CloudFront Developer Guide</i>
    /// 			(quotas were formerly referred to as limits).</p>
    public struct Origin: Swift.Equatable {
        /// <p>The number of times that CloudFront attempts to connect to the origin. The minimum number
        ///             is 1, the maximum is 3, and the default (if you don’t specify otherwise) is 3.</p>
        ///         <p>For a custom origin (including an Amazon S3 bucket that’s configured with static
        ///             website hosting), this value also specifies the number of times that CloudFront attempts to
        ///             get a response from the origin, in the case of an <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout">Origin Response Timeout</a>.</p>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts">Origin Connection Attempts</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let connectionAttempts: Swift.Int?
        /// <p>The number of seconds that CloudFront waits when trying to establish a connection to the origin.
        /// 			The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you
        /// 			don’t specify otherwise) is 10 seconds.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout">Origin Connection Timeout</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let connectionTimeout: Swift.Int?
        /// <p>A list of HTTP header names and values that CloudFront adds to the requests that it sends to
        ///             the origin.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html">Adding Custom Headers to Origin Requests</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let customHeaders: CloudFrontClientTypes.CustomHeaders?
        /// <p>Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the
        /// 			Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket
        /// 			is not configured with static website hosting, use the <code>S3OriginConfig</code> type
        /// 			instead.</p>
        public let customOriginConfig: CloudFrontClientTypes.CustomOriginConfig?
        /// <p>The domain name for the origin.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName">Origin Domain Name</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let domainName: Swift.String?
        /// <p>A unique identifier for the origin. This value must be unique within the
        /// 			distribution.</p>
        ///         <p>Use this value to specify the <code>TargetOriginId</code> in a
        ///             <code>CacheBehavior</code> or <code>DefaultCacheBehavior</code>.</p>
        public let id: Swift.String?
        /// <p>An optional path that CloudFront appends to the origin domain name when CloudFront requests content from
        /// 			the origin.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath">Origin Path</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originPath: Swift.String?
        /// <p>CloudFront Origin Shield. Using Origin Shield can help reduce the load on your
        ///             origin.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html">Using Origin Shield</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let originShield: CloudFrontClientTypes.OriginShield?
        /// <p>Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static
        /// 			website hosting. To specify any other type of origin, including an Amazon S3 bucket that is
        /// 			configured with static website hosting, use the <code>CustomOriginConfig</code> type
        /// 			instead.</p>
        public let s3OriginConfig: CloudFrontClientTypes.S3OriginConfig?

        public init (
            connectionAttempts: Swift.Int? = nil,
            connectionTimeout: Swift.Int? = nil,
            customHeaders: CloudFrontClientTypes.CustomHeaders? = nil,
            customOriginConfig: CloudFrontClientTypes.CustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originPath: Swift.String? = nil,
            originShield: CloudFrontClientTypes.OriginShield? = nil,
            s3OriginConfig: CloudFrontClientTypes.S3OriginConfig? = nil
        )
        {
            self.connectionAttempts = connectionAttempts
            self.connectionTimeout = connectionTimeout
            self.customHeaders = customHeaders
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.originShield = originShield
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerName = "HeaderName"
        case headerValue = "HeaderValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerName = headerName {
            try container.encode(headerName, forKey: ClientRuntime.Key("HeaderName"))
        }
        if let headerValue = headerValue {
            try container.encode(headerValue, forKey: ClientRuntime.Key("HeaderValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension CloudFrontClientTypes.OriginCustomHeader: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginCustomHeader(headerName: \(Swift.String(describing: headerName)), headerValue: \(Swift.String(describing: headerValue)))"}
}

extension CloudFrontClientTypes.OriginCustomHeader: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains <code>HeaderName</code> and <code>HeaderValue</code>
    /// 			elements, if any, for this distribution. </p>
    public struct OriginCustomHeader: Swift.Equatable {
        /// <p>The name of a header that you want CloudFront to send to your origin. For more information, see
        /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html">Adding Custom
        /// 			Headers to Origin Requests</a> in the <i> Amazon CloudFront Developer Guide</i>.</p>
        public let headerName: Swift.String?
        /// <p>The value for the header that you specified in the <code>HeaderName</code>
        /// 			field.</p>
        public let headerValue: Swift.String?

        public init (
            headerName: Swift.String? = nil,
            headerValue: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.headerValue = headerValue
        }
    }

}

extension CloudFrontClientTypes.OriginGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverCriteria = "FailoverCriteria"
        case id = "Id"
        case members = "Members"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let failoverCriteria = failoverCriteria {
            try container.encode(failoverCriteria, forKey: ClientRuntime.Key("FailoverCriteria"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let members = members {
            try container.encode(members, forKey: ClientRuntime.Key("Members"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupFailoverCriteria.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
        let membersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginGroupMembers.self, forKey: .members)
        members = membersDecoded
    }
}

extension CloudFrontClientTypes.OriginGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroup(failoverCriteria: \(Swift.String(describing: failoverCriteria)), id: \(Swift.String(describing: id)), members: \(Swift.String(describing: members)))"}
}

extension CloudFrontClientTypes.OriginGroup: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify.
    /// 		You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specifiy
    /// 		the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin
    /// 		under the failover conditions that you've chosen.</p>
    public struct OriginGroup: Swift.Equatable {
        /// <p>A complex type that contains information about the failover criteria for an origin group.</p>
        public let failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria?
        /// <p>The origin group's ID.</p>
        public let id: Swift.String?
        /// <p>A complex type that contains information about the origins in an origin group.</p>
        public let members: CloudFrontClientTypes.OriginGroupMembers?

        public init (
            failoverCriteria: CloudFrontClientTypes.OriginGroupFailoverCriteria? = nil,
            id: Swift.String? = nil,
            members: CloudFrontClientTypes.OriginGroupMembers? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
            self.id = id
            self.members = members
        }
    }

}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let statusCodes = statusCodes {
            try container.encode(statusCodes, forKey: ClientRuntime.Key("StatusCodes"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroupFailoverCriteria(statusCodes: \(Swift.String(describing: statusCodes)))"}
}

extension CloudFrontClientTypes.OriginGroupFailoverCriteria: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type that includes information about the failover criteria for an origin group, including
    /// 		the status codes for which CloudFront will failover from the primary origin to the second origin.</p>
    public struct OriginGroupFailoverCriteria: Swift.Equatable {
        /// <p>The status codes that, when returned from the primary origin, will trigger CloudFront to failover
        /// 		to the second origin.</p>
        public let statusCodes: CloudFrontClientTypes.StatusCodes?

        public init (
            statusCodes: CloudFrontClientTypes.StatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originId = "OriginId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originId = originId {
            try container.encode(originId, forKey: ClientRuntime.Key("OriginId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originId)
        originId = originIdDecoded
    }
}

extension CloudFrontClientTypes.OriginGroupMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroupMember(originId: \(Swift.String(describing: originId)))"}
}

extension CloudFrontClientTypes.OriginGroupMember: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An origin in an origin group.</p>
    public struct OriginGroupMember: Swift.Equatable {
        /// <p>The ID for an origin in an origin group.</p>
        public let originId: Swift.String?

        public init (
            originId: Swift.String? = nil
        )
        {
            self.originId = originId
        }
    }

}

extension CloudFrontClientTypes.OriginGroupMembers: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroupmember0 in items {
                try itemsContainer.encode(origingroupmember0, forKey: ClientRuntime.Key("OriginGroupMember"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroupMember{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroupMember>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroupMember].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroupMember]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroupMember]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroupMembers: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroupMembers(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginGroupMembers: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type for the origins included in an origin group.</p>
    public struct OriginGroupMembers: Swift.Equatable {
        /// <p>Items (origins) in an origin group.</p>
        public let items: [CloudFrontClientTypes.OriginGroupMember]?
        /// <p>The number of origins in an origin group.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginGroupMember]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.OriginGroups: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origingroup0 in items {
                try itemsContainer.encode(origingroup0, forKey: ClientRuntime.Key("OriginGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginGroup].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginGroup]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginGroup]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginGroups(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type for the origin groups specified for a distribution.</p>
    public struct OriginGroups: Swift.Equatable {
        /// <p>The items (origin groups) in a distribution.</p>
        public let items: [CloudFrontClientTypes.OriginGroup]?
        /// <p>The number of origin groups.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginGroup]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case httpOnly
        case httpsOnly
        case matchViewer
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginProtocolPolicy] {
            return [
                .httpOnly,
                .httpsOnly,
                .matchViewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .httpOnly: return "http-only"
            case .httpsOnly: return "https-only"
            case .matchViewer: return "match-viewer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginProtocolPolicy(rawValue: rawValue) ?? OriginProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicy(id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicy: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An origin request policy.</p>
    /// 		       <p>When it’s attached to a cache behavior, the origin request policy determines the values that
    /// 			CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to
    /// 			the origin includes the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The request body and the URL path (without the domain name) from the viewer
    /// 					request.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The headers that CloudFront automatically includes in every origin request, including
    /// 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the
    /// 					cache policy or the origin request policy. These can include items from the
    /// 					viewer request and, in the case of headers, additional ones that are added by
    /// 					CloudFront.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>CloudFront sends a request when it can’t find an object in its cache that matches the request. If
    /// 			you want to send values to the origin and also include them in the cache key, use
    /// 			<code>CachePolicy</code>.</p>
    public struct OriginRequestPolicy: Swift.Equatable {
        /// <p>The unique identifier for the origin request policy.</p>
        public let id: Swift.String?
        /// <p>The date and time when the origin request policy was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The origin request policy configuration.</p>
        public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

        public init (
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
        )
        {
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.originRequestPolicyConfig = originRequestPolicyConfig
        }
    }

}

extension OriginRequestPolicyAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension OriginRequestPolicyAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<OriginRequestPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An origin request policy with this name already exists. You must provide a unique
/// 			name. To modify an existing origin request policy, use
/// 			<code>UpdateOriginRequestPolicy</code>.</p>
public struct OriginRequestPolicyAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OriginRequestPolicyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case cookiesConfig = "CookiesConfig"
        case headersConfig = "HeadersConfig"
        case name = "Name"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyConfig(comment: \(Swift.String(describing: comment)), cookiesConfig: \(Swift.String(describing: cookiesConfig)), headersConfig: \(Swift.String(describing: headersConfig)), name: \(Swift.String(describing: name)), queryStringsConfig: \(Swift.String(describing: queryStringsConfig)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An origin request policy configuration.</p>
    /// 		       <p>This configuration determines the values that CloudFront includes in requests that it sends to the
    /// 			origin. Each request that CloudFront sends to the origin includes the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The request body and the URL path (without the domain name) from the viewer
    /// 					request.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The headers that CloudFront automatically includes in every origin request, including
    /// 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the
    /// 					cache policy or the origin request policy. These can include items from the
    /// 					viewer request and, in the case of headers, additional ones that are added by
    /// 					CloudFront.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>CloudFront sends a request when it can’t find an object in its cache that matches the request. If
    /// 			you want to send values to the origin and also include them in the cache key, use
    /// 			<code>CachePolicy</code>.</p>
    public struct OriginRequestPolicyConfig: Swift.Equatable {
        /// <p>A comment to describe the origin request policy. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>The cookies from viewer requests to include in origin requests.</p>
        public let cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig?
        /// <p>The HTTP headers to include in origin requests. These can include headers from viewer
        /// 			requests and additional headers added by CloudFront.</p>
        public let headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig?
        /// <p>A unique name to identify the origin request policy.</p>
        public let name: Swift.String?
        /// <p>The URL query strings from viewer requests to include in origin requests.</p>
        public let queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig?

        public init (
            comment: Swift.String? = nil,
            cookiesConfig: CloudFrontClientTypes.OriginRequestPolicyCookiesConfig? = nil,
            headersConfig: CloudFrontClientTypes.OriginRequestPolicyHeadersConfig? = nil,
            name: Swift.String? = nil,
            queryStringsConfig: CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig? = nil
        )
        {
            self.comment = comment
            self.cookiesConfig = cookiesConfig
            self.headersConfig = headersConfig
            self.name = name
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyCookieBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyCookieBehavior] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyCookieBehavior(rawValue: rawValue) ?? OriginRequestPolicyCookieBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: ClientRuntime.Key("CookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: ClientRuntime.Key("Cookies"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyCookiesConfig(cookieBehavior: \(Swift.String(describing: cookieBehavior)), cookies: \(Swift.String(describing: cookies)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyCookiesConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
    /// 			are included in requests that CloudFront sends to the origin.</p>
    public struct OriginRequestPolicyCookiesConfig: Swift.Equatable {
        /// <p>Determines whether cookies in viewer requests are included in requests that CloudFront sends to
        /// 			the origin. Valid values are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code> – Cookies in viewer requests are not included in requests that CloudFront
        /// 					sends to the origin. Even when this field is set to <code>none</code>, any
        /// 					cookies that are listed in a <code>CachePolicy</code>
        ///                   <i>are</i>
        /// 					included in origin requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code> – The cookies in viewer requests that are listed in the
        /// 					<code>CookieNames</code> type are included in requests that CloudFront sends to the
        /// 					origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>all</code> – All cookies in viewer requests are included in requests that CloudFront sends
        /// 					to the origin.</p>
        /// 			         </li>
        ///          </ul>
        public let cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior?
        /// <p>Contains a list of cookie names.</p>
        public let cookies: CloudFrontClientTypes.CookieNames?

        public init (
            cookieBehavior: CloudFrontClientTypes.OriginRequestPolicyCookieBehavior? = nil,
            cookies: CloudFrontClientTypes.CookieNames? = nil
        )
        {
            self.cookieBehavior = cookieBehavior
            self.cookies = cookies
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyHeaderBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allviewer
        case allviewerandwhitelistcloudfront
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyHeaderBehavior] {
            return [
                .allviewer,
                .allviewerandwhitelistcloudfront,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allviewer: return "allViewer"
            case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyHeaderBehavior(rawValue: rawValue) ?? OriginRequestPolicyHeaderBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: ClientRuntime.Key("HeaderBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: ClientRuntime.Key("Headers"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyHeadersConfig(headerBehavior: \(Swift.String(describing: headerBehavior)), headers: \(Swift.String(describing: headers)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyHeadersConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An object that determines whether any HTTP headers (and if so, which headers) are included
    /// 			in requests that CloudFront sends to the origin.</p>
    public struct OriginRequestPolicyHeadersConfig: Swift.Equatable {
        /// <p>Determines whether any HTTP headers are included in requests that CloudFront sends to the origin.
        /// 			Valid values are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code> – HTTP headers are not included in requests that CloudFront sends to the
        /// 					origin. Even when this field is set to <code>none</code>, any headers that are
        /// 					listed in a <code>CachePolicy</code>
        ///                   <i>are</i> included in origin
        /// 					requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code> – The HTTP headers that are listed in the <code>Headers</code> type
        /// 					are included in requests that CloudFront sends to the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>allViewer</code> – All HTTP headers in viewer requests are included in requests that
        /// 					CloudFront sends to the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>allViewerAndWhitelistCloudFront</code> – All HTTP headers in viewer requests and the
        /// 					additional CloudFront headers that are listed in the <code>Headers</code> type are
        /// 					included in requests that CloudFront sends to the origin. The additional headers are
        /// 					added by CloudFront.</p>
        /// 			         </li>
        ///          </ul>
        public let headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior?
        /// <p>Contains a list of HTTP header names.</p>
        public let headers: CloudFrontClientTypes.Headers?

        public init (
            headerBehavior: CloudFrontClientTypes.OriginRequestPolicyHeaderBehavior? = nil,
            headers: CloudFrontClientTypes.Headers? = nil
        )
        {
            self.headerBehavior = headerBehavior
            self.headers = headers
        }
    }

}

extension OriginRequestPolicyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyInUse(message: \(Swift.String(describing: message)))"}
}

extension OriginRequestPolicyInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<OriginRequestPolicyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the origin request policy because it is attached to one or more cache
/// 			behaviors.</p>
public struct OriginRequestPolicyInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OriginRequestPolicyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for originrequestpolicysummary0 in items {
                try itemsContainer.encode(originrequestpolicysummary0, forKey: ClientRuntime.Key("OriginRequestPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginRequestPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginRequestPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.OriginRequestPolicySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.OriginRequestPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.OriginRequestPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of origin request policies.</p>
    public struct OriginRequestPolicyList: Swift.Equatable {
        /// <p>Contains the origin request policies in the list.</p>
        public let items: [CloudFrontClientTypes.OriginRequestPolicySummary]?
        /// <p>The maximum number of origin request policies requested.</p>
        public let maxItems: Swift.Int?
        /// <p>If there are more items in the list than are in this response, this element is
        /// 			present. It contains the value that you should use in the <code>Marker</code> field of a
        /// 			subsequent request to continue listing origin request policies where you left
        /// 			off.</p>
        public let nextMarker: Swift.String?
        /// <p>The total number of origin request policies returned in the response.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.OriginRequestPolicySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyQueryStringBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case whitelist
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
            return [
                .all,
                .none,
                .whitelist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .none: return "none"
            case .whitelist: return "whitelist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyQueryStringBehavior(rawValue: rawValue) ?? OriginRequestPolicyQueryStringBehavior.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: ClientRuntime.Key("QueryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: ClientRuntime.Key("QueryStrings"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicyQueryStringsConfig(queryStringBehavior: \(Swift.String(describing: queryStringBehavior)), queryStrings: \(Swift.String(describing: queryStrings)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicyQueryStringsConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>An object that determines whether any URL query strings in viewer requests (and if so, which
    /// 			query strings) are included in requests that CloudFront sends to the origin.</p>
    public struct OriginRequestPolicyQueryStringsConfig: Swift.Equatable {
        /// <p>Determines whether any URL query strings in viewer requests are included in requests that
        /// 			CloudFront sends to the origin. Valid values are:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>none</code> – Query strings in viewer requests are not included in requests that
        /// 					CloudFront sends to the origin. Even when this field is set to <code>none</code>, any
        /// 					query strings that are listed in a <code>CachePolicy</code>
        /// 					             <i>are</i> included in origin requests.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>whitelist</code> – The query strings in viewer requests that are listed in the
        /// 					<code>QueryStringNames</code> type are included in requests that CloudFront sends to
        /// 					the origin.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>all</code> – All query strings in viewer requests are included in requests that CloudFront
        /// 					sends to the origin.</p>
        /// 			         </li>
        ///          </ul>
        public let queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior?
        /// <p>Contains a list of the query strings in viewer requests that are included in requests that
        /// 			CloudFront sends to the origin.</p>
        public let queryStrings: CloudFrontClientTypes.QueryStringNames?

        public init (
            queryStringBehavior: CloudFrontClientTypes.OriginRequestPolicyQueryStringBehavior? = nil,
            queryStrings: CloudFrontClientTypes.QueryStringNames? = nil
        )
        {
            self.queryStringBehavior = queryStringBehavior
            self.queryStrings = queryStrings
        }
    }

}

extension CloudFrontClientTypes.OriginRequestPolicySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicy = originRequestPolicy {
            try container.encode(originRequestPolicy, forKey: ClientRuntime.Key("OriginRequestPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyType.self, forKey: .type)
        type = typeDecoded
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension CloudFrontClientTypes.OriginRequestPolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginRequestPolicySummary(originRequestPolicy: \(Swift.String(describing: originRequestPolicy)), type: \(Swift.String(describing: type)))"}
}

extension CloudFrontClientTypes.OriginRequestPolicySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains an origin request policy.</p>
    public struct OriginRequestPolicySummary: Swift.Equatable {
        /// <p>The origin request policy.</p>
        public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
        /// <p>The type of origin request policy, either <code>managed</code> (created by AWS) or
        /// 			<code>custom</code> (created in this AWS account).</p>
        public let type: CloudFrontClientTypes.OriginRequestPolicyType?

        public init (
            originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil,
            type: CloudFrontClientTypes.OriginRequestPolicyType? = nil
        )
        {
            self.originRequestPolicy = originRequestPolicy
            self.type = type
        }
    }

}

extension CloudFrontClientTypes {
    public enum OriginRequestPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case managed
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginRequestPolicyType] {
            return [
                .custom,
                .managed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .managed: return "managed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginRequestPolicyType(rawValue: rawValue) ?? OriginRequestPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.OriginShield: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case originShieldRegion = "OriginShieldRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let originShieldRegion = originShieldRegion {
            try container.encode(originShieldRegion, forKey: ClientRuntime.Key("OriginShieldRegion"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let originShieldRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originShieldRegion)
        originShieldRegion = originShieldRegionDecoded
    }
}

extension CloudFrontClientTypes.OriginShield: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginShield(enabled: \(Swift.String(describing: enabled)), originShieldRegion: \(Swift.String(describing: originShieldRegion)))"}
}

extension CloudFrontClientTypes.OriginShield: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>CloudFront Origin Shield.</p>
    /// 		       <p>Using Origin Shield can help reduce the load on your origin. For more
    ///             information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html">Using Origin Shield</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public struct OriginShield: Swift.Equatable {
        /// <p>A flag that specifies whether Origin Shield is enabled.</p>
        /// 		       <p>When it’s enabled, CloudFront routes all requests through Origin Shield, which can
        ///             help protect your origin. When it’s disabled, CloudFront might send requests directly to
        ///             your origin from multiple edge locations or regional edge caches.</p>
        public let enabled: Swift.Bool?
        /// <p>The AWS Region for Origin Shield.</p>
        /// 		       <p>Specify the AWS Region that has the lowest latency to your origin.
        ///             To specify a region, use the region code, not the region name.
        ///             For example, specify the US East (Ohio) region as <code>us-east-2</code>.</p>
        ///         <p>When you enable CloudFront Origin Shield, you must specify the AWS Region for Origin
        ///             Shield. For the list of AWS Regions that you can specify, and for help choosing the best
        ///             Region for your origin, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region">Choosing the AWS Region for Origin Shield</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originShieldRegion: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            originShieldRegion: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.originShieldRegion = originShieldRegion
        }
    }

}

extension CloudFrontClientTypes.OriginSslProtocols: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for sslprotocol0 in items {
                try itemsContainer.encode(sslprotocol0, forKey: ClientRuntime.Key("SslProtocol"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct SslProtocol{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SslProtocol>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.SslProtocol].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.SslProtocol]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.SslProtocol]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.OriginSslProtocols: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OriginSslProtocols(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.OriginSslProtocols: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains information about the SSL/TLS protocols that CloudFront can use
    /// 			when establishing an HTTPS connection with your origin. </p>
    public struct OriginSslProtocols: Swift.Equatable {
        /// <p>A list that contains allowed SSL/TLS protocols for this distribution.</p>
        public let items: [CloudFrontClientTypes.SslProtocol]?
        /// <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an
        /// 			HTTPS connection with this origin. </p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.SslProtocol]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.Origins: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for origin0 in items {
                try itemsContainer.encode(origin0, forKey: ClientRuntime.Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Origin].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Origin]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Origin]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Origins: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Origins(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Origins: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains information about the origins for this distribution.</p>
    public struct Origins: Swift.Equatable {
        /// <p>A list of origins.</p>
        public let items: [CloudFrontClientTypes.Origin]?
        /// <p>The number of origins for this distribution.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.Origin]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookiesConfig = "CookiesConfig"
        case enableAcceptEncodingBrotli = "EnableAcceptEncodingBrotli"
        case enableAcceptEncodingGzip = "EnableAcceptEncodingGzip"
        case headersConfig = "HeadersConfig"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: ClientRuntime.Key("CookiesConfig"))
        }
        if let enableAcceptEncodingBrotli = enableAcceptEncodingBrotli {
            try container.encode(enableAcceptEncodingBrotli, forKey: ClientRuntime.Key("EnableAcceptEncodingBrotli"))
        }
        if let enableAcceptEncodingGzip = enableAcceptEncodingGzip {
            try container.encode(enableAcceptEncodingGzip, forKey: ClientRuntime.Key("EnableAcceptEncodingGzip"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: ClientRuntime.Key("HeadersConfig"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: ClientRuntime.Key("QueryStringsConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAcceptEncodingGzipDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingGzip)
        enableAcceptEncodingGzip = enableAcceptEncodingGzipDecoded
        let enableAcceptEncodingBrotliDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAcceptEncodingBrotli)
        enableAcceptEncodingBrotli = enableAcceptEncodingBrotliDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParametersInCacheKeyAndForwardedToOrigin(cookiesConfig: \(Swift.String(describing: cookiesConfig)), enableAcceptEncodingBrotli: \(Swift.String(describing: enableAcceptEncodingBrotli)), enableAcceptEncodingGzip: \(Swift.String(describing: enableAcceptEncodingGzip)), headersConfig: \(Swift.String(describing: headersConfig)), queryStringsConfig: \(Swift.String(describing: queryStringsConfig)))"}
}

extension CloudFrontClientTypes.ParametersInCacheKeyAndForwardedToOrigin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>This object determines the values that CloudFront includes in the cache key. These values can
    /// 			include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an
    /// 			object in its cache that it can return to the viewer.</p>
    /// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
    /// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
    /// 			find an object in its cache that matches the request’s cache key. If you want to send
    /// 			values to the origin but <i>not</i> include them in the cache key, use
    /// 			<code>OriginRequestPolicy</code>.</p>
    public struct ParametersInCacheKeyAndForwardedToOrigin: Swift.Equatable {
        /// <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
        /// 			are included in the cache key and automatically included in requests that CloudFront sends to
        /// 			the origin.</p>
        public let cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig?
        /// <p>A flag that can affect whether the <code>Accept-Encoding</code> HTTP header is
        /// 			included in the cache key and included in requests that CloudFront sends to the origin.</p>
        /// 		       <p>This field is related to the <code>EnableAcceptEncodingGzip</code> field. If one or
        /// 			both of these fields is <code>true</code>
        ///             <i>and</i> the viewer request
        /// 			includes the <code>Accept-Encoding</code> header, then CloudFront does the following:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>Normalizes the value of the viewer’s <code>Accept-Encoding</code>
        /// 					header</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Includes the normalized header in the cache key</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Includes the normalized header in the request to the origin, if a request is necessary</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects">Compression support</a> in the
        ///             <i>Amazon CloudFront Developer Guide</i>.</p>
        ///         <p>If you set this value to <code>true</code>, and this cache behavior also has an origin
        /// 			request policy attached, do not include the <code>Accept-Encoding</code> header in the
        /// 			origin request policy. CloudFront always includes the <code>Accept-Encoding</code> header in
        /// 			origin requests when the value of this field is <code>true</code>, so including this
        /// 			header in an origin request policy has no effect.</p>
        /// 		       <p>If both of these fields are <code>false</code>, then CloudFront treats the
        /// 			<code>Accept-Encoding</code> header the same as any other HTTP header in the viewer
        /// 			request. By default, it’s not included in the cache key and it’s not included in origin
        /// 			requests. In this case, you can manually add <code>Accept-Encoding</code> to the headers
        /// 			whitelist like any other HTTP header.</p>
        public let enableAcceptEncodingBrotli: Swift.Bool?
        /// <p>A flag that can affect whether the <code>Accept-Encoding</code> HTTP header is
        /// 			included in the cache key and included in requests that CloudFront sends to the origin.</p>
        /// 		       <p>This field is related to the <code>EnableAcceptEncodingBrotli</code> field. If one or
        /// 			both of these fields is <code>true</code>
        ///             <i>and</i> the viewer request
        /// 			includes the <code>Accept-Encoding</code> header, then CloudFront does the following:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>Normalizes the value of the viewer’s <code>Accept-Encoding</code>
        /// 					header</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Includes the normalized header in the cache key</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>Includes the normalized header in the request to the origin, if a request is necessary</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects">Compression support</a> in the
        ///             <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <p>If you set this value to <code>true</code>, and this cache behavior also has an origin
        /// 			request policy attached, do not include the <code>Accept-Encoding</code> header in the
        /// 			origin request policy. CloudFront always includes the <code>Accept-Encoding</code> header in
        /// 			origin requests when the value of this field is <code>true</code>, so including this
        /// 			header in an origin request policy has no effect.</p>
        /// 		       <p>If both of these fields are <code>false</code>, then CloudFront treats the
        /// 			<code>Accept-Encoding</code> header the same as any other HTTP header in the viewer
        /// 			request. By default, it’s not included in the cache key and it’s not included in origin
        /// 			requests. In this case, you can manually add <code>Accept-Encoding</code> to the headers
        /// 			whitelist like any other HTTP header.</p>
        public let enableAcceptEncodingGzip: Swift.Bool?
        /// <p>An object that determines whether any HTTP headers (and if so, which headers) are
        /// 			included in the cache key and automatically included in requests that CloudFront sends to the
        /// 			origin.</p>
        public let headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig?
        /// <p>An object that determines whether any URL query strings in viewer requests (and if so, which
        /// 			query strings) are included in the cache key and automatically included in requests that
        /// 			CloudFront sends to the origin.</p>
        public let queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig?

        public init (
            cookiesConfig: CloudFrontClientTypes.CachePolicyCookiesConfig? = nil,
            enableAcceptEncodingBrotli: Swift.Bool? = nil,
            enableAcceptEncodingGzip: Swift.Bool? = nil,
            headersConfig: CloudFrontClientTypes.CachePolicyHeadersConfig? = nil,
            queryStringsConfig: CloudFrontClientTypes.CachePolicyQueryStringsConfig? = nil
        )
        {
            self.cookiesConfig = cookiesConfig
            self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
            self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
            self.headersConfig = headersConfig
            self.queryStringsConfig = queryStringsConfig
        }
    }

}

extension CloudFrontClientTypes.Paths: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Path"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Path{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Path>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Paths: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Paths(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.Paths: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains information about the objects that you want to invalidate.
    /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects">Specifying the Objects
    /// 				to Invalidate</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
    public struct Paths: Swift.Equatable {
        /// <p>A complex type that contains a list of the paths that you want to invalidate.</p>
        public let items: [Swift.String]?
        /// <p>The number of invalidation paths specified for the objects that you want to invalidate.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension PreconditionFailed: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionFailed(message: \(Swift.String(describing: message)))"}
}

extension PreconditionFailed: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PreconditionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The precondition in one or more of the request fields evaluated to
/// 			<code>false</code>.</p>
public struct PreconditionFailed: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PreconditionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes {
    public enum PriceClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case priceclass100
        case priceclass200
        case priceclassAll
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceClass] {
            return [
                .priceclass100,
                .priceclass200,
                .priceclassAll,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .priceclass100: return "PriceClass_100"
            case .priceclass200: return "PriceClass_200"
            case .priceclassAll: return "PriceClass_All"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceClass(rawValue: rawValue) ?? PriceClass.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.PublicKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case id = "Id"
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CloudFrontClientTypes.PublicKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKey(createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension CloudFrontClientTypes.PublicKey: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    public struct PublicKey: Swift.Equatable {
        /// <p>The date and time when the public key was uploaded.</p>
        public let createdTime: ClientRuntime.Date?
        /// <p>The identifier of the public key.</p>
        public let id: Swift.String?
        /// <p>Configuration information about a public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
        public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
        )
        {
            self.createdTime = createdTime
            self.id = id
            self.publicKeyConfig = publicKeyConfig
        }
    }

}

extension PublicKeyAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension PublicKeyAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PublicKeyAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified public key already exists.</p>
public struct PublicKeyAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PublicKeyAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encodedKey = "EncodedKey"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyConfig(callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), encodedKey: \(Swift.String(describing: encodedKey)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.PublicKeyConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Configuration information about a public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    public struct PublicKeyConfig: Swift.Equatable {
        /// <p>A string included in the request to help make sure that the request can’t be
        /// 			replayed.</p>
        public let callerReference: Swift.String?
        /// <p>A comment to describe the public key. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>The public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
        public let encodedKey: Swift.String?
        /// <p>A name to help identify the public key.</p>
        public let name: Swift.String?

        public init (
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            encodedKey: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.callerReference = callerReference
            self.comment = comment
            self.encodedKey = encodedKey
            self.name = name
        }
    }

}

extension PublicKeyInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyInUse(message: \(Swift.String(describing: message)))"}
}

extension PublicKeyInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PublicKeyInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified public key is in use. </p>
public struct PublicKeyInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PublicKeyInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.PublicKeyList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for publickeysummary0 in items {
                try itemsContainer.encode(publickeysummary0, forKey: ClientRuntime.Key("PublicKeySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKeySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKeySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.PublicKeySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.PublicKeySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.PublicKeySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.PublicKeyList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeyList(items: \(Swift.String(describing: items)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.PublicKeyList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    public struct PublicKeyList: Swift.Equatable {
        /// <p>A list of public keys.</p>
        public let items: [CloudFrontClientTypes.PublicKeySummary]?
        /// <p>The maximum number of public keys you want in the response.</p>
        public let maxItems: Swift.Int?
        /// <p>If there are more elements to be listed, this element is present and contains
        /// 			the value that you can use for the <code>Marker</code> request parameter to continue
        /// 			listing your public keys where you left off.</p>
        public let nextMarker: Swift.String?
        /// <p>The number of public keys in the list.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.PublicKeySummary]? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.PublicKeySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
        case createdTime = "CreatedTime"
        case encodedKey = "EncodedKey"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let createdTime = createdTime {
            try container.encode(ClientRuntime.TimestampWrapper(createdTime, format: .dateTime), forKey: ClientRuntime.Key("CreatedTime"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: ClientRuntime.Key("EncodedKey"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        var createdTimeBuffer:ClientRuntime.Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let encodedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontClientTypes.PublicKeySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublicKeySummary(comment: \(Swift.String(describing: comment)), createdTime: \(Swift.String(describing: createdTime)), encodedKey: \(Swift.String(describing: encodedKey)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension CloudFrontClientTypes.PublicKeySummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains information about a public key.</p>
    public struct PublicKeySummary: Swift.Equatable {
        /// <p>A comment to describe the public key. The comment cannot be longer than 128
        /// 			characters.</p>
        public let comment: Swift.String?
        /// <p>The date and time when the public key was uploaded.</p>
        public let createdTime: ClientRuntime.Date?
        /// <p>The public key.</p>
        public let encodedKey: Swift.String?
        /// <p>The identifier of the public key.</p>
        public let id: Swift.String?
        /// <p>A name to help identify the public key.</p>
        public let name: Swift.String?

        public init (
            comment: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encodedKey: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.comment = comment
            self.createdTime = createdTime
            self.encodedKey = encodedKey
            self.id = id
            self.name = name
        }
    }

}

extension PublishFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishFunctionInput(ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)))"}
}

extension PublishFunctionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct PublishFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInput: Swift.Equatable {
    /// <p>The current version (<code>ETag</code> value) of the function that you are publishing, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>The name of the function that you are publishing.</p>
    public let name: Swift.String?

    public init (
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct PublishFunctionInputBody: Swift.Equatable {
}

extension PublishFunctionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PublishFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishFunctionOutputResponse(functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension PublishFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct PublishFunctionOutputResponse: Swift.Equatable {
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

struct PublishFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension PublishFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileId = "ProfileId"
        case queryArg = "QueryArg"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: ClientRuntime.Key("ProfileId"))
        }
        if let queryArg = queryArg {
            try container.encode(queryArg, forKey: ClientRuntime.Key("QueryArg"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryArg)
        queryArg = queryArgDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfile(profileId: \(Swift.String(describing: profileId)), queryArg: \(Swift.String(describing: queryArg)))"}
}

extension CloudFrontClientTypes.QueryArgProfile: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Query argument-profile mapping for field-level encryption.</p>
    public struct QueryArgProfile: Swift.Equatable {
        /// <p>ID of profile to use for field-level encryption query argument-profile mapping</p>
        public let profileId: Swift.String?
        /// <p>Query argument for field-level encryption query argument-profile mapping.</p>
        public let queryArg: Swift.String?

        public init (
            profileId: Swift.String? = nil,
            queryArg: Swift.String? = nil
        )
        {
            self.profileId = profileId
            self.queryArg = queryArg
        }
    }

}

extension CloudFrontClientTypes.QueryArgProfileConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardWhenQueryArgProfileIsUnknown = "ForwardWhenQueryArgProfileIsUnknown"
        case queryArgProfiles = "QueryArgProfiles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown {
            try container.encode(forwardWhenQueryArgProfileIsUnknown, forKey: ClientRuntime.Key("ForwardWhenQueryArgProfileIsUnknown"))
        }
        if let queryArgProfiles = queryArgProfiles {
            try container.encode(queryArgProfiles, forKey: ClientRuntime.Key("QueryArgProfiles"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenQueryArgProfileIsUnknownDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forwardWhenQueryArgProfileIsUnknown)
        forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknownDecoded
        let queryArgProfilesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.QueryArgProfiles.self, forKey: .queryArgProfiles)
        queryArgProfiles = queryArgProfilesDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfileConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfileConfig(forwardWhenQueryArgProfileIsUnknown: \(Swift.String(describing: forwardWhenQueryArgProfileIsUnknown)), queryArgProfiles: \(Swift.String(describing: queryArgProfiles)))"}
}

extension CloudFrontClientTypes.QueryArgProfileConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Configuration for query argument-profile mapping for field-level encryption.</p>
    public struct QueryArgProfileConfig: Swift.Equatable {
        /// <p>Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument,
        /// 			fle-profile, is unknown.</p>
        public let forwardWhenQueryArgProfileIsUnknown: Swift.Bool?
        /// <p>Profiles specified for query argument-profile mapping for field-level encryption.</p>
        public let queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles?

        public init (
            forwardWhenQueryArgProfileIsUnknown: Swift.Bool? = nil,
            queryArgProfiles: CloudFrontClientTypes.QueryArgProfiles? = nil
        )
        {
            self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
            self.queryArgProfiles = queryArgProfiles
        }
    }

}

extension QueryArgProfileEmpty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfileEmpty(message: \(Swift.String(describing: message)))"}
}

extension QueryArgProfileEmpty: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<QueryArgProfileEmptyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No profile specified for the field-level encryption query argument.</p>
public struct QueryArgProfileEmpty: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct QueryArgProfileEmptyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension QueryArgProfileEmptyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for queryargprofile0 in items {
                try itemsContainer.encode(queryargprofile0, forKey: ClientRuntime.Key("QueryArgProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct QueryArgProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.QueryArgProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.QueryArgProfile].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.QueryArgProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.QueryArgProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryArgProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryArgProfiles(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.QueryArgProfiles: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Query argument-profile mapping for field-level encryption.</p>
    public struct QueryArgProfiles: Swift.Equatable {
        /// <p>Number of items for query argument-profile mapping for field-level encryption.</p>
        public let items: [CloudFrontClientTypes.QueryArgProfile]?
        /// <p>Number of profiles for query argument-profile mapping for field-level encryption.</p>
        public let quantity: Swift.Int?

        public init (
            items: [CloudFrontClientTypes.QueryArgProfile]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringCacheKeys: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringCacheKeys: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStringCacheKeys(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.QueryStringCacheKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include query strings in the cache key, use
    /// 			<code>QueryStringsConfig</code> in a cache policy. See
    /// 			<code>CachePolicy</code>.</p>
    /// 		       <p>If you want to send query strings to the origin but not include them in the cache key,
    /// 			use <code>QueryStringsConfig</code> in an origin request policy. See
    /// 			<code>OriginRequestPolicy</code>.</p>
    /// 		       <p>A complex type that contains information about the query string parameters that you want
    /// 			CloudFront to use for caching for a cache behavior.
    /// 		</p>
    public struct QueryStringCacheKeys: Swift.Equatable {
        /// <p>A list that contains the query string parameters that you want CloudFront to use
        /// 			as a basis for caching for a cache behavior. If <code>Quantity</code> is 0, you can omit
        /// 			<code>Items</code>. </p>
        public let items: [Swift.String]?
        /// <p>The number of <code>whitelisted</code> query string parameters for a cache
        /// 			behavior.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.QueryStringNames: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.QueryStringNames: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryStringNames(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.QueryStringNames: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains a list of query string names.</p>
    public struct QueryStringNames: Swift.Equatable {
        /// <p>A list of query string names.</p>
        public let items: [Swift.String]?
        /// <p>The number of query string names in the <code>Items</code> list.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.RealtimeLogConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension CloudFrontClientTypes.RealtimeLogConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfig(aRN: \(Swift.String(describing: aRN)), endPoints: \(Swift.String(describing: endPoints)), fields: \(Swift.String(describing: fields)), name: \(Swift.String(describing: name)), samplingRate: \(Swift.String(describing: samplingRate)))"}
}

extension CloudFrontClientTypes.RealtimeLogConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A real-time log configuration.</p>
    public struct RealtimeLogConfig: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of this real-time log configuration.</p>
        public let aRN: Swift.String?
        /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
        /// 			log data for this real-time log configuration.</p>
        public let endPoints: [CloudFrontClientTypes.EndPoint]?
        /// <p>A list of fields that are included in each real-time log record. In an API response, the
        /// 			fields are provided in the same order in which they are sent to the Amazon Kinesis data
        /// 			stream.</p>
        /// 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
        /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
        public let fields: [Swift.String]?
        /// <p>The unique name of this real-time log configuration.</p>
        public let name: Swift.String?
        /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
        /// 			percentage of viewer requests that are represented in the real-time log data. The
        /// 			sampling rate is an integer between 1 and 100, inclusive.</p>
        public let samplingRate: Swift.Int?

        public init (
            aRN: Swift.String? = nil,
            endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
            fields: [Swift.String]? = nil,
            name: Swift.String? = nil,
            samplingRate: Swift.Int? = nil
        )
        {
            self.aRN = aRN
            self.endPoints = endPoints
            self.fields = fields
            self.name = name
            self.samplingRate = samplingRate
        }
    }

}

extension RealtimeLogConfigAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension RealtimeLogConfigAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<RealtimeLogConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A real-time log configuration with this name already exists. You must provide a unique name.
/// 			To modify an existing real-time log configuration, use
/// 			<code>UpdateRealtimeLogConfig</code>.</p>
public struct RealtimeLogConfigAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RealtimeLogConfigAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigInUse(message: \(Swift.String(describing: message)))"}
}

extension RealtimeLogConfigInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<RealtimeLogConfigInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the real-time log configuration because it is attached to one or more cache
/// 			behaviors.</p>
public struct RealtimeLogConfigInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RealtimeLogConfigInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigOwnerMismatch: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigOwnerMismatch(message: \(Swift.String(describing: message)))"}
}

extension RealtimeLogConfigOwnerMismatch: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<RealtimeLogConfigOwnerMismatchBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified real-time log configuration belongs to a different AWS account.</p>
public struct RealtimeLogConfigOwnerMismatch: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigOwnerMismatchBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RealtimeLogConfigOwnerMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for realtimelogconfig0 in items {
                try itemsContainer.encode(realtimelogconfig0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct member{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.RealtimeLogConfig].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.RealtimeLogConfig]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.RealtimeLogConfig]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension CloudFrontClientTypes.RealtimeLogConfigs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeLogConfigs(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)))"}
}

extension CloudFrontClientTypes.RealtimeLogConfigs: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of real-time log configurations.</p>
    public struct RealtimeLogConfigs: Swift.Equatable {
        /// <p>A flag that indicates whether there are more real-time log configurations than are contained
        /// 			in this list.</p>
        public let isTruncated: Swift.Bool?
        /// <p>Contains the list of real-time log configurations.</p>
        public let items: [CloudFrontClientTypes.RealtimeLogConfig]?
        /// <p>This parameter indicates where this list of real-time log configurations begins. This list
        /// 			includes real-time log configurations that occur after the marker.</p>
        public let marker: Swift.String?
        /// <p>The maximum number of real-time log configurations requested.</p>
        public let maxItems: Swift.Int?
        /// <p>If there are more items in the list than are in this response, this element is present. It
        /// 			contains the value that you should use in the <code>Marker</code> field of a subsequent
        /// 			request to continue listing real-time log configurations where you left off. </p>
        public let nextMarker: Swift.String?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.RealtimeLogConfig]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
        }
    }

}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeMetricsSubscriptionStatus = "RealtimeMetricsSubscriptionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus {
            try container.encode(realtimeMetricsSubscriptionStatus, forKey: ClientRuntime.Key("RealtimeMetricsSubscriptionStatus"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionStatusDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus.self, forKey: .realtimeMetricsSubscriptionStatus)
        realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatusDecoded
    }
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RealtimeMetricsSubscriptionConfig(realtimeMetricsSubscriptionStatus: \(Swift.String(describing: realtimeMetricsSubscriptionStatus)))"}
}

extension CloudFrontClientTypes.RealtimeMetricsSubscriptionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A subscription configuration for additional CloudWatch metrics.</p>
    public struct RealtimeMetricsSubscriptionConfig: Swift.Equatable {
        /// <p>A flag that indicates whether additional CloudWatch metrics are enabled for a given
        /// 			CloudFront distribution.</p>
        public let realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus?

        public init (
            realtimeMetricsSubscriptionStatus: CloudFrontClientTypes.RealtimeMetricsSubscriptionStatus? = nil
        )
        {
            self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
        }
    }

}

extension CloudFrontClientTypes {
    public enum RealtimeMetricsSubscriptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RealtimeMetricsSubscriptionStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealtimeMetricsSubscriptionStatus(rawValue: rawValue) ?? RealtimeMetricsSubscriptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUse(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUse: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ResourceInUseBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete this resource because it is in use.</p>
public struct ResourceInUse: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.Restrictions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case geoRestriction = "GeoRestriction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let geoRestriction = geoRestriction {
            try container.encode(geoRestriction, forKey: ClientRuntime.Key("GeoRestriction"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoRestrictionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.GeoRestriction.self, forKey: .geoRestriction)
        geoRestriction = geoRestrictionDecoded
    }
}

extension CloudFrontClientTypes.Restrictions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Restrictions(geoRestriction: \(Swift.String(describing: geoRestriction)))"}
}

extension CloudFrontClientTypes.Restrictions: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that identifies ways in which you want to restrict distribution of your
    /// 			content.</p>
    public struct Restrictions: Swift.Equatable {
        /// <p>A complex type that controls the countries in which your content is distributed. CloudFront
        /// 			determines the location of your users using <code>MaxMind</code> GeoIP databases.</p>
        public let geoRestriction: CloudFrontClientTypes.GeoRestriction?

        public init (
            geoRestriction: CloudFrontClientTypes.GeoRestriction? = nil
        )
        {
            self.geoRestriction = geoRestriction
        }
    }

}

extension CloudFrontClientTypes.S3Origin: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3Origin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Origin(domainName: \(Swift.String(describing: domainName)), originAccessIdentity: \(Swift.String(describing: originAccessIdentity)))"}
}

extension CloudFrontClientTypes.S3Origin: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains information about the Amazon S3 bucket from which you want
    /// 			CloudFront to get your media files for distribution.</p>
    public struct S3Origin: Swift.Equatable {
        /// <p>The DNS name of the Amazon S3 origin. </p>
        public let domainName: Swift.String?
        /// <p>The CloudFront origin access identity to associate with the distribution. Use an origin
        /// 			access identity to configure the distribution so that end users can only access objects in an
        /// 			Amazon S3 bucket through CloudFront.</p>
        /// 		       <p>If you want end users to be able to access objects using either the CloudFront URL or the
        /// 			Amazon S3 URL, specify an empty <code>OriginAccessIdentity</code> element.</p>
        /// 		       <p>To delete the origin access identity from an existing distribution, update the
        /// 			distribution configuration and include an empty <code>OriginAccessIdentity</code>
        /// 			element.</p>
        /// 		       <p>To replace the origin access identity, update the distribution configuration and
        /// 			specify the new origin access identity.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html">Using an Origin Access
        /// 				Identity to Restrict Access to Your Amazon S3 Content</a> in the <i>
        /// 				Amazon CloudFront Developer Guide</i>.</p>
        public let originAccessIdentity: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes.S3OriginConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: ClientRuntime.Key("OriginAccessIdentity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension CloudFrontClientTypes.S3OriginConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3OriginConfig(originAccessIdentity: \(Swift.String(describing: originAccessIdentity)))"}
}

extension CloudFrontClientTypes.S3OriginConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that contains information about the Amazon S3 origin. If the origin is a
    /// 			custom origin or an S3 bucket that is configured as a website endpoint, use the
    ///             <code>CustomOriginConfig</code> element instead.</p>
    public struct S3OriginConfig: Swift.Equatable {
        /// <p>The CloudFront origin access identity to associate with the origin. Use an origin access
        /// 			identity to configure the origin so that viewers can <i>only</i> access objects
        /// 			in an Amazon S3 bucket through CloudFront. The format of the value is:</p>
        /// 		       <p>origin-access-identity/cloudfront/<i>ID-of-origin-access-identity</i>
        ///          </p>
        /// 		       <p>where <code>
        ///                <i>ID-of-origin-access-identity</i>
        ///             </code> is the value that
        /// 			CloudFront returned in the <code>ID</code> element when you created the origin access
        /// 			identity.</p>
        /// 		       <p>If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3
        /// 			URL, specify an empty <code>OriginAccessIdentity</code> element.</p>
        /// 		       <p>To delete the origin access identity from an existing distribution, update the
        /// 			distribution configuration and include an empty <code>OriginAccessIdentity</code>
        /// 			element.</p>
        /// 		       <p>To replace the origin access identity, update the distribution configuration and
        /// 			specify the new origin access identity.</p>
        /// 		       <p>For more information about the origin access identity, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
        /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
        public let originAccessIdentity: Swift.String?

        public init (
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension CloudFrontClientTypes {
    public enum SSLSupportMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sniOnly
        case staticIp
        case vip
        case sdkUnknown(Swift.String)

        public static var allCases: [SSLSupportMethod] {
            return [
                .sniOnly,
                .staticIp,
                .vip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sniOnly: return "sni-only"
            case .staticIp: return "static-ip"
            case .vip: return "vip"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SSLSupportMethod(rawValue: rawValue) ?? SSLSupportMethod.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.Signer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountNumber = "AwsAccountNumber"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let awsAccountNumber = awsAccountNumber {
            try container.encode(awsAccountNumber, forKey: ClientRuntime.Key("AwsAccountNumber"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: ClientRuntime.Key("KeyPairIds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension CloudFrontClientTypes.Signer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Signer(awsAccountNumber: \(Swift.String(describing: awsAccountNumber)), keyPairIds: \(Swift.String(describing: keyPairIds)))"}
}

extension CloudFrontClientTypes.Signer: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of AWS accounts and the active CloudFront key pairs in each account that CloudFront can use to
    /// 			verify the signatures of signed URLs and signed cookies.</p>
    public struct Signer: Swift.Equatable {
        /// <p>An AWS account number that contains active CloudFront key pairs that CloudFront can use to verify the
        /// 			signatures of signed URLs and signed cookies. If the AWS account that owns the key pairs
        /// 			is the same account that owns the CloudFront distribution, the value of this field is
        /// 			<code>self</code>.</p>
        public let awsAccountNumber: Swift.String?
        /// <p>A list of CloudFront key pair identifiers.</p>
        public let keyPairIds: CloudFrontClientTypes.KeyPairIds?

        public init (
            awsAccountNumber: Swift.String? = nil,
            keyPairIds: CloudFrontClientTypes.KeyPairIds? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.keyPairIds = keyPairIds
        }
    }

}

extension CloudFrontClientTypes {
    public enum SslProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sslv3
        case tlsv1
        case tlsv11
        case tlsv12
        case sdkUnknown(Swift.String)

        public static var allCases: [SslProtocol] {
            return [
                .sslv3,
                .tlsv1,
                .tlsv11,
                .tlsv12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sslv3: return "SSLv3"
            case .tlsv1: return "TLSv1"
            case .tlsv11: return "TLSv1.1"
            case .tlsv12: return "TLSv1.2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SslProtocol(rawValue: rawValue) ?? SslProtocol.sdkUnknown(rawValue)
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for integer0 in items {
                try itemsContainer.encode(integer0, forKey: ClientRuntime.Key("StatusCode"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StatusCode{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StatusCode>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.Int].self, forKey: .member)
                var itemsBuffer:[Swift.Int]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.Int]()
                    for integerContainer0 in itemsContainer {
                        itemsBuffer?.append(integerContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StatusCodes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StatusCodes(items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.StatusCodes: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex data type for the status codes that you specify that, when returned by a primary origin, trigger
    /// 		CloudFront to failover to a second origin.</p>
    public struct StatusCodes: Swift.Equatable {
        /// <p>The items (status codes) for an origin group.</p>
        public let items: [Swift.Int]?
        /// <p>The number of status codes.</p>
        public let quantity: Swift.Int?

        public init (
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension CloudFrontClientTypes.StreamingDistribution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case domainName = "DomainName"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: ClientRuntime.Key("ActiveTrustedSigners"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistribution(aRN: \(Swift.String(describing: aRN)), activeTrustedSigners: \(Swift.String(describing: activeTrustedSigners)), domainName: \(Swift.String(describing: domainName)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension CloudFrontClientTypes.StreamingDistribution: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to
    /// 			track and manage content delivery.</p>
    public struct StreamingDistribution: Swift.Equatable {
        /// <p>The ARN (Amazon Resource Name) for the distribution. For example:
        /// 			<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
        /// 			<code>123456789012</code> is your AWS account ID.</p>
        public let aRN: Swift.String?
        /// <p>A complex type that lists the AWS accounts, if any, that you included in the
        /// 				<code>TrustedSigners</code> complex type for this distribution. These are the accounts that
        /// 			you want to allow to create signed URLs for private content.</p>
        /// 		       <p>The <code>Signer</code> complex type lists the AWS account number of the trusted
        /// 			signer or <code>self</code> if the signer is the AWS account that created the distribution.
        /// 			The <code>Signer</code> element also includes the IDs of any active CloudFront key pairs that are
        /// 			associated with the trusted signer's AWS account. If no <code>KeyPairId</code> element
        /// 			appears for a <code>Signer</code>, that signer can't create signed URLs.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private
        /// 				Content through CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
        public let activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners?
        /// <p>The domain name that corresponds to the streaming distribution, for example, <code>s5c39gqb8ow64r.cloudfront.net</code>. </p>
        public let domainName: Swift.String?
        /// <p>The identifier for the RTMP distribution. For example:
        /// 			<code>EGTXBD79EXAMPLE</code>.</p>
        public let id: Swift.String?
        /// <p>The date and time that the distribution was last modified. </p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>The current status of the RTMP distribution. When the status is <code>Deployed</code>,
        /// 			the distribution's information is propagated to all CloudFront edge locations.</p>
        public let status: Swift.String?
        /// <p>The current configuration information for the RTMP distribution.</p>
        public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

        public init (
            aRN: Swift.String? = nil,
            activeTrustedSigners: CloudFrontClientTypes.ActiveTrustedSigners? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil,
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
        )
        {
            self.aRN = aRN
            self.activeTrustedSigners = activeTrustedSigners
            self.domainName = domainName
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.streamingDistributionConfig = streamingDistributionConfig
        }
    }

}

extension StreamingDistributionAlreadyExists: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionAlreadyExists(message: \(Swift.String(describing: message)))"}
}

extension StreamingDistributionAlreadyExists: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<StreamingDistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller reference you attempted to create the streaming distribution with
/// 			is associated with another distribution</p>
public struct StreamingDistributionAlreadyExists: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionAlreadyExistsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StreamingDistributionAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case enabled = "Enabled"
        case logging = "Logging"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: ClientRuntime.Key("CallerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: ClientRuntime.Key("Logging"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingLoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionConfig(aliases: \(Swift.String(describing: aliases)), callerReference: \(Swift.String(describing: callerReference)), comment: \(Swift.String(describing: comment)), enabled: \(Swift.String(describing: enabled)), logging: \(Swift.String(describing: logging)), priceClass: \(Swift.String(describing: priceClass)), s3Origin: \(Swift.String(describing: s3Origin)), trustedSigners: \(Swift.String(describing: trustedSigners)))"}
}

extension CloudFrontClientTypes.StreamingDistributionConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>The RTMP distribution's configuration information.</p>
    public struct StreamingDistributionConfig: Swift.Equatable {
        /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
        /// 			for this streaming distribution. </p>
        public let aliases: CloudFrontClientTypes.Aliases?
        /// <p>A unique value (for example, a date-time stamp) that ensures that the request can't be
        /// 			replayed.</p>
        /// 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
        /// 			<code>StreamingDistributionConfig</code> object), CloudFront creates a new distribution.</p>
        /// 		       <p>If <code>CallerReference</code> is a value that you already sent in a previous request to
        /// 			create a distribution, CloudFront returns a <code>DistributionAlreadyExists</code> error.</p>
        public let callerReference: Swift.String?
        /// <p>Any comments you want to include about the streaming distribution. </p>
        public let comment: Swift.String?
        /// <p>Whether the streaming distribution is enabled to accept user requests for
        /// 			content.</p>
        public let enabled: Swift.Bool?
        /// <p>A complex type that controls whether access logs are written for the streaming
        /// 			distribution. </p>
        public let logging: CloudFrontClientTypes.StreamingLoggingConfig?
        /// <p>A complex type that contains information about price class for this streaming
        /// 			distribution. </p>
        public let priceClass: CloudFrontClientTypes.PriceClass?
        /// <p>A complex type that contains information about the Amazon S3 bucket from which you want
        /// 			CloudFront to get your media files for distribution. </p>
        public let s3Origin: CloudFrontClientTypes.S3Origin?
        /// <p>A complex type that specifies any AWS accounts that you want to permit to create signed
        /// 			URLs for private content. If you want the distribution to use signed URLs, include this
        /// 			element; if you want the distribution to use public URLs, remove this element. For more
        /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through
        /// 				CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
        public let trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init (
            aliases: CloudFrontClientTypes.Aliases? = nil,
            callerReference: Swift.String? = nil,
            comment: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            logging: CloudFrontClientTypes.StreamingLoggingConfig? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aliases = aliases
            self.callerReference = callerReference
            self.comment = comment
            self.enabled = enabled
            self.logging = logging
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionConfigWithTags(streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)), tags: \(Swift.String(describing: tags)))"}
}

extension CloudFrontClientTypes.StreamingDistributionConfigWithTags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A streaming distribution Configuration and a list of tags to be associated with the
    /// 			streaming distribution.</p>
    public struct StreamingDistributionConfigWithTags: Swift.Equatable {
        /// <p>A streaming distribution Configuration.</p>
        public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
        /// <p>A complex type that contains zero or more <code>Tag</code> elements.</p>
        public let tags: CloudFrontClientTypes.Tags?

        public init (
            streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil,
            tags: CloudFrontClientTypes.Tags? = nil
        )
        {
            self.streamingDistributionConfig = streamingDistributionConfig
            self.tags = tags
        }
    }

}

extension CloudFrontClientTypes.StreamingDistributionList: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: ClientRuntime.Key("IsTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for streamingdistributionsummary0 in items {
                try itemsContainer.encode(streamingdistributionsummary0, forKey: ClientRuntime.Key("StreamingDistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: ClientRuntime.Key("Marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: ClientRuntime.Key("MaxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: ClientRuntime.Key("NextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StreamingDistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StreamingDistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.StreamingDistributionSummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.StreamingDistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.StreamingDistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.StreamingDistributionList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionList(isTruncated: \(Swift.String(describing: isTruncated)), items: \(Swift.String(describing: items)), marker: \(Swift.String(describing: marker)), maxItems: \(Swift.String(describing: maxItems)), nextMarker: \(Swift.String(describing: nextMarker)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.StreamingDistributionList: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A streaming distribution list. </p>
    public struct StreamingDistributionList: Swift.Equatable {
        /// <p>A flag that indicates whether more streaming distributions remain to be listed. If your
        /// 			results were truncated, you can make a follow-up pagination request using the
        /// 				<code>Marker</code> request parameter to retrieve more distributions in the list. </p>
        public let isTruncated: Swift.Bool?
        /// <p>A complex type that contains one <code>StreamingDistributionSummary</code> element for
        /// 			each distribution that was created by the current AWS account.</p>
        public let items: [CloudFrontClientTypes.StreamingDistributionSummary]?
        /// <p>The value you provided for the <code>Marker</code> request parameter. </p>
        public let marker: Swift.String?
        /// <p>The value you provided for the <code>MaxItems</code> request parameter. </p>
        public let maxItems: Swift.Int?
        /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
        /// 			the value you can use for the <code>Marker</code> request parameter to continue listing your
        /// 			RTMP distributions where they left off. </p>
        public let nextMarker: Swift.String?
        /// <p>The number of streaming distributions that were created by the current AWS account.
        /// 		</p>
        public let quantity: Swift.Int?

        public init (
            isTruncated: Swift.Bool? = nil,
            items: [CloudFrontClientTypes.StreamingDistributionSummary]? = nil,
            marker: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            nextMarker: Swift.String? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.isTruncated = isTruncated
            self.items = items
            self.marker = marker
            self.maxItems = maxItems
            self.nextMarker = nextMarker
            self.quantity = quantity
        }
    }

}

extension StreamingDistributionNotDisabled: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionNotDisabled(message: \(Swift.String(describing: message)))"}
}

extension StreamingDistributionNotDisabled: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<StreamingDistributionNotDisabledBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CloudFront distribution is not disabled. You must disable
/// 			the distribution before you can delete it.</p>
public struct StreamingDistributionNotDisabled: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionNotDisabledBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StreamingDistributionNotDisabledBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case aliases = "Aliases"
        case comment = "Comment"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case status = "Status"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: ClientRuntime.Key("Aliases"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: ClientRuntime.Key("Comment"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: ClientRuntime.Key("DomainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(ClientRuntime.TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: ClientRuntime.Key("LastModifiedTime"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: ClientRuntime.Key("PriceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: ClientRuntime.Key("S3Origin"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: ClientRuntime.Key("TrustedSigners"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:ClientRuntime.Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension CloudFrontClientTypes.StreamingDistributionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingDistributionSummary(aRN: \(Swift.String(describing: aRN)), aliases: \(Swift.String(describing: aliases)), comment: \(Swift.String(describing: comment)), domainName: \(Swift.String(describing: domainName)), enabled: \(Swift.String(describing: enabled)), id: \(Swift.String(describing: id)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), priceClass: \(Swift.String(describing: priceClass)), s3Origin: \(Swift.String(describing: s3Origin)), status: \(Swift.String(describing: status)), trustedSigners: \(Swift.String(describing: trustedSigners)))"}
}

extension CloudFrontClientTypes.StreamingDistributionSummary: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p> A summary of the information for a CloudFront streaming distribution.</p>
    public struct StreamingDistributionSummary: Swift.Equatable {
        /// <p> The ARN (Amazon Resource Name) for the streaming distribution. For example:
        /// 				<code>arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5</code>, where
        /// 				<code>123456789012</code> is your AWS account ID.</p>
        public let aRN: Swift.String?
        /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
        /// 			for this streaming distribution.</p>
        public let aliases: CloudFrontClientTypes.Aliases?
        /// <p>The comment originally specified when this distribution was created.</p>
        public let comment: Swift.String?
        /// <p>The domain name corresponding to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>.</p>
        public let domainName: Swift.String?
        /// <p>Whether the distribution is enabled to accept end user requests for content.</p>
        public let enabled: Swift.Bool?
        /// <p>The identifier for the distribution, for example, <code>EDFDVBD632BHDS5</code>.</p>
        public let id: Swift.String?
        /// <p>The date and time the distribution was last modified.</p>
        public let lastModifiedTime: ClientRuntime.Date?
        /// <p>A complex type that contains information about price class for this streaming
        /// 			distribution. </p>
        public let priceClass: CloudFrontClientTypes.PriceClass?
        /// <p>A complex type that contains information about the Amazon S3 bucket from which you want
        /// 			CloudFront to get your media files for distribution.</p>
        public let s3Origin: CloudFrontClientTypes.S3Origin?
        /// <p> Indicates the current status of the distribution. When the status is
        /// 			<code>Deployed</code>, the distribution's information is fully propagated throughout the
        /// 			Amazon CloudFront system.</p>
        public let status: Swift.String?
        /// <p>A complex type that specifies the AWS accounts, if any, that you want to allow to
        /// 			create signed URLs for private content. If you want to require signed URLs in requests for
        /// 			objects in the target origin that match the <code>PathPattern</code> for this cache behavior,
        /// 			specify <code>true</code> for <code>Enabled</code>, and specify the applicable values for
        /// 				<code>Quantity</code> and <code>Items</code>.If you don't want to require signed URLs in
        /// 			requests for objects that match <code>PathPattern</code>, specify <code>false</code> for
        /// 				<code>Enabled</code> and <code>0</code> for <code>Quantity</code>. Omit <code>Items</code>.
        /// 			To add, change, or remove one or more trusted signers, change <code>Enabled</code> to
        /// 				<code>true</code> (if it's currently <code>false</code>), change <code>Quantity</code> as
        /// 			applicable, and specify all of the trusted signers that you want to include in the updated
        /// 			distribution.</p>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private
        /// 			Content through CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
        public let trustedSigners: CloudFrontClientTypes.TrustedSigners?

        public init (
            aRN: Swift.String? = nil,
            aliases: CloudFrontClientTypes.Aliases? = nil,
            comment: Swift.String? = nil,
            domainName: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            priceClass: CloudFrontClientTypes.PriceClass? = nil,
            s3Origin: CloudFrontClientTypes.S3Origin? = nil,
            status: Swift.String? = nil,
            trustedSigners: CloudFrontClientTypes.TrustedSigners? = nil
        )
        {
            self.aRN = aRN
            self.aliases = aliases
            self.comment = comment
            self.domainName = domainName
            self.enabled = enabled
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.priceClass = priceClass
            self.s3Origin = s3Origin
            self.status = status
            self.trustedSigners = trustedSigners
        }
    }

}

extension CloudFrontClientTypes.StreamingLoggingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: ClientRuntime.Key("Bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: ClientRuntime.Key("Prefix"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension CloudFrontClientTypes.StreamingLoggingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingLoggingConfig(bucket: \(Swift.String(describing: bucket)), enabled: \(Swift.String(describing: enabled)), prefix: \(Swift.String(describing: prefix)))"}
}

extension CloudFrontClientTypes.StreamingLoggingConfig: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that controls whether access logs are written for this streaming distribution.</p>
    public struct StreamingLoggingConfig: Swift.Equatable {
        /// <p>The Amazon S3 bucket to store the access logs in, for example, <code>myawslogbucket.s3.amazonaws.com</code>.</p>
        public let bucket: Swift.String?
        /// <p>Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't
        /// 			want to enable logging when you create a streaming distribution or if you want to disable
        /// 			logging for an existing streaming distribution, specify <code>false</code> for
        /// 				<code>Enabled</code>, and specify <code>empty Bucket</code> and <code>Prefix</code>
        /// 			elements. If you specify <code>false</code> for <code>Enabled</code> but you specify values
        /// 			for <code>Bucket</code> and <code>Prefix</code>, the values are automatically deleted.
        /// 		</p>
        public let enabled: Swift.Bool?
        /// <p>An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example,
        /// 			<code>myprefix/</code>. If you want to enable logging, but you don't want to specify a prefix, you still must include
        /// 			an empty <code>Prefix</code> element in the <code>Logging</code> element.</p>
        public let prefix: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            prefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.prefix = prefix
        }
    }

}

extension CloudFrontClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudFrontClientTypes.Tag: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p> A complex type that contains <code>Tag</code> key and <code>Tag</code> value.</p>
    public struct Tag: Swift.Equatable {
        /// <p> A string that contains <code>Tag</code> key.</p>
        /// 		       <p>The string length should be between 1 and 128 characters. Valid characters include
        /// 				<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, space, and the special characters
        /// 				<code>_ - . : / = + @</code>.</p>
        public let key: Swift.String?
        /// <p> A string that contains an optional <code>Tag</code> value.</p>
        /// 		       <p>The string length should be between 0 and 256 characters. Valid characters include
        /// 				<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, space, and the special characters
        /// 				<code>_ - . : / = + @</code>.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudFrontClientTypes.TagKeys: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tagkey0 in items {
                try itemsContainer.encode(tagkey0, forKey: ClientRuntime.Key("Key"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Key{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Key>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TagKeys: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagKeys(items: \(Swift.String(describing: items)))"}
}

extension CloudFrontClientTypes.TagKeys: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
    public struct TagKeys: Swift.Equatable {
        /// <p> A complex type that contains <code>Tag</code> key elements.</p>
        public let items: [Swift.String]?

        public init (
            items: [Swift.String]? = nil
        )
        {
            self.items = items
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tags = input.operationInput.tags {
            do {
                let encoder = context.getEncoder()
                let tagsdata = try encoder.encode(tags)
                let tagsbody = ClientRuntime.HttpBody.data(tagsdata)
                input.builder.withBody(tagsbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resource: \(Swift.String(describing: resource)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: ClientRuntime.Key("Tags"))
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "Operation", value: "Tag"))
        if let resource = input.operationInput.resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// <p> The request to add tags to a CloudFront resource.</p>
public struct TagResourceInput: Swift.Equatable {
    /// <p> An ARN of a CloudFront resource.</p>
    public let resource: Swift.String?
    /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
    public let tags: CloudFrontClientTypes.Tags?

    public init (
        resource: Swift.String? = nil,
        tags: CloudFrontClientTypes.Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: CloudFrontClientTypes.Tags?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CloudFrontClientTypes.Tags: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for tag0 in items {
                try itemsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Tag{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.Tag].self, forKey: .member)
                var itemsBuffer:[CloudFrontClientTypes.Tag]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontClientTypes.Tag]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.Tags: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tags(items: \(Swift.String(describing: items)))"}
}

extension CloudFrontClientTypes.Tags: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
    public struct Tags: Swift.Equatable {
        /// <p> A complex type that contains <code>Tag</code> elements.</p>
        public let items: [CloudFrontClientTypes.Tag]?

        public init (
            items: [CloudFrontClientTypes.Tag]? = nil
        )
        {
            self.items = items
        }
    }

}

extension TestFunctionFailed: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionFailed(message: \(Swift.String(describing: message)))"}
}

extension TestFunctionFailed: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TestFunctionFailedBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CloudFront function failed.</p>
public struct TestFunctionFailed: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TestFunctionFailedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TestFunctionFailedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TestFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

extension TestFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionInput(eventObject: \(Swift.String(describing: eventObject)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)), stage: \(Swift.String(describing: stage)))"}
}

extension TestFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TestFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let eventObject = eventObject {
            try container.encode(eventObject, forKey: ClientRuntime.Key("EventObject"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: ClientRuntime.Key("Stage"))
        }
    }
}

public struct TestFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

public struct TestFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestFunctionOutputError>
}

public struct TestFunctionInput: Swift.Equatable {
    /// <p>The event object to test the function with. For more information about the structure of the
    /// 			event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let eventObject: ClientRuntime.Data?
    /// <p>The current version (<code>ETag</code> value) of the function that you are testing, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>The name of the function that you are testing.</p>
    public let name: Swift.String?
    /// <p>The stage of the function that you are testing, either <code>DEVELOPMENT</code> or
    /// 			<code>LIVE</code>.</p>
    public let stage: CloudFrontClientTypes.FunctionStage?

    public init (
        eventObject: ClientRuntime.Data? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil,
        stage: CloudFrontClientTypes.FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

struct TestFunctionInputBody: Swift.Equatable {
    public let stage: CloudFrontClientTypes.FunctionStage?
    public let eventObject: ClientRuntime.Data?
}

extension TestFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        if containerValues.contains(.eventObject) {
            do {
                let eventObjectDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .eventObject)
                eventObject = eventObjectDecoded
            } catch {
                eventObject = "".data(using: .utf8)
            }
        } else {
            eventObject = nil
        }
    }
}

extension TestFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TestFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TestFunctionFailed" : self = .testFunctionFailed(try TestFunctionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestFunctionOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case testFunctionFailed(TestFunctionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestFunctionOutputResponse(testResult: \(Swift.String(describing: testResult)))"}
}

extension TestFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.TestResult = try responseDecoder.decode(responseBody: data)
                self.testResult = output
            } else {
                self.testResult = nil
            }
        } else {
            self.testResult = nil
        }
    }
}

public struct TestFunctionOutputResponse: Swift.Equatable {
    /// <p>An object that represents the result of running the function with the provided event
    /// 			object.</p>
    public let testResult: CloudFrontClientTypes.TestResult?

    public init (
        testResult: CloudFrontClientTypes.TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

struct TestFunctionOutputResponseBody: Swift.Equatable {
    public let testResult: CloudFrontClientTypes.TestResult?
}

extension TestFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case testResult = "TestResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testResultDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
    }
}

extension CloudFrontClientTypes.TestResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeUtilization = "ComputeUtilization"
        case functionErrorMessage = "FunctionErrorMessage"
        case functionExecutionLogs = "FunctionExecutionLogs"
        case functionOutput = "FunctionOutput"
        case functionSummary = "FunctionSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let computeUtilization = computeUtilization {
            try container.encode(computeUtilization, forKey: ClientRuntime.Key("ComputeUtilization"))
        }
        if let functionErrorMessage = functionErrorMessage {
            try container.encode(functionErrorMessage, forKey: ClientRuntime.Key("FunctionErrorMessage"))
        }
        if let functionExecutionLogs = functionExecutionLogs {
            var functionExecutionLogsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FunctionExecutionLogs"))
            for string0 in functionExecutionLogs {
                try functionExecutionLogsContainer.encode(string0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let functionOutput = functionOutput {
            try container.encode(functionOutput, forKey: ClientRuntime.Key("FunctionOutput"))
        }
        if let functionSummary = functionSummary {
            try container.encode(functionSummary, forKey: ClientRuntime.Key("FunctionSummary"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
        let computeUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .computeUtilization)
        computeUtilization = computeUtilizationDecoded
        if containerValues.contains(.functionExecutionLogs) {
            struct KeyVal0{struct member{}}
            let functionExecutionLogsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .functionExecutionLogs)
            if let functionExecutionLogsWrappedContainer = functionExecutionLogsWrappedContainer {
                let functionExecutionLogsContainer = try functionExecutionLogsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var functionExecutionLogsBuffer:[Swift.String]? = nil
                if let functionExecutionLogsContainer = functionExecutionLogsContainer {
                    functionExecutionLogsBuffer = [Swift.String]()
                    for stringContainer0 in functionExecutionLogsContainer {
                        functionExecutionLogsBuffer?.append(stringContainer0)
                    }
                }
                functionExecutionLogs = functionExecutionLogsBuffer
            } else {
                functionExecutionLogs = []
            }
        } else {
            functionExecutionLogs = nil
        }
        let functionErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionErrorMessage)
        functionErrorMessage = functionErrorMessageDecoded
        let functionOutputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionOutput)
        functionOutput = functionOutputDecoded
    }
}

extension CloudFrontClientTypes.TestResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestResult(computeUtilization: \(Swift.String(describing: computeUtilization)), functionErrorMessage: \(Swift.String(describing: functionErrorMessage)), functionExecutionLogs: \(Swift.String(describing: functionExecutionLogs)), functionOutput: \(Swift.String(describing: functionOutput)), functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension CloudFrontClientTypes.TestResult: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>Contains the result of testing a CloudFront function with <code>TestFunction</code>.</p>
    public struct TestResult: Swift.Equatable {
        /// <p>The amount of time that the function took to run as a percentage of the maximum
        /// 			allowed time. For example, a compute utilization of 35 means that the function completed
        /// 			in 35% of the maximum allowed time.</p>
        public let computeUtilization: Swift.String?
        /// <p>If the result of testing the function was an error, this field contains the error
        /// 			message.</p>
        public let functionErrorMessage: Swift.String?
        /// <p>Contains the log lines that the function wrote (if any) when running the test.</p>
        public let functionExecutionLogs: [Swift.String]?
        /// <p>The event object returned by the function. For more information about the structure of the
        /// 			event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html">Event object
        /// 			structure</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        public let functionOutput: Swift.String?
        /// <p>Contains configuration information and metadata about the CloudFront function that was
        /// 			tested.</p>
        public let functionSummary: CloudFrontClientTypes.FunctionSummary?

        public init (
            computeUtilization: Swift.String? = nil,
            functionErrorMessage: Swift.String? = nil,
            functionExecutionLogs: [Swift.String]? = nil,
            functionOutput: Swift.String? = nil,
            functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
        )
        {
            self.computeUtilization = computeUtilization
            self.functionErrorMessage = functionErrorMessage
            self.functionExecutionLogs = functionExecutionLogs
            self.functionOutput = functionOutput
            self.functionSummary = functionSummary
        }
    }

}

extension TooManyCacheBehaviors: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCacheBehaviors(message: \(Swift.String(describing: message)))"}
}

extension TooManyCacheBehaviors: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCacheBehaviorsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create more cache behaviors for the distribution.</p>
public struct TooManyCacheBehaviors: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCacheBehaviorsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCacheBehaviorsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCachePolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCachePolicies(message: \(Swift.String(describing: message)))"}
}

extension TooManyCachePolicies: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCachePoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of cache policies for this AWS account. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyCachePolicies: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCachePoliciesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCachePoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCertificates(message: \(Swift.String(describing: message)))"}
}

extension TooManyCertificates: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCertificatesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create anymore custom SSL/TLS certificates.</p>
public struct TooManyCertificates: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCertificatesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCertificatesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCloudFrontOriginAccessIdentities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCloudFrontOriginAccessIdentities(message: \(Swift.String(describing: message)))"}
}

extension TooManyCloudFrontOriginAccessIdentities: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCloudFrontOriginAccessIdentitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
public struct TooManyCloudFrontOriginAccessIdentities: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCloudFrontOriginAccessIdentitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookieNamesInWhiteList: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCookieNamesInWhiteList(message: \(Swift.String(describing: message)))"}
}

extension TooManyCookieNamesInWhiteList: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCookieNamesInWhiteListBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
public struct TooManyCookieNamesInWhiteList: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookieNamesInWhiteListBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCookieNamesInWhiteListBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCookiesInCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyCookiesInCachePolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCookiesInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of cookies in the cache policy exceeds the maximum. For more information,
/// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyCookiesInCachePolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCookiesInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyCookiesInOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyCookiesInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyCookiesInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of cookies in the origin request policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyCookiesInOriginRequestPolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyCookiesInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionCNAMEs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionCNAMEs(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionCNAMEs: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
public struct TooManyDistributionCNAMEs: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionCNAMEsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributions(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributions: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
public struct TooManyDistributions: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyDistributionsAssociatedToCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToCachePolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified cache
/// 			policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsAssociatedToCachePolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToKeyGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToKeyGroup(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToKeyGroup: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of distributions that reference this key group is more than the maximum
/// 			allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsAssociatedToKeyGroup: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToKeyGroupBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsAssociatedToOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified origin
/// 			request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsAssociatedToOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyDistributionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsWithFunctionAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsWithFunctionAssociations: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsWithFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of distributions that are associated with a CloudFront
/// 			function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsWithFunctionAssociations: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithFunctionAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsWithFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithLambdaAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsWithLambdaAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsWithLambdaAssociations: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsWithLambdaAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause the maximum number of distributions with Lambda function associations per owner
/// 			to be exceeded.</p>
public struct TooManyDistributionsWithLambdaAssociations: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithLambdaAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsWithLambdaAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithSingleFunctionARN: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyDistributionsWithSingleFunctionARN(message: \(Swift.String(describing: message)))"}
}

extension TooManyDistributionsWithSingleFunctionARN: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyDistributionsWithSingleFunctionARNBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified Lambda
/// 			function.</p>
public struct TooManyDistributionsWithSingleFunctionARN: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithSingleFunctionARNBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyDistributionsWithSingleFunctionARNBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionConfigs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionConfigs(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionConfigs: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of configurations for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionConfigs: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionConfigsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionContentTypeProfiles(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionContentTypeProfiles: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionContentTypeProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionContentTypeProfiles: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionContentTypeProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionEncryptionEntities(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionEncryptionEntities: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionEncryptionEntitiesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionEncryptionEntities: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionEncryptionEntitiesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionFieldPatterns(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionFieldPatterns: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionFieldPatternsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of field patterns for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionFieldPatterns: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionFieldPatternsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionProfiles(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionProfiles: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of profiles for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionProfiles: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionProfilesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFieldLevelEncryptionQueryArgProfiles(message: \(Swift.String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionQueryArgProfiles: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionQueryArgProfilesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionQueryArgProfiles: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFieldLevelEncryptionQueryArgProfilesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFunctionAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyFunctionAssociations: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of CloudFront function associations for this
/// 			distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyFunctionAssociations: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyFunctions(message: \(Swift.String(describing: message)))"}
}

extension TooManyFunctions: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyFunctionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of CloudFront functions for this AWS account. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyFunctions: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyFunctionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyHeadersInCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyHeadersInCachePolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyHeadersInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of headers in the cache policy exceeds the maximum. For more information,
/// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyHeadersInCachePolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyHeadersInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInForwardedValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyHeadersInForwardedValues(message: \(Swift.String(describing: message)))"}
}

extension TooManyHeadersInForwardedValues: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyHeadersInForwardedValuesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains too many headers in forwarded values.</p>
public struct TooManyHeadersInForwardedValues: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInForwardedValuesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyHeadersInForwardedValuesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyHeadersInOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyHeadersInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyHeadersInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of headers in the origin request policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyHeadersInOriginRequestPolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyHeadersInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyInvalidationsInProgress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyInvalidationsInProgress(message: \(Swift.String(describing: message)))"}
}

extension TooManyInvalidationsInProgress: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyInvalidationsInProgressBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
public struct TooManyInvalidationsInProgress: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyInvalidationsInProgressBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyInvalidationsInProgressBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyKeyGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyKeyGroups(message: \(Swift.String(describing: message)))"}
}

extension TooManyKeyGroups: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyKeyGroupsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of key groups for this AWS account. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyKeyGroups: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyKeyGroupsAssociatedToDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyKeyGroupsAssociatedToDistribution(message: \(Swift.String(describing: message)))"}
}

extension TooManyKeyGroupsAssociatedToDistribution: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyKeyGroupsAssociatedToDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of key groups referenced by this distribution is more than the maximum
/// 			allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyKeyGroupsAssociatedToDistribution: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyKeyGroupsAssociatedToDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyKeyGroupsAssociatedToDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyKeyGroupsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyKeyGroupsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLambdaFunctionAssociations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyLambdaFunctionAssociations(message: \(Swift.String(describing: message)))"}
}

extension TooManyLambdaFunctionAssociations: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyLambdaFunctionAssociationsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more Lambda function associations than are allowed per distribution.</p>
public struct TooManyLambdaFunctionAssociations: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLambdaFunctionAssociationsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyLambdaFunctionAssociationsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginCustomHeaders: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOriginCustomHeaders(message: \(Swift.String(describing: message)))"}
}

extension TooManyOriginCustomHeaders: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyOriginCustomHeadersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains too many origin custom headers.</p>
public struct TooManyOriginCustomHeaders: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginCustomHeadersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginCustomHeadersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginGroupsPerDistribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOriginGroupsPerDistribution(message: \(Swift.String(describing: message)))"}
}

extension TooManyOriginGroupsPerDistribution: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyOriginGroupsPerDistributionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
public struct TooManyOriginGroupsPerDistribution: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginGroupsPerDistributionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginGroupsPerDistributionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginRequestPolicies: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOriginRequestPolicies(message: \(Swift.String(describing: message)))"}
}

extension TooManyOriginRequestPolicies: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyOriginRequestPoliciesBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of origin request policies for this AWS account.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyOriginRequestPolicies: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginRequestPoliciesBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginRequestPoliciesBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOrigins: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyOrigins(message: \(Swift.String(describing: message)))"}
}

extension TooManyOrigins: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyOriginsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create more origins for the distribution.</p>
public struct TooManyOrigins: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyOriginsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeys: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyPublicKeys(message: \(Swift.String(describing: message)))"}
}

extension TooManyPublicKeys: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyPublicKeysBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
public struct TooManyPublicKeys: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyPublicKeysBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeysInKeyGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyPublicKeysInKeyGroup(message: \(Swift.String(describing: message)))"}
}

extension TooManyPublicKeysInKeyGroup: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyPublicKeysInKeyGroupBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of public keys in this key group is more than the maximum allowed. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyPublicKeysInKeyGroup: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysInKeyGroupBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyPublicKeysInKeyGroupBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyQueryStringParameters(message: \(Swift.String(describing: message)))"}
}

extension TooManyQueryStringParameters: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyQueryStringParametersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains too many query string parameters.</p>
public struct TooManyQueryStringParameters: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringParametersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyQueryStringParametersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInCachePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyQueryStringsInCachePolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyQueryStringsInCachePolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyQueryStringsInCachePolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of query strings in the cache policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyQueryStringsInCachePolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInCachePolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyQueryStringsInCachePolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInOriginRequestPolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyQueryStringsInOriginRequestPolicy(message: \(Swift.String(describing: message)))"}
}

extension TooManyQueryStringsInOriginRequestPolicy: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyQueryStringsInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of query strings in the origin request policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyQueryStringsInOriginRequestPolicy: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInOriginRequestPolicyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyQueryStringsInOriginRequestPolicyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRealtimeLogConfigs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRealtimeLogConfigs(message: \(Swift.String(describing: message)))"}
}

extension TooManyRealtimeLogConfigs: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyRealtimeLogConfigsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of real-time log configurations for this AWS account.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyRealtimeLogConfigs: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRealtimeLogConfigsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRealtimeLogConfigsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributionCNAMEs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyStreamingDistributionCNAMEs(message: \(Swift.String(describing: message)))"}
}

extension TooManyStreamingDistributionCNAMEs: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyStreamingDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
public struct TooManyStreamingDistributionCNAMEs: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionCNAMEsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyStreamingDistributionCNAMEsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyStreamingDistributions(message: \(Swift.String(describing: message)))"}
}

extension TooManyStreamingDistributions: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyStreamingDistributionsBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
public struct TooManyStreamingDistributions: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionsBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyStreamingDistributionsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTrustedSigners: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTrustedSigners(message: \(Swift.String(describing: message)))"}
}

extension TooManyTrustedSigners: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TooManyTrustedSignersBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more trusted signers than are allowed per distribution.</p>
public struct TooManyTrustedSigners: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTrustedSignersBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTrustedSignersBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedKeyGroupDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedKeyGroupDoesNotExist(message: \(Swift.String(describing: message)))"}
}

extension TrustedKeyGroupDoesNotExist: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TrustedKeyGroupDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified key group does not exist.</p>
public struct TrustedKeyGroupDoesNotExist: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedKeyGroupDoesNotExistBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TrustedKeyGroupDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedKeyGroups: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedKeyGroups(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.TrustedKeyGroups: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of key groups whose public keys CloudFront can use to verify the signatures of signed
    /// 			URLs and signed cookies.</p>
    public struct TrustedKeyGroups: Swift.Equatable {
        /// <p>This field is <code>true</code> if any of the key groups in the list have public keys that
        /// 			CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this
        /// 			field is <code>false</code>.</p>
        public let enabled: Swift.Bool?
        /// <p>A list of key groups identifiers.</p>
        public let items: [Swift.String]?
        /// <p>The number of key groups in the list.</p>
        public let quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension TrustedSignerDoesNotExist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedSignerDoesNotExist(message: \(Swift.String(describing: message)))"}
}

extension TrustedSignerDoesNotExist: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<TrustedSignerDoesNotExistBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of your trusted signers don't exist.</p>
public struct TrustedSignerDoesNotExist: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedSignerDoesNotExistBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TrustedSignerDoesNotExistBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontClientTypes.TrustedSigners: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: ClientRuntime.Key("Enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: ClientRuntime.Key("AwsAccountNumber"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: ClientRuntime.Key("Quantity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct AwsAccountNumber{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AwsAccountNumber>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var itemsBuffer:[Swift.String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Swift.String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontClientTypes.TrustedSigners: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedSigners(enabled: \(Swift.String(describing: enabled)), items: \(Swift.String(describing: items)), quantity: \(Swift.String(describing: quantity)))"}
}

extension CloudFrontClientTypes.TrustedSigners: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A list of AWS accounts whose public keys CloudFront can use to verify the signatures of signed
    /// 			URLs and signed cookies.</p>
    public struct TrustedSigners: Swift.Equatable {
        /// <p>This field is <code>true</code> if any of the AWS accounts have public keys that CloudFront can
        /// 			use to verify the signatures of signed URLs and signed cookies. If not, this field is
        /// 			<code>false</code>.</p>
        public let enabled: Swift.Bool?
        /// <p>A list of AWS account identifiers.</p>
        public let items: [Swift.String]?
        /// <p>The number of AWS accounts in the list.</p>
        public let quantity: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.items = items
            self.quantity = quantity
        }
    }

}

extension UnsupportedOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperation(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<UnsupportedOperationBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not supported in this region.</p>
public struct UnsupportedOperation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            do {
                let encoder = context.getEncoder()
                let tagKeysdata = try encoder.encode(tagKeys)
                let tagKeysbody = ClientRuntime.HttpBody.data(tagKeysdata)
                input.builder.withBody(tagKeysbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resource: \(Swift.String(describing: resource)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let tagKeys = tagKeys {
            try container.encode(tagKeys, forKey: ClientRuntime.Key("TagKeys"))
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(ClientRuntime.URLQueryItem(name: "Operation", value: "Untag"))
        if let resource = input.operationInput.resource {
            let resourceQueryItem = ClientRuntime.URLQueryItem(name: "Resource".urlPercentEncoding(), value: Swift.String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

/// <p> The request to remove tags from a CloudFront resource.</p>
public struct UntagResourceInput: Swift.Equatable {
    /// <p> An ARN of a CloudFront resource.</p>
    public let resource: Swift.String?
    /// <p> A complex type that contains zero or more <code>Tag</code> key elements.</p>
    public let tagKeys: CloudFrontClientTypes.TagKeys?

    public init (
        resource: Swift.String? = nil,
        tagKeys: CloudFrontClientTypes.TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let tagKeys: CloudFrontClientTypes.TagKeys?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.TagKeys.self, forKey: .tagKeys)
        tagKeys = tagKeysDecoded
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateCachePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
            do {
                let encoder = context.getEncoder()
                let cachePolicyConfigdata = try encoder.encode(cachePolicyConfig)
                let cachePolicyConfigbody = ClientRuntime.HttpBody.data(cachePolicyConfigdata)
                input.builder.withBody(cachePolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

extension UpdateCachePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCachePolicyInput(cachePolicyConfig: \(Swift.String(describing: cachePolicyConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateCachePolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCachePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: ClientRuntime.Key("CachePolicyConfig"))
        }
    }
}

public struct UpdateCachePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInput: Swift.Equatable {
    /// <p>A cache policy configuration.</p>
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
    /// <p>The unique identifier for the cache policy that you are updating. The identifier is returned
    /// 			in a cache behavior’s <code>CachePolicyId</code> field in the response to
    /// 			<code>GetDistributionConfig</code>.</p>
    public let id: Swift.String?
    /// <p>The version of the cache policy that you are updating. The version is returned in the cache
    /// 			policy’s <code>ETag</code> field in the response to
    /// 			<code>GetCachePolicyConfig</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCachePolicyInputBody: Swift.Equatable {
    public let cachePolicyConfig: CloudFrontClientTypes.CachePolicyConfig?
}

extension UpdateCachePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension UpdateCachePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCachePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCachePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCachePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCachePolicyOutputResponse(cachePolicy: \(Swift.String(describing: cachePolicy)), eTag: \(Swift.String(describing: eTag)))"}
}

extension UpdateCachePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CachePolicy = try responseDecoder.decode(responseBody: data)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct UpdateCachePolicyOutputResponse: Swift.Equatable {
    /// <p>A cache policy.</p>
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
    /// <p>The current version of the cache policy.</p>
    public let eTag: Swift.String?

    public init (
        cachePolicy: CloudFrontClientTypes.CachePolicy? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct UpdateCachePolicyOutputResponseBody: Swift.Equatable {
    public let cachePolicy: CloudFrontClientTypes.CachePolicy?
}

extension UpdateCachePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
            do {
                let encoder = context.getEncoder()
                let cloudFrontOriginAccessIdentityConfigdata = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let cloudFrontOriginAccessIdentityConfigbody = ClientRuntime.HttpBody.data(cloudFrontOriginAccessIdentityConfigdata)
                input.builder.withBody(cloudFrontOriginAccessIdentityConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

extension UpdateCloudFrontOriginAccessIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCloudFrontOriginAccessIdentityInput(cloudFrontOriginAccessIdentityConfig: \(Swift.String(describing: cloudFrontOriginAccessIdentityConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateCloudFrontOriginAccessIdentityInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: ClientRuntime.Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

public struct UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

/// <p>The request to update an origin access identity.</p>
public struct UpdateCloudFrontOriginAccessIdentityInput: Swift.Equatable {
    /// <p>The identity's configuration information.</p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
    /// <p>The identity's id.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			identity's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig?
}

extension UpdateCloudFrontOriginAccessIdentityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCloudFrontOriginAccessIdentityOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case missingBody(MissingBody)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(Swift.String(describing: cloudFrontOriginAccessIdentity)), eTag: \(Swift.String(describing: eTag)))"}
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: data)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct UpdateCloudFrontOriginAccessIdentityOutputResponse: Swift.Equatable {
    /// <p>The origin access identity's information.</p>
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontClientTypes.CloudFrontOriginAccessIdentity?
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct UpdateDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfig = input.operationInput.distributionConfig {
            do {
                let encoder = context.getEncoder()
                let distributionConfigdata = try encoder.encode(distributionConfig)
                let distributionConfigbody = ClientRuntime.HttpBody.data(distributionConfigdata)
                input.builder.withBody(distributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

extension UpdateDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDistributionInput(distributionConfig: \(Swift.String(describing: distributionConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: ClientRuntime.Key("DistributionConfig"))
        }
    }
}

public struct UpdateDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

public struct UpdateDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionOutputError>
}

/// <p>The request to update a distribution.</p>
public struct UpdateDistributionInput: Swift.Equatable {
    /// <p>The distribution's configuration information.</p>
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
    /// <p>The distribution's id.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        distributionConfig: CloudFrontClientTypes.DistributionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateDistributionInputBody: Swift.Equatable {
    public let distributionConfig: CloudFrontClientTypes.DistributionConfig?
}

extension UpdateDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension UpdateDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case preconditionFailed(PreconditionFailed)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDistributionOutputResponse(distribution: \(Swift.String(describing: distribution)), eTag: \(Swift.String(describing: eTag)))"}
}

extension UpdateDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.Distribution = try responseDecoder.decode(responseBody: data)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct UpdateDistributionOutputResponse: Swift.Equatable {
    /// <p>The distribution's information.</p>
    public let distribution: CloudFrontClientTypes.Distribution?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?

    public init (
        distribution: CloudFrontClientTypes.Distribution? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct UpdateDistributionOutputResponseBody: Swift.Equatable {
    public let distribution: CloudFrontClientTypes.Distribution?
}

extension UpdateDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct UpdateFieldLevelEncryptionConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionConfigdata = try encoder.encode(fieldLevelEncryptionConfig)
                let fieldLevelEncryptionConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionConfigdata)
                input.builder.withBody(fieldLevelEncryptionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

extension UpdateFieldLevelEncryptionConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionConfigInput(fieldLevelEncryptionConfig: \(Swift.String(describing: fieldLevelEncryptionConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateFieldLevelEncryptionConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionConfig"))
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInput: Swift.Equatable {
    /// <p>Request to update a field-level encryption configuration. </p>
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
    /// <p>The ID of the configuration you want to update.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the configuration identity to update.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionConfigInputBody: Swift.Equatable {
    public let fieldLevelEncryptionConfig: CloudFrontClientTypes.FieldLevelEncryptionConfig?
}

extension UpdateFieldLevelEncryptionConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionConfigOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryption: \(Swift.String(describing: fieldLevelEncryption)))"}
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryption = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigOutputResponse: Swift.Equatable {
    /// <p>The value of the <code>ETag</code> header that you received when updating the configuration.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>Return the results of updating the configuration.</p>
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct UpdateFieldLevelEncryptionConfigOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryption: CloudFrontClientTypes.FieldLevelEncryption?
}

extension UpdateFieldLevelEncryptionConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct UpdateFieldLevelEncryptionProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
            do {
                let encoder = context.getEncoder()
                let fieldLevelEncryptionProfileConfigdata = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let fieldLevelEncryptionProfileConfigbody = ClientRuntime.HttpBody.data(fieldLevelEncryptionProfileConfigdata)
                input.builder.withBody(fieldLevelEncryptionProfileConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

extension UpdateFieldLevelEncryptionProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionProfileInput(fieldLevelEncryptionProfileConfig: \(Swift.String(describing: fieldLevelEncryptionProfileConfig)), id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)))"}
}

extension UpdateFieldLevelEncryptionProfileInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: ClientRuntime.Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInput: Swift.Equatable {
    /// <p>Request to update a field-level encryption profile. </p>
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
    /// <p>The ID of the field-level encryption profile request. </p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the profile identity to update.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?

    public init (
        fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig? = nil,
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionProfileInputBody: Swift.Equatable {
    public let fieldLevelEncryptionProfileConfig: CloudFrontClientTypes.FieldLevelEncryptionProfileConfig?
}

extension UpdateFieldLevelEncryptionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFieldLevelEncryptionProfileOutputResponse(eTag: \(Swift.String(describing: eTag)), fieldLevelEncryptionProfile: \(Swift.String(describing: fieldLevelEncryptionProfile)))"}
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: data)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileOutputResponse: Swift.Equatable {
    /// <p>The result of the field-level encryption profile request. </p>
    public let eTag: Swift.String?
    /// <p>Return the results of updating the profile.</p>
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?

    public init (
        eTag: Swift.String? = nil,
        fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct UpdateFieldLevelEncryptionProfileOutputResponseBody: Swift.Equatable {
    public let fieldLevelEncryptionProfile: CloudFrontClientTypes.FieldLevelEncryptionProfile?
}

extension UpdateFieldLevelEncryptionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

public struct UpdateFunctionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

extension UpdateFunctionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionInput(functionCode: \(Swift.String(describing: functionCode)), functionConfig: \(Swift.String(describing: functionConfig)), ifMatch: \(Swift.String(describing: ifMatch)), name: \(Swift.String(describing: name)))"}
}

extension UpdateFunctionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFunctionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: ClientRuntime.Key("FunctionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: ClientRuntime.Key("FunctionConfig"))
        }
    }
}

public struct UpdateFunctionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInput: Swift.Equatable {
    /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
    /// 			code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let functionCode: ClientRuntime.Data?
    /// <p>Configuration information about the function.</p>
    public let functionConfig: CloudFrontClientTypes.FunctionConfig?
    /// <p>The current version (<code>ETag</code> value) of the function that you are updating, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>The name of the function that you are updating.</p>
    public let name: Swift.String?

    public init (
        functionCode: ClientRuntime.Data? = nil,
        functionConfig: CloudFrontClientTypes.FunctionConfig? = nil,
        ifMatch: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct UpdateFunctionInputBody: Swift.Equatable {
    public let functionConfig: CloudFrontClientTypes.FunctionConfig?
    public let functionCode: ClientRuntime.Data?
}

extension UpdateFunctionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension UpdateFunctionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Swift.Error, Swift.Equatable {
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFunctionOutputResponse(eTag: \(Swift.String(describing: eTag)), functionSummary: \(Swift.String(describing: functionSummary)))"}
}

extension UpdateFunctionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.FunctionSummary = try responseDecoder.decode(responseBody: data)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Swift.Equatable {
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: Swift.String?
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?

    public init (
        eTag: Swift.String? = nil,
        functionSummary: CloudFrontClientTypes.FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct UpdateFunctionOutputResponseBody: Swift.Equatable {
    public let functionSummary: CloudFrontClientTypes.FunctionSummary?
}

extension UpdateFunctionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct UpdateKeyGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyGroupConfig = input.operationInput.keyGroupConfig {
            do {
                let encoder = context.getEncoder()
                let keyGroupConfigdata = try encoder.encode(keyGroupConfig)
                let keyGroupConfigbody = ClientRuntime.HttpBody.data(keyGroupConfigdata)
                input.builder.withBody(keyGroupConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

extension UpdateKeyGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateKeyGroupInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), keyGroupConfig: \(Swift.String(describing: keyGroupConfig)))"}
}

extension UpdateKeyGroupInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateKeyGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: ClientRuntime.Key("KeyGroupConfig"))
        }
    }
}

public struct UpdateKeyGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInput: Swift.Equatable {
    /// <p>The identifier of the key group that you are updating.</p>
    public let id: Swift.String?
    /// <p>The version of the key group that you are updating. The version is the key group’s
    /// 			<code>ETag</code> value.</p>
    public let ifMatch: Swift.String?
    /// <p>The key group configuration.</p>
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

struct UpdateKeyGroupInputBody: Swift.Equatable {
    public let keyGroupConfig: CloudFrontClientTypes.KeyGroupConfig?
}

extension UpdateKeyGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension UpdateKeyGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateKeyGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateKeyGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKeyGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateKeyGroupOutputResponse(eTag: \(Swift.String(describing: eTag)), keyGroup: \(Swift.String(describing: keyGroup)))"}
}

extension UpdateKeyGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.KeyGroup = try responseDecoder.decode(responseBody: data)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct UpdateKeyGroupOutputResponse: Swift.Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: Swift.String?
    /// <p>The key group that was just updated.</p>
    public let keyGroup: CloudFrontClientTypes.KeyGroup?

    public init (
        eTag: Swift.String? = nil,
        keyGroup: CloudFrontClientTypes.KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct UpdateKeyGroupOutputResponseBody: Swift.Equatable {
    public let keyGroup: CloudFrontClientTypes.KeyGroup?
}

extension UpdateKeyGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct UpdateOriginRequestPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
            do {
                let encoder = context.getEncoder()
                let originRequestPolicyConfigdata = try encoder.encode(originRequestPolicyConfig)
                let originRequestPolicyConfigbody = ClientRuntime.HttpBody.data(originRequestPolicyConfigdata)
                input.builder.withBody(originRequestPolicyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

extension UpdateOriginRequestPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOriginRequestPolicyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), originRequestPolicyConfig: \(Swift.String(describing: originRequestPolicyConfig)))"}
}

extension UpdateOriginRequestPolicyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateOriginRequestPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: ClientRuntime.Key("OriginRequestPolicyConfig"))
        }
    }
}

public struct UpdateOriginRequestPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInput: Swift.Equatable {
    /// <p>The unique identifier for the origin request policy that you are updating. The identifier is
    /// 			returned in a cache behavior’s <code>OriginRequestPolicyId</code> field in the response
    /// 			to <code>GetDistributionConfig</code>.</p>
    public let id: Swift.String?
    /// <p>The version of the origin request policy that you are updating. The version is returned in
    /// 			the origin request policy’s <code>ETag</code> field in the response to
    /// 			<code>GetOriginRequestPolicyConfig</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>An origin request policy configuration.</p>
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct UpdateOriginRequestPolicyInputBody: Swift.Equatable {
    public let originRequestPolicyConfig: CloudFrontClientTypes.OriginRequestPolicyConfig?
}

extension UpdateOriginRequestPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension UpdateOriginRequestPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateOriginRequestPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOriginRequestPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginRequestPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOriginRequestPolicyOutputResponse(eTag: \(Swift.String(describing: eTag)), originRequestPolicy: \(Swift.String(describing: originRequestPolicy)))"}
}

extension UpdateOriginRequestPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.OriginRequestPolicy = try responseDecoder.decode(responseBody: data)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct UpdateOriginRequestPolicyOutputResponse: Swift.Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: Swift.String?
    /// <p>An origin request policy.</p>
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?

    public init (
        eTag: Swift.String? = nil,
        originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct UpdateOriginRequestPolicyOutputResponseBody: Swift.Equatable {
    public let originRequestPolicy: CloudFrontClientTypes.OriginRequestPolicy?
}

extension UpdateOriginRequestPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct UpdatePublicKeyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicKeyConfig = input.operationInput.publicKeyConfig {
            do {
                let encoder = context.getEncoder()
                let publicKeyConfigdata = try encoder.encode(publicKeyConfig)
                let publicKeyConfigbody = ClientRuntime.HttpBody.data(publicKeyConfigdata)
                input.builder.withBody(publicKeyConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

extension UpdatePublicKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePublicKeyInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), publicKeyConfig: \(Swift.String(describing: publicKeyConfig)))"}
}

extension UpdatePublicKeyInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdatePublicKeyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: ClientRuntime.Key("PublicKeyConfig"))
        }
    }
}

public struct UpdatePublicKeyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInput: Swift.Equatable {
    /// <p>The identifier of the public key that you are updating.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the public key to update.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>A public key configuration.</p>
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

struct UpdatePublicKeyInputBody: Swift.Equatable {
    public let publicKeyConfig: CloudFrontClientTypes.PublicKeyConfig?
}

extension UpdatePublicKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension UpdatePublicKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdatePublicKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotChangeImmutablePublicKeyFields" : self = .cannotChangeImmutablePublicKeyFields(try CannotChangeImmutablePublicKeyFields(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublicKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cannotChangeImmutablePublicKeyFields(CannotChangeImmutablePublicKeyFields)
    case illegalUpdate(IllegalUpdate)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicKeyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePublicKeyOutputResponse(eTag: \(Swift.String(describing: eTag)), publicKey: \(Swift.String(describing: publicKey)))"}
}

extension UpdatePublicKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.PublicKey = try responseDecoder.decode(responseBody: data)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct UpdatePublicKeyOutputResponse: Swift.Equatable {
    /// <p>The identifier of the current version of the public key.</p>
    public let eTag: Swift.String?
    /// <p>The public key.</p>
    public let publicKey: CloudFrontClientTypes.PublicKey?

    public init (
        eTag: Swift.String? = nil,
        publicKey: CloudFrontClientTypes.PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct UpdatePublicKeyOutputResponseBody: Swift.Equatable {
    public let publicKey: CloudFrontClientTypes.PublicKey?
}

extension UpdatePublicKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct UpdateRealtimeLogConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

extension UpdateRealtimeLogConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRealtimeLogConfigInput(aRN: \(Swift.String(describing: aRN)), endPoints: \(Swift.String(describing: endPoints)), fields: \(Swift.String(describing: fields)), name: \(Swift.String(describing: name)), samplingRate: \(Swift.String(describing: samplingRate)))"}
}

extension UpdateRealtimeLogConfigInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateRealtimeLogConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EndPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: ClientRuntime.Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: ClientRuntime.Key("SamplingRate"))
        }
    }
}

public struct UpdateRealtimeLogConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) for this real-time log configuration.</p>
    public let aRN: Swift.String?
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
    /// 			log data.</p>
    public let endPoints: [CloudFrontClientTypes.EndPoint]?
    /// <p>A list of fields to include in each real-time log record.</p>
    /// 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let fields: [Swift.String]?
    /// <p>The name for this real-time log configuration.</p>
    public let name: Swift.String?
    /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
    /// 			percentage of viewer requests that are represented in the real-time log data. You must
    /// 			provide an integer between 1 and 100, inclusive.</p>
    public let samplingRate: Swift.Int?

    public init (
        aRN: Swift.String? = nil,
        endPoints: [CloudFrontClientTypes.EndPoint]? = nil,
        fields: [Swift.String]? = nil,
        name: Swift.String? = nil,
        samplingRate: Swift.Int? = nil
    )
    {
        self.aRN = aRN
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct UpdateRealtimeLogConfigInputBody: Swift.Equatable {
    public let endPoints: [CloudFrontClientTypes.EndPoint]?
    public let fields: [Swift.String]?
    public let name: Swift.String?
    public let aRN: Swift.String?
    public let samplingRate: Swift.Int?
}

extension UpdateRealtimeLogConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([CloudFrontClientTypes.EndPoint].self, forKey: .member)
                var endPointsBuffer:[CloudFrontClientTypes.EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [CloudFrontClientTypes.EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var fieldsBuffer:[Swift.String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [Swift.String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension UpdateRealtimeLogConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRealtimeLogConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRealtimeLogConfigOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRealtimeLogConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRealtimeLogConfigOutputResponse(realtimeLogConfig: \(Swift.String(describing: realtimeLogConfig)))"}
}

extension UpdateRealtimeLogConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct UpdateRealtimeLogConfigOutputResponse: Swift.Equatable {
    /// <p>A real-time log configuration.</p>
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?

    public init (
        realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct UpdateRealtimeLogConfigOutputResponseBody: Swift.Equatable {
    public let realtimeLogConfig: CloudFrontClientTypes.RealtimeLogConfig?
}

extension UpdateRealtimeLogConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct UpdateStreamingDistributionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
            do {
                let encoder = context.getEncoder()
                let streamingDistributionConfigdata = try encoder.encode(streamingDistributionConfig)
                let streamingDistributionConfigbody = ClientRuntime.HttpBody.data(streamingDistributionConfigdata)
                input.builder.withBody(streamingDistributionConfigbody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

extension UpdateStreamingDistributionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingDistributionInput(id: \(Swift.String(describing: id)), ifMatch: \(Swift.String(describing: ifMatch)), streamingDistributionConfig: \(Swift.String(describing: streamingDistributionConfig)))"}
}

extension UpdateStreamingDistributionInput: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateStreamingDistributionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: ClientRuntime.Key("StreamingDistributionConfig"))
        }
    }
}

public struct UpdateStreamingDistributionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: Swift.String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

public struct UpdateStreamingDistributionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingDistributionOutputError>
}

/// <p>The request to update a streaming distribution.</p>
public struct UpdateStreamingDistributionInput: Swift.Equatable {
    /// <p>The streaming distribution's id.</p>
    public let id: Swift.String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			streaming distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: Swift.String?
    /// <p>The streaming distribution's configuration information.</p>
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?

    public init (
        id: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct UpdateStreamingDistributionInputBody: Swift.Equatable {
    public let streamingDistributionConfig: CloudFrontClientTypes.StreamingDistributionConfig?
}

extension UpdateStreamingDistributionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension UpdateStreamingDistributionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStreamingDistributionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingDistributionOutputError: Swift.Error, Swift.Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingDistributionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingDistributionOutputResponse(eTag: \(Swift.String(describing: eTag)), streamingDistribution: \(Swift.String(describing: streamingDistribution)))"}
}

extension UpdateStreamingDistributionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CloudFrontClientTypes.StreamingDistribution = try responseDecoder.decode(responseBody: data)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct UpdateStreamingDistributionOutputResponse: Swift.Equatable {
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: Swift.String?
    /// <p>The streaming distribution's information.</p>
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?

    public init (
        eTag: Swift.String? = nil,
        streamingDistribution: CloudFrontClientTypes.StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct UpdateStreamingDistributionOutputResponseBody: Swift.Equatable {
    public let streamingDistribution: CloudFrontClientTypes.StreamingDistribution?
}

extension UpdateStreamingDistributionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aCMCertificateArn = "ACMCertificateArn"
        case certificate = "Certificate"
        case certificateSource = "CertificateSource"
        case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
        case iAMCertificateId = "IAMCertificateId"
        case minimumProtocolVersion = "MinimumProtocolVersion"
        case sSLSupportMethod = "SSLSupportMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let aCMCertificateArn = aCMCertificateArn {
            try container.encode(aCMCertificateArn, forKey: ClientRuntime.Key("ACMCertificateArn"))
        }
        if let certificate = certificate {
            try container.encode(certificate, forKey: ClientRuntime.Key("Certificate"))
        }
        if let certificateSource = certificateSource {
            try container.encode(certificateSource, forKey: ClientRuntime.Key("CertificateSource"))
        }
        if let cloudFrontDefaultCertificate = cloudFrontDefaultCertificate {
            try container.encode(cloudFrontDefaultCertificate, forKey: ClientRuntime.Key("CloudFrontDefaultCertificate"))
        }
        if let iAMCertificateId = iAMCertificateId {
            try container.encode(iAMCertificateId, forKey: ClientRuntime.Key("IAMCertificateId"))
        }
        if let minimumProtocolVersion = minimumProtocolVersion {
            try container.encode(minimumProtocolVersion, forKey: ClientRuntime.Key("MinimumProtocolVersion"))
        }
        if let sSLSupportMethod = sSLSupportMethod {
            try container.encode(sSLSupportMethod, forKey: ClientRuntime.Key("SSLSupportMethod"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDefaultCertificateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudFrontDefaultCertificate)
        cloudFrontDefaultCertificate = cloudFrontDefaultCertificateDecoded
        let iAMCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iAMCertificateId)
        iAMCertificateId = iAMCertificateIdDecoded
        let aCMCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aCMCertificateArn)
        aCMCertificateArn = aCMCertificateArnDecoded
        let sSLSupportMethodDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.SSLSupportMethod.self, forKey: .sSLSupportMethod)
        sSLSupportMethod = sSLSupportMethodDecoded
        let minimumProtocolVersionDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.MinimumProtocolVersion.self, forKey: .minimumProtocolVersion)
        minimumProtocolVersion = minimumProtocolVersionDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateSourceDecoded = try containerValues.decodeIfPresent(CloudFrontClientTypes.CertificateSource.self, forKey: .certificateSource)
        certificateSource = certificateSourceDecoded
    }
}

extension CloudFrontClientTypes.ViewerCertificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewerCertificate(aCMCertificateArn: \(Swift.String(describing: aCMCertificateArn)), certificate: \(Swift.String(describing: certificate)), certificateSource: \(Swift.String(describing: certificateSource)), cloudFrontDefaultCertificate: \(Swift.String(describing: cloudFrontDefaultCertificate)), iAMCertificateId: \(Swift.String(describing: iAMCertificateId)), minimumProtocolVersion: \(Swift.String(describing: minimumProtocolVersion)), sSLSupportMethod: \(Swift.String(describing: sSLSupportMethod)))"}
}

extension CloudFrontClientTypes.ViewerCertificate: ClientRuntime.DynamicNodeEncoding {
    public static func nodeEncoding(for key: Swift.CodingKey) -> ClientRuntime.NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? ClientRuntime.Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CloudFrontClientTypes {
    /// <p>A complex type that determines the distribution’s SSL/TLS configuration for communicating
    /// 			with viewers.</p>
    /// 		       <p>If the distribution doesn’t use <code>Aliases</code> (also known as alternate domain
    /// 			names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as
    /// 			<code>d111111abcdef8.cloudfront.net</code>—set <code>CloudFrontDefaultCertificate</code>
    /// 			to <code>true</code> and leave all other fields empty.</p>
    /// 		       <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), use
    /// 			the fields in this type to specify the following settings:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Which viewers the distribution accepts HTTPS connections from: only viewers that support
    /// 					<a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server name
    /// 					indication (SNI)</a> (recommended), or all viewers including those that
    /// 					don’t support SNI.</p>
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>To accept HTTPS connections from only viewers that support SNI, set
    /// 							<code>SSLSupportMethod</code> to <code>sni-only</code>. This is
    /// 							recommended. Most browsers and clients support
    ///                             SNI.
    ///
    ///                   </p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>To accept HTTPS connections from all viewers, including those that don’t support SNI,
    /// 							set <code>SSLSupportMethod</code> to <code>vip</code>. This is not
    /// 							recommended, and results in additional monthly charges from
    /// 							CloudFront.
    ///                   </p>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The minimum SSL/TLS protocol version that the distribution can use to
    /// 					communicate with viewers. To specify a minimum version, choose a value for
    /// 					<code>MinimumProtocolVersion</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy">Security Policy</a> in the
    /// 					<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The location of the SSL/TLS certificate, <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html">AWS
    /// 					Certificate Manager (ACM)</a> (recommended) or <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html">AWS Identity and Access Management (AWS IAM)</a>. You specify the location
    /// 					by setting a value in one of the following fields (not both):</p>
    /// 				           <ul>
    ///                   <li>
    /// 						               <p>
    ///                         <code>ACMCertificateArn</code>
    ///
    ///                      </p>
    /// 					             </li>
    ///                   <li>
    /// 						               <p>
    ///                         <code>IAMCertificateId</code>
    ///
    ///                      </p>
    /// 					             </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>All distributions support HTTPS connections from viewers. To require viewers to use
    /// 			HTTPS only, or to redirect them from HTTP to HTTPS, use
    /// 			<code>ViewerProtocolPolicy</code> in the <code>CacheBehavior</code> or
    /// 			<code>DefaultCacheBehavior</code>. To specify how CloudFront should use SSL/TLS to
    /// 			communicate with your custom origin, use <code>CustomOriginConfig</code>.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html">Using
    /// 			HTTPS with CloudFront</a> and <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html">
    /// 			Using Alternate Domain Names and HTTPS</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public struct ViewerCertificate: Swift.Equatable {
        /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs) and
        /// 			the SSL/TLS certificate is stored in <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html">AWS Certificate Manager (ACM)</a>, provide the Amazon Resource
        /// 			Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US
        /// 			East (N. Virginia) Region (<code>us-east-1</code>).</p>
        /// 		       <p>If you specify an ACM certificate ARN, you must also specify values for
        /// 			<code>MinimumProtocolVersion</code> and <code>SSLSupportMethod</code>.
        ///       </p>
        public let aCMCertificateArn: Swift.String?
        /// <p>This field is deprecated. Use one of the following fields instead:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>ACMCertificateArn</code>
        ///
        ///                </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>IAMCertificateId</code>
        ///
        ///                </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>CloudFrontDefaultCertificate</code>
        ///                </p>
        /// 			         </li>
        ///          </ul>
        @available(*, deprecated)
        public let certificate: Swift.String?
        /// <p>This field is deprecated. Use one of the following fields instead:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>ACMCertificateArn</code>
        ///
        ///                </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>IAMCertificateId</code>
        ///
        ///                </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>CloudFrontDefaultCertificate</code>
        ///                </p>
        /// 			         </li>
        ///          </ul>
        @available(*, deprecated)
        public let certificateSource: CloudFrontClientTypes.CertificateSource?
        /// <p>If the distribution uses the CloudFront domain name such as
        /// 			<code>d111111abcdef8.cloudfront.net</code>, set this field to <code>true</code>.</p>
        /// 		       <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), set
        /// 			this field to <code>false</code> and specify values for the following fields:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>ACMCertificateArn</code> or <code>IAMCertificateId</code> (specify a value for one,
        /// 					not both)</p>
        /// 				
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>MinimumProtocolVersion</code>
        ///                </p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>SSLSupportMethod</code>
        ///
        ///                </p>
        /// 			         </li>
        ///          </ul>
        public let cloudFrontDefaultCertificate: Swift.Bool?
        /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs) and
        /// 			the SSL/TLS certificate is stored in <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html">AWS
        /// 			Identity and Access Management (AWS IAM)</a>, provide the ID of the IAM
        /// 			certificate.</p>
        /// 		       <p>If you specify an IAM certificate ID, you must also specify values for
        /// 			<code>MinimumProtocolVersion</code> and <code>SSLSupportMethod</code>.
        ///       </p>
        public let iAMCertificateId: Swift.String?
        /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs),
        /// 			specify the security policy that you want CloudFront to use for HTTPS connections with
        /// 			viewers. The security policy determines two settings:</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>The minimum SSL/TLS protocol that CloudFront can use to communicate with
        /// 					viewers.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>The ciphers that CloudFront can use to encrypt the content that it returns to
        /// 					viewers.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy">Security Policy</a> and <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers">Supported Protocols and Ciphers Between Viewers and
        /// 			CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
        /// 		       <note>
        /// 			         <p>On the CloudFront console, this setting is called <b>Security
        /// 				Policy</b>.</p>
        /// 		       </note>
        /// 		       <p>When you’re using SNI only (you set <code>SSLSupportMethod</code> to <code>sni-only</code>),
        /// 			you must specify <code>TLSv1</code> or higher.
        ///       </p>
        /// 		       <p>If the distribution uses the CloudFront domain name such as
        /// 			<code>d111111abcdef8.cloudfront.net</code> (you set
        /// 			<code>CloudFrontDefaultCertificate</code> to <code>true</code>), CloudFront automatically sets
        /// 			the security policy to <code>TLSv1</code> regardless of the value that you set
        /// 			here.</p>
        public let minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion?
        /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), specify
        /// 			which viewers the distribution accepts HTTPS connections from.</p>
        /// 		       <ul>
        ///             <li>
        /// 				           <p>
        ///                   <code>sni-only</code> – The distribution accepts HTTPS connections from only viewers that
        /// 					support <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server
        /// 					name indication (SNI)</a>. This is recommended. Most browsers and clients support SNI.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>vip</code> – The distribution accepts HTTPS connections from all viewers including
        /// 					those that don’t support SNI. This is not recommended, and results in additional
        /// 					monthly charges from CloudFront.</p>
        /// 			         </li>
        ///             <li>
        /// 				           <p>
        ///                   <code>static-ip</code> - Do not specify this value unless your distribution
        /// 					has been enabled for this feature by the CloudFront team. If you have a use case
        /// 					that requires static IP addresses for a distribution, contact CloudFront through
        /// 					the <a href="https://console.aws.amazon.com/support/home">AWS Support Center</a>.</p>
        /// 			         </li>
        ///          </ul>
        /// 		       <p>If the distribution uses the CloudFront domain name such as
        /// 			<code>d111111abcdef8.cloudfront.net</code>, don’t set a value for this field.</p>
        public let sSLSupportMethod: CloudFrontClientTypes.SSLSupportMethod?

        public init (
            aCMCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: CloudFrontClientTypes.CertificateSource? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iAMCertificateId: Swift.String? = nil,
            minimumProtocolVersion: CloudFrontClientTypes.MinimumProtocolVersion? = nil,
            sSLSupportMethod: CloudFrontClientTypes.SSLSupportMethod? = nil
        )
        {
            self.aCMCertificateArn = aCMCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iAMCertificateId = iAMCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sSLSupportMethod = sSLSupportMethod
        }
    }

}

extension CloudFrontClientTypes {
    public enum ViewerProtocolPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case httpsOnly
        case redirectToHttps
        case sdkUnknown(Swift.String)

        public static var allCases: [ViewerProtocolPolicy] {
            return [
                .allowAll,
                .httpsOnly,
                .redirectToHttps,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "allow-all"
            case .httpsOnly: return "https-only"
            case .redirectToHttps: return "redirect-to-https"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ViewerProtocolPolicy(rawValue: rawValue) ?? ViewerProtocolPolicy.sdkUnknown(rawValue)
        }
    }
}
