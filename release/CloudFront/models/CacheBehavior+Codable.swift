// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CacheBehavior: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case pathPattern = "PathPattern"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: Key("allowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: Key("cachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: Key("compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: Key("defaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: Key("fieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: Key("forwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: Key("functionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: Key("lambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: Key("maxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: Key("minTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: Key("originRequestPolicyId"))
        }
        if let pathPattern = pathPattern {
            try container.encode(pathPattern, forKey: Key("pathPattern"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: Key("realtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: Key("smoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: Key("targetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: Key("trustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: Key("trustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: Key("viewerProtocolPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPattern)
        pathPattern = pathPatternDecoded
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}
