// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension CloudFrontClient {
    /// <p>Creates a cache policy.</p>
    /// 		       <p>After you create a cache policy, you can attach it to one or more cache behaviors. When it’s
    /// 			attached to a cache behavior, the cache policy determines the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The values that CloudFront includes in the <i>cache key</i>. These values can
    /// 					include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to
    /// 					find an object in its cache that it can return to the viewer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
    /// 					in the CloudFront cache.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
    /// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
    /// 			find an object in its cache that matches the request’s cache key. If you want to send
    /// 			values to the origin but <i>not</i> include them in the cache key, use
    /// 			<code>OriginRequestPolicy</code>.</p>
    /// 		       <p>For more information about cache policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html">Controlling the cache key</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    func createCachePolicy(input: CreateCachePolicyInput) async throws -> CreateCachePolicyOutputResponse
    {
        typealias createCachePolicyContinuation = CheckedContinuation<CreateCachePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCachePolicyContinuation) in
            createCachePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a new origin access identity. If you're using Amazon S3 for your origin, you can
    /// 			use an origin access identity to require users to access your content using a CloudFront URL instead
    /// 			of the Amazon S3 URL. For more information about how to use origin access identities, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    func createCloudFrontOriginAccessIdentity(input: CreateCloudFrontOriginAccessIdentityInput) async throws -> CreateCloudFrontOriginAccessIdentityOutputResponse
    {
        typealias createCloudFrontOriginAccessIdentityContinuation = CheckedContinuation<CreateCloudFrontOriginAccessIdentityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCloudFrontOriginAccessIdentityContinuation) in
            createCloudFrontOriginAccessIdentity(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a new web distribution. You create a CloudFront distribution to tell CloudFront where you
    /// 			want content to be delivered from, and the details about how to track and manage content delivery. Send a <code>POST</code> request to the
    /// 			<code>/<i>CloudFront API version</i>/distribution</code>/<code>distribution ID</code> resource.</p>
    /// 		       <important>
    ///             <p>When you update a distribution, there are more required fields than when you create a distribution.
    /// 			When you update your distribution by using
    /// 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html">UpdateDistribution</a>,
    /// 			follow the steps included
    /// 			in the documentation to get the current configuration
    /// 			and then make your updates. This helps to make sure that you include all of the required fields. To view a summary,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
    /// 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    ///          </important>
    func createDistribution(input: CreateDistributionInput) async throws -> CreateDistributionOutputResponse
    {
        typealias createDistributionContinuation = CheckedContinuation<CreateDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDistributionContinuation) in
            createDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Create a new distribution with tags.</p>
    func createDistributionWithTags(input: CreateDistributionWithTagsInput) async throws -> CreateDistributionWithTagsOutputResponse
    {
        typealias createDistributionWithTagsContinuation = CheckedContinuation<CreateDistributionWithTagsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDistributionWithTagsContinuation) in
            createDistributionWithTags(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Create a new field-level encryption configuration.</p>
    func createFieldLevelEncryptionConfig(input: CreateFieldLevelEncryptionConfigInput) async throws -> CreateFieldLevelEncryptionConfigOutputResponse
    {
        typealias createFieldLevelEncryptionConfigContinuation = CheckedContinuation<CreateFieldLevelEncryptionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFieldLevelEncryptionConfigContinuation) in
            createFieldLevelEncryptionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Create a field-level encryption profile.</p>
    func createFieldLevelEncryptionProfile(input: CreateFieldLevelEncryptionProfileInput) async throws -> CreateFieldLevelEncryptionProfileOutputResponse
    {
        typealias createFieldLevelEncryptionProfileContinuation = CheckedContinuation<CreateFieldLevelEncryptionProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFieldLevelEncryptionProfileContinuation) in
            createFieldLevelEncryptionProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a CloudFront function.</p>
    /// 		       <p>To create a function, you provide the function code and some configuration information
    /// 			about the function. The response contains an Amazon Resource Name (ARN) that uniquely
    /// 			identifies the function.</p>
    /// 		       <p>When you create a function, it’s in the <code>DEVELOPMENT</code> stage. In this stage, you
    /// 			can test the function with <code>TestFunction</code>, and update it with
    /// 			<code>UpdateFunction</code>.</p>
    /// 		       <p>When you’re ready to use your function with a CloudFront distribution, use
    /// 			<code>PublishFunction</code> to copy the function from the <code>DEVELOPMENT</code>
    /// 			stage to <code>LIVE</code>. When it’s live, you can attach the function to a
    /// 			distribution’s cache behavior, using the function’s ARN.</p>
    func createFunction(input: CreateFunctionInput) async throws -> CreateFunctionOutputResponse
    {
        typealias createFunctionContinuation = CheckedContinuation<CreateFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFunctionContinuation) in
            createFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Create a new invalidation. </p>
    func createInvalidation(input: CreateInvalidationInput) async throws -> CreateInvalidationOutputResponse
    {
        typealias createInvalidationContinuation = CheckedContinuation<CreateInvalidationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createInvalidationContinuation) in
            createInvalidation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a key group that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
    /// 		       <p>To create a key group, you must specify at least one public key for the key group. After you
    /// 			create a key group, you can reference it from one or more cache behaviors. When you
    /// 			reference a key group in a cache behavior, CloudFront requires signed URLs or signed cookies
    /// 			for all requests that match the cache behavior. The URLs or cookies must be signed with
    /// 			a private key whose corresponding public key is in the key group. The signed URL or
    /// 			cookie contains information about which public key CloudFront should use to verify the
    /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    func createKeyGroup(input: CreateKeyGroupInput) async throws -> CreateKeyGroupOutputResponse
    {
        typealias createKeyGroupContinuation = CheckedContinuation<CreateKeyGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createKeyGroupContinuation) in
            createKeyGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Enables additional CloudWatch metrics for the specified CloudFront distribution. The
    /// 			additional metrics incur an additional cost.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional">Viewing additional CloudFront distribution metrics</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    func createMonitoringSubscription(input: CreateMonitoringSubscriptionInput) async throws -> CreateMonitoringSubscriptionOutputResponse
    {
        typealias createMonitoringSubscriptionContinuation = CheckedContinuation<CreateMonitoringSubscriptionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createMonitoringSubscriptionContinuation) in
            createMonitoringSubscription(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an origin request policy.</p>
    /// 		       <p>After you create an origin request policy, you can attach it to one or more cache behaviors.
    /// 			When it’s attached to a cache behavior, the origin request policy determines the values
    /// 			that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends
    /// 			to the origin includes the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The request body and the URL path (without the domain name) from the viewer
    /// 					request.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The headers that CloudFront automatically includes in every origin request, including
    /// 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the cache policy or
    /// 					the origin request policy. These can include items from the viewer request and,
    /// 					in the case of headers, additional ones that are added by CloudFront.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>CloudFront sends a request when it can’t find a valid object in its cache that matches the
    /// 			request. If you want to send values to the origin and also include them in the cache
    /// 			key, use <code>CachePolicy</code>.</p>
    /// 		       <p>For more information about origin request policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html">Controlling origin requests</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    func createOriginRequestPolicy(input: CreateOriginRequestPolicyInput) async throws -> CreateOriginRequestPolicyOutputResponse
    {
        typealias createOriginRequestPolicyContinuation = CheckedContinuation<CreateOriginRequestPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createOriginRequestPolicyContinuation) in
            createOriginRequestPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Uploads a public key to CloudFront that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    func createPublicKey(input: CreatePublicKeyInput) async throws -> CreatePublicKeyOutputResponse
    {
        typealias createPublicKeyContinuation = CheckedContinuation<CreatePublicKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createPublicKeyContinuation) in
            createPublicKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a real-time log configuration.</p>
    /// 		       <p>After you create a real-time log configuration, you can attach it to one or more cache
    /// 			behaviors to send real-time log data to the specified Amazon Kinesis data stream.</p>
    /// 		       <p>For more information about real-time log configurations, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    func createRealtimeLogConfig(input: CreateRealtimeLogConfigInput) async throws -> CreateRealtimeLogConfigOutputResponse
    {
        typealias createRealtimeLogConfigContinuation = CheckedContinuation<CreateRealtimeLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createRealtimeLogConfigContinuation) in
            createRealtimeLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>This API is deprecated.
    ///             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
    ///             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
    func createStreamingDistribution(input: CreateStreamingDistributionInput) async throws -> CreateStreamingDistributionOutputResponse
    {
        typealias createStreamingDistributionContinuation = CheckedContinuation<CreateStreamingDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createStreamingDistributionContinuation) in
            createStreamingDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>This API is deprecated.
    ///             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
    ///             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
    func createStreamingDistributionWithTags(input: CreateStreamingDistributionWithTagsInput) async throws -> CreateStreamingDistributionWithTagsOutputResponse
    {
        typealias createStreamingDistributionWithTagsContinuation = CheckedContinuation<CreateStreamingDistributionWithTagsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createStreamingDistributionWithTagsContinuation) in
            createStreamingDistributionWithTags(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a cache policy.</p>
    /// 		       <p>You cannot delete a cache policy if it’s attached to a cache behavior. First update your
    /// 			distributions to remove the cache policy from all cache behaviors, then delete the cache
    /// 			policy.</p>
    /// 		       <p>To delete a cache policy, you must provide the policy’s identifier and version. To get these
    /// 			values, you can use <code>ListCachePolicies</code> or
    /// 			<code>GetCachePolicy</code>.</p>
    func deleteCachePolicy(input: DeleteCachePolicyInput) async throws -> DeleteCachePolicyOutputResponse
    {
        typealias deleteCachePolicyContinuation = CheckedContinuation<DeleteCachePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCachePolicyContinuation) in
            deleteCachePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete an origin access identity. </p>
    func deleteCloudFrontOriginAccessIdentity(input: DeleteCloudFrontOriginAccessIdentityInput) async throws -> DeleteCloudFrontOriginAccessIdentityOutputResponse
    {
        typealias deleteCloudFrontOriginAccessIdentityContinuation = CheckedContinuation<DeleteCloudFrontOriginAccessIdentityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCloudFrontOriginAccessIdentityContinuation) in
            deleteCloudFrontOriginAccessIdentity(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete a distribution. </p>
    func deleteDistribution(input: DeleteDistributionInput) async throws -> DeleteDistributionOutputResponse
    {
        typealias deleteDistributionContinuation = CheckedContinuation<DeleteDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDistributionContinuation) in
            deleteDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Remove a field-level encryption configuration.</p>
    func deleteFieldLevelEncryptionConfig(input: DeleteFieldLevelEncryptionConfigInput) async throws -> DeleteFieldLevelEncryptionConfigOutputResponse
    {
        typealias deleteFieldLevelEncryptionConfigContinuation = CheckedContinuation<DeleteFieldLevelEncryptionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFieldLevelEncryptionConfigContinuation) in
            deleteFieldLevelEncryptionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Remove a field-level encryption profile.</p>
    func deleteFieldLevelEncryptionProfile(input: DeleteFieldLevelEncryptionProfileInput) async throws -> DeleteFieldLevelEncryptionProfileOutputResponse
    {
        typealias deleteFieldLevelEncryptionProfileContinuation = CheckedContinuation<DeleteFieldLevelEncryptionProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFieldLevelEncryptionProfileContinuation) in
            deleteFieldLevelEncryptionProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a CloudFront function.</p>
    /// 		       <p>You cannot delete a function if it’s associated with a cache behavior. First, update your
    /// 			distributions to remove the function association from all cache behaviors, then delete
    /// 			the function.</p>
    /// 		       <p>To delete a function, you must provide the function’s name and version
    /// 			(<code>ETag</code> value). To get these values, you can use <code>ListFunctions</code>
    /// 			and <code>DescribeFunction</code>.</p>
    func deleteFunction(input: DeleteFunctionInput) async throws -> DeleteFunctionOutputResponse
    {
        typealias deleteFunctionContinuation = CheckedContinuation<DeleteFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFunctionContinuation) in
            deleteFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a key group.</p>
    /// 		       <p>You cannot delete a key group that is referenced in a cache behavior. First update
    /// 			your distributions to remove the key group from all cache behaviors, then delete the key
    /// 			group.</p>
    /// 		       <p>To delete a key group, you must provide the key group’s identifier and version. To get
    /// 			these values, use <code>ListKeyGroups</code> followed by <code>GetKeyGroup</code> or
    /// 			<code>GetKeyGroupConfig</code>.</p>
    func deleteKeyGroup(input: DeleteKeyGroupInput) async throws -> DeleteKeyGroupOutputResponse
    {
        typealias deleteKeyGroupContinuation = CheckedContinuation<DeleteKeyGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteKeyGroupContinuation) in
            deleteKeyGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Disables additional CloudWatch metrics for the specified CloudFront distribution.</p>
    func deleteMonitoringSubscription(input: DeleteMonitoringSubscriptionInput) async throws -> DeleteMonitoringSubscriptionOutputResponse
    {
        typealias deleteMonitoringSubscriptionContinuation = CheckedContinuation<DeleteMonitoringSubscriptionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteMonitoringSubscriptionContinuation) in
            deleteMonitoringSubscription(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes an origin request policy.</p>
    /// 		       <p>You cannot delete an origin request policy if it’s attached to any cache behaviors. First
    /// 			update your distributions to remove the origin request policy from all cache behaviors,
    /// 			then delete the origin request policy.</p>
    /// 		       <p>To delete an origin request policy, you must provide the policy’s identifier and version. To
    /// 			get the identifier, you can use <code>ListOriginRequestPolicies</code> or
    /// 			<code>GetOriginRequestPolicy</code>.</p>
    func deleteOriginRequestPolicy(input: DeleteOriginRequestPolicyInput) async throws -> DeleteOriginRequestPolicyOutputResponse
    {
        typealias deleteOriginRequestPolicyContinuation = CheckedContinuation<DeleteOriginRequestPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteOriginRequestPolicyContinuation) in
            deleteOriginRequestPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Remove a public key you previously added to CloudFront.</p>
    func deletePublicKey(input: DeletePublicKeyInput) async throws -> DeletePublicKeyOutputResponse
    {
        typealias deletePublicKeyContinuation = CheckedContinuation<DeletePublicKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deletePublicKeyContinuation) in
            deletePublicKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a real-time log configuration.</p>
    /// 		       <p>You cannot delete a real-time log configuration if it’s attached to a cache behavior.
    /// 			First update your distributions to remove the real-time log configuration from all cache
    /// 			behaviors, then delete the real-time log configuration.</p>
    /// 		       <p>To delete a real-time log configuration, you can provide the configuration’s name or its
    /// 			Amazon Resource Name (ARN). You must provide at least one. If you provide both, CloudFront
    /// 			uses the name to identify the real-time log configuration to delete.</p>
    func deleteRealtimeLogConfig(input: DeleteRealtimeLogConfigInput) async throws -> DeleteRealtimeLogConfigOutputResponse
    {
        typealias deleteRealtimeLogConfigContinuation = CheckedContinuation<DeleteRealtimeLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRealtimeLogConfigContinuation) in
            deleteRealtimeLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete a streaming distribution. To delete an RTMP distribution using the CloudFront API,
    /// 			perform the following steps.</p>
    ///
    /// 		       <p>
    ///             <b>To delete an RTMP distribution using the CloudFront
    /// 			API</b>:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Disable the RTMP distribution.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to get the current
    /// 					configuration and the <code>Etag</code> header for the distribution. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Update the XML document that was returned in the response to your <code>GET
    /// 						Streaming Distribution Config</code> request to change the value of <code>Enabled</code>
    /// 					to <code>false</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>PUT Streaming Distribution Config</code> request to update the
    /// 					configuration for your distribution. In the request body, include the XML document that
    /// 					you updated in Step 3. Then set the value of the HTTP <code>If-Match</code> header to the
    /// 					value of the <code>ETag</code> header that CloudFront returned when you submitted the <code>GET
    /// 						Streaming Distribution Config</code> request in Step 2.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Review the response to the <code>PUT Streaming Distribution Config</code> request
    /// 					to confirm that the distribution was successfully disabled.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to confirm that
    /// 					your changes have propagated. When propagation is complete, the value of
    /// 						<code>Status</code> is <code>Deployed</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>DELETE Streaming Distribution</code> request. Set the value of the
    /// 					HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
    /// 					returned when you submitted the <code>GET Streaming Distribution Config</code> request in
    /// 					Step 2.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Review the response to your <code>DELETE Streaming Distribution</code> request to
    /// 					confirm that the distribution was successfully deleted.</p>
    /// 			         </li>
    ///          </ol>
    /// 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    func deleteStreamingDistribution(input: DeleteStreamingDistributionInput) async throws -> DeleteStreamingDistributionOutputResponse
    {
        typealias deleteStreamingDistributionContinuation = CheckedContinuation<DeleteStreamingDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteStreamingDistributionContinuation) in
            deleteStreamingDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets configuration information and metadata about a CloudFront function, but not the function’s
    /// 			code. To get a function’s code, use <code>GetFunction</code>.</p>
    /// 		       <p>To get configuration information and metadata about a function, you must provide the
    /// 			function’s name and stage. To get these values, you can use
    /// 			<code>ListFunctions</code>.</p>
    func describeFunction(input: DescribeFunctionInput) async throws -> DescribeFunctionOutputResponse
    {
        typealias describeFunctionContinuation = CheckedContinuation<DescribeFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFunctionContinuation) in
            describeFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a cache policy, including the following metadata:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The policy’s identifier.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The date and time when the policy was last modified.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>To get a cache policy, you must provide the policy’s identifier. If the cache policy is
    /// 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
    /// 			not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    func getCachePolicy(input: GetCachePolicyInput) async throws -> GetCachePolicyOutputResponse
    {
        typealias getCachePolicyContinuation = CheckedContinuation<GetCachePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCachePolicyContinuation) in
            getCachePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a cache policy configuration.</p>
    /// 		       <p>To get a cache policy configuration, you must provide the policy’s identifier. If the cache
    /// 			policy is attached to a distribution’s cache behavior, you can get the policy’s
    /// 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
    /// 			cache policy is not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    func getCachePolicyConfig(input: GetCachePolicyConfigInput) async throws -> GetCachePolicyConfigOutputResponse
    {
        typealias getCachePolicyConfigContinuation = CheckedContinuation<GetCachePolicyConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCachePolicyConfigContinuation) in
            getCachePolicyConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the information about an origin access identity. </p>
    func getCloudFrontOriginAccessIdentity(input: GetCloudFrontOriginAccessIdentityInput) async throws -> GetCloudFrontOriginAccessIdentityOutputResponse
    {
        typealias getCloudFrontOriginAccessIdentityContinuation = CheckedContinuation<GetCloudFrontOriginAccessIdentityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCloudFrontOriginAccessIdentityContinuation) in
            getCloudFrontOriginAccessIdentity(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the configuration information about an origin access identity. </p>
    func getCloudFrontOriginAccessIdentityConfig(input: GetCloudFrontOriginAccessIdentityConfigInput) async throws -> GetCloudFrontOriginAccessIdentityConfigOutputResponse
    {
        typealias getCloudFrontOriginAccessIdentityConfigContinuation = CheckedContinuation<GetCloudFrontOriginAccessIdentityConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getCloudFrontOriginAccessIdentityConfigContinuation) in
            getCloudFrontOriginAccessIdentityConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the information about a distribution.</p>
    func getDistribution(input: GetDistributionInput) async throws -> GetDistributionOutputResponse
    {
        typealias getDistributionContinuation = CheckedContinuation<GetDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDistributionContinuation) in
            getDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the configuration information about a distribution. </p>
    func getDistributionConfig(input: GetDistributionConfigInput) async throws -> GetDistributionConfigOutputResponse
    {
        typealias getDistributionConfigContinuation = CheckedContinuation<GetDistributionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDistributionConfigContinuation) in
            getDistributionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the field-level encryption configuration information.</p>
    func getFieldLevelEncryption(input: GetFieldLevelEncryptionInput) async throws -> GetFieldLevelEncryptionOutputResponse
    {
        typealias getFieldLevelEncryptionContinuation = CheckedContinuation<GetFieldLevelEncryptionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFieldLevelEncryptionContinuation) in
            getFieldLevelEncryption(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the field-level encryption configuration information.</p>
    func getFieldLevelEncryptionConfig(input: GetFieldLevelEncryptionConfigInput) async throws -> GetFieldLevelEncryptionConfigOutputResponse
    {
        typealias getFieldLevelEncryptionConfigContinuation = CheckedContinuation<GetFieldLevelEncryptionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFieldLevelEncryptionConfigContinuation) in
            getFieldLevelEncryptionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the field-level encryption profile information.</p>
    func getFieldLevelEncryptionProfile(input: GetFieldLevelEncryptionProfileInput) async throws -> GetFieldLevelEncryptionProfileOutputResponse
    {
        typealias getFieldLevelEncryptionProfileContinuation = CheckedContinuation<GetFieldLevelEncryptionProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFieldLevelEncryptionProfileContinuation) in
            getFieldLevelEncryptionProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the field-level encryption profile configuration information.</p>
    func getFieldLevelEncryptionProfileConfig(input: GetFieldLevelEncryptionProfileConfigInput) async throws -> GetFieldLevelEncryptionProfileConfigOutputResponse
    {
        typealias getFieldLevelEncryptionProfileConfigContinuation = CheckedContinuation<GetFieldLevelEncryptionProfileConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFieldLevelEncryptionProfileConfigContinuation) in
            getFieldLevelEncryptionProfileConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets the code of a CloudFront function. To get configuration information and metadata about
    /// 			a function, use <code>DescribeFunction</code>.</p>
    /// 		       <p>To get a function’s code, you must provide the function’s name and stage. To get these
    /// 			values, you can use <code>ListFunctions</code>.</p>
    func getFunction(input: GetFunctionInput) async throws -> GetFunctionOutputResponse
    {
        typealias getFunctionContinuation = CheckedContinuation<GetFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getFunctionContinuation) in
            getFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the information about an invalidation. </p>
    func getInvalidation(input: GetInvalidationInput) async throws -> GetInvalidationOutputResponse
    {
        typealias getInvalidationContinuation = CheckedContinuation<GetInvalidationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getInvalidationContinuation) in
            getInvalidation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a key group, including the date and time when the key group was last modified.</p>
    /// 		       <p>To get a key group, you must provide the key group’s identifier. If the key group is
    /// 			referenced in a distribution’s cache behavior, you can get the key group’s identifier
    /// 			using <code>ListDistributions</code> or <code>GetDistribution</code>. If the key group
    /// 			is not referenced in a cache behavior, you can get the identifier using
    /// 			<code>ListKeyGroups</code>.</p>
    func getKeyGroup(input: GetKeyGroupInput) async throws -> GetKeyGroupOutputResponse
    {
        typealias getKeyGroupContinuation = CheckedContinuation<GetKeyGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getKeyGroupContinuation) in
            getKeyGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a key group configuration.</p>
    /// 		       <p>To get a key group configuration, you must provide the key group’s identifier. If the
    /// 			key group is referenced in a distribution’s cache behavior, you can get the key group’s
    /// 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
    /// 			key group is not referenced in a cache behavior, you can get the identifier using
    /// 			<code>ListKeyGroups</code>.</p>
    func getKeyGroupConfig(input: GetKeyGroupConfigInput) async throws -> GetKeyGroupConfigOutputResponse
    {
        typealias getKeyGroupConfigContinuation = CheckedContinuation<GetKeyGroupConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getKeyGroupConfigContinuation) in
            getKeyGroupConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about whether additional CloudWatch metrics are enabled for the specified
    /// 			CloudFront distribution.</p>
    func getMonitoringSubscription(input: GetMonitoringSubscriptionInput) async throws -> GetMonitoringSubscriptionOutputResponse
    {
        typealias getMonitoringSubscriptionContinuation = CheckedContinuation<GetMonitoringSubscriptionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getMonitoringSubscriptionContinuation) in
            getMonitoringSubscription(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets an origin request policy, including the following metadata:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The policy’s identifier.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The date and time when the policy was last modified.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>To get an origin request policy, you must provide the policy’s identifier. If the origin
    /// 			request policy is attached to a distribution’s cache behavior, you can get the policy’s
    /// 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
    /// 			origin request policy is not attached to a cache behavior, you can get the identifier
    /// 			using <code>ListOriginRequestPolicies</code>.</p>
    func getOriginRequestPolicy(input: GetOriginRequestPolicyInput) async throws -> GetOriginRequestPolicyOutputResponse
    {
        typealias getOriginRequestPolicyContinuation = CheckedContinuation<GetOriginRequestPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getOriginRequestPolicyContinuation) in
            getOriginRequestPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets an origin request policy configuration.</p>
    /// 		       <p>To get an origin request policy configuration, you must provide the policy’s identifier. If
    /// 			the origin request policy is attached to a distribution’s cache behavior, you can get
    /// 			the policy’s identifier using <code>ListDistributions</code> or
    /// 			<code>GetDistribution</code>. If the origin request policy is not attached to a cache
    /// 			behavior, you can get the identifier using
    /// 			<code>ListOriginRequestPolicies</code>.</p>
    func getOriginRequestPolicyConfig(input: GetOriginRequestPolicyConfigInput) async throws -> GetOriginRequestPolicyConfigOutputResponse
    {
        typealias getOriginRequestPolicyConfigContinuation = CheckedContinuation<GetOriginRequestPolicyConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getOriginRequestPolicyConfigContinuation) in
            getOriginRequestPolicyConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a public key.</p>
    func getPublicKey(input: GetPublicKeyInput) async throws -> GetPublicKeyOutputResponse
    {
        typealias getPublicKeyContinuation = CheckedContinuation<GetPublicKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPublicKeyContinuation) in
            getPublicKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a public key configuration.</p>
    func getPublicKeyConfig(input: GetPublicKeyConfigInput) async throws -> GetPublicKeyConfigOutputResponse
    {
        typealias getPublicKeyConfigContinuation = CheckedContinuation<GetPublicKeyConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getPublicKeyConfigContinuation) in
            getPublicKeyConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a real-time log configuration.</p>
    /// 		       <p>To get a real-time log configuration, you can provide the configuration’s name or its Amazon
    /// 			Resource Name (ARN). You must provide at least one. If you provide both, CloudFront uses the
    /// 			name to identify the real-time log configuration to get.</p>
    func getRealtimeLogConfig(input: GetRealtimeLogConfigInput) async throws -> GetRealtimeLogConfigOutputResponse
    {
        typealias getRealtimeLogConfigContinuation = CheckedContinuation<GetRealtimeLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRealtimeLogConfigContinuation) in
            getRealtimeLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets information about a specified RTMP distribution, including the distribution configuration.</p>
    func getStreamingDistribution(input: GetStreamingDistributionInput) async throws -> GetStreamingDistributionOutputResponse
    {
        typealias getStreamingDistributionContinuation = CheckedContinuation<GetStreamingDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getStreamingDistributionContinuation) in
            getStreamingDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get the configuration information about a streaming distribution. </p>
    func getStreamingDistributionConfig(input: GetStreamingDistributionConfigInput) async throws -> GetStreamingDistributionConfigOutputResponse
    {
        typealias getStreamingDistributionConfigContinuation = CheckedContinuation<GetStreamingDistributionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getStreamingDistributionConfigContinuation) in
            getStreamingDistributionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of cache policies.</p>
    /// 		       <p>You can optionally apply a filter to return only the managed policies created by AWS, or
    /// 			only the custom policies created in your AWS account.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listCachePolicies(input: ListCachePoliciesInput) async throws -> ListCachePoliciesOutputResponse
    {
        typealias listCachePoliciesContinuation = CheckedContinuation<ListCachePoliciesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCachePoliciesContinuation) in
            listCachePolicies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists origin access identities.</p>
    func listCloudFrontOriginAccessIdentities(input: ListCloudFrontOriginAccessIdentitiesInput) async throws -> ListCloudFrontOriginAccessIdentitiesOutputResponse
    {
        typealias listCloudFrontOriginAccessIdentitiesContinuation = CheckedContinuation<ListCloudFrontOriginAccessIdentitiesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCloudFrontOriginAccessIdentitiesContinuation) in
            listCloudFrontOriginAccessIdentities(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List CloudFront distributions.</p>
    func listDistributions(input: ListDistributionsInput) async throws -> ListDistributionsOutputResponse
    {
        typealias listDistributionsContinuation = CheckedContinuation<ListDistributionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionsContinuation) in
            listDistributions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
    /// 			associated with the specified cache policy.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listDistributionsByCachePolicyId(input: ListDistributionsByCachePolicyIdInput) async throws -> ListDistributionsByCachePolicyIdOutputResponse
    {
        typealias listDistributionsByCachePolicyIdContinuation = CheckedContinuation<ListDistributionsByCachePolicyIdOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionsByCachePolicyIdContinuation) in
            listDistributionsByCachePolicyId(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of distribution IDs for distributions that have a cache behavior that references
    /// 			the specified key group.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listDistributionsByKeyGroup(input: ListDistributionsByKeyGroupInput) async throws -> ListDistributionsByKeyGroupOutputResponse
    {
        typealias listDistributionsByKeyGroupContinuation = CheckedContinuation<ListDistributionsByKeyGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionsByKeyGroupContinuation) in
            listDistributionsByKeyGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
    /// 			associated with the specified origin request policy.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listDistributionsByOriginRequestPolicyId(input: ListDistributionsByOriginRequestPolicyIdInput) async throws -> ListDistributionsByOriginRequestPolicyIdOutputResponse
    {
        typealias listDistributionsByOriginRequestPolicyIdContinuation = CheckedContinuation<ListDistributionsByOriginRequestPolicyIdOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionsByOriginRequestPolicyIdContinuation) in
            listDistributionsByOriginRequestPolicyId(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of distributions that have a cache behavior that’s associated with the specified
    /// 			real-time log configuration.</p>
    /// 		       <p>You can specify the real-time log configuration by its name or its Amazon Resource Name
    /// 			(ARN). You must provide at least one. If you provide both, CloudFront uses the name to
    /// 			identify the real-time log configuration to list distributions for.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request. </p>
    func listDistributionsByRealtimeLogConfig(input: ListDistributionsByRealtimeLogConfigInput) async throws -> ListDistributionsByRealtimeLogConfigOutputResponse
    {
        typealias listDistributionsByRealtimeLogConfigContinuation = CheckedContinuation<ListDistributionsByRealtimeLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionsByRealtimeLogConfigContinuation) in
            listDistributionsByRealtimeLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List the distributions that are associated with a specified AWS WAF web ACL. </p>
    func listDistributionsByWebACLId(input: ListDistributionsByWebACLIdInput) async throws -> ListDistributionsByWebACLIdOutputResponse
    {
        typealias listDistributionsByWebACLIdContinuation = CheckedContinuation<ListDistributionsByWebACLIdOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionsByWebACLIdContinuation) in
            listDistributionsByWebACLId(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List all field-level encryption configurations that have been created in CloudFront for this account.</p>
    func listFieldLevelEncryptionConfigs(input: ListFieldLevelEncryptionConfigsInput) async throws -> ListFieldLevelEncryptionConfigsOutputResponse
    {
        typealias listFieldLevelEncryptionConfigsContinuation = CheckedContinuation<ListFieldLevelEncryptionConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFieldLevelEncryptionConfigsContinuation) in
            listFieldLevelEncryptionConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Request a list of field-level encryption profiles that have been created in CloudFront for this account.</p>
    func listFieldLevelEncryptionProfiles(input: ListFieldLevelEncryptionProfilesInput) async throws -> ListFieldLevelEncryptionProfilesOutputResponse
    {
        typealias listFieldLevelEncryptionProfilesContinuation = CheckedContinuation<ListFieldLevelEncryptionProfilesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFieldLevelEncryptionProfilesContinuation) in
            listFieldLevelEncryptionProfiles(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of all CloudFront functions in your AWS account.</p>
    /// 		       <p>You can optionally apply a filter to return only the functions that are in the
    /// 			specified stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listFunctions(input: ListFunctionsInput) async throws -> ListFunctionsOutputResponse
    {
        typealias listFunctionsContinuation = CheckedContinuation<ListFunctionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFunctionsContinuation) in
            listFunctions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists invalidation batches. </p>
    func listInvalidations(input: ListInvalidationsInput) async throws -> ListInvalidationsOutputResponse
    {
        typealias listInvalidationsContinuation = CheckedContinuation<ListInvalidationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listInvalidationsContinuation) in
            listInvalidations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of key groups.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listKeyGroups(input: ListKeyGroupsInput) async throws -> ListKeyGroupsOutputResponse
    {
        typealias listKeyGroupsContinuation = CheckedContinuation<ListKeyGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listKeyGroupsContinuation) in
            listKeyGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of origin request policies.</p>
    /// 		       <p>You can optionally apply a filter to return only the managed policies created by AWS, or
    /// 			only the custom policies created in your AWS account.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    func listOriginRequestPolicies(input: ListOriginRequestPoliciesInput) async throws -> ListOriginRequestPoliciesOutputResponse
    {
        typealias listOriginRequestPoliciesContinuation = CheckedContinuation<ListOriginRequestPoliciesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listOriginRequestPoliciesContinuation) in
            listOriginRequestPolicies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List all public keys that have been added to CloudFront for this account.</p>
    func listPublicKeys(input: ListPublicKeysInput) async throws -> ListPublicKeysOutputResponse
    {
        typealias listPublicKeysContinuation = CheckedContinuation<ListPublicKeysOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listPublicKeysContinuation) in
            listPublicKeys(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Gets a list of real-time log configurations.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request. </p>
    func listRealtimeLogConfigs(input: ListRealtimeLogConfigsInput) async throws -> ListRealtimeLogConfigsOutputResponse
    {
        typealias listRealtimeLogConfigsContinuation = CheckedContinuation<ListRealtimeLogConfigsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRealtimeLogConfigsContinuation) in
            listRealtimeLogConfigs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List streaming distributions. </p>
    func listStreamingDistributions(input: ListStreamingDistributionsInput) async throws -> ListStreamingDistributionsOutputResponse
    {
        typealias listStreamingDistributionsContinuation = CheckedContinuation<ListStreamingDistributionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listStreamingDistributionsContinuation) in
            listStreamingDistributions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List tags for a CloudFront resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Publishes a CloudFront function by copying the function code from the <code>DEVELOPMENT</code>
    /// 			stage to <code>LIVE</code>. This automatically updates all cache behaviors that are
    /// 			using this function to use the newly published copy in the <code>LIVE</code>
    /// 			stage.</p>
    /// 		       <p>When a function is published to the <code>LIVE</code> stage, you can attach the function to
    /// 			a distribution’s cache behavior, using the function’s Amazon Resource Name (ARN).</p>
    /// 		       <p>To publish a function, you must provide the function’s name and version (<code>ETag</code>
    /// 			value). To get these values, you can use <code>ListFunctions</code> and
    /// 			<code>DescribeFunction</code>.</p>
    func publishFunction(input: PublishFunctionInput) async throws -> PublishFunctionOutputResponse
    {
        typealias publishFunctionContinuation = CheckedContinuation<PublishFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: publishFunctionContinuation) in
            publishFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Add tags to a CloudFront resource.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Tests a CloudFront function.</p>
    /// 		       <p>To test a function, you provide an <i>event object</i> that represents an HTTP
    /// 			request or response that your CloudFront distribution could receive in production. CloudFront runs
    /// 			the function, passing it the event object that you provided, and returns the function’s
    /// 			result (the modified event object) in the response. The response also contains function
    /// 			logs and error messages, if any exist. For more information about testing functions, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>To test a function, you provide the function’s name and version (<code>ETag</code> value)
    /// 			along with the event object. To get the function’s name and version, you can use
    /// 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
    func testFunction(input: TestFunctionInput) async throws -> TestFunctionOutputResponse
    {
        typealias testFunctionContinuation = CheckedContinuation<TestFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: testFunctionContinuation) in
            testFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Remove tags from a CloudFront resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a cache policy configuration.</p>
    /// 		       <p>When you update a cache policy configuration, all the fields are updated with the
    /// 			values provided in the request. You cannot update some fields independent of others. To
    /// 			update a cache policy configuration:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Use <code>GetCachePolicyConfig</code> to get the current configuration.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the fields in the cache policy configuration that you want to
    /// 					update.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call <code>UpdateCachePolicy</code> by providing the entire cache policy
    /// 					configuration, including the fields that you modified and those that you
    /// 					didn’t.</p>
    /// 			         </li>
    ///          </ol>
    func updateCachePolicy(input: UpdateCachePolicyInput) async throws -> UpdateCachePolicyOutputResponse
    {
        typealias updateCachePolicyContinuation = CheckedContinuation<UpdateCachePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCachePolicyContinuation) in
            updateCachePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Update an origin access identity. </p>
    func updateCloudFrontOriginAccessIdentity(input: UpdateCloudFrontOriginAccessIdentityInput) async throws -> UpdateCloudFrontOriginAccessIdentityOutputResponse
    {
        typealias updateCloudFrontOriginAccessIdentityContinuation = CheckedContinuation<UpdateCloudFrontOriginAccessIdentityOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCloudFrontOriginAccessIdentityContinuation) in
            updateCloudFrontOriginAccessIdentity(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates the configuration for a web distribution. </p>
    /// 		       <important>
    ///             <p>When you update a distribution, there are more required fields than when you create a distribution.
    /// 			When you update your distribution by using this API action, follow the steps here to get the current configuration
    /// 			and then make your updates, to make sure that you include all of the required fields. To view a summary,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
    /// 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    ///          </important>
    /// 		       <p>The update process includes getting the current distribution configuration, updating the XML document that is
    /// 			returned to make your changes, and then submitting an <code>UpdateDistribution</code> request to make the updates.</p>
    /// 		       <p>For information about updating a distribution using the CloudFront console instead, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html">Creating a
    /// 				Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		
    /// 		       <p>
    ///             <b>To update a web distribution using the CloudFront API</b>
    ///          </p>
    /// 		       <ol>
    ///             <li>
    ///                <p>Submit a
    /// 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistributionConfig.html">GetDistributionConfig</a>
    /// 				request to get the current configuration and an <code>Etag</code> header
    /// 				for the distribution.</p>
    /// 				           <note>
    ///                   <p>If you update the distribution again, you must get a new <code>Etag</code> header.</p>
    ///                </note>
    /// 			         </li>
    ///             <li>
    ///                <p>Update the XML document that was returned in the response to your <code>GetDistributionConfig</code> request to include
    /// 				your changes. </p>
    /// 				           <important>
    /// 					             <p>When you edit the XML file, be aware of the following:</p>
    /// 					             <ul>
    ///                      <li>
    ///                         <p>You must strip out the ETag parameter that is returned.</p>
    ///                      </li>
    ///                      <li>
    ///                         <p>Additional fields are required when you update a distribution. There may be fields included in the
    /// 							XML file for features that you haven't configured for your distribution. This is expected and required to
    /// 							successfully update the distribution.</p>
    ///                      </li>
    ///                      <li>
    ///                         <p>You can't change the value of <code>CallerReference</code>. If you try to change this value, CloudFront returns an
    /// 							<code>IllegalUpdate</code> error. </p>
    ///                      </li>
    ///                      <li>
    ///                         <p>The new configuration replaces the existing configuration; the values that you specify in an
    /// 							<code>UpdateDistribution</code> request are not merged into your existing configuration. When you add, delete, or
    /// 							replace values in an element that allows multiple values (for example, <code>CNAME</code>), you must specify all of the
    /// 							values that you want to appear in the updated distribution. In addition,
    /// 							you must update the corresponding <code>Quantity</code> element.</p>
    ///                      </li>
    ///                   </ul>
    ///                </important>
    /// 			         </li>
    ///             <li>
    ///                <p>Submit an <code>UpdateDistribution</code> request to update the configuration for your distribution:</p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>In the request body, include the XML document that you updated in Step 2. The request body must include an
    /// 						XML document with a <code>DistributionConfig</code> element.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Set the value of the HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront returned
    /// 						when you submitted the <code>GetDistributionConfig</code> request in Step 1.</p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///             <li>
    ///                <p>Review the response to the <code>UpdateDistribution</code> request to confirm that the configuration was
    /// 				successfully updated.</p>
    ///             </li>
    ///             <li>
    ///                <p>Optional: Submit a
    /// 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistribution.html">GetDistribution</a>
    /// 				request to confirm that your changes have propagated.
    /// 				When propagation is complete, the value of <code>Status</code> is <code>Deployed</code>.</p>
    /// 			         </li>
    ///          </ol>
    func updateDistribution(input: UpdateDistributionInput) async throws -> UpdateDistributionOutputResponse
    {
        typealias updateDistributionContinuation = CheckedContinuation<UpdateDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDistributionContinuation) in
            updateDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Update a field-level encryption configuration. </p>
    func updateFieldLevelEncryptionConfig(input: UpdateFieldLevelEncryptionConfigInput) async throws -> UpdateFieldLevelEncryptionConfigOutputResponse
    {
        typealias updateFieldLevelEncryptionConfigContinuation = CheckedContinuation<UpdateFieldLevelEncryptionConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFieldLevelEncryptionConfigContinuation) in
            updateFieldLevelEncryptionConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Update a field-level encryption profile. </p>
    func updateFieldLevelEncryptionProfile(input: UpdateFieldLevelEncryptionProfileInput) async throws -> UpdateFieldLevelEncryptionProfileOutputResponse
    {
        typealias updateFieldLevelEncryptionProfileContinuation = CheckedContinuation<UpdateFieldLevelEncryptionProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFieldLevelEncryptionProfileContinuation) in
            updateFieldLevelEncryptionProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a CloudFront function.</p>
    /// 		       <p>You can update a function’s code or the comment that describes the function. You
    /// 			cannot update a function’s name.</p>
    /// 		       <p>To update a function, you provide the function’s name and version (<code>ETag</code> value)
    /// 			along with the updated function code. To get the name and version, you can use
    /// 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
    func updateFunction(input: UpdateFunctionInput) async throws -> UpdateFunctionOutputResponse
    {
        typealias updateFunctionContinuation = CheckedContinuation<UpdateFunctionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateFunctionContinuation) in
            updateFunction(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a key group.</p>
    /// 		       <p>When you update a key group, all the fields are updated with the values provided in
    /// 			the request. You cannot update some fields independent of others. To update a key
    /// 			group:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Get the current key group with <code>GetKeyGroup</code> or
    /// 					<code>GetKeyGroupConfig</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the fields in the key group that you want to update. For
    /// 					example, add or remove public key IDs.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call <code>UpdateKeyGroup</code> with the entire key group object, including
    /// 					the fields that you modified and those that you didn’t.</p>
    /// 			         </li>
    ///          </ol>
    func updateKeyGroup(input: UpdateKeyGroupInput) async throws -> UpdateKeyGroupOutputResponse
    {
        typealias updateKeyGroupContinuation = CheckedContinuation<UpdateKeyGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateKeyGroupContinuation) in
            updateKeyGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an origin request policy configuration.</p>
    /// 		       <p>When you update an origin request policy configuration, all the fields are updated
    /// 			with the values provided in the request. You cannot update some fields independent of
    /// 			others. To update an origin request policy configuration:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Use <code>GetOriginRequestPolicyConfig</code> to get the current configuration.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the fields in the origin request policy configuration that you
    /// 					want to update.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call <code>UpdateOriginRequestPolicy</code> by providing the entire origin
    /// 					request policy configuration, including the fields that you modified and those
    /// 					that you didn’t.</p>
    /// 			         </li>
    ///          </ol>
    func updateOriginRequestPolicy(input: UpdateOriginRequestPolicyInput) async throws -> UpdateOriginRequestPolicyOutputResponse
    {
        typealias updateOriginRequestPolicyContinuation = CheckedContinuation<UpdateOriginRequestPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateOriginRequestPolicyContinuation) in
            updateOriginRequestPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Update public key information. Note that the only value you can change is the comment.</p>
    func updatePublicKey(input: UpdatePublicKeyInput) async throws -> UpdatePublicKeyOutputResponse
    {
        typealias updatePublicKeyContinuation = CheckedContinuation<UpdatePublicKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updatePublicKeyContinuation) in
            updatePublicKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a real-time log configuration.</p>
    /// 		       <p>When you update a real-time log configuration, all the parameters are updated with the
    /// 			values provided in the request. You cannot update some parameters independent of others.
    /// 			To update a real-time log configuration:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Call <code>GetRealtimeLogConfig</code> to get the current real-time log
    /// 					configuration.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the parameters in the real-time log configuration that you want
    /// 					to update.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call this API (<code>UpdateRealtimeLogConfig</code>) by providing the entire
    /// 					real-time log configuration, including the parameters that you modified and
    /// 					those that you didn’t.</p>
    /// 			         </li>
    ///          </ol>
    /// 		       <p>You cannot update a real-time log configuration’s <code>Name</code> or
    /// 			<code>ARN</code>.</p>
    func updateRealtimeLogConfig(input: UpdateRealtimeLogConfigInput) async throws -> UpdateRealtimeLogConfigOutputResponse
    {
        typealias updateRealtimeLogConfigContinuation = CheckedContinuation<UpdateRealtimeLogConfigOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRealtimeLogConfigContinuation) in
            updateRealtimeLogConfig(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Update a streaming distribution. </p>
    func updateStreamingDistribution(input: UpdateStreamingDistributionInput) async throws -> UpdateStreamingDistributionOutputResponse
    {
        typealias updateStreamingDistributionContinuation = CheckedContinuation<UpdateStreamingDistributionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateStreamingDistributionContinuation) in
            updateStreamingDistribution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
