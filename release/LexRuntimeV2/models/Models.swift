// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.ActiveContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextAttributes
        case name
        case timeToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextAttributes = contextAttributes {
            var contextAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .contextAttributes)
            for (dictKey0, activecontextparametersmap0) in contextAttributes {
                try contextAttributesContainer.encode(activecontextparametersmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timeToLive = timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ActiveContextTimeToLive.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let contextAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .contextAttributes)
        var contextAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let contextAttributesContainer = contextAttributesContainer {
            contextAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, text0) in contextAttributesContainer {
                if let text0 = text0 {
                    contextAttributesDecoded0?[key0] = text0
                }
            }
        }
        contextAttributes = contextAttributesDecoded0
    }
}

extension LexRuntimeV2ClientTypes.ActiveContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveContext(contextAttributes: \(Swift.String(describing: contextAttributes)), name: \(Swift.String(describing: name)), timeToLive: \(Swift.String(describing: timeToLive)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Contains information about the contexts that a user is using in a
    ///          session. You can configure Amazon Lex to set a context when an intent is
    ///          fulfilled, or you can set a context using the , , or  operations.</p>
    ///          <p>Use a context to indicate to Amazon Lex intents that should be used as
    ///          follow-up intents. For example, if the active context is
    ///             <code>order-fulfilled</code>, only intents that have
    ///             <code>order-fulfilled</code> configured as a trigger are considered
    ///          for follow up.</p>
    public struct ActiveContext: Swift.Equatable {
        /// <p>A lis tof contexts active for the request. A context can be
        ///          activated when a previous intent is fulfilled, or by including the
        ///          context in the request.</p>
        ///          <p>If you don't specify a list of contexts, Amazon Lex will use the
        ///          current list of contexts for the session. If you specify an empty list,
        ///          all contexts for the session are cleared. </p>
        public let contextAttributes: [Swift.String:Swift.String]?
        /// <p>The name of the context.</p>
        public let name: Swift.String?
        /// <p>Indicates the number of turns or seconds that the context is active.
        ///          Once the time to live expires, the context is no longer returned in a
        ///          response.</p>
        public let timeToLive: LexRuntimeV2ClientTypes.ActiveContextTimeToLive?

        public init (
            contextAttributes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            timeToLive: LexRuntimeV2ClientTypes.ActiveContextTimeToLive? = nil
        )
        {
            self.contextAttributes = contextAttributes
            self.name = name
            self.timeToLive = timeToLive
        }
    }

}

extension LexRuntimeV2ClientTypes.ActiveContextTimeToLive: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeToLiveInSeconds = timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension LexRuntimeV2ClientTypes.ActiveContextTimeToLive: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveContextTimeToLive(timeToLiveInSeconds: \(Swift.String(describing: timeToLiveInSeconds)), turnsToLive: \(Swift.String(describing: turnsToLive)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The time that a context is active. You can specify the time to live
    ///          in seconds or in conversation turns.</p>
    public struct ActiveContextTimeToLive: Swift.Equatable {
        /// <p>The number of seconds that the context is active. You can specify
        ///          between 5 and 86400 seconds (24 hours).</p>
        public let timeToLiveInSeconds: Swift.Int?
        /// <p>The number of turns that the context is active. You can specify up
        ///          to 20 turns. Each request and response from the bot is a turn.</p>
        public let turnsToLive: Swift.Int?

        public init (
            timeToLiveInSeconds: Swift.Int? = nil,
            turnsToLive: Swift.Int? = nil
        )
        {
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }
    }

}

extension LexRuntimeV2ClientTypes.AudioInputEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChunk
        case clientTimestampMillis
        case contentType
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.AudioInputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AudioInputEvent(audioChunk: \(Swift.String(describing: audioChunk)), clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), contentType: \(Swift.String(describing: contentType)), eventId: \(Swift.String(describing: eventId)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Represents a chunk of audio sent from the client application to
    ///          Amazon Lex. The audio is all or part of an utterance from the user.</p>
    ///          <p>Amazon Lex accumulates audio chunks until it recognizes a natural pause
    ///          in speech before processing the input.</p>
    public struct AudioInputEvent: Swift.Equatable {
        /// <p>An encoded stream of audio.</p>
        public let audioChunk: ClientRuntime.Data?
        /// <p>A timestamp set by the client of the date and time that the event
        ///          was sent to Amazon Lex.</p>
        public let clientTimestampMillis: Swift.Int
        /// <p>The encoding used for the audio chunk. You must use 8 KHz PCM 16-bit
        ///          mono-channel little-endian format. The value of the field should
        ///          be:</p>
        ///          <p>
        ///             <code>audio/lpcm; sample-rate=8000; sample-size-bits=16;
        ///             channel-count=1; is-big-endian=false</code>
        ///          </p>
        public let contentType: Swift.String?
        /// <p>A unique identifier that your application assigns to the event. You
        ///          can use this to identify events in logs.</p>
        public let eventId: Swift.String?

        public init (
            audioChunk: ClientRuntime.Data? = nil,
            clientTimestampMillis: Swift.Int = 0,
            contentType: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.audioChunk = audioChunk
            self.clientTimestampMillis = clientTimestampMillis
            self.contentType = contentType
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.AudioResponseEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChunk
        case contentType
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChunk = audioChunk {
            try encodeContainer.encode(audioChunk.base64EncodedString(), forKey: .audioChunk)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioChunkDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .audioChunk)
        audioChunk = audioChunkDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.AudioResponseEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AudioResponseEvent(audioChunk: \(Swift.String(describing: audioChunk)), contentType: \(Swift.String(describing: contentType)), eventId: \(Swift.String(describing: eventId)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>An event sent from Amazon Lex to your client application containing audio
    ///          to play to the user. </p>
    public struct AudioResponseEvent: Swift.Equatable {
        /// <p>A chunk of the audio to play. </p>
        public let audioChunk: ClientRuntime.Data?
        /// <p>The encoding of the audio chunk. This is the same as the encoding
        ///          configure in the <code>contentType</code> field of the
        ///             <code>ConfigurationEvent</code>.</p>
        public let contentType: Swift.String?
        /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
        ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
        ///          and incremented for each event sent by Amazon Lex in the current
        ///          session.</p>
        public let eventId: Swift.String?

        public init (
            audioChunk: ClientRuntime.Data? = nil,
            contentType: Swift.String? = nil,
            eventId: Swift.String? = nil
        )
        {
            self.audioChunk = audioChunk
            self.contentType = contentType
            self.eventId = eventId
        }
    }

}

extension BadGatewayException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadGatewayException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadGatewayException(message: \(Swift.String(describing: message)))"}
}

extension BadGatewayException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct BadGatewayException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadGatewayExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadGatewayExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.Button: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexRuntimeV2ClientTypes.Button: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Button(text: \(Swift.String(describing: text)), value: \(Swift.String(describing: value)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>A button that appears on a response card show to the user.</p>
    public struct Button: Swift.Equatable {
        /// <p>The text that is displayed on the button.</p>
        public let text: Swift.String?
        /// <p>The value returned to Amazon Lex when a user chooses the button.</p>
        public let value: Swift.String?

        public init (
            text: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.text = text
            self.value = value
        }
    }

}

extension LexRuntimeV2ClientTypes.ConfidenceScore: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .score)
        score = scoreDecoded
    }
}

extension LexRuntimeV2ClientTypes.ConfidenceScore: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfidenceScore(score: \(Swift.String(describing: score)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Provides a score that indicates the confidence that Amazon Lex has that
    ///          an intent is the one that satisfies the user's intent.</p>
    public struct ConfidenceScore: Swift.Equatable {
        /// <p>A score that indicates how confident Amazon Lex is that an intent
        ///          satisfies the user's intent. Ranges between 0.00 and 1.00. Higher
        ///          scores indicate higher confidence.</p>
        public let score: Swift.Double

        public init (
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension LexRuntimeV2ClientTypes.ConfigurationEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case disablePlayback
        case eventId
        case requestAttributes
        case responseContentType
        case sessionState
        case welcomeMessages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if disablePlayback != false {
            try encodeContainer.encode(disablePlayback, forKey: .disablePlayback)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseContentType = responseContentType {
            try encodeContainer.encode(responseContentType, forKey: .responseContentType)
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let welcomeMessages = welcomeMessages {
            var welcomeMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .welcomeMessages)
            for messages0 in welcomeMessages {
                try welcomeMessagesContainer.encode(messages0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let responseContentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseContentType)
        responseContentType = responseContentTypeDecoded
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let welcomeMessagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .welcomeMessages)
        var welcomeMessagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let welcomeMessagesContainer = welcomeMessagesContainer {
            welcomeMessagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in welcomeMessagesContainer {
                if let structure0 = structure0 {
                    welcomeMessagesDecoded0?.append(structure0)
                }
            }
        }
        welcomeMessages = welcomeMessagesDecoded0
        let disablePlaybackDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disablePlayback)
        disablePlayback = disablePlaybackDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.ConfigurationEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), disablePlayback: \(Swift.String(describing: disablePlayback)), eventId: \(Swift.String(describing: eventId)), requestAttributes: \(Swift.String(describing: requestAttributes)), responseContentType: \(Swift.String(describing: responseContentType)), sessionState: \(Swift.String(describing: sessionState)), welcomeMessages: \(Swift.String(describing: welcomeMessages)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The initial event sent from the application to Amazon Lex to configure
    ///          the conversation, including session and request attributes and the
    ///          response content type.</p>
    public struct ConfigurationEvent: Swift.Equatable {
        /// <p>A timestamp set by the client of the date and time that the event
        ///          was sent to Amazon Lex.</p>
        public let clientTimestampMillis: Swift.Int
        /// <p>Determines whether Amazon Lex should send audio responses to the
        ///       client application. When this parameter if <code>false</code>,
        ///       the client application needs to create responses for the user.
        ///
        ///       </p>
        public let disablePlayback: Swift.Bool
        /// <p>A unique identifier that your application assigns to the event. You
        ///          can use this to identify events in logs.</p>
        public let eventId: Swift.String?
        /// <p>Request-specific information passed between the client application
        ///          and Amazon Lex.</p>
        ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
        ///          attributes. Don't create any request attributes for prefix
        ///             <code>x-amz-lex:</code>.</p>
        public let requestAttributes: [Swift.String:Swift.String]?
        /// <p>The message that Amazon Lex returns in the response can be either text or
        ///          speech based on the <code>responseContentType</code> value.</p>
        ///          <ul>
        ///             <li>
        ///                <p>If the value is <code>text/plain;charset=utf-8</code>, Amazon Lex
        ///                returns text in the response.</p>
        ///             </li>
        ///             <li>
        ///                <p>If the value begins with <code>audio/</code>, Amazon Lex returns
        ///                speech in the response. Amazon Lex uses Amazon Polly to generate the speech
        ///                using the configuration that you specified in the
        ///                   <code>requestContentType</code> parameter. For example, if you
        ///                specify <code>audio/mpeg</code> as the value, Amazon Lex returns
        ///                speech in the MPEG format.</p>
        ///             </li>
        ///             <li>
        ///                <p>If the value is <code>audio/pcm</code>, the speech returned is
        ///                audio/pcm in 16-bit, little-endian format.</p>
        ///             </li>
        ///             <li>
        ///                <p>The following are the accepted values:</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>audio/mpeg</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>audio/ogg</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>audio/pcm</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>audio/* (defaults to mpeg)</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>text/plain; charset=utf-8</p>
        ///                   </li>
        ///                </ul>
        ///             </li>
        ///          </ul>
        public let responseContentType: Swift.String?
        /// <p>The state of the user's session with Amazon Lex.</p>
        public let sessionState: LexRuntimeV2ClientTypes.SessionState?
        /// <p>A list of messages to send to the user.</p>
        public let welcomeMessages: [LexRuntimeV2ClientTypes.Message]?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            disablePlayback: Swift.Bool = false,
            eventId: Swift.String? = nil,
            requestAttributes: [Swift.String:Swift.String]? = nil,
            responseContentType: Swift.String? = nil,
            sessionState: LexRuntimeV2ClientTypes.SessionState? = nil,
            welcomeMessages: [LexRuntimeV2ClientTypes.Message]? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.disablePlayback = disablePlayback
            self.eventId = eventId
            self.requestAttributes = requestAttributes
            self.responseContentType = responseContentType
            self.sessionState = sessionState
            self.welcomeMessages = welcomeMessages
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum ConfirmationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confirmed
        case denied
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfirmationState] {
            return [
                .confirmed,
                .denied,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "Confirmed"
            case .denied: return "Denied"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfirmationState(rawValue: rawValue) ?? ConfirmationState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes {
    public enum ConversationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audio
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationMode] {
            return [
                .audio,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConversationMode(rawValue: rawValue) ?? ConversationMode.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.DTMFInputEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
        case inputCharacter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let inputCharacter = inputCharacter {
            try encodeContainer.encode(inputCharacter, forKey: .inputCharacter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputCharacterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputCharacter)
        inputCharacter = inputCharacterDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.DTMFInputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DTMFInputEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), eventId: \(Swift.String(describing: eventId)), inputCharacter: \(Swift.String(describing: inputCharacter)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>A DTMF character sent from the client application. DTMF characters
    ///          are typically sent from a phone keypad to represent numbers. For
    ///          example, you can have Amazon Lex process a credit card number input from a
    ///          phone.</p>
    public struct DTMFInputEvent: Swift.Equatable {
        /// <p>A timestamp set by the client of the date and time that the event
        ///          was sent to Amazon Lex.</p>
        public let clientTimestampMillis: Swift.Int
        /// <p>A unique identifier that your application assigns to the event. You
        ///          can use this to identify events in logs.</p>
        public let eventId: Swift.String?
        /// <p>The DTMF character that the user pressed. The allowed characters are
        ///          A - D, 0 - 9, # and *.</p>
        public let inputCharacter: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil,
            inputCharacter: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
            self.inputCharacter = inputCharacter
        }
    }

}

extension DeleteSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSessionInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), localeId: \(Swift.String(describing: localeId)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension DeleteSessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSessionOutputError>
}

public struct DeleteSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSessionOutputError>
}

public struct DeleteSessionInput: Swift.Equatable {
    /// <p>The alias identifier in use for the bot that contains the session
    ///          data.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot that contains the session data.</p>
    public let botId: Swift.String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: Swift.String?
    /// <p>The identifier of the session to delete.</p>
    public let sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteSessionInputBody: Swift.Equatable {
}

extension DeleteSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSessionOutputResponse(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), localeId: \(Swift.String(describing: localeId)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension DeleteSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAliasId = output.botAliasId
            self.botId = output.botId
            self.localeId = output.localeId
            self.sessionId = output.sessionId
        } else {
            self.botAliasId = nil
            self.botId = nil
            self.localeId = nil
            self.sessionId = nil
        }
    }
}

public struct DeleteSessionOutputResponse: Swift.Equatable {
    /// <p>The alias identifier in use for the bot that contained the session
    ///          data.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot that contained the session data.</p>
    public let botId: Swift.String?
    /// <p>The locale where the session was used.</p>
    public let localeId: Swift.String?
    /// <p>The identifier of the deleted session.</p>
    public let sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct DeleteSessionOutputResponseBody: Swift.Equatable {
    public let botId: Swift.String?
    public let botAliasId: Swift.String?
    public let localeId: Swift.String?
    public let sessionId: Swift.String?
}

extension DeleteSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAliasId
        case botId
        case localeId
        case sessionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botId)
        botId = botIdDecoded
        let botAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAliasId)
        botAliasId = botAliasIdDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension DependencyFailedException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DependencyFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependencyFailedException(message: \(Swift.String(describing: message)))"}
}

extension DependencyFailedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct DependencyFailedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DependencyFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.DialogAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case slotToElicit
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let slotToElicit = slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.DialogActionType.self, forKey: .type)
        type = typeDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
    }
}

extension LexRuntimeV2ClientTypes.DialogAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DialogAction(slotToElicit: \(Swift.String(describing: slotToElicit)), type: \(Swift.String(describing: type)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The next action that Amazon Lex should take.</p>
    public struct DialogAction: Swift.Equatable {
        /// <p>The name of the slot that should be elicited from the user.</p>
        public let slotToElicit: Swift.String?
        /// <p>The next action that the bot should take in its interaction with the
        ///          user. The possible values are:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Close</code> - Indicates that there will not be a
        ///                response from the user. For example, the statement "Your order
        ///                has been placed" does not require a response.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ConfirmIntent</code> - The next action is asking the
        ///                user if the intent is complete and ready to be fulfilled. This is
        ///                a yes/no question such as "Place the order?"</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Delegate</code> - The next action is determined by
        ///                Amazon Lex.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ElicitSlot</code> - The next action is to elicit a slot
        ///                value from the user.</p>
        ///             </li>
        ///          </ul>
        public let type: LexRuntimeV2ClientTypes.DialogActionType?

        public init (
            slotToElicit: Swift.String? = nil,
            type: LexRuntimeV2ClientTypes.DialogActionType? = nil
        )
        {
            self.slotToElicit = slotToElicit
            self.type = type
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum DialogActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case close
        case confirmIntent
        case delegate
        case elicitIntent
        case elicitSlot
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogActionType] {
            return [
                .close,
                .confirmIntent,
                .delegate,
                .elicitIntent,
                .elicitSlot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .close: return "Close"
            case .confirmIntent: return "ConfirmIntent"
            case .delegate: return "Delegate"
            case .elicitIntent: return "ElicitIntent"
            case .elicitSlot: return "ElicitSlot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DialogActionType(rawValue: rawValue) ?? DialogActionType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.DisconnectionEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.DisconnectionEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectionEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), eventId: \(Swift.String(describing: eventId)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>A notification from the client that it is disconnecting from Amazon Lex.
    ///          Sending a <code>DisconnectionEvent</code> event is optional, but can
    ///          help identify a conversation in logs.</p>
    public struct DisconnectionEvent: Swift.Equatable {
        /// <p>A timestamp set by the client of the date and time that the event
        ///          was sent to Amazon Lex.</p>
        public let clientTimestampMillis: Swift.Int
        /// <p>A unique identifier that your application assigns to the event. You
        ///          can use this to identify events in logs.</p>
        public let eventId: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
        }
    }

}

extension GetSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), localeId: \(Swift.String(describing: localeId)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension GetSessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionOutputError>
}

public struct GetSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionOutputError>
}

public struct GetSessionInput: Swift.Equatable {
    /// <p>The alias identifier in use for the bot that contains the session
    ///          data.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot that contains the session data.</p>
    public let botId: Swift.String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: Swift.String?
    /// <p>The identifier of the session to return.</p>
    public let sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionOutputResponse(interpretations: \(Swift.String(describing: interpretations)), messages: \(Swift.String(describing: messages)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension GetSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interpretations = output.interpretations
            self.messages = output.messages
            self.sessionId = output.sessionId
            self.sessionState = output.sessionState
        } else {
            self.interpretations = nil
            self.messages = nil
            self.sessionId = nil
            self.sessionState = nil
        }
    }
}

public struct GetSessionOutputResponse: Swift.Equatable {
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance. </p>
    ///          <p>Each interpretation includes the intent, a score that indicates how
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    /// <p>A list of messages that were last sent to the user. The messages are
    ///          ordered based on the order that your returned the messages from your
    ///          Lambda function or the order that messages are defined in the bot.
    ///       </p>
    public let messages: [LexRuntimeV2ClientTypes.Message]?
    /// <p>The identifier of the returned session.</p>
    public let sessionId: Swift.String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot.</p>
    ///          <p>You can use this to determine the progress of the conversation and
    ///          what the next action might be.</p>
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?

    public init (
        interpretations: [LexRuntimeV2ClientTypes.Interpretation]? = nil,
        messages: [LexRuntimeV2ClientTypes.Message]? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
    )
    {
        self.interpretations = interpretations
        self.messages = messages
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct GetSessionOutputResponseBody: Swift.Equatable {
    public let sessionId: Swift.String?
    public let messages: [LexRuntimeV2ClientTypes.Message]?
    public let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?
}

extension GetSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretations
        case messages
        case sessionId
        case sessionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let interpretationsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[LexRuntimeV2ClientTypes.Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [LexRuntimeV2ClientTypes.Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
    }
}

extension LexRuntimeV2ClientTypes.HeartbeatEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.HeartbeatEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HeartbeatEvent(eventId: \(Swift.String(describing: eventId)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Event that Amazon Lex sends to indicate that the stream is still open
    ///          between the client application and Amazon Lex </p>
    public struct HeartbeatEvent: Swift.Equatable {
        /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
        ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
        ///          and incremented for each event sent by Amazon Lex in the current
        ///          session.</p>
        public let eventId: Swift.String?

        public init (
            eventId: Swift.String? = nil
        )
        {
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.ImageResponseCard: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buttons
        case imageUrl
        case subtitle
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for buttonslist0 in buttons {
                try buttonsContainer.encode(buttonslist0)
            }
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subtitle = subtitle {
            try encodeContainer.encode(subtitle, forKey: .subtitle)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subtitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subtitle)
        subtitle = subtitleDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Button?].self, forKey: .buttons)
        var buttonsDecoded0:[LexRuntimeV2ClientTypes.Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [LexRuntimeV2ClientTypes.Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension LexRuntimeV2ClientTypes.ImageResponseCard: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageResponseCard(buttons: \(Swift.String(describing: buttons)), imageUrl: \(Swift.String(describing: imageUrl)), subtitle: \(Swift.String(describing: subtitle)), title: \(Swift.String(describing: title)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>A card that is shown to the user by a messaging platform. You define
    ///          the contents of the card, the card is displayed by the platform. </p>
    ///          <p>When you use a response card, the response from the user is
    ///          constrained to the text associated with a button on the card.</p>
    public struct ImageResponseCard: Swift.Equatable {
        /// <p>A list of buttons that should be displayed on the response card. The
        ///          arrangement of the buttons is determined by the platform that displays
        ///          the button.</p>
        public let buttons: [LexRuntimeV2ClientTypes.Button]?
        /// <p>The URL of an image to display on the response card. The image URL
        ///          must be publicly available so that the platform displaying the response
        ///          card has access to the image.</p>
        public let imageUrl: Swift.String?
        /// <p>The subtitle to display on the response card. The format of the
        ///          subtitle is determined by the platform displaying the response
        ///          card.</p>
        public let subtitle: Swift.String?
        /// <p>The title to display on the response card. The format of the title
        ///          is determined by the platform displaying the response card.</p>
        public let title: Swift.String?

        public init (
            buttons: [LexRuntimeV2ClientTypes.Button]? = nil,
            imageUrl: Swift.String? = nil,
            subtitle: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subtitle = subtitle
            self.title = title
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum InputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dtmf
        case speech
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [InputMode] {
            return [
                .dtmf,
                .speech,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dtmf: return "DTMF"
            case .speech: return "Speech"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InputMode(rawValue: rawValue) ?? InputMode.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.Intent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationState
        case name
        case slots
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confirmationState = confirmationState {
            try encodeContainer.encode(confirmationState.rawValue, forKey: .confirmationState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, slots0) in slots {
                try slotsContainer.encode(slots0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: LexRuntimeV2ClientTypes.Slot?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:LexRuntimeV2ClientTypes.Slot]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:LexRuntimeV2ClientTypes.Slot]()
            for (key0, slot0) in slotsContainer {
                if let slot0 = slot0 {
                    slotsDecoded0?[key0] = slot0
                }
            }
        }
        slots = slotsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.IntentState.self, forKey: .state)
        state = stateDecoded
        let confirmationStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ConfirmationState.self, forKey: .confirmationState)
        confirmationState = confirmationStateDecoded
    }
}

extension LexRuntimeV2ClientTypes.Intent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Intent(confirmationState: \(Swift.String(describing: confirmationState)), name: \(Swift.String(describing: name)), slots: \(Swift.String(describing: slots)), state: \(Swift.String(describing: state)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The current intent that Amazon Lex is attempting to fulfill.</p>
    public struct Intent: Swift.Equatable {
        /// <p>Contains information about whether fulfillment of the intent has
        ///          been confirmed.</p>
        public let confirmationState: LexRuntimeV2ClientTypes.ConfirmationState?
        /// <p>The name of the intent.</p>
        public let name: Swift.String?
        /// <p>A map of all of the slots for the intent. The name of the slot maps
        ///          to the value of the slot. If a slot has not been filled, the value is
        ///          null.</p>
        public let slots: [Swift.String:LexRuntimeV2ClientTypes.Slot]?
        /// <p>Contains fulfillment information for the intent. </p>
        public let state: LexRuntimeV2ClientTypes.IntentState?

        public init (
            confirmationState: LexRuntimeV2ClientTypes.ConfirmationState? = nil,
            name: Swift.String? = nil,
            slots: [Swift.String:LexRuntimeV2ClientTypes.Slot]? = nil,
            state: LexRuntimeV2ClientTypes.IntentState? = nil
        )
        {
            self.confirmationState = confirmationState
            self.name = name
            self.slots = slots
            self.state = state
        }
    }

}

extension LexRuntimeV2ClientTypes.IntentResultEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case inputMode
        case interpretations
        case requestAttributes
        case sessionId
        case sessionState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let inputMode = inputMode {
            try encodeContainer.encode(inputMode.rawValue, forKey: .inputMode)
        }
        if let interpretations = interpretations {
            var interpretationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .interpretations)
            for interpretations0 in interpretations {
                try interpretationsContainer.encode(interpretations0)
            }
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputModeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.InputMode.self, forKey: .inputMode)
        inputMode = inputModeDecoded
        let interpretationsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[LexRuntimeV2ClientTypes.Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [LexRuntimeV2ClientTypes.Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.IntentResultEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntentResultEvent(eventId: \(Swift.String(describing: eventId)), inputMode: \(Swift.String(describing: inputMode)), interpretations: \(Swift.String(describing: interpretations)), requestAttributes: \(Swift.String(describing: requestAttributes)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Contains the current state of the conversation between the client
    ///          application and Amazon Lex.</p>
    public struct IntentResultEvent: Swift.Equatable {
        /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
        ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
        ///          and incremented for each event sent by Amazon Lex in the current
        ///          session.</p>
        public let eventId: Swift.String?
        /// <p>Indicates whether the input to the operation was text or speech.</p>
        public let inputMode: LexRuntimeV2ClientTypes.InputMode?
        /// <p>A list of intents that Amazon Lex determined might satisfy the user's
        ///          utterance.</p>
        ///
        ///          <p>Each interpretation includes the intent, a score that indicates how
        ///          confident Amazon Lex is that the interpretation is the correct one, and an
        ///          optional sentiment response that indicates the sentiment expressed in
        ///          the utterance.</p>
        public let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
        /// <p>The attributes sent in the request.</p>
        public let requestAttributes: [Swift.String:Swift.String]?
        /// <p>The identifier of the session in use.</p>
        public let sessionId: Swift.String?
        /// <p>The state of the user's session with Amazon Lex.</p>
        public let sessionState: LexRuntimeV2ClientTypes.SessionState?

        public init (
            eventId: Swift.String? = nil,
            inputMode: LexRuntimeV2ClientTypes.InputMode? = nil,
            interpretations: [LexRuntimeV2ClientTypes.Interpretation]? = nil,
            requestAttributes: [Swift.String:Swift.String]? = nil,
            sessionId: Swift.String? = nil,
            sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
        )
        {
            self.eventId = eventId
            self.inputMode = inputMode
            self.interpretations = interpretations
            self.requestAttributes = requestAttributes
            self.sessionId = sessionId
            self.sessionState = sessionState
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum IntentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case fulfilled
        case inProgress
        case readyForFulfillment
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [IntentState] {
            return [
                .failed,
                .fulfilled,
                .inProgress,
                .readyForFulfillment,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .inProgress: return "InProgress"
            case .readyForFulfillment: return "ReadyForFulfillment"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntentState(rawValue: rawValue) ?? IntentState.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.Interpretation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intent
        case nluConfidence
        case sentimentResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intent = intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let nluConfidence = nluConfidence {
            try encodeContainer.encode(nluConfidence, forKey: .nluConfidence)
        }
        if let sentimentResponse = sentimentResponse {
            try encodeContainer.encode(sentimentResponse, forKey: .sentimentResponse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nluConfidenceDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ConfidenceScore.self, forKey: .nluConfidence)
        nluConfidence = nluConfidenceDecoded
        let sentimentResponseDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SentimentResponse.self, forKey: .sentimentResponse)
        sentimentResponse = sentimentResponseDecoded
        let intentDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Intent.self, forKey: .intent)
        intent = intentDecoded
    }
}

extension LexRuntimeV2ClientTypes.Interpretation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Interpretation(intent: \(Swift.String(describing: intent)), nluConfidence: \(Swift.String(describing: nluConfidence)), sentimentResponse: \(Swift.String(describing: sentimentResponse)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>An intent that Amazon Lex determined might satisfy the user's utterance.
    ///          The intents are ordered by the confidence score. </p>
    public struct Interpretation: Swift.Equatable {
        /// <p>A list of intents that might satisfy the user's utterance. The
        ///          intents are ordered by the confidence score.</p>
        public let intent: LexRuntimeV2ClientTypes.Intent?
        /// <p>Determines the threshold where Amazon Lex will insert the
        ///             <code>AMAZON.FallbackIntent</code>,
        ///             <code>AMAZON.KendraSearchIntent</code>, or both when returning
        ///          alternative intents in a response. <code>AMAZON.FallbackIntent</code>
        ///          and <code>AMAZON.KendraSearchIntent</code> are only inserted if they
        ///          are configured for the bot.</p>
        public let nluConfidence: LexRuntimeV2ClientTypes.ConfidenceScore?
        /// <p>The sentiment expressed in an utterance. </p>
        ///          <p>When the bot is configured to send utterances to Amazon Comprehend
        ///          for sentiment analysis, this field contains the result of the
        ///          analysis.</p>
        public let sentimentResponse: LexRuntimeV2ClientTypes.SentimentResponse?

        public init (
            intent: LexRuntimeV2ClientTypes.Intent? = nil,
            nluConfidence: LexRuntimeV2ClientTypes.ConfidenceScore? = nil,
            sentimentResponse: LexRuntimeV2ClientTypes.SentimentResponse? = nil
        )
        {
            self.intent = intent
            self.nluConfidence = nluConfidence
            self.sentimentResponse = sentimentResponse
        }
    }

}

extension LexRuntimeV2ClientTypes.Message: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case contentType
        case imageResponseCard
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let imageResponseCard = imageResponseCard {
            try encodeContainer.encode(imageResponseCard, forKey: .imageResponseCard)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.MessageContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let imageResponseCardDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.ImageResponseCard.self, forKey: .imageResponseCard)
        imageResponseCard = imageResponseCardDecoded
    }
}

extension LexRuntimeV2ClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), imageResponseCard: \(Swift.String(describing: imageResponseCard)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Container for text that is returned to the customer..</p>
    public struct Message: Swift.Equatable {
        /// <p>The text of the message.</p>
        public let content: Swift.String?
        /// <p>Indicates the type of response.</p>
        public let contentType: LexRuntimeV2ClientTypes.MessageContentType?
        /// <p>A card that is shown to the user by a messaging platform. You define
        ///          the contents of the card, the card is displayed by the platform. </p>
        ///          <p>When you use a response card, the response from the user is
        ///          constrained to the text associated with a button on the card.</p>
        public let imageResponseCard: LexRuntimeV2ClientTypes.ImageResponseCard?

        public init (
            content: Swift.String? = nil,
            contentType: LexRuntimeV2ClientTypes.MessageContentType? = nil,
            imageResponseCard: LexRuntimeV2ClientTypes.ImageResponseCard? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.imageResponseCard = imageResponseCard
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum MessageContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customPayload
        case imageResponseCard
        case plainText
        case ssml
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageContentType] {
            return [
                .customPayload,
                .imageResponseCard,
                .plainText,
                .ssml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customPayload: return "CustomPayload"
            case .imageResponseCard: return "ImageResponseCard"
            case .plainText: return "PlainText"
            case .ssml: return "SSML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageContentType(rawValue: rawValue) ?? MessageContentType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.PlaybackCompletionEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.PlaybackCompletionEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaybackCompletionEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), eventId: \(Swift.String(describing: eventId)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Event sent from the client application to Amazon Lex to indicate that
    ///          playback of audio is complete and that Amazon Lex should start processing
    ///          the user's input.</p>
    public struct PlaybackCompletionEvent: Swift.Equatable {
        /// <p>A timestamp set by the client of the date and time that the event
        ///          was sent to Amazon Lex.</p>
        public let clientTimestampMillis: Swift.Int
        /// <p>A unique identifier that your application assigns to the event. You
        ///          can use this to identify events in logs.</p>
        public let eventId: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
        }
    }

}

extension LexRuntimeV2ClientTypes.PlaybackInterruptionEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case causedByEventId
        case eventId
        case eventReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causedByEventId = causedByEventId {
            try encodeContainer.encode(causedByEventId, forKey: .causedByEventId)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventReason = eventReason {
            try encodeContainer.encode(eventReason.rawValue, forKey: .eventReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventReasonDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.PlaybackInterruptionReason.self, forKey: .eventReason)
        eventReason = eventReasonDecoded
        let causedByEventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causedByEventId)
        causedByEventId = causedByEventIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.PlaybackInterruptionEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlaybackInterruptionEvent(causedByEventId: \(Swift.String(describing: causedByEventId)), eventId: \(Swift.String(describing: eventId)), eventReason: \(Swift.String(describing: eventReason)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Event sent from Amazon Lex to indicate to the client application should
    ///          stop playback of audio. For example, if the client is playing a prompt
    ///          that asks for the user's telephone number, the user might start to say
    ///          the phone number before the prompt is complete. Amazon Lex sends this event
    ///          to the client application to indicate that the user is responding and
    ///          that Amazon Lex is processing their input.</p>
    public struct PlaybackInterruptionEvent: Swift.Equatable {
        /// <p>The identifier of the event that contained the audio, DTMF, or text
        ///          that caused the interruption.</p>
        public let causedByEventId: Swift.String?
        /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
        ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
        ///          and incremented for each event sent by Amazon Lex in the current
        ///          session.</p>
        public let eventId: Swift.String?
        /// <p>Indicates the type of user input that Amazon Lex detected.</p>
        public let eventReason: LexRuntimeV2ClientTypes.PlaybackInterruptionReason?

        public init (
            causedByEventId: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventReason: LexRuntimeV2ClientTypes.PlaybackInterruptionReason? = nil
        )
        {
            self.causedByEventId = causedByEventId
            self.eventId = eventId
            self.eventReason = eventReason
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum PlaybackInterruptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dtmfStartDetected
        case textDetected
        case voiceStartDetected
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaybackInterruptionReason] {
            return [
                .dtmfStartDetected,
                .textDetected,
                .voiceStartDetected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dtmfStartDetected: return "DTMF_START_DETECTED"
            case .textDetected: return "TEXT_DETECTED"
            case .voiceStartDetected: return "VOICE_START_DETECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlaybackInterruptionReason(rawValue: rawValue) ?? PlaybackInterruptionReason.sdkUnknown(rawValue)
        }
    }
}

public struct PutSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSessionOutputError>
}

extension PutSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSessionInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), localeId: \(Swift.String(describing: localeId)), messages: \(Swift.String(describing: messages)), requestAttributes: \(Swift.String(describing: requestAttributes)), responseContentType: \(Swift.String(describing: responseContentType)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension PutSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case requestAttributes
        case sessionState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
    }
}

public struct PutSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let responseContentType = input.operationInput.responseContentType {
            input.builder.withHeader(name: "ResponseContentType", value: Swift.String(responseContentType))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSessionOutputError>
}

public struct PutSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutSessionOutputError>
}

public struct PutSessionInput: Swift.Equatable {
    /// <p>The alias identifier of the bot that receives the session
    ///          data.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot that receives the session data.</p>
    public let botId: Swift.String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: Swift.String?
    /// <p>A list of messages to send to the user. Messages are sent in the
    ///          order that they are defined in the list.</p>
    public let messages: [LexRuntimeV2ClientTypes.Message]?
    /// <p>Request-specific information passed between Amazon Lex and the client
    ///          application.</p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes with the prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: [Swift.String:Swift.String]?
    /// <p>The message that Amazon Lex returns in the response can be either text or
    ///          speech depending on the value of this parameter. </p>
    ///          <ul>
    ///             <li>
    ///                <p>If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex
    ///                returns text in the response.</p>
    ///             </li>
    ///          </ul>
    public let responseContentType: Swift.String?
    /// <p>The identifier of the session that receives the session data.</p>
    public let sessionId: Swift.String?
    /// <p>Sets the state of the session with the user. You can use this to set
    ///          the current intent, attributes, context, and dialog action. Use the
    ///          dialog action to determine the next step that Amazon Lex should use in the
    ///          conversation with the user.</p>
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        messages: [LexRuntimeV2ClientTypes.Message]? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        responseContentType: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.responseContentType = responseContentType
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct PutSessionInputBody: Swift.Equatable {
    public let messages: [LexRuntimeV2ClientTypes.Message]?
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?
    public let requestAttributes: [Swift.String:Swift.String]?
}

extension PutSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
        case requestAttributes
        case sessionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
    }
}

extension PutSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSessionOutputResponse(audioStream: \(Swift.String(describing: audioStream)), contentType: \(Swift.String(describing: contentType)), messages: \(Swift.String(describing: messages)), requestAttributes: \(Swift.String(describing: requestAttributes)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension PutSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let messagesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-messages") {
            self.messages = messagesHeaderValue
        } else {
            self.messages = nil
        }
        if let requestAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-request-attributes") {
            self.requestAttributes = requestAttributesHeaderValue
        } else {
            self.requestAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let sessionStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-state") {
            self.sessionState = sessionStateHeaderValue
        } else {
            self.sessionState = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.audioStream = data
        } else {
            self.audioStream = nil
        }
    }
}

public struct PutSessionOutputResponse: Swift.Equatable {
    /// <p>If the requested content type was audio, the audio version of the
    ///          message to convey to the user.</p>
    public let audioStream: ClientRuntime.ByteStream?
    /// <p>The type of response. Same as the type specified in the
    ///             <code>responseContentType</code> field in the request.</p>
    public let contentType: Swift.String?
    /// <p>A list of messages that were last sent to the user. The messages are
    ///          ordered based on how you return the messages from you Lambda function
    ///          or the order that the messages are defined in the bot.</p>
    public let messages: Swift.String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex. These are the same as the <code>requestAttribute</code>
    ///          parameter in the call to the <code>PutSession</code> operation.</p>
    public let requestAttributes: Swift.String?
    /// <p>The identifier of the session that received the data.</p>
    public let sessionId: Swift.String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot.</p>
    ///          <p>Use this to determine the progress of the conversation and what the
    ///          next action may be.</p>
    public let sessionState: Swift.String?

    public init (
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        messages: Swift.String? = nil,
        requestAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: Swift.String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct PutSessionOutputResponseBody: Swift.Equatable {
    public let audioStream: ClientRuntime.ByteStream?
}

extension PutSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

public struct RecognizeTextInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeTextInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RecognizeTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RecognizeTextOutputError>
}

extension RecognizeTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecognizeTextInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), localeId: \(Swift.String(describing: localeId)), requestAttributes: \(Swift.String(describing: requestAttributes)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)), text: \(Swift.String(describing: text)))"}
}

extension RecognizeTextInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestAttributes
        case sessionState
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringmap0) in requestAttributes {
                try requestAttributesContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionState = sessionState {
            try encodeContainer.encode(sessionState, forKey: .sessionState)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

public struct RecognizeTextInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeTextInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RecognizeTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RecognizeTextOutputError>
}

public struct RecognizeTextInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeTextInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeTextInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RecognizeTextOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeTextInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeTextOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RecognizeTextOutputError>
}

public struct RecognizeTextInput: Swift.Equatable {
    /// <p>The alias identifier in use for the bot that processes the
    ///          request.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot that processes the request.</p>
    public let botId: Swift.String?
    /// <p>The locale where the session is in use.</p>
    public let localeId: Swift.String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex </p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes with the prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: [Swift.String:Swift.String]?
    /// <p>The identifier of the user session that is having the
    ///          conversation.</p>
    public let sessionId: Swift.String?
    /// <p>The current state of the dialog between the user and the bot.</p>
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?
    /// <p>The text that the user entered. Amazon Lex interprets this text.</p>
    public let text: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        localeId: Swift.String? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil,
        text: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.localeId = localeId
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
        self.text = text
    }
}

struct RecognizeTextInputBody: Swift.Equatable {
    public let text: Swift.String?
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?
    public let requestAttributes: [Swift.String:Swift.String]?
}

extension RecognizeTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestAttributes
        case sessionState
        case text
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
    }
}

extension RecognizeTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RecognizeTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RecognizeTextOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecognizeTextOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecognizeTextOutputResponse(interpretations: \(Swift.String(describing: interpretations)), messages: \(Swift.String(describing: messages)), requestAttributes: \(Swift.String(describing: requestAttributes)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension RecognizeTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RecognizeTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interpretations = output.interpretations
            self.messages = output.messages
            self.requestAttributes = output.requestAttributes
            self.sessionId = output.sessionId
            self.sessionState = output.sessionState
        } else {
            self.interpretations = nil
            self.messages = nil
            self.requestAttributes = nil
            self.sessionId = nil
            self.sessionState = nil
        }
    }
}

public struct RecognizeTextOutputResponse: Swift.Equatable {
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance. </p>
    ///          <p>Each interpretation includes the intent, a score that indicates now
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    /// <p>A list of messages last sent to the user. The messages are ordered
    ///          based on the order that you returned the messages from your Lambda
    ///          function or the order that the messages are defined in the bot.</p>
    public let messages: [LexRuntimeV2ClientTypes.Message]?
    /// <p>The attributes sent in the request.</p>
    public let requestAttributes: [Swift.String:Swift.String]?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: Swift.String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot. </p>
    ///          <p>Use this to determine the progress of the conversation and what the
    ///          next action may be.</p>
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?

    public init (
        interpretations: [LexRuntimeV2ClientTypes.Interpretation]? = nil,
        messages: [LexRuntimeV2ClientTypes.Message]? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        sessionId: Swift.String? = nil,
        sessionState: LexRuntimeV2ClientTypes.SessionState? = nil
    )
    {
        self.interpretations = interpretations
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeTextOutputResponseBody: Swift.Equatable {
    public let messages: [LexRuntimeV2ClientTypes.Message]?
    public let sessionState: LexRuntimeV2ClientTypes.SessionState?
    public let interpretations: [LexRuntimeV2ClientTypes.Interpretation]?
    public let requestAttributes: [Swift.String:Swift.String]?
    public let sessionId: Swift.String?
}

extension RecognizeTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretations
        case messages
        case requestAttributes
        case sessionId
        case sessionState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let sessionStateDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SessionState.self, forKey: .sessionState)
        sessionState = sessionStateDecoded
        let interpretationsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Interpretation?].self, forKey: .interpretations)
        var interpretationsDecoded0:[LexRuntimeV2ClientTypes.Interpretation]? = nil
        if let interpretationsContainer = interpretationsContainer {
            interpretationsDecoded0 = [LexRuntimeV2ClientTypes.Interpretation]()
            for structure0 in interpretationsContainer {
                if let structure0 = structure0 {
                    interpretationsDecoded0?.append(structure0)
                }
            }
        }
        interpretations = interpretationsDecoded0
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

public struct RecognizeUtteranceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeUtteranceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let inputStream = input.operationInput.inputStream {
            let inputStreamdata = inputStream
            let inputStreambody = ClientRuntime.HttpBody.stream(inputStreamdata)
            input.builder.withBody(inputStreambody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RecognizeUtteranceOutputError>
}

extension RecognizeUtteranceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecognizeUtteranceInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), inputStream: \(Swift.String(describing: inputStream)), localeId: \(Swift.String(describing: localeId)), requestAttributes: \(Swift.String(describing: requestAttributes)), requestContentType: \(Swift.String(describing: requestContentType)), responseContentType: \(Swift.String(describing: responseContentType)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension RecognizeUtteranceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStream = inputStream {
            try encodeContainer.encode(inputStream.toBytes().toData(), forKey: .inputStream)
        }
    }
}

public struct RecognizeUtteranceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeUtteranceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let requestAttributes = input.operationInput.requestAttributes {
            input.builder.withHeader(name: "x-amz-lex-request-attributes", value: Swift.String(requestAttributes))
        }
        if let requestContentType = input.operationInput.requestContentType {
            input.builder.withHeader(name: "Content-Type", value: Swift.String(requestContentType))
        }
        if let responseContentType = input.operationInput.responseContentType {
            input.builder.withHeader(name: "Response-Content-Type", value: Swift.String(responseContentType))
        }
        if let sessionState = input.operationInput.sessionState {
            input.builder.withHeader(name: "x-amz-lex-session-state", value: Swift.String(sessionState))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RecognizeUtteranceOutputError>
}

public struct RecognizeUtteranceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RecognizeUtteranceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RecognizeUtteranceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RecognizeUtteranceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RecognizeUtteranceOutputError>
}

public struct RecognizeUtteranceInput: Swift.Equatable {
    /// <p>The alias identifier in use for the bot that should receive the
    ///          request.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot that should receive the request.</p>
    public let botId: Swift.String?
    /// <p>User input in PCM or Opus audio format or text format as described
    ///          in the <code>requestContentType</code> parameter.</p>
    public let inputStream: ClientRuntime.ByteStream?
    /// <p>The locale where the session is in use.</p>
    public let localeId: Swift.String?
    /// <p>Request-specific information passed between the client application
    ///          and Amazon Lex </p>
    ///          <p>The namespace <code>x-amz-lex:</code> is reserved for special
    ///          attributes. Don't create any request attributes for prefix
    ///             <code>x-amz-lex:</code>.</p>
    public let requestAttributes: Swift.String?
    /// <p>Indicates the format for audio input or that the content is text.
    ///          The header must start with one of the following prefixes:</p>
    ///          <ul>
    ///             <li>
    ///                <p>PCM format, audio data must be in little-endian byte
    ///                order.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/l16; rate=16000; channels=1</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/x-l16; sample-rate=16000; channel-count=1</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/lpcm; sample-rate=8000; sample-size-bits=16;
    ///                      channel-count=1; is-big-endian=false</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Opus format</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>Text format</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let requestContentType: Swift.String?
    /// <p>The message that Amazon Lex returns in the response can be either text or
    ///          speech based on the <code>responseContentType</code> value.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If the value is <code>text/plain;charset=utf-8</code>, Amazon Lex
    ///                returns text in the response.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value begins with <code>audio/</code>, Amazon Lex returns
    ///                speech in the response. Amazon Lex uses Amazon Polly to generate the speech
    ///                using the configuration that you specified in the
    ///                   <code>requestContentType</code> parameter. For example, if you
    ///                specify <code>audio/mpeg</code> as the value, Amazon Lex returns
    ///                speech in the MPEG format.</p>
    ///             </li>
    ///             <li>
    ///                <p>If the value is <code>audio/pcm</code>, the speech returned is
    ///                   <code>audio/pcm</code> at 16 KHz in 16-bit, little-endian
    ///                format.</p>
    ///             </li>
    ///             <li>
    ///                <p>The following are the accepted values:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>audio/mpeg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/ogg</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/pcm (16 KHz)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>audio/* (defaults to mpeg)</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>text/plain; charset=utf-8</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let responseContentType: Swift.String?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: Swift.String?
    /// <p>Sets the state of the session with the user. You can use this to set
    ///          the current intent, attributes, context, and dialog action. Use the
    ///          dialog action to determine the next step that Amazon Lex should use in the
    ///          conversation with the user.</p>
    public let sessionState: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        inputStream: ClientRuntime.ByteStream? = nil,
        localeId: Swift.String? = nil,
        requestAttributes: Swift.String? = nil,
        requestContentType: Swift.String? = nil,
        responseContentType: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.inputStream = inputStream
        self.localeId = localeId
        self.requestAttributes = requestAttributes
        self.requestContentType = requestContentType
        self.responseContentType = responseContentType
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeUtteranceInputBody: Swift.Equatable {
    public let inputStream: ClientRuntime.ByteStream?
}

extension RecognizeUtteranceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .inputStream)
        inputStream = inputStreamDecoded
    }
}

extension RecognizeUtteranceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RecognizeUtteranceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RecognizeUtteranceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badGatewayException(BadGatewayException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RecognizeUtteranceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecognizeUtteranceOutputResponse(audioStream: \(Swift.String(describing: audioStream)), contentType: \(Swift.String(describing: contentType)), inputMode: \(Swift.String(describing: inputMode)), inputTranscript: \(Swift.String(describing: inputTranscript)), interpretations: \(Swift.String(describing: interpretations)), messages: \(Swift.String(describing: messages)), requestAttributes: \(Swift.String(describing: requestAttributes)), sessionId: \(Swift.String(describing: sessionId)), sessionState: \(Swift.String(describing: sessionState)))"}
}

extension RecognizeUtteranceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let inputModeHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-mode") {
            self.inputMode = inputModeHeaderValue
        } else {
            self.inputMode = nil
        }
        if let inputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-transcript") {
            self.inputTranscript = inputTranscriptHeaderValue
        } else {
            self.inputTranscript = nil
        }
        if let interpretationsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-interpretations") {
            self.interpretations = interpretationsHeaderValue
        } else {
            self.interpretations = nil
        }
        if let messagesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-messages") {
            self.messages = messagesHeaderValue
        } else {
            self.messages = nil
        }
        if let requestAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-request-attributes") {
            self.requestAttributes = requestAttributesHeaderValue
        } else {
            self.requestAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let sessionStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-state") {
            self.sessionState = sessionStateHeaderValue
        } else {
            self.sessionState = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.audioStream = data
        } else {
            self.audioStream = nil
        }
    }
}

public struct RecognizeUtteranceOutputResponse: Swift.Equatable {
    /// <p>The prompt or statement to send to the user. This is based on the
    ///          bot configuration and context. For example, if Amazon Lex did not understand
    ///          the user intent, it sends the <code>clarificationPrompt</code>
    ///          configured for the bot. If the intent requires confirmation before
    ///          taking the fulfillment action, it sends the
    ///             <code>confirmationPrompt</code>. Another example: Suppose that the
    ///          Lambda function successfully fulfilled the intent, and sent a message
    ///          to convey to the user. Then Amazon Lex sends that message in the
    ///          response.</p>
    public let audioStream: ClientRuntime.ByteStream?
    /// <p>Content type as specified in the <code>responseContentType</code> in
    ///          the request.</p>
    public let contentType: Swift.String?
    /// <p>Indicates whether the input mode to the operation was text or
    ///          speech.
    ///       </p>
    public let inputMode: Swift.String?
    /// <p>The text used to process the request.</p>
    ///          <p>If the input was an audio stream, the <code>inputTranscript</code>
    ///          field contains the text extracted from the audio stream. This is the
    ///          text that is actually processed to recognize intents and slot values.
    ///          You can use this information to determine if Amazon Lex is correctly
    ///          processing the audio that you send.</p>
    public let inputTranscript: Swift.String?
    /// <p>A list of intents that Amazon Lex determined might satisfy the user's
    ///          utterance.</p>
    ///          <p>Each interpretation includes the intent, a score that indicates how
    ///          confident Amazon Lex is that the interpretation is the correct one, and an
    ///          optional sentiment response that indicates the sentiment expressed in
    ///          the utterance.</p>
    public let interpretations: Swift.String?
    /// <p>A list of messages that were last sent to the user. The messages are
    ///          ordered based on the order that you returned the messages from your
    ///          Lambda function or the order that the messages are defined in the
    ///          bot.</p>
    public let messages: Swift.String?
    /// <p>The attributes sent in the request.</p>
    public let requestAttributes: Swift.String?
    /// <p>The identifier of the session in use.</p>
    public let sessionId: Swift.String?
    /// <p>Represents the current state of the dialog between the user and the
    ///          bot.</p>
    ///          <p>Use this to determine the progress of the conversation and what the
    ///          next action might be.</p>
    public let sessionState: Swift.String?

    public init (
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        inputMode: Swift.String? = nil,
        inputTranscript: Swift.String? = nil,
        interpretations: Swift.String? = nil,
        messages: Swift.String? = nil,
        requestAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        sessionState: Swift.String? = nil
    )
    {
        self.audioStream = audioStream
        self.contentType = contentType
        self.inputMode = inputMode
        self.inputTranscript = inputTranscript
        self.interpretations = interpretations
        self.messages = messages
        self.requestAttributes = requestAttributes
        self.sessionId = sessionId
        self.sessionState = sessionState
    }
}

struct RecognizeUtteranceOutputResponseBody: Swift.Equatable {
    public let audioStream: ClientRuntime.ByteStream?
}

extension RecognizeUtteranceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension ResourceNotFoundException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.SentimentResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sentiment
        case sentimentScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sentiment = sentiment {
            try encodeContainer.encode(sentiment.rawValue, forKey: .sentiment)
        }
        if let sentimentScore = sentimentScore {
            try encodeContainer.encode(sentimentScore, forKey: .sentimentScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SentimentType.self, forKey: .sentiment)
        sentiment = sentimentDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.SentimentScore.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

extension LexRuntimeV2ClientTypes.SentimentResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SentimentResponse(sentiment: \(Swift.String(describing: sentiment)), sentimentScore: \(Swift.String(describing: sentimentScore)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Provides information about the sentiment expressed in a user's
    ///          response in a conversation. Sentiments are determined using Amazon
    ///          Comprehend. Sentiments are only returned if they are enabled for the
    ///          bot.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/comprehend/latest/dg/how-sentiment.html">
    ///             Determine Sentiment </a> in the <i>Amazon Comprehend
    ///             developer guide</i>.</p>
    public struct SentimentResponse: Swift.Equatable {
        /// <p>The overall sentiment expressed in the user's response. This is the
        ///          sentiment most likely expressed by the user based on the analysis by
        ///          Amazon Comprehend.</p>
        public let sentiment: LexRuntimeV2ClientTypes.SentimentType?
        /// <p>The individual sentiment responses for the utterance.</p>
        public let sentimentScore: LexRuntimeV2ClientTypes.SentimentScore?

        public init (
            sentiment: LexRuntimeV2ClientTypes.SentimentType? = nil,
            sentimentScore: LexRuntimeV2ClientTypes.SentimentScore? = nil
        )
        {
            self.sentiment = sentiment
            self.sentimentScore = sentimentScore
        }
    }

}

extension LexRuntimeV2ClientTypes.SentimentScore: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mixed
        case negative
        case neutral
        case positive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if mixed != 0.0 {
            try encodeContainer.encode(mixed, forKey: .mixed)
        }
        if negative != 0.0 {
            try encodeContainer.encode(negative, forKey: .negative)
        }
        if neutral != 0.0 {
            try encodeContainer.encode(neutral, forKey: .neutral)
        }
        if positive != 0.0 {
            try encodeContainer.encode(positive, forKey: .positive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positiveDecoded = try containerValues.decode(Swift.Double.self, forKey: .positive)
        positive = positiveDecoded
        let negativeDecoded = try containerValues.decode(Swift.Double.self, forKey: .negative)
        negative = negativeDecoded
        let neutralDecoded = try containerValues.decode(Swift.Double.self, forKey: .neutral)
        neutral = neutralDecoded
        let mixedDecoded = try containerValues.decode(Swift.Double.self, forKey: .mixed)
        mixed = mixedDecoded
    }
}

extension LexRuntimeV2ClientTypes.SentimentScore: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SentimentScore(mixed: \(Swift.String(describing: mixed)), negative: \(Swift.String(describing: negative)), neutral: \(Swift.String(describing: neutral)), positive: \(Swift.String(describing: positive)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The individual sentiment responses for the utterance.</p>
    public struct SentimentScore: Swift.Equatable {
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy
        ///          of its detection of the <code>MIXED</code> sentiment.</p>
        public let mixed: Swift.Double
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy
        ///          of its detection of the <code>NEGATIVE</code> sentiment.</p>
        public let negative: Swift.Double
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy
        ///          of its detection of the <code>NEUTRAL</code> sentiment.</p>
        public let neutral: Swift.Double
        /// <p>The level of confidence that Amazon Comprehend has in the accuracy
        ///          of its detection of the <code>POSITIVE</code> sentiment.</p>
        public let positive: Swift.Double

        public init (
            mixed: Swift.Double = 0.0,
            negative: Swift.Double = 0.0,
            neutral: Swift.Double = 0.0,
            positive: Swift.Double = 0.0
        )
        {
            self.mixed = mixed
            self.negative = negative
            self.neutral = neutral
            self.positive = positive
        }
    }

}

extension LexRuntimeV2ClientTypes {
    public enum SentimentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mixed
        case negative
        case neutral
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [SentimentType] {
            return [
                .mixed,
                .negative,
                .neutral,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mixed: return "MIXED"
            case .negative: return "NEGATIVE"
            case .neutral: return "NEUTRAL"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SentimentType(rawValue: rawValue) ?? SentimentType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeV2ClientTypes.SessionState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case dialogAction
        case intent
        case originatingRequestId
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontextslist0 in activeContexts {
                try activeContextsContainer.encode(activecontextslist0)
            }
        }
        if let dialogAction = dialogAction {
            try encodeContainer.encode(dialogAction, forKey: .dialogAction)
        }
        if let intent = intent {
            try encodeContainer.encode(intent, forKey: .intent)
        }
        if let originatingRequestId = originatingRequestId {
            try encodeContainer.encode(originatingRequestId, forKey: .originatingRequestId)
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringmap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialogActionDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let intentDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Intent.self, forKey: .intent)
        intent = intentDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexRuntimeV2ClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexRuntimeV2ClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let originatingRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originatingRequestId)
        originatingRequestId = originatingRequestIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.SessionState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionState(activeContexts: \(Swift.String(describing: activeContexts)), dialogAction: \(Swift.String(describing: dialogAction)), intent: \(Swift.String(describing: intent)), originatingRequestId: \(Swift.String(describing: originatingRequestId)), sessionAttributes: \(Swift.String(describing: sessionAttributes)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The state of the user's session with Amazon Lex.</p>
    public struct SessionState: Swift.Equatable {
        /// <p>One or more contexts that indicate to Amazon Lex the context of a
        ///          request. When a context is active, Amazon Lex considers intents with the
        ///          matching context as a trigger as the next intent in a session.</p>
        public let activeContexts: [LexRuntimeV2ClientTypes.ActiveContext]?
        /// <p>The next step that Amazon Lex should take in the conversation with a
        ///          user.</p>
        public let dialogAction: LexRuntimeV2ClientTypes.DialogAction?
        /// <p>The active intent that Amazon Lex is processing.</p>
        public let intent: LexRuntimeV2ClientTypes.Intent?
        /// <p></p>
        public let originatingRequestId: Swift.String?
        /// <p>Map of key/value pairs representing session-specific context
        ///          information. It contains application information passed between Amazon Lex
        ///          and a client application.</p>
        public let sessionAttributes: [Swift.String:Swift.String]?

        public init (
            activeContexts: [LexRuntimeV2ClientTypes.ActiveContext]? = nil,
            dialogAction: LexRuntimeV2ClientTypes.DialogAction? = nil,
            intent: LexRuntimeV2ClientTypes.Intent? = nil,
            originatingRequestId: Swift.String? = nil,
            sessionAttributes: [Swift.String:Swift.String]? = nil
        )
        {
            self.activeContexts = activeContexts
            self.dialogAction = dialogAction
            self.intent = intent
            self.originatingRequestId = originatingRequestId
            self.sessionAttributes = sessionAttributes
        }
    }

}

extension LexRuntimeV2ClientTypes.Slot: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.Value.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexRuntimeV2ClientTypes.Slot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Slot(value: \(Swift.String(describing: value)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>A value that Amazon Lex uses to fulfill an intent. </p>
    public struct Slot: Swift.Equatable {
        /// <p>The current value of the slot.</p>
        public let value: LexRuntimeV2ClientTypes.Value?

        public init (
            value: LexRuntimeV2ClientTypes.Value? = nil
        )
        {
            self.value = value
        }
    }

}

public struct StartConversationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartConversationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartConversationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartConversationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let requestEventStream = input.operationInput.requestEventStream {
            do {
                let encoder = context.getEncoder()
                let requestEventStreamdata = try encoder.encode(requestEventStream)
                let requestEventStreambody = ClientRuntime.HttpBody.data(requestEventStreamdata)
                input.builder.withBody(requestEventStreambody)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartConversationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartConversationOutputError>
}

extension StartConversationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartConversationInput(botAliasId: \(Swift.String(describing: botAliasId)), botId: \(Swift.String(describing: botId)), conversationMode: \(Swift.String(describing: conversationMode)), localeId: \(Swift.String(describing: localeId)), requestEventStream: \(Swift.String(describing: requestEventStream)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension StartConversationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestEventStream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requestEventStream = requestEventStream {
            try encodeContainer.encode(requestEventStream, forKey: .requestEventStream)
        }
    }
}

public struct StartConversationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartConversationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartConversationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartConversationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let conversationMode = input.operationInput.conversationMode {
            input.builder.withHeader(name: "x-amz-lex-conversation-mode", value: Swift.String(conversationMode.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartConversationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartConversationOutputError>
}

public struct StartConversationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartConversationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartConversationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartConversationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartConversationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartConversationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartConversationOutputError>
}

public struct StartConversationInput: Swift.Equatable {
    /// <p>The alias identifier in use for the bot that processes the
    ///          request.</p>
    public let botAliasId: Swift.String?
    /// <p>The identifier of the bot to process the request.</p>
    public let botId: Swift.String?
    /// <p>The conversation type that you are using the Amazon Lex. If the
    ///          conversation mode is <code>AUDIO</code> you can send both audio and
    ///          DTMF information. If the mode is <code>TEXT</code> you can only send
    ///          text.</p>
    public let conversationMode: LexRuntimeV2ClientTypes.ConversationMode?
    /// <p>The locale where the session is in use.</p>
    public let localeId: Swift.String?
    /// <p>Represents the stream of events to Amazon Lex from your application. The
    ///          events are encoded as HTTP/2 data frames.</p>
    public let requestEventStream: LexRuntimeV2ClientTypes.StartConversationRequestEventStream?
    /// <p>The identifier of the user session that is having the
    ///          conversation.</p>
    public let sessionId: Swift.String?

    public init (
        botAliasId: Swift.String? = nil,
        botId: Swift.String? = nil,
        conversationMode: LexRuntimeV2ClientTypes.ConversationMode? = nil,
        localeId: Swift.String? = nil,
        requestEventStream: LexRuntimeV2ClientTypes.StartConversationRequestEventStream? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.botAliasId = botAliasId
        self.botId = botId
        self.conversationMode = conversationMode
        self.localeId = localeId
        self.requestEventStream = requestEventStream
        self.sessionId = sessionId
    }
}

struct StartConversationInputBody: Swift.Equatable {
    public let requestEventStream: LexRuntimeV2ClientTypes.StartConversationRequestEventStream?
}

extension StartConversationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requestEventStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestEventStreamDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.StartConversationRequestEventStream.self, forKey: .requestEventStream)
        requestEventStream = requestEventStreamDecoded
    }
}

extension StartConversationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConversationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartConversationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConversationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartConversationOutputResponse(responseEventStream: \(Swift.String(describing: responseEventStream)))"}
}

extension StartConversationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: LexRuntimeV2ClientTypes.StartConversationResponseEventStream = try responseDecoder.decode(responseBody: data)
                self.responseEventStream = output
            } else {
                self.responseEventStream = nil
            }
        } else {
            self.responseEventStream = nil
        }
    }
}

public struct StartConversationOutputResponse: Swift.Equatable {
    /// <p>Represents the stream of events from Amazon Lex to your application. The
    ///          events are encoded as HTTP/2 data frames.</p>
    public let responseEventStream: LexRuntimeV2ClientTypes.StartConversationResponseEventStream?

    public init (
        responseEventStream: LexRuntimeV2ClientTypes.StartConversationResponseEventStream? = nil
    )
    {
        self.responseEventStream = responseEventStream
    }
}

struct StartConversationOutputResponseBody: Swift.Equatable {
    public let responseEventStream: LexRuntimeV2ClientTypes.StartConversationResponseEventStream?
}

extension StartConversationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseEventStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseEventStreamDecoded = try containerValues.decodeIfPresent(LexRuntimeV2ClientTypes.StartConversationResponseEventStream.self, forKey: .responseEventStream)
        responseEventStream = responseEventStreamDecoded
    }
}

extension LexRuntimeV2ClientTypes.StartConversationRequestEventStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioinputevent = "AudioInputEvent"
        case configurationevent = "ConfigurationEvent"
        case dtmfinputevent = "DTMFInputEvent"
        case disconnectionevent = "DisconnectionEvent"
        case playbackcompletionevent = "PlaybackCompletionEvent"
        case textinputevent = "TextInputEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .audioinputevent(audioinputevent):
                try container.encode(audioinputevent, forKey: .audioinputevent)
            case let .configurationevent(configurationevent):
                try container.encode(configurationevent, forKey: .configurationevent)
            case let .dtmfinputevent(dtmfinputevent):
                try container.encode(dtmfinputevent, forKey: .dtmfinputevent)
            case let .disconnectionevent(disconnectionevent):
                try container.encode(disconnectionevent, forKey: .disconnectionevent)
            case let .playbackcompletionevent(playbackcompletionevent):
                try container.encode(playbackcompletionevent, forKey: .playbackcompletionevent)
            case let .textinputevent(textinputevent):
                try container.encode(textinputevent, forKey: .textinputevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let configurationeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.ConfigurationEvent.self, forKey: .configurationevent)
        if let configurationevent = configurationeventDecoded {
            self = .configurationevent(configurationevent)
            return
        }
        let audioinputeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.AudioInputEvent.self, forKey: .audioinputevent)
        if let audioinputevent = audioinputeventDecoded {
            self = .audioinputevent(audioinputevent)
            return
        }
        let dtmfinputeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.DTMFInputEvent.self, forKey: .dtmfinputevent)
        if let dtmfinputevent = dtmfinputeventDecoded {
            self = .dtmfinputevent(dtmfinputevent)
            return
        }
        let textinputeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.TextInputEvent.self, forKey: .textinputevent)
        if let textinputevent = textinputeventDecoded {
            self = .textinputevent(textinputevent)
            return
        }
        let playbackcompletioneventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.PlaybackCompletionEvent.self, forKey: .playbackcompletionevent)
        if let playbackcompletionevent = playbackcompletioneventDecoded {
            self = .playbackcompletionevent(playbackcompletionevent)
            return
        }
        let disconnectioneventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.DisconnectionEvent.self, forKey: .disconnectionevent)
        if let disconnectionevent = disconnectioneventDecoded {
            self = .disconnectionevent(disconnectionevent)
            return
        }
        self = .sdkUnknown("")
    }
}

extension LexRuntimeV2ClientTypes {
    /// <p>Represents a stream of events between your application and
    ///          Amazon Lex.</p>
    public enum StartConversationRequestEventStream: Swift.Equatable {
        /// <p>Configuration information sent from your client application to
        ///          Amazon Lex</p>
        case configurationevent(LexRuntimeV2ClientTypes.ConfigurationEvent)
        /// <p>Speech audio sent from your client application to Amazon Lex. Audio
        ///          starts accumulating when Amazon Lex identifies a voice and continues until a
        ///          natural pause in the speech is found before processing.</p>
        case audioinputevent(LexRuntimeV2ClientTypes.AudioInputEvent)
        /// <p>DTMF information sent to Amazon Lex by your application. Amazon Lex
        ///          accumulates the DMTF information from when the user sends the first
        ///          character and ends</p>
        ///          <ul>
        ///             <li>
        ///                <p>when there's a pause longer that the value configured for the
        ///                end timeout.</p>
        ///             </li>
        ///             <li>
        ///                <p>when there's a digit that is the configured end
        ///                character.</p>
        ///             </li>
        ///             <li>
        ///                <p>when Amazon Lex accumulates characters equal to the maximum DTMF
        ///                character configuration.</p>
        ///             </li>
        ///          </ul>
        case dtmfinputevent(LexRuntimeV2ClientTypes.DTMFInputEvent)
        /// <p>Text sent from your client application to Amazon Lex. Each
        ///             <code>TextInputEvent</code> is processed individually.</p>
        case textinputevent(LexRuntimeV2ClientTypes.TextInputEvent)
        /// <p>Event sent from the client application to Amazon Lex to indicate that it
        ///          has finished playing audio and that Amazon Lex should start listening for
        ///          user input.</p>
        case playbackcompletionevent(LexRuntimeV2ClientTypes.PlaybackCompletionEvent)
        /// <p>Event sent from the client application to indicate to Amazon Lex that the
        ///          conversation is over.</p>
        case disconnectionevent(LexRuntimeV2ClientTypes.DisconnectionEvent)
        case sdkUnknown(Swift.String)
    }

}

extension LexRuntimeV2ClientTypes.StartConversationResponseEventStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessdeniedexception = "AccessDeniedException"
        case audioresponseevent = "AudioResponseEvent"
        case badgatewayexception = "BadGatewayException"
        case conflictexception = "ConflictException"
        case dependencyfailedexception = "DependencyFailedException"
        case heartbeatevent = "HeartbeatEvent"
        case intentresultevent = "IntentResultEvent"
        case internalserverexception = "InternalServerException"
        case playbackinterruptionevent = "PlaybackInterruptionEvent"
        case resourcenotfoundexception = "ResourceNotFoundException"
        case textresponseevent = "TextResponseEvent"
        case throttlingexception = "ThrottlingException"
        case transcriptevent = "TranscriptEvent"
        case validationexception = "ValidationException"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accessdeniedexception(accessdeniedexception):
                try container.encode(accessdeniedexception, forKey: .accessdeniedexception)
            case let .audioresponseevent(audioresponseevent):
                try container.encode(audioresponseevent, forKey: .audioresponseevent)
            case let .badgatewayexception(badgatewayexception):
                try container.encode(badgatewayexception, forKey: .badgatewayexception)
            case let .conflictexception(conflictexception):
                try container.encode(conflictexception, forKey: .conflictexception)
            case let .dependencyfailedexception(dependencyfailedexception):
                try container.encode(dependencyfailedexception, forKey: .dependencyfailedexception)
            case let .heartbeatevent(heartbeatevent):
                try container.encode(heartbeatevent, forKey: .heartbeatevent)
            case let .intentresultevent(intentresultevent):
                try container.encode(intentresultevent, forKey: .intentresultevent)
            case let .internalserverexception(internalserverexception):
                try container.encode(internalserverexception, forKey: .internalserverexception)
            case let .playbackinterruptionevent(playbackinterruptionevent):
                try container.encode(playbackinterruptionevent, forKey: .playbackinterruptionevent)
            case let .resourcenotfoundexception(resourcenotfoundexception):
                try container.encode(resourcenotfoundexception, forKey: .resourcenotfoundexception)
            case let .textresponseevent(textresponseevent):
                try container.encode(textresponseevent, forKey: .textresponseevent)
            case let .throttlingexception(throttlingexception):
                try container.encode(throttlingexception, forKey: .throttlingexception)
            case let .transcriptevent(transcriptevent):
                try container.encode(transcriptevent, forKey: .transcriptevent)
            case let .validationexception(validationexception):
                try container.encode(validationexception, forKey: .validationexception)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let playbackinterruptioneventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.PlaybackInterruptionEvent.self, forKey: .playbackinterruptionevent)
        if let playbackinterruptionevent = playbackinterruptioneventDecoded {
            self = .playbackinterruptionevent(playbackinterruptionevent)
            return
        }
        let transcripteventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.TranscriptEvent.self, forKey: .transcriptevent)
        if let transcriptevent = transcripteventDecoded {
            self = .transcriptevent(transcriptevent)
            return
        }
        let intentresulteventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.IntentResultEvent.self, forKey: .intentresultevent)
        if let intentresultevent = intentresulteventDecoded {
            self = .intentresultevent(intentresultevent)
            return
        }
        let textresponseeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.TextResponseEvent.self, forKey: .textresponseevent)
        if let textresponseevent = textresponseeventDecoded {
            self = .textresponseevent(textresponseevent)
            return
        }
        let audioresponseeventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.AudioResponseEvent.self, forKey: .audioresponseevent)
        if let audioresponseevent = audioresponseeventDecoded {
            self = .audioresponseevent(audioresponseevent)
            return
        }
        let heartbeateventDecoded = try values.decodeIfPresent(LexRuntimeV2ClientTypes.HeartbeatEvent.self, forKey: .heartbeatevent)
        if let heartbeatevent = heartbeateventDecoded {
            self = .heartbeatevent(heartbeatevent)
            return
        }
        let accessdeniedexceptionDecoded = try values.decodeIfPresent(AccessDeniedException.self, forKey: .accessdeniedexception)
        if let accessdeniedexception = accessdeniedexceptionDecoded {
            self = .accessdeniedexception(accessdeniedexception)
            return
        }
        let resourcenotfoundexceptionDecoded = try values.decodeIfPresent(ResourceNotFoundException.self, forKey: .resourcenotfoundexception)
        if let resourcenotfoundexception = resourcenotfoundexceptionDecoded {
            self = .resourcenotfoundexception(resourcenotfoundexception)
            return
        }
        let validationexceptionDecoded = try values.decodeIfPresent(ValidationException.self, forKey: .validationexception)
        if let validationexception = validationexceptionDecoded {
            self = .validationexception(validationexception)
            return
        }
        let throttlingexceptionDecoded = try values.decodeIfPresent(ThrottlingException.self, forKey: .throttlingexception)
        if let throttlingexception = throttlingexceptionDecoded {
            self = .throttlingexception(throttlingexception)
            return
        }
        let internalserverexceptionDecoded = try values.decodeIfPresent(InternalServerException.self, forKey: .internalserverexception)
        if let internalserverexception = internalserverexceptionDecoded {
            self = .internalserverexception(internalserverexception)
            return
        }
        let conflictexceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictexception)
        if let conflictexception = conflictexceptionDecoded {
            self = .conflictexception(conflictexception)
            return
        }
        let dependencyfailedexceptionDecoded = try values.decodeIfPresent(DependencyFailedException.self, forKey: .dependencyfailedexception)
        if let dependencyfailedexception = dependencyfailedexceptionDecoded {
            self = .dependencyfailedexception(dependencyfailedexception)
            return
        }
        let badgatewayexceptionDecoded = try values.decodeIfPresent(BadGatewayException.self, forKey: .badgatewayexception)
        if let badgatewayexception = badgatewayexceptionDecoded {
            self = .badgatewayexception(badgatewayexception)
            return
        }
        self = .sdkUnknown("")
    }
}

extension LexRuntimeV2ClientTypes {
    /// <p>Represents a stream of events between Amazon Lex and your
    ///          application.</p>
    public enum StartConversationResponseEventStream: Swift.Equatable {
        /// <p>Event sent from Amazon Lex to indicate to the client application should
        ///          stop playback of audio. For example, if the client is playing a prompt
        ///          that asks for the user's telephone number, the user might start to say
        ///          the phone number before the prompt is complete. Amazon Lex sends this event
        ///          to the client application to indicate that the user is responding and
        ///          that Amazon Lex is processing their input.</p>
        case playbackinterruptionevent(LexRuntimeV2ClientTypes.PlaybackInterruptionEvent)
        /// <p>Event sent from Amazon Lex to your client application that contains a
        ///          transcript of voice audio. </p>
        case transcriptevent(LexRuntimeV2ClientTypes.TranscriptEvent)
        /// <p>Event sent from Amazon Lex to the client application containing the
        ///          current state of the conversation between the user and Amazon Lex.</p>
        case intentresultevent(LexRuntimeV2ClientTypes.IntentResultEvent)
        /// <p>The event sent from Amazon Lex to your application with text to present
        ///          to the user.</p>
        case textresponseevent(LexRuntimeV2ClientTypes.TextResponseEvent)
        /// <p>An event sent from Amazon Lex to your client application containing audio
        ///          to play to the user. </p>
        case audioresponseevent(LexRuntimeV2ClientTypes.AudioResponseEvent)
        /// <p>Event that Amazon Lex sends to indicate that the stream is still open
        ///          between the client application and Amazon Lex </p>
        case heartbeatevent(LexRuntimeV2ClientTypes.HeartbeatEvent)
        /// <p>Exception thrown when the credentials passed with the request are
        ///          invalid or expired. Also thrown when the credentials in the request do
        ///          not have permission to access the <code>StartConversation</code>
        ///          operation.</p>
        case accessdeniedexception(AccessDeniedException)
        /// <p>Exception thrown if one of the input parameters points to a resource
        ///          that does not exist. For example, if the bot ID specified does not
        ///          exist.</p>
        case resourcenotfoundexception(ResourceNotFoundException)
        /// <p>Exception thrown when one or more parameters could not be validated.
        ///          The <code>message</code> contains the name of the field that isn't
        ///          valid.</p>
        case validationexception(ValidationException)
        /// <p>Exception thrown when your application exceeds the maximum number of
        ///          concurrent requests. </p>
        case throttlingexception(ThrottlingException)
        /// <p>An error occurred with Amazon Lex.</p>
        case internalserverexception(InternalServerException)
        /// <p>Exception thrown when two clients are using the same AWS account,
        ///          Amazon Lex bot, and session ID.</p>
        case conflictexception(ConflictException)
        /// <p></p>
        case dependencyfailedexception(DependencyFailedException)
        /// <p></p>
        case badgatewayexception(BadGatewayException)
        case sdkUnknown(Swift.String)
    }

}

extension LexRuntimeV2ClientTypes.TextInputEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientTimestampMillis
        case eventId
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if clientTimestampMillis != 0 {
            try encodeContainer.encode(clientTimestampMillis, forKey: .clientTimestampMillis)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let clientTimestampMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientTimestampMillis)
        clientTimestampMillis = clientTimestampMillisDecoded
    }
}

extension LexRuntimeV2ClientTypes.TextInputEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextInputEvent(clientTimestampMillis: \(Swift.String(describing: clientTimestampMillis)), eventId: \(Swift.String(describing: eventId)), text: \(Swift.String(describing: text)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The event sent from your client application to Amazon Lex with text input
    ///          from the user.</p>
    public struct TextInputEvent: Swift.Equatable {
        /// <p>A timestamp set by the client of the date and time that the event
        ///          was sent to Amazon Lex.</p>
        public let clientTimestampMillis: Swift.Int
        /// <p>A unique identifier that your application assigns to the event. You
        ///          can use this to identify events in logs.</p>
        public let eventId: Swift.String?
        /// <p>The text from the user. Amazon Lex processes this as a complete
        ///          statement.</p>
        public let text: Swift.String?

        public init (
            clientTimestampMillis: Swift.Int = 0,
            eventId: Swift.String? = nil,
            text: Swift.String? = nil
        )
        {
            self.clientTimestampMillis = clientTimestampMillis
            self.eventId = eventId
            self.text = text
        }
    }

}

extension LexRuntimeV2ClientTypes.TextResponseEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case messages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([LexRuntimeV2ClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[LexRuntimeV2ClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [LexRuntimeV2ClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.TextResponseEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TextResponseEvent(eventId: \(Swift.String(describing: eventId)), messages: \(Swift.String(describing: messages)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The event sent from Amazon Lex to your application with text to present
    ///          to the user.</p>
    public struct TextResponseEvent: Swift.Equatable {
        /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
        ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
        ///          and incremented for each event sent by Amazon Lex in the current
        ///          session.</p>
        public let eventId: Swift.String?
        /// <p>A list of messages to send to the user. Messages are ordered based
        ///          on the order that you returned the messages from your Lambda function
        ///          or the order that the messages are defined in the bot.</p>
        public let messages: [LexRuntimeV2ClientTypes.Message]?

        public init (
            eventId: Swift.String? = nil,
            messages: [LexRuntimeV2ClientTypes.Message]? = nil
        )
        {
            self.eventId = eventId
            self.messages = messages
        }
    }

}

extension ThrottlingException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.TranscriptEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case transcript
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let transcript = transcript {
            try encodeContainer.encode(transcript, forKey: .transcript)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transcriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcript)
        transcript = transcriptDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension LexRuntimeV2ClientTypes.TranscriptEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TranscriptEvent(eventId: \(Swift.String(describing: eventId)), transcript: \(Swift.String(describing: transcript)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>Event sent from Amazon Lex to your client application that contains a
    ///          transcript of voice audio. </p>
    public struct TranscriptEvent: Swift.Equatable {
        /// <p>A unique identifier of the event sent by Amazon Lex. The identifier is in
        ///          the form <code>RESPONSE-N</code>, where N is a number starting with one
        ///          and incremented for each event sent by Amazon Lex in the current
        ///          session.</p>
        public let eventId: Swift.String?
        /// <p>The transcript of the voice audio from the user.</p>
        public let transcript: Swift.String?

        public init (
            eventId: Swift.String? = nil,
            transcript: Swift.String? = nil
        )
        {
            self.eventId = eventId
            self.transcript = transcript
        }
    }

}

extension ValidationException: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeV2ClientTypes.Value: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpretedValue
        case originalValue
        case resolvedValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interpretedValue = interpretedValue {
            try encodeContainer.encode(interpretedValue, forKey: .interpretedValue)
        }
        if let originalValue = originalValue {
            try encodeContainer.encode(originalValue, forKey: .originalValue)
        }
        if let resolvedValues = resolvedValues {
            var resolvedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resolvedValues)
            for stringlist0 in resolvedValues {
                try resolvedValuesContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originalValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalValue)
        originalValue = originalValueDecoded
        let interpretedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interpretedValue)
        interpretedValue = interpretedValueDecoded
        let resolvedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resolvedValues)
        var resolvedValuesDecoded0:[Swift.String]? = nil
        if let resolvedValuesContainer = resolvedValuesContainer {
            resolvedValuesDecoded0 = [Swift.String]()
            for string0 in resolvedValuesContainer {
                if let string0 = string0 {
                    resolvedValuesDecoded0?.append(string0)
                }
            }
        }
        resolvedValues = resolvedValuesDecoded0
    }
}

extension LexRuntimeV2ClientTypes.Value: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Value(interpretedValue: \(Swift.String(describing: interpretedValue)), originalValue: \(Swift.String(describing: originalValue)), resolvedValues: \(Swift.String(describing: resolvedValues)))"}
}

extension LexRuntimeV2ClientTypes {
    /// <p>The value of a slot.</p>
    public struct Value: Swift.Equatable {
        /// <p>The value that Amazon Lex determines for the slot. The actual value
        ///          depends on the setting of the value selection strategy for the bot. You
        ///          can choose to use the value entered by the user, or you can have Amazon Lex
        ///          choose the first value in the <code>resolvedValues</code> list.</p>
        public let interpretedValue: Swift.String?
        /// <p>The text of the utterance from the user that was entered for the
        ///          slot.</p>
        public let originalValue: Swift.String?
        /// <p>A list of additional values that have been recognized for the
        ///          slot.</p>
        public let resolvedValues: [Swift.String]?

        public init (
            interpretedValue: Swift.String? = nil,
            originalValue: Swift.String? = nil,
            resolvedValues: [Swift.String]? = nil
        )
        {
            self.interpretedValue = interpretedValue
            self.originalValue = originalValue
            self.resolvedValues = resolvedValues
        }
    }

}
