// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>The criteria by which the behavior is determined to be normal.</p>
public struct BehaviorCriteria: Equatable {
    /// <p>The operator that relates the thing measured (<code>metric</code>) to the criteria
    ///           (containing a <code>value</code> or <code>statisticalThreshold</code>). Valid operators include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>string-list</code>: <code>in-set</code> and <code>not-in-set</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>number-list</code>: <code>in-set</code> and <code>not-in-set</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ip-address-list</code>: <code>in-cidr-set</code> and <code>not-in-cidr-set</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>number</code>: <code>less-than</code>, <code>less-than-equals</code>, <code>greater-than</code>, and <code>greater-than-equals</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let comparisonOperator: ComparisonOperator?
    /// <p>If a device is in violation of the behavior for the specified number of consecutive
    ///           datapoints, an alarm occurs. If not specified, the default is 1.</p>
    public let consecutiveDatapointsToAlarm: Int?
    /// <p>If an alarm has occurred and the offending device is no longer in violation of the behavior
    ///           for the specified number of consecutive datapoints, the alarm is cleared. If not specified,
    ///           the default is 1.</p>
    public let consecutiveDatapointsToClear: Int?
    /// <p>Use this to specify the time duration over which the behavior is evaluated, for those criteria that
    ///       have a time dimension (for example, <code>NUM_MESSAGES_SENT</code>). For a
    ///         <code>statisticalThreshhold</code> metric comparison, measurements from all devices are
    ///       accumulated over this time duration before being used to calculate percentiles, and later,
    ///       measurements from an individual device are also accumulated over this time duration before
    ///       being given a percentile rank. Cannot be used with list-based metric datatypes.</p>
    public let durationSeconds: Int?
    /// <p>
    ///             The configuration of an ML Detect
    ///         </p>
    public let mlDetectionConfig: MachineLearningDetectionConfig?
    /// <p>A statistical ranking (percentile)that
    ///       indicates a threshold value by which a behavior is determined to be in compliance or in
    ///       violation of the behavior.</p>
    public let statisticalThreshold: StatisticalThreshold?
    /// <p>The value to be compared with the <code>metric</code>.</p>
    public let value: MetricValue?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        consecutiveDatapointsToAlarm: Int? = nil,
        consecutiveDatapointsToClear: Int? = nil,
        durationSeconds: Int? = nil,
        mlDetectionConfig: MachineLearningDetectionConfig? = nil,
        statisticalThreshold: StatisticalThreshold? = nil,
        value: MetricValue? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.consecutiveDatapointsToAlarm = consecutiveDatapointsToAlarm
        self.consecutiveDatapointsToClear = consecutiveDatapointsToClear
        self.durationSeconds = durationSeconds
        self.mlDetectionConfig = mlDetectionConfig
        self.statisticalThreshold = statisticalThreshold
        self.value = value
    }
}

extension BehaviorCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BehaviorCriteria(comparisonOperator: \(String(describing: comparisonOperator)), consecutiveDatapointsToAlarm: \(String(describing: consecutiveDatapointsToAlarm)), consecutiveDatapointsToClear: \(String(describing: consecutiveDatapointsToClear)), durationSeconds: \(String(describing: durationSeconds)), mlDetectionConfig: \(String(describing: mlDetectionConfig)), statisticalThreshold: \(String(describing: statisticalThreshold)), value: \(String(describing: value)))"}
}
