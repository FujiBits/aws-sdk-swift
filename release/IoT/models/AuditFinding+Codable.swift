// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AuditFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case checkName
        case findingId
        case findingTime
        case isSuppressed
        case nonCompliantResource
        case reasonForNonCompliance
        case reasonForNonComplianceCode
        case relatedResources
        case severity
        case taskId
        case taskStartTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkName = checkName {
            try encodeContainer.encode(checkName, forKey: .checkName)
        }
        if let findingId = findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let findingTime = findingTime {
            try encodeContainer.encode(findingTime.timeIntervalSince1970, forKey: .findingTime)
        }
        if let isSuppressed = isSuppressed {
            try encodeContainer.encode(isSuppressed, forKey: .isSuppressed)
        }
        if let nonCompliantResource = nonCompliantResource {
            try encodeContainer.encode(nonCompliantResource, forKey: .nonCompliantResource)
        }
        if let reasonForNonCompliance = reasonForNonCompliance {
            try encodeContainer.encode(reasonForNonCompliance, forKey: .reasonForNonCompliance)
        }
        if let reasonForNonComplianceCode = reasonForNonComplianceCode {
            try encodeContainer.encode(reasonForNonComplianceCode, forKey: .reasonForNonComplianceCode)
        }
        if let relatedResources = relatedResources {
            var relatedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedResources)
            for relatedresources0 in relatedResources {
                try relatedResourcesContainer.encode(relatedresources0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let taskStartTime = taskStartTime {
            try encodeContainer.encode(taskStartTime.timeIntervalSince1970, forKey: .taskStartTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .findingId)
        findingId = findingIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let checkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .checkName)
        checkName = checkNameDecoded
        let taskStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .taskStartTime)
        taskStartTime = taskStartTimeDecoded
        let findingTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .findingTime)
        findingTime = findingTimeDecoded
        let severityDecoded = try containerValues.decodeIfPresent(AuditFindingSeverity.self, forKey: .severity)
        severity = severityDecoded
        let nonCompliantResourceDecoded = try containerValues.decodeIfPresent(NonCompliantResource.self, forKey: .nonCompliantResource)
        nonCompliantResource = nonCompliantResourceDecoded
        let relatedResourcesContainer = try containerValues.decodeIfPresent([RelatedResource?].self, forKey: .relatedResources)
        var relatedResourcesDecoded0:[RelatedResource]? = nil
        if let relatedResourcesContainer = relatedResourcesContainer {
            relatedResourcesDecoded0 = [RelatedResource]()
            for structure0 in relatedResourcesContainer {
                if let structure0 = structure0 {
                    relatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        relatedResources = relatedResourcesDecoded0
        let reasonForNonComplianceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonForNonCompliance)
        reasonForNonCompliance = reasonForNonComplianceDecoded
        let reasonForNonComplianceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reasonForNonComplianceCode)
        reasonForNonComplianceCode = reasonForNonComplianceCodeDecoded
        let isSuppressedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isSuppressed)
        isSuppressed = isSuppressedDecoded
    }
}
