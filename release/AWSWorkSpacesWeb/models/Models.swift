// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension AssociateBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBrowserSettingsOutputError>
}

public struct AssociateBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let browserSettingsArn = input.operationInput.browserSettingsArn {
            let browserSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "browserSettingsArn".urlPercentEncoding(), value: Swift.String(browserSettingsArn).urlPercentEncoding())
            input.builder.withQueryItem(browserSettingsArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBrowserSettingsOutputError>
}

public struct AssociateBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBrowserSettingsOutputError>
}

public struct AssociateBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/browserSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBrowserSettingsOutputError>
}

public struct AssociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsInputBody: Swift.Equatable {
}

extension AssociateBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateBrowserSettingsOutputResponse(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension AssociateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.browserSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateBrowserSettingsOutputResponseBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let browserSettingsArn: Swift.String?
}

extension AssociateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case portalArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension AssociateNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateNetworkSettingsInput(networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension AssociateNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNetworkSettingsOutputError>
}

public struct AssociateNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let networkSettingsArn = input.operationInput.networkSettingsArn {
            let networkSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "networkSettingsArn".urlPercentEncoding(), value: Swift.String(networkSettingsArn).urlPercentEncoding())
            input.builder.withQueryItem(networkSettingsArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNetworkSettingsOutputError>
}

public struct AssociateNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNetworkSettingsOutputError>
}

public struct AssociateNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/networkSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNetworkSettingsOutputError>
}

public struct AssociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsInputBody: Swift.Equatable {
}

extension AssociateNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateNetworkSettingsOutputResponse(networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension AssociateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
            self.portalArn = output.portalArn
        } else {
            self.networkSettingsArn = nil
            self.portalArn = nil
        }
    }
}

public struct AssociateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
        self.portalArn = portalArn
    }
}

struct AssociateNetworkSettingsOutputResponseBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let networkSettingsArn: Swift.String?
}

extension AssociateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case portalArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

extension AssociateTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTrustStoreInput(portalArn: \(Swift.String(describing: portalArn)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension AssociateTrustStoreInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateTrustStoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrustStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrustStoreOutputError>
}

public struct AssociateTrustStoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrustStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let trustStoreArn = input.operationInput.trustStoreArn {
            let trustStoreArnQueryItem = ClientRuntime.URLQueryItem(name: "trustStoreArn".urlPercentEncoding(), value: Swift.String(trustStoreArn).urlPercentEncoding())
            input.builder.withQueryItem(trustStoreArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrustStoreOutputError>
}

public struct AssociateTrustStoreInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrustStoreInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrustStoreOutputError>
}

public struct AssociateTrustStoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTrustStoreInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/trustStores"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTrustStoreOutputError>
}

public struct AssociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreInputBody: Swift.Equatable {
}

extension AssociateTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTrustStoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTrustStoreOutputResponse(portalArn: \(Swift.String(describing: portalArn)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension AssociateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.portalArn = nil
            self.trustStoreArn = nil
        }
    }
}

public struct AssociateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.trustStoreArn = trustStoreArn
    }
}

struct AssociateTrustStoreOutputResponseBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let trustStoreArn: Swift.String?
}

extension AssociateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension AssociateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateUserSettingsInput(portalArn: \(Swift.String(describing: portalArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension AssociateUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateUserSettingsOutputError>
}

public struct AssociateUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let userSettingsArn = input.operationInput.userSettingsArn {
            let userSettingsArnQueryItem = ClientRuntime.URLQueryItem(name: "userSettingsArn".urlPercentEncoding(), value: Swift.String(userSettingsArn).urlPercentEncoding())
            input.builder.withQueryItem(userSettingsArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateUserSettingsOutputError>
}

public struct AssociateUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateUserSettingsOutputError>
}

public struct AssociateUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/userSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateUserSettingsOutputError>
}

public struct AssociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsInputBody: Swift.Equatable {
}

extension AssociateUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateUserSettingsOutputResponse(portalArn: \(Swift.String(describing: portalArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension AssociateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.portalArn = nil
            self.userSettingsArn = nil
        }
    }
}

public struct AssociateUserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.userSettingsArn = userSettingsArn
    }
}

struct AssociateUserSettingsOutputResponseBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let userSettingsArn: Swift.String?
}

extension AssociateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case userSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case browserPolicy
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arnlist0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arnlist0)
            }
        }
        if let browserPolicy = browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let browserSettingsArn = browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), browserPolicy: \(Swift.String(describing: browserPolicy)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// The browser settings resource that can be associated with a web portal. Once associated with a web portal, browser settings control how the browser will behave once a user starts a streaming session for the web portal.
    public struct BrowserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this browser settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
        public var browserPolicy: Swift.String?
        /// The ARN of the browser settings.
        /// This member is required.
        public var browserSettingsArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            browserPolicy: Swift.String? = nil,
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.browserPolicy = browserPolicy
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.BrowserSettingsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

extension WorkSpacesWebClientTypes.BrowserSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrowserSettingsSummary(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary for browser settings.
    public struct BrowserSettingsSummary: Swift.Equatable {
        /// The ARN of the browser settings.
        public var browserSettingsArn: Swift.String?

        public init (
            browserSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum BrowserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chrome
        case sdkUnknown(Swift.String)

        public static var allCases: [BrowserType] {
            return [
                .chrome,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chrome: return "Chrome"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrowserType(rawValue: rawValue) ?? BrowserType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.Certificate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = notValidAfter {
            try encodeContainer.encode(notValidAfter.timeIntervalSince1970, forKey: .notValidAfter)
        }
        if let notValidBefore = notValidBefore {
            try encodeContainer.encode(notValidBefore.timeIntervalSince1970, forKey: .notValidBefore)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension WorkSpacesWebClientTypes.Certificate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Certificate(body: \(Swift.String(describing: body)), issuer: \(Swift.String(describing: issuer)), notValidAfter: \(Swift.String(describing: notValidAfter)), notValidBefore: \(Swift.String(describing: notValidBefore)), subject: \(Swift.String(describing: subject)), thumbprint: \(Swift.String(describing: thumbprint)))"}
}

extension WorkSpacesWebClientTypes {
    /// The certificate.
    public struct Certificate: Swift.Equatable {
        /// The body of the certificate.
        public var body: ClientRuntime.Data?
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init (
            body: ClientRuntime.Data? = nil,
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.body = body
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension WorkSpacesWebClientTypes.CertificateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issuer
        case notValidAfter
        case notValidBefore
        case subject
        case thumbprint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let notValidAfter = notValidAfter {
            try encodeContainer.encode(notValidAfter.timeIntervalSince1970, forKey: .notValidAfter)
        }
        if let notValidBefore = notValidBefore {
            try encodeContainer.encode(notValidBefore.timeIntervalSince1970, forKey: .notValidBefore)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let thumbprint = thumbprint {
            try encodeContainer.encode(thumbprint, forKey: .thumbprint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thumbprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbprint)
        thumbprint = thumbprintDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let notValidBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notValidBefore)
        notValidBefore = notValidBeforeDecoded
        let notValidAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notValidAfter)
        notValidAfter = notValidAfterDecoded
    }
}

extension WorkSpacesWebClientTypes.CertificateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CertificateSummary(issuer: \(Swift.String(describing: issuer)), notValidAfter: \(Swift.String(describing: notValidAfter)), notValidBefore: \(Swift.String(describing: notValidBefore)), subject: \(Swift.String(describing: subject)), thumbprint: \(Swift.String(describing: thumbprint)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the certificate.
    public struct CertificateSummary: Swift.Equatable {
        /// The entity that issued the certificate.
        public var issuer: Swift.String?
        /// The certificate is not valid after this date.
        public var notValidAfter: ClientRuntime.Date?
        /// The certificate is not valid before this date.
        public var notValidBefore: ClientRuntime.Date?
        /// The entity the certificate belongs to.
        public var subject: Swift.String?
        /// A hexadecimal identifier for the certificate.
        public var thumbprint: Swift.String?

        public init (
            issuer: Swift.String? = nil,
            notValidAfter: ClientRuntime.Date? = nil,
            notValidBefore: ClientRuntime.Date? = nil,
            subject: Swift.String? = nil,
            thumbprint: Swift.String? = nil
        )
        {
            self.issuer = issuer
            self.notValidAfter = notValidAfter
            self.notValidBefore = notValidBefore
            self.subject = subject
            self.thumbprint = thumbprint
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateBrowserSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrowserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrowserSettingsOutputError>
}

extension CreateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserSettingsInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), browserPolicy: \(Swift.String(describing: browserPolicy)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptioncontextmap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptioncontextmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let browserPolicy = browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrowserSettingsOutputError>
}

public struct CreateBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrowserSettingsOutputError>
}

public struct CreateBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrowserSettingsOutputError>
}

public struct CreateBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/browserSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrowserSettingsOutputError>
}

public struct CreateBrowserSettingsInput: Swift.Equatable {
    /// Additional encryption context of the browser settings.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    /// This member is required.
    public var browserPolicy: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The custom managed key of the browser settings.
    public var customerManagedKey: Swift.String?
    /// The tags to add to the browser settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        browserPolicy: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.browserPolicy = browserPolicy
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.tags = tags
    }
}

struct CreateBrowserSettingsInputBody: Swift.Equatable {
    public let tags: [WorkSpacesWebClientTypes.Tag]?
    public let customerManagedKey: Swift.String?
    public let additionalEncryptionContext: [Swift.String:Swift.String]?
    public let browserPolicy: Swift.String?
    public let clientToken: Swift.String?
}

extension CreateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case browserPolicy
        case clientToken
        case customerManagedKey
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrowserSettingsOutputResponse(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)))"}
}

extension CreateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettingsArn = output.browserSettingsArn
        } else {
            self.browserSettingsArn = nil
        }
    }
}

public struct CreateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct CreateBrowserSettingsOutputResponseBody: Swift.Equatable {
    public let browserSettingsArn: Swift.String?
}

extension CreateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
    }
}

public struct CreateIdentityProviderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityProviderOutputError>
}

extension CreateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderName: \(Swift.String(describing: identityProviderName)), identityProviderType: \(Swift.String(describing: identityProviderType)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension CreateIdentityProviderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityproviderdetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityproviderdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let portalArn = portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
    }
}

public struct CreateIdentityProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityProviderOutputError>
}

public struct CreateIdentityProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityProviderOutputError>
}

public struct CreateIdentityProviderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityProviderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityProviderOutputError>
}

public struct CreateIdentityProviderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateIdentityProviderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/identityProviders"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateIdentityProviderOutputError>
}

public struct CreateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
    ///
    /// * For Google and Login with Amazon:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For Facebook:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * authorize_scopes
    ///
    /// * api_version
    ///
    ///
    ///
    ///
    /// * For Sign in with Apple:
    ///
    /// * client_id
    ///
    /// * team_id
    ///
    /// * key_id
    ///
    /// * private_key
    ///
    /// * authorize_scopes
    ///
    ///
    ///
    ///
    /// * For OIDC providers:
    ///
    /// * client_id
    ///
    /// * client_secret
    ///
    /// * attributes_request_method
    ///
    /// * oidc_issuer
    ///
    /// * authorize_scopes
    ///
    /// * authorize_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * token_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * attributes_url if not available from discovery URL specified by oidc_issuer key
    ///
    /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
    ///
    ///
    ///
    ///
    /// * For SAML providers:
    ///
    /// * MetadataFile OR MetadataURL
    ///
    /// * IDPSignout optional
    /// This member is required.
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The identity provider name.
    /// This member is required.
    public var identityProviderName: Swift.String?
    /// The identity provider type.
    /// This member is required.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
        self.portalArn = portalArn
    }
}

struct CreateIdentityProviderInputBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let identityProviderName: Swift.String?
    public let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    public let identityProviderDetails: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
        case portalArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIdentityProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentityProviderOutputResponse(identityProviderArn: \(Swift.String(describing: identityProviderArn)))"}
}

extension CreateIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviderArn = output.identityProviderArn
        } else {
            self.identityProviderArn = nil
        }
    }
}

public struct CreateIdentityProviderOutputResponse: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init (
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct CreateIdentityProviderOutputResponseBody: Swift.Equatable {
    public let identityProviderArn: Swift.String?
}

extension CreateIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
    }
}

public struct CreateNetworkSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkSettingsOutputError>
}

extension CreateNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSettingsInput(clientToken: \(Swift.String(describing: clientToken)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension CreateNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct CreateNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkSettingsOutputError>
}

public struct CreateNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkSettingsOutputError>
}

public struct CreateNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkSettingsOutputError>
}

public struct CreateNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/networkSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateNetworkSettingsOutputError>
}

public struct CreateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags to add to the network settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// The VPC that streaming instances will connect to.
    /// This member is required.
    public var vpcId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateNetworkSettingsInputBody: Swift.Equatable {
    public let vpcId: Swift.String?
    public let subnetIds: [Swift.String]?
    public let securityGroupIds: [Swift.String]?
    public let tags: [WorkSpacesWebClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case tags
        case vpcId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNetworkSettingsOutputResponse(networkSettingsArn: \(Swift.String(describing: networkSettingsArn)))"}
}

extension CreateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettingsArn = output.networkSettingsArn
        } else {
            self.networkSettingsArn = nil
        }
    }
}

public struct CreateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct CreateNetworkSettingsOutputResponseBody: Swift.Equatable {
    public let networkSettingsArn: Swift.String?
}

extension CreateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
    }
}

public struct CreatePortalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

extension CreatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalInput(additionalEncryptionContext: \(Swift.String(describing: additionalEncryptionContext)), clientToken: \(Swift.String(describing: clientToken)), customerManagedKey: \(Swift.String(describing: customerManagedKey)), displayName: \(Swift.String(describing: displayName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePortalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalEncryptionContext = additionalEncryptionContext {
            var additionalEncryptionContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalEncryptionContext)
            for (dictKey0, encryptioncontextmap0) in additionalEncryptionContext {
                try additionalEncryptionContextContainer.encode(encryptioncontextmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKey = customerManagedKey {
            try encodeContainer.encode(customerManagedKey, forKey: .customerManagedKey)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreatePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreatePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/portals"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInput: Swift.Equatable {
    /// The additional encryption context of the portal.
    public var additionalEncryptionContext: [Swift.String:Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The customer managed key of the web portal.
    public var customerManagedKey: Swift.String?
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The tags to add to the web portal. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        additionalEncryptionContext: [Swift.String:Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        customerManagedKey: Swift.String? = nil,
        displayName: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.additionalEncryptionContext = additionalEncryptionContext
        self.clientToken = clientToken
        self.customerManagedKey = customerManagedKey
        self.displayName = displayName
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    public let displayName: Swift.String?
    public let tags: [WorkSpacesWebClientTypes.Tag]?
    public let customerManagedKey: Swift.String?
    public let additionalEncryptionContext: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalEncryptionContext
        case clientToken
        case customerManagedKey
        case displayName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerManagedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKey)
        customerManagedKey = customerManagedKeyDecoded
        let additionalEncryptionContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalEncryptionContext)
        var additionalEncryptionContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalEncryptionContextContainer = additionalEncryptionContextContainer {
            additionalEncryptionContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in additionalEncryptionContextContainer {
                if let stringtype0 = stringtype0 {
                    additionalEncryptionContextDecoded0?[key0] = stringtype0
                }
            }
        }
        additionalEncryptionContext = additionalEncryptionContextDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalOutputResponse(portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)))"}
}

extension CreatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalEndpoint = output.portalEndpoint
        } else {
            self.portalArn = nil
            self.portalEndpoint = nil
        }
    }
}

public struct CreatePortalOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The endpoint URL of the web portal that users access in order to start streaming sessions.
    /// This member is required.
    public var portalEndpoint: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        portalEndpoint: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalEndpoint = portalEndpoint
    }
}

struct CreatePortalOutputResponseBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let portalEndpoint: Swift.String?
}

extension CreatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
    }
}

public struct CreateTrustStoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrustStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrustStoreOutputError>
}

extension CreateTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTrustStoreInput(certificateList: \(Swift.String(describing: certificateList)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTrustStoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateList = certificateList {
            var certificateListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateList)
            for certificatelist0 in certificateList {
                try certificateListContainer.encode(certificatelist0.base64EncodedString())
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateTrustStoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrustStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrustStoreOutputError>
}

public struct CreateTrustStoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrustStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrustStoreOutputError>
}

public struct CreateTrustStoreInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrustStoreInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrustStoreOutputError>
}

public struct CreateTrustStoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTrustStoreInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/trustStores"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTrustStoreOutputError>
}

public struct CreateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to be added to the trust store.
    /// This member is required.
    public var certificateList: [ClientRuntime.Data]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The tags to add to the trust store. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        certificateList: [ClientRuntime.Data]? = nil,
        clientToken: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.certificateList = certificateList
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateTrustStoreInputBody: Swift.Equatable {
    public let certificateList: [ClientRuntime.Data]?
    public let tags: [WorkSpacesWebClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificateList)
        var certificateListDecoded0:[ClientRuntime.Data]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificateListContainer {
                if let blob0 = blob0 {
                    certificateListDecoded0?.append(blob0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrustStoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTrustStoreOutputResponse(trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension CreateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct CreateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct CreateTrustStoreOutputResponseBody: Swift.Equatable {
    public let trustStoreArn: Swift.String?
}

extension CreateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

public struct CreateUserSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserSettingsOutputError>
}

extension CreateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserSettingsInput(clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), tags: \(Swift.String(describing: tags)), uploadAllowed: \(Swift.String(describing: uploadAllowed)))"}
}

extension CreateUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case downloadAllowed
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let copyAllowed = copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let downloadAllowed = downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let pasteAllowed = pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let uploadAllowed = uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

public struct CreateUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserSettingsOutputError>
}

public struct CreateUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserSettingsOutputError>
}

public struct CreateUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserSettingsOutputError>
}

public struct CreateUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/userSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserSettingsOutputError>
}

public struct CreateUserSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    /// This member is required.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can download files from the streaming session to the local device.
    /// This member is required.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    /// This member is required.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    /// This member is required.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The tags to add to the user settings resource. A tag is a key-value pair.
    public var tags: [WorkSpacesWebClientTypes.Tag]?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    /// This member is required.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?

    public init (
        clientToken: Swift.String? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil
    )
    {
        self.clientToken = clientToken
        self.copyAllowed = copyAllowed
        self.downloadAllowed = downloadAllowed
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.tags = tags
        self.uploadAllowed = uploadAllowed
    }
}

struct CreateUserSettingsInputBody: Swift.Equatable {
    public let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let tags: [WorkSpacesWebClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension CreateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case downloadAllowed
        case pasteAllowed
        case printAllowed
        case tags
        case uploadAllowed
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserSettingsOutputResponse(userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension CreateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettingsArn = output.userSettingsArn
        } else {
            self.userSettingsArn = nil
        }
    }
}

public struct CreateUserSettingsOutputResponse: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct CreateUserSettingsOutputResponseBody: Swift.Equatable {
    public let userSettingsArn: Swift.String?
}

extension CreateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettingsArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
    }
}

extension DeleteBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)))"}
}

extension DeleteBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrowserSettingsOutputError>
}

public struct DeleteBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrowserSettingsOutputError>
}

public struct DeleteBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrowserSettingsOutputError>
}

public struct DeleteBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let browserSettingsArn = input.browserSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("browserSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/browserSettings/\(browserSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrowserSettingsOutputError>
}

public struct DeleteBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct DeleteBrowserSettingsInputBody: Swift.Equatable {
}

extension DeleteBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBrowserSettingsOutputResponse()"}
}

extension DeleteBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBrowserSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBrowserSettingsOutputResponseBody: Swift.Equatable {
}

extension DeleteBrowserSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIdentityProviderInput(identityProviderArn: \(Swift.String(describing: identityProviderArn)))"}
}

extension DeleteIdentityProviderInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteIdentityProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityProviderOutputError>
}

public struct DeleteIdentityProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityProviderOutputError>
}

public struct DeleteIdentityProviderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityProviderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityProviderOutputError>
}

public struct DeleteIdentityProviderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteIdentityProviderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityProviderArn = input.identityProviderArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityProviderArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identityProviders/\(identityProviderArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteIdentityProviderOutputError>
}

public struct DeleteIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init (
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct DeleteIdentityProviderInputBody: Swift.Equatable {
}

extension DeleteIdentityProviderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteIdentityProviderOutputResponse()"}
}

extension DeleteIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIdentityProviderOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteIdentityProviderOutputResponseBody: Swift.Equatable {
}

extension DeleteIdentityProviderOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNetworkSettingsInput(networkSettingsArn: \(Swift.String(describing: networkSettingsArn)))"}
}

extension DeleteNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkSettingsOutputError>
}

public struct DeleteNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkSettingsOutputError>
}

public struct DeleteNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkSettingsOutputError>
}

public struct DeleteNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let networkSettingsArn = input.networkSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("networkSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/networkSettings/\(networkSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteNetworkSettingsOutputError>
}

public struct DeleteNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct DeleteNetworkSettingsInputBody: Swift.Equatable {
}

extension DeleteNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteNetworkSettingsOutputResponse()"}
}

extension DeleteNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteNetworkSettingsOutputResponseBody: Swift.Equatable {
}

extension DeleteNetworkSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortalInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension DeletePortalInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeletePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeletePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortalOutputResponse()"}
}

extension DeletePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePortalOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePortalOutputResponseBody: Swift.Equatable {
}

extension DeletePortalOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTrustStoreInput(trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension DeleteTrustStoreInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteTrustStoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrustStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrustStoreOutputError>
}

public struct DeleteTrustStoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrustStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrustStoreOutputError>
}

public struct DeleteTrustStoreInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrustStoreInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrustStoreOutputError>
}

public struct DeleteTrustStoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTrustStoreInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trustStoreArn = input.trustStoreArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trustStoreArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/trustStores/\(trustStoreArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTrustStoreOutputError>
}

public struct DeleteTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct DeleteTrustStoreInputBody: Swift.Equatable {
}

extension DeleteTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrustStoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTrustStoreOutputResponse()"}
}

extension DeleteTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTrustStoreOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTrustStoreOutputResponseBody: Swift.Equatable {
}

extension DeleteTrustStoreOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserSettingsInput(userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension DeleteUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserSettingsOutputError>
}

public struct DeleteUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserSettingsOutputError>
}

public struct DeleteUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserSettingsOutputError>
}

public struct DeleteUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let userSettingsArn = input.userSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/userSettings/\(userSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserSettingsOutputError>
}

public struct DeleteUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct DeleteUserSettingsInputBody: Swift.Equatable {
}

extension DeleteUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserSettingsOutputResponse()"}
}

extension DeleteUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUserSettingsOutputResponseBody: Swift.Equatable {
}

extension DeleteUserSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateBrowserSettingsInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension DisassociateBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBrowserSettingsOutputError>
}

public struct DisassociateBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBrowserSettingsOutputError>
}

public struct DisassociateBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBrowserSettingsOutputError>
}

public struct DisassociateBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/browserSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBrowserSettingsOutputError>
}

public struct DisassociateBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateBrowserSettingsInputBody: Swift.Equatable {
}

extension DisassociateBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateBrowserSettingsOutputResponse()"}
}

extension DisassociateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateBrowserSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateBrowserSettingsOutputResponseBody: Swift.Equatable {
}

extension DisassociateBrowserSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateNetworkSettingsInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension DisassociateNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNetworkSettingsOutputError>
}

public struct DisassociateNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNetworkSettingsOutputError>
}

public struct DisassociateNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNetworkSettingsOutputError>
}

public struct DisassociateNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/networkSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNetworkSettingsOutputError>
}

public struct DisassociateNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateNetworkSettingsInputBody: Swift.Equatable {
}

extension DisassociateNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateNetworkSettingsOutputResponse()"}
}

extension DisassociateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateNetworkSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateNetworkSettingsOutputResponseBody: Swift.Equatable {
}

extension DisassociateNetworkSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTrustStoreInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension DisassociateTrustStoreInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateTrustStoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrustStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrustStoreOutputError>
}

public struct DisassociateTrustStoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrustStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrustStoreOutputError>
}

public struct DisassociateTrustStoreInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrustStoreInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrustStoreOutputError>
}

public struct DisassociateTrustStoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTrustStoreInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/trustStores"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTrustStoreOutputError>
}

public struct DisassociateTrustStoreInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateTrustStoreInputBody: Swift.Equatable {
}

extension DisassociateTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTrustStoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTrustStoreOutputResponse()"}
}

extension DisassociateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTrustStoreOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateTrustStoreOutputResponseBody: Swift.Equatable {
}

extension DisassociateTrustStoreOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateUserSettingsInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension DisassociateUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateUserSettingsOutputError>
}

public struct DisassociateUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateUserSettingsOutputError>
}

public struct DisassociateUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateUserSettingsOutputError>
}

public struct DisassociateUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/userSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateUserSettingsOutputError>
}

public struct DisassociateUserSettingsInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct DisassociateUserSettingsInputBody: Swift.Equatable {
}

extension DisassociateUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateUserSettingsOutputResponse()"}
}

extension DisassociateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateUserSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateUserSettingsOutputResponseBody: Swift.Equatable {
}

extension DisassociateUserSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkSpacesWebClientTypes {
    public enum EnabledType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnabledType] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnabledType(rawValue: rawValue) ?? EnabledType.sdkUnknown(rawValue)
        }
    }
}

extension GetBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBrowserSettingsInput(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)))"}
}

extension GetBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBrowserSettingsOutputError>
}

public struct GetBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBrowserSettingsOutputError>
}

public struct GetBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBrowserSettingsOutputError>
}

public struct GetBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let browserSettingsArn = input.browserSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("browserSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/browserSettings/\(browserSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBrowserSettingsOutputError>
}

public struct GetBrowserSettingsInput: Swift.Equatable {
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?

    public init (
        browserSettingsArn: Swift.String? = nil
    )
    {
        self.browserSettingsArn = browserSettingsArn
    }
}

struct GetBrowserSettingsInputBody: Swift.Equatable {
}

extension GetBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBrowserSettingsOutputResponse(browserSettings: \(Swift.String(describing: browserSettings)))"}
}

extension GetBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct GetBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init (
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct GetBrowserSettingsOutputResponseBody: Swift.Equatable {
    public let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension GetBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

extension GetIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentityProviderInput(identityProviderArn: \(Swift.String(describing: identityProviderArn)))"}
}

extension GetIdentityProviderInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetIdentityProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityProviderOutputError>
}

public struct GetIdentityProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityProviderOutputError>
}

public struct GetIdentityProviderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityProviderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityProviderOutputError>
}

public struct GetIdentityProviderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetIdentityProviderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityProviderArn = input.identityProviderArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityProviderArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identityProviders/\(identityProviderArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetIdentityProviderOutputError>
}

public struct GetIdentityProviderInput: Swift.Equatable {
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?

    public init (
        identityProviderArn: Swift.String? = nil
    )
    {
        self.identityProviderArn = identityProviderArn
    }
}

struct GetIdentityProviderInputBody: Swift.Equatable {
}

extension GetIdentityProviderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentityProviderOutputResponse(identityProvider: \(Swift.String(describing: identityProvider)))"}
}

extension GetIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct GetIdentityProviderOutputResponse: Swift.Equatable {
    /// The identity provider.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init (
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct GetIdentityProviderOutputResponseBody: Swift.Equatable {
    public let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension GetIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

extension GetNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkSettingsInput(networkSettingsArn: \(Swift.String(describing: networkSettingsArn)))"}
}

extension GetNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkSettingsOutputError>
}

public struct GetNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkSettingsOutputError>
}

public struct GetNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkSettingsOutputError>
}

public struct GetNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let networkSettingsArn = input.networkSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("networkSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/networkSettings/\(networkSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNetworkSettingsOutputError>
}

public struct GetNetworkSettingsInput: Swift.Equatable {
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?

    public init (
        networkSettingsArn: Swift.String? = nil
    )
    {
        self.networkSettingsArn = networkSettingsArn
    }
}

struct GetNetworkSettingsInputBody: Swift.Equatable {
}

extension GetNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNetworkSettingsOutputResponse(networkSettings: \(Swift.String(describing: networkSettings)))"}
}

extension GetNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct GetNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init (
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct GetNetworkSettingsOutputResponseBody: Swift.Equatable {
    public let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension GetNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

extension GetPortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPortalInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension GetPortalInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalOutputError>
}

public struct GetPortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalOutputError>
}

public struct GetPortalInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalOutputError>
}

public struct GetPortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalOutputError>
}

public struct GetPortalInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalInputBody: Swift.Equatable {
}

extension GetPortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPortalOutputResponse(portal: \(Swift.String(describing: portal)))"}
}

extension GetPortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct GetPortalOutputResponse: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init (
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct GetPortalOutputResponseBody: Swift.Equatable {
    public let portal: WorkSpacesWebClientTypes.Portal?
}

extension GetPortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

extension GetPortalServiceProviderMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPortalServiceProviderMetadataInput(portalArn: \(Swift.String(describing: portalArn)))"}
}

extension GetPortalServiceProviderMetadataInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPortalServiceProviderMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalServiceProviderMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPortalServiceProviderMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPortalServiceProviderMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalServiceProviderMetadataOutputError>
}

public struct GetPortalServiceProviderMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalServiceProviderMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPortalServiceProviderMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPortalServiceProviderMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalServiceProviderMetadataOutputError>
}

public struct GetPortalServiceProviderMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalServiceProviderMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetPortalServiceProviderMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPortalServiceProviderMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalServiceProviderMetadataOutputError>
}

public struct GetPortalServiceProviderMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPortalServiceProviderMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetPortalServiceProviderMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portalIdp/\(portalArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPortalServiceProviderMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPortalServiceProviderMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPortalServiceProviderMetadataOutputError>
}

public struct GetPortalServiceProviderMetadataInput: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        portalArn: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
    }
}

struct GetPortalServiceProviderMetadataInputBody: Swift.Equatable {
}

extension GetPortalServiceProviderMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPortalServiceProviderMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPortalServiceProviderMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPortalServiceProviderMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPortalServiceProviderMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPortalServiceProviderMetadataOutputResponse(portalArn: \(Swift.String(describing: portalArn)), serviceProviderSamlMetadata: \(Swift.String(describing: serviceProviderSamlMetadata)))"}
}

extension GetPortalServiceProviderMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPortalServiceProviderMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.portalArn = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct GetPortalServiceProviderMetadataOutputResponse: Swift.Equatable {
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service provider SAML metadata.
    public var serviceProviderSamlMetadata: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        serviceProviderSamlMetadata: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct GetPortalServiceProviderMetadataOutputResponseBody: Swift.Equatable {
    public let portalArn: Swift.String?
    public let serviceProviderSamlMetadata: Swift.String?
}

extension GetPortalServiceProviderMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case serviceProviderSamlMetadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
    }
}

extension GetTrustStoreCertificateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTrustStoreCertificateInput(thumbprint: \(Swift.String(describing: thumbprint)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension GetTrustStoreCertificateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTrustStoreCertificateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTrustStoreCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTrustStoreCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreCertificateOutputError>
}

public struct GetTrustStoreCertificateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTrustStoreCertificateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let thumbprint = input.operationInput.thumbprint {
            let thumbprintQueryItem = ClientRuntime.URLQueryItem(name: "thumbprint".urlPercentEncoding(), value: Swift.String(thumbprint).urlPercentEncoding())
            input.builder.withQueryItem(thumbprintQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTrustStoreCertificateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreCertificateOutputError>
}

public struct GetTrustStoreCertificateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreCertificateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTrustStoreCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTrustStoreCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreCertificateOutputError>
}

public struct GetTrustStoreCertificateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreCertificateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTrustStoreCertificateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trustStoreArn = input.trustStoreArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trustStoreArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/trustStores/\(trustStoreArn)/certificate"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTrustStoreCertificateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreCertificateOutputError>
}

public struct GetTrustStoreCertificateInput: Swift.Equatable {
    /// The thumbprint of the trust store certificate.
    /// This member is required.
    public var thumbprint: Swift.String?
    /// The ARN of the trust store certificate.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        thumbprint: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.thumbprint = thumbprint
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateInputBody: Swift.Equatable {
}

extension GetTrustStoreCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustStoreCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrustStoreCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTrustStoreCertificateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrustStoreCertificateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTrustStoreCertificateOutputResponse(certificate: \(Swift.String(describing: certificate)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension GetTrustStoreCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTrustStoreCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificate = nil
            self.trustStoreArn = nil
        }
    }
}

public struct GetTrustStoreCertificateOutputResponse: Swift.Equatable {
    /// The certificate of the trust store certificate.
    public var certificate: WorkSpacesWebClientTypes.Certificate?
    /// The ARN of the trust store certificate.
    public var trustStoreArn: Swift.String?

    public init (
        certificate: WorkSpacesWebClientTypes.Certificate? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreCertificateOutputResponseBody: Swift.Equatable {
    public let trustStoreArn: Swift.String?
    public let certificate: WorkSpacesWebClientTypes.Certificate?
}

extension GetTrustStoreCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Certificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension GetTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTrustStoreInput(trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension GetTrustStoreInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTrustStoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreOutputError>
}

public struct GetTrustStoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreOutputError>
}

public struct GetTrustStoreInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreOutputError>
}

public struct GetTrustStoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTrustStoreInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trustStoreArn = input.trustStoreArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trustStoreArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/trustStores/\(trustStoreArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTrustStoreOutputError>
}

public struct GetTrustStoreInput: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct GetTrustStoreInputBody: Swift.Equatable {
}

extension GetTrustStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrustStoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTrustStoreOutputResponse(trustStore: \(Swift.String(describing: trustStore)))"}
}

extension GetTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStore = output.trustStore
        } else {
            self.trustStore = nil
        }
    }
}

public struct GetTrustStoreOutputResponse: Swift.Equatable {
    /// The trust store.
    public var trustStore: WorkSpacesWebClientTypes.TrustStore?

    public init (
        trustStore: WorkSpacesWebClientTypes.TrustStore? = nil
    )
    {
        self.trustStore = trustStore
    }
}

struct GetTrustStoreOutputResponseBody: Swift.Equatable {
    public let trustStore: WorkSpacesWebClientTypes.TrustStore?
}

extension GetTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStore
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.TrustStore.self, forKey: .trustStore)
        trustStore = trustStoreDecoded
    }
}

extension GetUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserSettingsInput(userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension GetUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let userSettingsArn = input.userSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/userSettings/\(userSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetUserSettingsOutputError>
}

public struct GetUserSettingsInput: Swift.Equatable {
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        userSettingsArn: Swift.String? = nil
    )
    {
        self.userSettingsArn = userSettingsArn
    }
}

struct GetUserSettingsInputBody: Swift.Equatable {
}

extension GetUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserSettingsOutputResponse(userSettings: \(Swift.String(describing: userSettings)))"}
}

extension GetUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct GetUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init (
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct GetUserSettingsOutputResponseBody: Swift.Equatable {
    public let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension GetUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityproviderdetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityproviderdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
    }
}

extension WorkSpacesWebClientTypes.IdentityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProvider(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderName: \(Swift.String(describing: identityProviderName)), identityProviderType: \(Swift.String(describing: identityProviderType)))"}
}

extension WorkSpacesWebClientTypes {
    /// The identity provider.
    public struct IdentityProvider: Swift.Equatable {
        /// The ARN of the identity provider.
        /// This member is required.
        public var identityProviderArn: Swift.String?
        /// The identity provider details. The following list describes the provider detail keys for each identity provider type.
        ///
        /// * For Google and Login with Amazon:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For Facebook:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * authorize_scopes
        ///
        /// * api_version
        ///
        ///
        ///
        ///
        /// * For Sign in with Apple:
        ///
        /// * client_id
        ///
        /// * team_id
        ///
        /// * key_id
        ///
        /// * private_key
        ///
        /// * authorize_scopes
        ///
        ///
        ///
        ///
        /// * For OIDC providers:
        ///
        /// * client_id
        ///
        /// * client_secret
        ///
        /// * attributes_request_method
        ///
        /// * oidc_issuer
        ///
        /// * authorize_scopes
        ///
        /// * authorize_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * token_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * attributes_url if not available from discovery URL specified by oidc_issuer key
        ///
        /// * jwks_uri if not available from discovery URL specified by oidc_issuer key
        ///
        ///
        ///
        ///
        /// * For SAML providers:
        ///
        /// * MetadataFile OR MetadataURL
        ///
        /// * IDPSignout optional
        public var identityProviderDetails: [Swift.String:Swift.String]?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init (
            identityProviderArn: Swift.String? = nil,
            identityProviderDetails: [Swift.String:Swift.String]? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderDetails = identityProviderDetails
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviderArn
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityProviderArn = identityProviderArn {
            try encodeContainer.encode(identityProviderArn, forKey: .identityProviderArn)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderArn)
        identityProviderArn = identityProviderArnDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
    }
}

extension WorkSpacesWebClientTypes.IdentityProviderSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentityProviderSummary(identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderName: \(Swift.String(describing: identityProviderName)), identityProviderType: \(Swift.String(describing: identityProviderType)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the identity provider.
    public struct IdentityProviderSummary: Swift.Equatable {
        /// The ARN of the identity provider.
        public var identityProviderArn: Swift.String?
        /// The identity provider name.
        public var identityProviderName: Swift.String?
        /// The identity provider type.
        public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

        public init (
            identityProviderArn: Swift.String? = nil,
            identityProviderName: Swift.String? = nil,
            identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
        )
        {
            self.identityProviderArn = identityProviderArn
            self.identityProviderName = identityProviderName
            self.identityProviderType = identityProviderType
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum IdentityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case facebook
        case google
        case loginwithamazon
        case oidc
        case saml
        case signinwithapple
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityProviderType] {
            return [
                .facebook,
                .google,
                .loginwithamazon,
                .oidc,
                .saml,
                .signinwithapple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .facebook: return "Facebook"
            case .google: return "Google"
            case .loginwithamazon: return "LoginWithAmazon"
            case .oidc: return "OIDC"
            case .saml: return "SAML"
            case .signinwithapple: return "SignInWithApple"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBrowserSettingsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrowserSettingsOutputError>
}

public struct ListBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrowserSettingsOutputError>
}

public struct ListBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrowserSettingsOutputError>
}

public struct ListBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/browserSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrowserSettingsOutputError>
}

public struct ListBrowserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsInputBody: Swift.Equatable {
}

extension ListBrowserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBrowserSettingsOutputResponse(browserSettings: \(Swift.String(describing: browserSettings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
            self.nextToken = output.nextToken
        } else {
            self.browserSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    public var browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.browserSettings = browserSettings
        self.nextToken = nextToken
    }
}

struct ListBrowserSettingsOutputResponseBody: Swift.Equatable {
    public let browserSettings: [WorkSpacesWebClientTypes.BrowserSettingsSummary]?
    public let nextToken: Swift.String?
}

extension ListBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.BrowserSettingsSummary?].self, forKey: .browserSettings)
        var browserSettingsDecoded0:[WorkSpacesWebClientTypes.BrowserSettingsSummary]? = nil
        if let browserSettingsContainer = browserSettingsContainer {
            browserSettingsDecoded0 = [WorkSpacesWebClientTypes.BrowserSettingsSummary]()
            for structure0 in browserSettingsContainer {
                if let structure0 = structure0 {
                    browserSettingsDecoded0?.append(structure0)
                }
            }
        }
        browserSettings = browserSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityProvidersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentityProvidersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension ListIdentityProvidersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListIdentityProvidersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityProvidersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityProvidersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityProvidersOutputError>
}

public struct ListIdentityProvidersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListIdentityProvidersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListIdentityProvidersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityProvidersOutputError>
}

public struct ListIdentityProvidersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityProvidersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListIdentityProvidersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIdentityProvidersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityProvidersOutputError>
}

public struct ListIdentityProvidersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListIdentityProvidersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListIdentityProvidersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)/identityProviders"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListIdentityProvidersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListIdentityProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListIdentityProvidersOutputError>
}

public struct ListIdentityProvidersInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalArn = portalArn
    }
}

struct ListIdentityProvidersInputBody: Swift.Equatable {
}

extension ListIdentityProvidersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIdentityProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityProvidersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityProvidersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListIdentityProvidersOutputResponse(identityProviders: \(Swift.String(describing: identityProviders)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListIdentityProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIdentityProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProviders = output.identityProviders
            self.nextToken = output.nextToken
        } else {
            self.identityProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListIdentityProvidersOutputResponse: Swift.Equatable {
    /// The identity providers.
    public var identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityProviders = identityProviders
        self.nextToken = nextToken
    }
}

struct ListIdentityProvidersOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let identityProviders: [WorkSpacesWebClientTypes.IdentityProviderSummary]?
}

extension ListIdentityProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProviders
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let identityProvidersContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.IdentityProviderSummary?].self, forKey: .identityProviders)
        var identityProvidersDecoded0:[WorkSpacesWebClientTypes.IdentityProviderSummary]? = nil
        if let identityProvidersContainer = identityProvidersContainer {
            identityProvidersDecoded0 = [WorkSpacesWebClientTypes.IdentityProviderSummary]()
            for structure0 in identityProvidersContainer {
                if let structure0 = structure0 {
                    identityProvidersDecoded0?.append(structure0)
                }
            }
        }
        identityProviders = identityProvidersDecoded0
    }
}

extension ListNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNetworkSettingsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkSettingsOutputError>
}

public struct ListNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkSettingsOutputError>
}

public struct ListNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkSettingsOutputError>
}

public struct ListNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/networkSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListNetworkSettingsOutputError>
}

public struct ListNetworkSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsInputBody: Swift.Equatable {
}

extension ListNetworkSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListNetworkSettingsOutputResponse(networkSettings: \(Swift.String(describing: networkSettings)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
            self.nextToken = output.nextToken
        } else {
            self.networkSettings = nil
            self.nextToken = nil
        }
    }
}

public struct ListNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    public var networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkSettings = networkSettings
        self.nextToken = nextToken
    }
}

struct ListNetworkSettingsOutputResponseBody: Swift.Equatable {
    public let networkSettings: [WorkSpacesWebClientTypes.NetworkSettingsSummary]?
    public let nextToken: Swift.String?
}

extension ListNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.NetworkSettingsSummary?].self, forKey: .networkSettings)
        var networkSettingsDecoded0:[WorkSpacesWebClientTypes.NetworkSettingsSummary]? = nil
        if let networkSettingsContainer = networkSettingsContainer {
            networkSettingsDecoded0 = [WorkSpacesWebClientTypes.NetworkSettingsSummary]()
            for structure0 in networkSettingsContainer {
                if let structure0 = structure0 {
                    networkSettingsDecoded0?.append(structure0)
                }
            }
        }
        networkSettings = networkSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPortalsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortalsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPortalsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPortalsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListPortalsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPortalsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListPortalsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/portals"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPortalsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPortalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortalsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortalsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortalsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), portals: \(Swift.String(describing: portals)))"}
}

extension ListPortalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPortalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portals = output.portals
        } else {
            self.nextToken = nil
            self.portals = nil
        }
    }
}

public struct ListPortalsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The portals in the list.
    public var portals: [WorkSpacesWebClientTypes.PortalSummary]?

    public init (
        nextToken: Swift.String? = nil,
        portals: [WorkSpacesWebClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portals = portals
    }
}

struct ListPortalsOutputResponseBody: Swift.Equatable {
    public let portals: [WorkSpacesWebClientTypes.PortalSummary]?
    public let nextToken: Swift.String?
}

extension ListPortalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.PortalSummary?].self, forKey: .portals)
        var portalsDecoded0:[WorkSpacesWebClientTypes.PortalSummary]? = nil
        if let portalsContainer = portalsContainer {
            portalsDecoded0 = [WorkSpacesWebClientTypes.PortalSummary]()
            for structure0 in portalsContainer {
                if let structure0 = structure0 {
                    portalsDecoded0?.append(structure0)
                }
            }
        }
        portals = portalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags of the resource.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [WorkSpacesWebClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTrustStoreCertificatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrustStoreCertificatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension ListTrustStoreCertificatesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTrustStoreCertificatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoreCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrustStoreCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrustStoreCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoreCertificatesOutputError>
}

public struct ListTrustStoreCertificatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoreCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrustStoreCertificatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrustStoreCertificatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoreCertificatesOutputError>
}

public struct ListTrustStoreCertificatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoreCertificatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTrustStoreCertificatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrustStoreCertificatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoreCertificatesOutputError>
}

public struct ListTrustStoreCertificatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoreCertificatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTrustStoreCertificatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trustStoreArn = input.trustStoreArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trustStoreArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/trustStores/\(trustStoreArn)/certificates"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrustStoreCertificatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoreCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoreCertificatesOutputError>
}

public struct ListTrustStoreCertificatesInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The ARN of the trust store
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesInputBody: Swift.Equatable {
}

extension ListTrustStoreCertificatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustStoreCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrustStoreCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTrustStoreCertificatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrustStoreCertificatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrustStoreCertificatesOutputResponse(certificateList: \(Swift.String(describing: certificateList)), nextToken: \(Swift.String(describing: nextToken)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension ListTrustStoreCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTrustStoreCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateList = output.certificateList
            self.nextToken = output.nextToken
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.certificateList = nil
            self.nextToken = nil
            self.trustStoreArn = nil
        }
    }
}

public struct ListTrustStoreCertificatesOutputResponse: Swift.Equatable {
    /// The certificate list.
    public var certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    /// The pagination token used to retrieve the next page of results for this operation.>
    public var nextToken: Swift.String?
    /// The ARN of the trust store.
    public var trustStoreArn: Swift.String?

    public init (
        certificateList: [WorkSpacesWebClientTypes.CertificateSummary]? = nil,
        nextToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificateList = certificateList
        self.nextToken = nextToken
        self.trustStoreArn = trustStoreArn
    }
}

struct ListTrustStoreCertificatesOutputResponseBody: Swift.Equatable {
    public let certificateList: [WorkSpacesWebClientTypes.CertificateSummary]?
    public let trustStoreArn: Swift.String?
    public let nextToken: Swift.String?
}

extension ListTrustStoreCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateList
        case nextToken
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.CertificateSummary?].self, forKey: .certificateList)
        var certificateListDecoded0:[WorkSpacesWebClientTypes.CertificateSummary]? = nil
        if let certificateListContainer = certificateListContainer {
            certificateListDecoded0 = [WorkSpacesWebClientTypes.CertificateSummary]()
            for structure0 in certificateListContainer {
                if let structure0 = structure0 {
                    certificateListDecoded0?.append(structure0)
                }
            }
        }
        certificateList = certificateListDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrustStoresInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrustStoresInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListTrustStoresInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTrustStoresInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrustStoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrustStoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoresOutputError>
}

public struct ListTrustStoresInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTrustStoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTrustStoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoresOutputError>
}

public struct ListTrustStoresInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoresInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTrustStoresInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrustStoresInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoresOutputError>
}

public struct ListTrustStoresInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTrustStoresInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTrustStoresInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/trustStores"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTrustStoresInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTrustStoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTrustStoresOutputError>
}

public struct ListTrustStoresInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrustStoresInputBody: Swift.Equatable {
}

extension ListTrustStoresInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTrustStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrustStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTrustStoresOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrustStoresOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTrustStoresOutputResponse(nextToken: \(Swift.String(describing: nextToken)), trustStores: \(Swift.String(describing: trustStores)))"}
}

extension ListTrustStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTrustStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustStores = output.trustStores
        } else {
            self.nextToken = nil
            self.trustStores = nil
        }
    }
}

public struct ListTrustStoresOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The trust stores.
    public var trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?

    public init (
        nextToken: Swift.String? = nil,
        trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustStores = trustStores
    }
}

struct ListTrustStoresOutputResponseBody: Swift.Equatable {
    public let trustStores: [WorkSpacesWebClientTypes.TrustStoreSummary]?
    public let nextToken: Swift.String?
}

extension ListTrustStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case trustStores
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoresContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.TrustStoreSummary?].self, forKey: .trustStores)
        var trustStoresDecoded0:[WorkSpacesWebClientTypes.TrustStoreSummary]? = nil
        if let trustStoresContainer = trustStoresContainer {
            trustStoresDecoded0 = [WorkSpacesWebClientTypes.TrustStoreSummary]()
            for structure0 in trustStoresContainer {
                if let structure0 = structure0 {
                    trustStoresDecoded0?.append(structure0)
                }
            }
        }
        trustStores = trustStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUserSettingsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserSettingsOutputError>
}

public struct ListUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserSettingsOutputError>
}

public struct ListUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserSettingsOutputError>
}

public struct ListUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/userSettings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUserSettingsOutputError>
}

public struct ListUserSettingsInput: Swift.Equatable {
    /// The maximum number of results to be included in the next page.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUserSettingsInputBody: Swift.Equatable {
}

extension ListUserSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUserSettingsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), userSettings: \(Swift.String(describing: userSettings)))"}
}

extension ListUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userSettings = output.userSettings
        } else {
            self.nextToken = nil
            self.userSettings = nil
        }
    }
}

public struct ListUserSettingsOutputResponse: Swift.Equatable {
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?
    /// The user settings.
    public var userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?

    public init (
        nextToken: Swift.String? = nil,
        userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.userSettings = userSettings
    }
}

struct ListUserSettingsOutputResponseBody: Swift.Equatable {
    public let userSettings: [WorkSpacesWebClientTypes.UserSettingsSummary]?
    public let nextToken: Swift.String?
}

extension ListUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case userSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.UserSettingsSummary?].self, forKey: .userSettings)
        var userSettingsDecoded0:[WorkSpacesWebClientTypes.UserSettingsSummary]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [WorkSpacesWebClientTypes.UserSettingsSummary]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WorkSpacesWebClientTypes.NetworkSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case networkSettingsArn
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arnlist0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arnlist0)
            }
        }
        if let networkSettingsArn = networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension WorkSpacesWebClientTypes.NetworkSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension WorkSpacesWebClientTypes {
    /// A network settings resource that can be associated with a web portal. Once associated with a web portal, network settings define how streaming instances will connect with your specified VPC.
    public struct NetworkSettings: Swift.Equatable {
        /// A list of web portal ARNs that this network settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the network settings.
        /// This member is required.
        public var networkSettingsArn: Swift.String?
        /// One or more security groups used to control access from streaming instances to your VPC.
        public var securityGroupIds: [Swift.String]?
        /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
        public var subnetIds: [Swift.String]?
        /// The VPC that streaming instances will connect to.
        public var vpcId: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            networkSettingsArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.networkSettingsArn = networkSettingsArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.NetworkSettingsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettingsArn
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkSettingsArn = networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension WorkSpacesWebClientTypes.NetworkSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NetworkSettingsSummary(networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of network settings.
    public struct NetworkSettingsSummary: Swift.Equatable {
        /// The ARN of the network settings.
        public var networkSettingsArn: Swift.String?
        /// The VPC ID of the network settings.
        public var vpcId: Swift.String?

        public init (
            networkSettingsArn: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkSettingsArn = networkSettingsArn
            self.vpcId = vpcId
        }
    }

}

extension WorkSpacesWebClientTypes.Portal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case statusReason
        case trustStoreArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let networkSettingsArn = networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let trustStoreArn = trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userSettingsArn = userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension WorkSpacesWebClientTypes.Portal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Portal(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), displayName: \(Swift.String(describing: displayName)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), statusReason: \(Swift.String(describing: statusReason)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// The web portal.
    public struct Portal: Swift.Equatable {
        /// The ARN of the browser settings that is associated with this web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser that users see when using a streaming session.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// A message that explains why the web portal is in its current status.
        public var statusReason: Swift.String?
        /// The ARN of the trust store that is associated with the web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the trust store that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init (
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            statusReason: Swift.String? = nil,
            trustStoreArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.statusReason = statusReason
            self.trustStoreArn = trustStoreArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum PortalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case incomplete
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalStatus] {
            return [
                .active,
                .incomplete,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .incomplete: return "Incomplete"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalStatus(rawValue: rawValue) ?? PortalStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettingsArn
        case browserType
        case creationDate
        case displayName
        case networkSettingsArn
        case portalArn
        case portalEndpoint
        case portalStatus
        case rendererType
        case trustStoreArn
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserSettingsArn = browserSettingsArn {
            try encodeContainer.encode(browserSettingsArn, forKey: .browserSettingsArn)
        }
        if let browserType = browserType {
            try encodeContainer.encode(browserType.rawValue, forKey: .browserType)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let networkSettingsArn = networkSettingsArn {
            try encodeContainer.encode(networkSettingsArn, forKey: .networkSettingsArn)
        }
        if let portalArn = portalArn {
            try encodeContainer.encode(portalArn, forKey: .portalArn)
        }
        if let portalEndpoint = portalEndpoint {
            try encodeContainer.encode(portalEndpoint, forKey: .portalEndpoint)
        }
        if let portalStatus = portalStatus {
            try encodeContainer.encode(portalStatus.rawValue, forKey: .portalStatus)
        }
        if let rendererType = rendererType {
            try encodeContainer.encode(rendererType.rawValue, forKey: .rendererType)
        }
        if let trustStoreArn = trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
        if let userSettingsArn = userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let rendererTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.RendererType.self, forKey: .rendererType)
        rendererType = rendererTypeDecoded
        let browserTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserType.self, forKey: .browserType)
        browserType = browserTypeDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalEndpoint)
        portalEndpoint = portalEndpointDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let browserSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserSettingsArn)
        browserSettingsArn = browserSettingsArnDecoded
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let networkSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkSettingsArn)
        networkSettingsArn = networkSettingsArnDecoded
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes.PortalSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalSummary(browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), browserType: \(Swift.String(describing: browserType)), creationDate: \(Swift.String(describing: creationDate)), displayName: \(Swift.String(describing: displayName)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), portalArn: \(Swift.String(describing: portalArn)), portalEndpoint: \(Swift.String(describing: portalEndpoint)), portalStatus: \(Swift.String(describing: portalStatus)), rendererType: \(Swift.String(describing: rendererType)), trustStoreArn: \(Swift.String(describing: trustStoreArn)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the portal.
    public struct PortalSummary: Swift.Equatable {
        /// The ARN of the browser settings that is associated with the web portal.
        public var browserSettingsArn: Swift.String?
        /// The browser type of the web portal.
        public var browserType: WorkSpacesWebClientTypes.BrowserType?
        /// The creation date of the web portal.
        public var creationDate: ClientRuntime.Date?
        /// The name of the web portal.
        public var displayName: Swift.String?
        /// The ARN of the network settings that is associated with the web portal.
        public var networkSettingsArn: Swift.String?
        /// The ARN of the web portal.
        public var portalArn: Swift.String?
        /// The endpoint URL of the web portal that users access in order to start streaming sessions.
        public var portalEndpoint: Swift.String?
        /// The status of the web portal.
        public var portalStatus: WorkSpacesWebClientTypes.PortalStatus?
        /// The renderer that is used in streaming sessions.
        public var rendererType: WorkSpacesWebClientTypes.RendererType?
        /// The ARN of the trust that is associated with this web portal.
        public var trustStoreArn: Swift.String?
        /// The ARN of the user settings that is associated with the web portal.
        public var userSettingsArn: Swift.String?

        public init (
            browserSettingsArn: Swift.String? = nil,
            browserType: WorkSpacesWebClientTypes.BrowserType? = nil,
            creationDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            networkSettingsArn: Swift.String? = nil,
            portalArn: Swift.String? = nil,
            portalEndpoint: Swift.String? = nil,
            portalStatus: WorkSpacesWebClientTypes.PortalStatus? = nil,
            rendererType: WorkSpacesWebClientTypes.RendererType? = nil,
            trustStoreArn: Swift.String? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.browserSettingsArn = browserSettingsArn
            self.browserType = browserType
            self.creationDate = creationDate
            self.displayName = displayName
            self.networkSettingsArn = networkSettingsArn
            self.portalArn = portalArn
            self.portalEndpoint = portalEndpoint
            self.portalStatus = portalStatus
            self.rendererType = rendererType
            self.trustStoreArn = trustStoreArn
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum RendererType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appstream
        case sdkUnknown(Swift.String)

        public static var allCases: [RendererType] {
            return [
                .appstream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "AppStream"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RendererType(rawValue: rawValue) ?? RendererType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Hypothetical identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Hypothetical type of the resource affected.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service quota has been exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The originating quota.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?
    /// The originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkSpacesWebClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension WorkSpacesWebClientTypes {
    /// The tag.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(clientToken: \(Swift.String(describing: clientToken)), resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token returns the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the resource.
    /// This member is required.
    public var tags: [WorkSpacesWebClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [WorkSpacesWebClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [WorkSpacesWebClientTypes.Tag]?
    public let clientToken: Swift.String?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkSpacesWebClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkSpacesWebClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a throttling error.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The originating quota.
    public var quotaCode: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int
    /// The originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are too many tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Name of the resource affected.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WorkSpacesWebClientTypes.TrustStore: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arnlist0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arnlist0)
            }
        }
        if let trustStoreArn = trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes.TrustStore: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustStore(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// A trust store that can be associated with a web portal. A trust store contains certificate authority (CA) certificates. Once associated with a web portal, the browser in a streaming session will recognize certificates that have been issued using any of the CAs in the trust store. If your organization has internal websites that use certificates issued by private CAs, you should add the private CA certificate to the trust store.
    public struct TrustStore: Swift.Equatable {
        /// A list of web portal ARNs that this trust store is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            trustStoreArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension WorkSpacesWebClientTypes.TrustStoreSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustStoreArn = trustStoreArn {
            try encodeContainer.encode(trustStoreArn, forKey: .trustStoreArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

extension WorkSpacesWebClientTypes.TrustStoreSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustStoreSummary(trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of the trust store.
    public struct TrustStoreSummary: Swift.Equatable {
        /// The ARN of the trust store.
        public var trustStoreArn: Swift.String?

        public init (
            trustStoreArn: Swift.String? = nil
        )
        {
            self.trustStoreArn = trustStoreArn
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateBrowserSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrowserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrowserSettingsOutputError>
}

extension UpdateBrowserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrowserSettingsInput(browserPolicy: \(Swift.String(describing: browserPolicy)), browserSettingsArn: \(Swift.String(describing: browserSettingsArn)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension UpdateBrowserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let browserPolicy = browserPolicy {
            try encodeContainer.encode(browserPolicy, forKey: .browserPolicy)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateBrowserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrowserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrowserSettingsOutputError>
}

public struct UpdateBrowserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrowserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrowserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrowserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrowserSettingsOutputError>
}

public struct UpdateBrowserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrowserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrowserSettingsOutputError>
}

public struct UpdateBrowserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrowserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBrowserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let browserSettingsArn = input.browserSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("browserSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/browserSettings/\(browserSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrowserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrowserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrowserSettingsOutputError>
}

public struct UpdateBrowserSettingsInput: Swift.Equatable {
    /// A JSON string containing Chrome Enterprise policies that will be applied to all streaming sessions.
    public var browserPolicy: Swift.String?
    /// The ARN of the browser settings.
    /// This member is required.
    public var browserSettingsArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?

    public init (
        browserPolicy: Swift.String? = nil,
        browserSettingsArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.browserPolicy = browserPolicy
        self.browserSettingsArn = browserSettingsArn
        self.clientToken = clientToken
    }
}

struct UpdateBrowserSettingsInputBody: Swift.Equatable {
    public let browserPolicy: Swift.String?
    public let clientToken: Swift.String?
}

extension UpdateBrowserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserPolicy
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .browserPolicy)
        browserPolicy = browserPolicyDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateBrowserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrowserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrowserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrowserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrowserSettingsOutputResponse(browserSettings: \(Swift.String(describing: browserSettings)))"}
}

extension UpdateBrowserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBrowserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.browserSettings = output.browserSettings
        } else {
            self.browserSettings = nil
        }
    }
}

public struct UpdateBrowserSettingsOutputResponse: Swift.Equatable {
    /// The browser settings.
    /// This member is required.
    public var browserSettings: WorkSpacesWebClientTypes.BrowserSettings?

    public init (
        browserSettings: WorkSpacesWebClientTypes.BrowserSettings? = nil
    )
    {
        self.browserSettings = browserSettings
    }
}

struct UpdateBrowserSettingsOutputResponseBody: Swift.Equatable {
    public let browserSettings: WorkSpacesWebClientTypes.BrowserSettings?
}

extension UpdateBrowserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case browserSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let browserSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.BrowserSettings.self, forKey: .browserSettings)
        browserSettings = browserSettingsDecoded
    }
}

public struct UpdateIdentityProviderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderOutputError>
}

extension UpdateIdentityProviderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderInput(clientToken: \(Swift.String(describing: clientToken)), identityProviderArn: \(Swift.String(describing: identityProviderArn)), identityProviderDetails: \(Swift.String(describing: identityProviderDetails)), identityProviderName: \(Swift.String(describing: identityProviderName)), identityProviderType: \(Swift.String(describing: identityProviderType)))"}
}

extension UpdateIdentityProviderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let identityProviderDetails = identityProviderDetails {
            var identityProviderDetailsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .identityProviderDetails)
            for (dictKey0, identityproviderdetails0) in identityProviderDetails {
                try identityProviderDetailsContainer.encode(identityproviderdetails0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

public struct UpdateIdentityProviderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderOutputError>
}

public struct UpdateIdentityProviderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateIdentityProviderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateIdentityProviderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderOutputError>
}

public struct UpdateIdentityProviderInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderOutputError>
}

public struct UpdateIdentityProviderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateIdentityProviderInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateIdentityProviderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let identityProviderArn = input.identityProviderArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("identityProviderArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/identityProviders/\(identityProviderArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateIdentityProviderInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateIdentityProviderOutputError>
}

public struct UpdateIdentityProviderInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the identity provider.
    /// This member is required.
    public var identityProviderArn: Swift.String?
    /// The details of the identity provider.
    public var identityProviderDetails: [Swift.String:Swift.String]?
    /// The name of the identity provider.
    public var identityProviderName: Swift.String?
    /// The type of the identity provider.
    public var identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?

    public init (
        clientToken: Swift.String? = nil,
        identityProviderArn: Swift.String? = nil,
        identityProviderDetails: [Swift.String:Swift.String]? = nil,
        identityProviderName: Swift.String? = nil,
        identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType? = nil
    )
    {
        self.clientToken = clientToken
        self.identityProviderArn = identityProviderArn
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderName = identityProviderName
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderInputBody: Swift.Equatable {
    public let identityProviderName: Swift.String?
    public let identityProviderType: WorkSpacesWebClientTypes.IdentityProviderType?
    public let identityProviderDetails: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension UpdateIdentityProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case identityProviderDetails
        case identityProviderName
        case identityProviderType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderDetailsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .identityProviderDetails)
        var identityProviderDetailsDecoded0: [Swift.String:Swift.String]? = nil
        if let identityProviderDetailsContainer = identityProviderDetailsContainer {
            identityProviderDetailsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringtype0) in identityProviderDetailsContainer {
                if let stringtype0 = stringtype0 {
                    identityProviderDetailsDecoded0?[key0] = stringtype0
                }
            }
        }
        identityProviderDetails = identityProviderDetailsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateIdentityProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityProviderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentityProviderOutputResponse(identityProvider: \(Swift.String(describing: identityProvider)))"}
}

extension UpdateIdentityProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.identityProvider = output.identityProvider
        } else {
            self.identityProvider = nil
        }
    }
}

public struct UpdateIdentityProviderOutputResponse: Swift.Equatable {
    /// The identity provider.
    /// This member is required.
    public var identityProvider: WorkSpacesWebClientTypes.IdentityProvider?

    public init (
        identityProvider: WorkSpacesWebClientTypes.IdentityProvider? = nil
    )
    {
        self.identityProvider = identityProvider
    }
}

struct UpdateIdentityProviderOutputResponseBody: Swift.Equatable {
    public let identityProvider: WorkSpacesWebClientTypes.IdentityProvider?
}

extension UpdateIdentityProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityProvider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.IdentityProvider.self, forKey: .identityProvider)
        identityProvider = identityProviderDecoded
    }
}

public struct UpdateNetworkSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkSettingsOutputError>
}

extension UpdateNetworkSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSettingsInput(clientToken: \(Swift.String(describing: clientToken)), networkSettingsArn: \(Swift.String(describing: networkSettingsArn)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), subnetIds: \(Swift.String(describing: subnetIds)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension UpdateNetworkSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct UpdateNetworkSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkSettingsOutputError>
}

public struct UpdateNetworkSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateNetworkSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateNetworkSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkSettingsOutputError>
}

public struct UpdateNetworkSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkSettingsOutputError>
}

public struct UpdateNetworkSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateNetworkSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateNetworkSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let networkSettingsArn = input.networkSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("networkSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/networkSettings/\(networkSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateNetworkSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateNetworkSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateNetworkSettingsOutputError>
}

public struct UpdateNetworkSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the network settings.
    /// This member is required.
    public var networkSettingsArn: Swift.String?
    /// One or more security groups used to control access from streaming instances to your VPC.
    public var securityGroupIds: [Swift.String]?
    /// The subnets in which network interfaces are created to connect streaming instances to your VPC. At least two of these subnets must be in different availability zones.
    public var subnetIds: [Swift.String]?
    /// The VPC that streaming instances will connect to.
    public var vpcId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        networkSettingsArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.networkSettingsArn = networkSettingsArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateNetworkSettingsInputBody: Swift.Equatable {
    public let vpcId: Swift.String?
    public let subnetIds: [Swift.String]?
    public let securityGroupIds: [Swift.String]?
    public let clientToken: Swift.String?
}

extension UpdateNetworkSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case subnetIds
        case vpcId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateNetworkSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNetworkSettingsOutputResponse(networkSettings: \(Swift.String(describing: networkSettings)))"}
}

extension UpdateNetworkSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateNetworkSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkSettings = output.networkSettings
        } else {
            self.networkSettings = nil
        }
    }
}

public struct UpdateNetworkSettingsOutputResponse: Swift.Equatable {
    /// The network settings.
    /// This member is required.
    public var networkSettings: WorkSpacesWebClientTypes.NetworkSettings?

    public init (
        networkSettings: WorkSpacesWebClientTypes.NetworkSettings? = nil
    )
    {
        self.networkSettings = networkSettings
    }
}

struct UpdateNetworkSettingsOutputResponseBody: Swift.Equatable {
    public let networkSettings: WorkSpacesWebClientTypes.NetworkSettings?
}

extension UpdateNetworkSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.NetworkSettings.self, forKey: .networkSettings)
        networkSettings = networkSettingsDecoded
    }
}

public struct UpdatePortalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

extension UpdatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalInput(displayName: \(Swift.String(describing: displayName)), portalArn: \(Swift.String(describing: portalArn)))"}
}

extension UpdatePortalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

public struct UpdatePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalArn = input.portalArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInput: Swift.Equatable {
    /// The name of the web portal. This is not visible to users who log into the web portal.
    public var displayName: Swift.String?
    /// The ARN of the web portal.
    /// This member is required.
    public var portalArn: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        portalArn: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.portalArn = portalArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    public let displayName: Swift.String?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortalOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalOutputResponse(portal: \(Swift.String(describing: portal)))"}
}

extension UpdatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portal = output.portal
        } else {
            self.portal = nil
        }
    }
}

public struct UpdatePortalOutputResponse: Swift.Equatable {
    /// The web portal.
    public var portal: WorkSpacesWebClientTypes.Portal?

    public init (
        portal: WorkSpacesWebClientTypes.Portal? = nil
    )
    {
        self.portal = portal
    }
}

struct UpdatePortalOutputResponseBody: Swift.Equatable {
    public let portal: WorkSpacesWebClientTypes.Portal?
}

extension UpdatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.Portal.self, forKey: .portal)
        portal = portalDecoded
    }
}

public struct UpdateTrustStoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrustStoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrustStoreOutputError>
}

extension UpdateTrustStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTrustStoreInput(certificatesToAdd: \(Swift.String(describing: certificatesToAdd)), certificatesToDelete: \(Swift.String(describing: certificatesToDelete)), clientToken: \(Swift.String(describing: clientToken)), trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension UpdateTrustStoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificatesToAdd = certificatesToAdd {
            var certificatesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToAdd)
            for certificatelist0 in certificatesToAdd {
                try certificatesToAddContainer.encode(certificatelist0.base64EncodedString())
            }
        }
        if let certificatesToDelete = certificatesToDelete {
            var certificatesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificatesToDelete)
            for certificatethumbprintlist0 in certificatesToDelete {
                try certificatesToDeleteContainer.encode(certificatethumbprintlist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateTrustStoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrustStoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrustStoreOutputError>
}

public struct UpdateTrustStoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrustStoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTrustStoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTrustStoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrustStoreOutputError>
}

public struct UpdateTrustStoreInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrustStoreInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrustStoreOutputError>
}

public struct UpdateTrustStoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTrustStoreInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateTrustStoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let trustStoreArn = input.trustStoreArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("trustStoreArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/trustStores/\(trustStoreArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTrustStoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTrustStoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTrustStoreOutputError>
}

public struct UpdateTrustStoreInput: Swift.Equatable {
    /// A list of CA certificates to add to the trust store.
    public var certificatesToAdd: [ClientRuntime.Data]?
    /// A list of CA certificates to delete from a trust store.
    public var certificatesToDelete: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        certificatesToAdd: [ClientRuntime.Data]? = nil,
        certificatesToDelete: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        trustStoreArn: Swift.String? = nil
    )
    {
        self.certificatesToAdd = certificatesToAdd
        self.certificatesToDelete = certificatesToDelete
        self.clientToken = clientToken
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreInputBody: Swift.Equatable {
    public let certificatesToAdd: [ClientRuntime.Data]?
    public let certificatesToDelete: [Swift.String]?
    public let clientToken: Swift.String?
}

extension UpdateTrustStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificatesToAdd
        case certificatesToDelete
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificatesToAddContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .certificatesToAdd)
        var certificatesToAddDecoded0:[ClientRuntime.Data]? = nil
        if let certificatesToAddContainer = certificatesToAddContainer {
            certificatesToAddDecoded0 = [ClientRuntime.Data]()
            for blob0 in certificatesToAddContainer {
                if let blob0 = blob0 {
                    certificatesToAddDecoded0?.append(blob0)
                }
            }
        }
        certificatesToAdd = certificatesToAddDecoded0
        let certificatesToDeleteContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .certificatesToDelete)
        var certificatesToDeleteDecoded0:[Swift.String]? = nil
        if let certificatesToDeleteContainer = certificatesToDeleteContainer {
            certificatesToDeleteDecoded0 = [Swift.String]()
            for string0 in certificatesToDeleteContainer {
                if let string0 = string0 {
                    certificatesToDeleteDecoded0?.append(string0)
                }
            }
        }
        certificatesToDelete = certificatesToDeleteDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateTrustStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrustStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTrustStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrustStoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTrustStoreOutputResponse(trustStoreArn: \(Swift.String(describing: trustStoreArn)))"}
}

extension UpdateTrustStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTrustStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.trustStoreArn = output.trustStoreArn
        } else {
            self.trustStoreArn = nil
        }
    }
}

public struct UpdateTrustStoreOutputResponse: Swift.Equatable {
    /// The ARN of the trust store.
    /// This member is required.
    public var trustStoreArn: Swift.String?

    public init (
        trustStoreArn: Swift.String? = nil
    )
    {
        self.trustStoreArn = trustStoreArn
    }
}

struct UpdateTrustStoreOutputResponseBody: Swift.Equatable {
    public let trustStoreArn: Swift.String?
}

extension UpdateTrustStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustStoreArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustStoreArn)
        trustStoreArn = trustStoreArnDecoded
    }
}

public struct UpdateUserSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

extension UpdateUserSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsInput(clientToken: \(Swift.String(describing: clientToken)), copyAllowed: \(Swift.String(describing: copyAllowed)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension UpdateUserSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case downloadAllowed
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let copyAllowed = copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let downloadAllowed = downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let pasteAllowed = pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
    }
}

public struct UpdateUserSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateUserSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let userSettingsArn = input.userSettingsArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("userSettingsArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/userSettings/\(userSettingsArn)"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserSettingsOutputError>
}

public struct UpdateUserSettingsInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, subsequent retries with the same client token return the result from the original successful request. If you do not specify a client token, one is automatically generated by the AWS SDK.
    public var clientToken: Swift.String?
    /// Specifies whether the user can copy text from the streaming session to the local device.
    public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can download files from the streaming session to the local device.
    public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can paste text from the local device to the streaming session.
    public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can print to the local device.
    public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// Specifies whether the user can upload files from the local device to the streaming session.
    public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    /// The ARN of the user settings.
    /// This member is required.
    public var userSettingsArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
        userSettingsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.copyAllowed = copyAllowed
        self.downloadAllowed = downloadAllowed
        self.pasteAllowed = pasteAllowed
        self.printAllowed = printAllowed
        self.uploadAllowed = uploadAllowed
        self.userSettingsArn = userSettingsArn
    }
}

struct UpdateUserSettingsInputBody: Swift.Equatable {
    public let copyAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let printAllowed: WorkSpacesWebClientTypes.EnabledType?
    public let clientToken: Swift.String?
}

extension UpdateUserSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case copyAllowed
        case downloadAllowed
        case pasteAllowed
        case printAllowed
        case uploadAllowed
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateUserSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserSettingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserSettingsOutputResponse(userSettings: \(Swift.String(describing: userSettings)))"}
}

extension UpdateUserSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userSettings = output.userSettings
        } else {
            self.userSettings = nil
        }
    }
}

public struct UpdateUserSettingsOutputResponse: Swift.Equatable {
    /// The user settings.
    /// This member is required.
    public var userSettings: WorkSpacesWebClientTypes.UserSettings?

    public init (
        userSettings: WorkSpacesWebClientTypes.UserSettings? = nil
    )
    {
        self.userSettings = userSettings
    }
}

struct UpdateUserSettingsOutputResponseBody: Swift.Equatable {
    public let userSettings: WorkSpacesWebClientTypes.UserSettings?
}

extension UpdateUserSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.UserSettings.self, forKey: .userSettings)
        userSettings = userSettingsDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedPortalArns
        case copyAllowed
        case downloadAllowed
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedPortalArns = associatedPortalArns {
            var associatedPortalArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedPortalArns)
            for arnlist0 in associatedPortalArns {
                try associatedPortalArnsContainer.encode(arnlist0)
            }
        }
        if let copyAllowed = copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let downloadAllowed = downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let pasteAllowed = pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let associatedPortalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedPortalArns)
        var associatedPortalArnsDecoded0:[Swift.String]? = nil
        if let associatedPortalArnsContainer = associatedPortalArnsContainer {
            associatedPortalArnsDecoded0 = [Swift.String]()
            for string0 in associatedPortalArnsContainer {
                if let string0 = string0 {
                    associatedPortalArnsDecoded0?.append(string0)
                }
            }
        }
        associatedPortalArns = associatedPortalArnsDecoded0
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettings(associatedPortalArns: \(Swift.String(describing: associatedPortalArns)), copyAllowed: \(Swift.String(describing: copyAllowed)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// A user settings resource that can be associated with a web portal. Once associated with a web portal, user settings control how users can transfer data between a streaming session and the their local devices.
    public struct UserSettings: Swift.Equatable {
        /// A list of web portal ARNs that this user settings is associated with.
        public var associatedPortalArns: [Swift.String]?
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        /// This member is required.
        public var userSettingsArn: Swift.String?

        public init (
            associatedPortalArns: [Swift.String]? = nil,
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.associatedPortalArns = associatedPortalArns
            self.copyAllowed = copyAllowed
            self.downloadAllowed = downloadAllowed
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyAllowed
        case downloadAllowed
        case pasteAllowed
        case printAllowed
        case uploadAllowed
        case userSettingsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyAllowed = copyAllowed {
            try encodeContainer.encode(copyAllowed.rawValue, forKey: .copyAllowed)
        }
        if let downloadAllowed = downloadAllowed {
            try encodeContainer.encode(downloadAllowed.rawValue, forKey: .downloadAllowed)
        }
        if let pasteAllowed = pasteAllowed {
            try encodeContainer.encode(pasteAllowed.rawValue, forKey: .pasteAllowed)
        }
        if let printAllowed = printAllowed {
            try encodeContainer.encode(printAllowed.rawValue, forKey: .printAllowed)
        }
        if let uploadAllowed = uploadAllowed {
            try encodeContainer.encode(uploadAllowed.rawValue, forKey: .uploadAllowed)
        }
        if let userSettingsArn = userSettingsArn {
            try encodeContainer.encode(userSettingsArn, forKey: .userSettingsArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userSettingsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSettingsArn)
        userSettingsArn = userSettingsArnDecoded
        let copyAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .copyAllowed)
        copyAllowed = copyAllowedDecoded
        let pasteAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .pasteAllowed)
        pasteAllowed = pasteAllowedDecoded
        let downloadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .downloadAllowed)
        downloadAllowed = downloadAllowedDecoded
        let uploadAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .uploadAllowed)
        uploadAllowed = uploadAllowedDecoded
        let printAllowedDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.EnabledType.self, forKey: .printAllowed)
        printAllowed = printAllowedDecoded
    }
}

extension WorkSpacesWebClientTypes.UserSettingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSettingsSummary(copyAllowed: \(Swift.String(describing: copyAllowed)), downloadAllowed: \(Swift.String(describing: downloadAllowed)), pasteAllowed: \(Swift.String(describing: pasteAllowed)), printAllowed: \(Swift.String(describing: printAllowed)), uploadAllowed: \(Swift.String(describing: uploadAllowed)), userSettingsArn: \(Swift.String(describing: userSettingsArn)))"}
}

extension WorkSpacesWebClientTypes {
    /// The summary of user settings.
    public struct UserSettingsSummary: Swift.Equatable {
        /// Specifies whether the user can copy text from the streaming session to the local device.
        public var copyAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can download files from the streaming session to the local device.
        public var downloadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can paste text from the local device to the streaming session.
        public var pasteAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can print to the local device.
        public var printAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// Specifies whether the user can upload files from the local device to the streaming session.
        public var uploadAllowed: WorkSpacesWebClientTypes.EnabledType?
        /// The ARN of the user settings.
        public var userSettingsArn: Swift.String?

        public init (
            copyAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            downloadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            pasteAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            printAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            uploadAllowed: WorkSpacesWebClientTypes.EnabledType? = nil,
            userSettingsArn: Swift.String? = nil
        )
        {
            self.copyAllowed = copyAllowed
            self.downloadAllowed = downloadAllowed
            self.pasteAllowed = pasteAllowed
            self.printAllowed = printAllowed
            self.uploadAllowed = uploadAllowed
            self.userSettingsArn = userSettingsArn
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fieldList: \(Swift.String(describing: fieldList)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a validation error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The field that caused the error.
    public var fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// Reason the request failed validation
    public var reason: WorkSpacesWebClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesWebClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: WorkSpacesWebClientTypes.ValidationExceptionReason?
    public let fieldList: [WorkSpacesWebClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WorkSpacesWebClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([WorkSpacesWebClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[WorkSpacesWebClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [WorkSpacesWebClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension WorkSpacesWebClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesWebClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension WorkSpacesWebClientTypes {
    /// Information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WorkSpacesWebClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
