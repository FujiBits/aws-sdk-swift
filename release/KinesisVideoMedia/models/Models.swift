// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ClientLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClientLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ClientLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of
///       allowed client calls. Try making the call later.</p>
public struct ClientLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClientLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectionLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ConnectionLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of
///       allowed client connections.</p>
public struct ConnectionLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectionLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConnectionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetMediaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaOutputError>
}

extension GetMediaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMediaInput(startSelector: \(Swift.String(describing: startSelector)), streamARN: \(Swift.String(describing: streamARN)), streamName: \(Swift.String(describing: streamName)))"}
}

extension GetMediaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startSelector = "StartSelector"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startSelector = startSelector {
            try encodeContainer.encode(startSelector, forKey: .startSelector)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetMediaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaOutputError>
}

public struct GetMediaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMediaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMediaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMediaOutputError>
}

public struct GetMediaInput: Swift.Equatable {
    /// <p>Identifies the starting chunk to get from the specified stream. </p>
    public let startSelector: KinesisVideoMediaClientTypes.StartSelector?
    /// <p>The ARN of the stream from where you want to get the media content. If you don't
    ///       specify the <code>streamARN</code>, you must specify the <code>streamName</code>.</p>
    public let streamARN: Swift.String?
    /// <p>The Kinesis video stream name from where you want to get the media content. If you
    ///       don't specify the <code>streamName</code>, you must specify the
    ///       <code>streamARN</code>.</p>
    public let streamName: Swift.String?

    public init (
        startSelector: KinesisVideoMediaClientTypes.StartSelector? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.startSelector = startSelector
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetMediaInputBody: Swift.Equatable {
    public let streamName: Swift.String?
    public let streamARN: Swift.String?
    public let startSelector: KinesisVideoMediaClientTypes.StartSelector?
}

extension GetMediaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startSelector = "StartSelector"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let startSelectorDecoded = try containerValues.decodeIfPresent(KinesisVideoMediaClientTypes.StartSelector.self, forKey: .startSelector)
        startSelector = startSelectorDecoded
    }
}

extension GetMediaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectionLimitExceededException" : self = .connectionLimitExceededException(try ConnectionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMediaOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case connectionLimitExceededException(ConnectionLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidEndpointException(InvalidEndpointException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMediaOutputResponse(contentType: \(Swift.String(describing: contentType)), payload: \(Swift.String(describing: payload)))"}
}

extension GetMediaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.payload = data
        } else {
            self.payload = nil
        }
    }
}

public struct GetMediaOutputResponse: Swift.Equatable {
    /// <p>The content type of the requested media.</p>
    public let contentType: Swift.String?
    /// <p> The payload Kinesis Video Streams returns is a sequence of chunks from the specified
    ///       stream. For information about the chunks, see . The
    ///       chunks that Kinesis Video Streams returns in the <code>GetMedia</code> call also include the
    ///       following additional Matroska (MKV) tags: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_CONTINUATION_TOKEN (UTF-8 string) - In the event your
    ///             <code>GetMedia</code> call terminates, you can use this continuation token in your next
    ///           request to get the next chunk where the last request terminated.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_MILLIS_BEHIND_NOW (UTF-8 string) - Client applications can use
    ///           this tag value to determine how far behind the chunk returned in the response is from the
    ///           latest chunk on the stream. </p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the chunk.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_SERVER_TIMESTAMP - Server timestamp of the fragment.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_PRODUCER_TIMESTAMP - Producer timestamp of the fragment.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The following tags will be present if an error occurs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_ERROR_CODE - String description of an error that caused GetMedia
    ///           to stop.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_ERROR_ID: Integer code of the error.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The error codes are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>3002 - Error writing to the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>4000 - Requested fragment is not found</p>
    ///             </li>
    ///             <li>
    ///                <p>4500 - Access denied for the stream's KMS key</p>
    ///             </li>
    ///             <li>
    ///                <p>4501 - Stream's KMS key is disabled</p>
    ///             </li>
    ///             <li>
    ///                <p>4502 - Validation error on the stream's KMS key</p>
    ///             </li>
    ///             <li>
    ///                <p>4503 - KMS key specified in the stream is unavailable</p>
    ///             </li>
    ///             <li>
    ///                <p>4504 - Invalid usage of the KMS key specified in the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>4505 - Invalid state of the KMS key specified in the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>4506 - Unable to find the KMS key specified in the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>5000 - Internal error</p>
    ///             </li>
    ///          </ul>
    public let payload: ClientRuntime.ByteStream?

    public init (
        contentType: Swift.String? = nil,
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.contentType = contentType
        self.payload = payload
    }
}

struct GetMediaOutputResponseBody: Swift.Equatable {
    public let payload: ClientRuntime.ByteStream?
}

extension GetMediaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InvalidArgumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArgumentException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for this input parameter is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidEndpointException(message: \(Swift.String(describing: message)))"}
}

extension InvalidEndpointException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Status Code: 400, Caller used wrong endpoint to write data to a stream. On receiving
///       such an exception, the user must call <code>GetDataEndpoint</code> with
///         <code>AccessMode</code> set to "READ" and use the endpoint Kinesis Video returns in the next
///         <code>GetMedia</code> call. </p>
public struct InvalidEndpointException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidEndpointExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotAuthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotAuthorizedException(message: \(Swift.String(describing: message)))"}
}

extension NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Status Code: 403, The caller is not authorized to perform an operation on the given
///       stream, or the token has expired.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Status Code: 404, The stream with the given name does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoMediaClientTypes.StartSelector: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterFragmentNumber = "AfterFragmentNumber"
        case continuationToken = "ContinuationToken"
        case startSelectorType = "StartSelectorType"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterFragmentNumber = afterFragmentNumber {
            try encodeContainer.encode(afterFragmentNumber, forKey: .afterFragmentNumber)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let startSelectorType = startSelectorType {
            try encodeContainer.encode(startSelectorType.rawValue, forKey: .startSelectorType)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startSelectorTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoMediaClientTypes.StartSelectorType.self, forKey: .startSelectorType)
        startSelectorType = startSelectorTypeDecoded
        let afterFragmentNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterFragmentNumber)
        afterFragmentNumber = afterFragmentNumberDecoded
        let startTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
    }
}

extension KinesisVideoMediaClientTypes.StartSelector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSelector(afterFragmentNumber: \(Swift.String(describing: afterFragmentNumber)), continuationToken: \(Swift.String(describing: continuationToken)), startSelectorType: \(Swift.String(describing: startSelectorType)), startTimestamp: \(Swift.String(describing: startTimestamp)))"}
}

extension KinesisVideoMediaClientTypes {
    /// <p>Identifies the chunk on the Kinesis video stream where you want the
    ///         <code>GetMedia</code> API to start returning media data. You have the following options to
    ///       identify the starting chunk: </p>
    ///          <ul>
    ///             <li>
    ///                <p>Choose the latest (or oldest) chunk.</p>
    ///             </li>
    ///             <li>
    ///                <p>Identify a specific chunk. You can identify a specific chunk either by providing a
    ///           fragment number or timestamp (server or producer). </p>
    ///             </li>
    ///             <li>
    ///                <p>Each chunk's metadata includes a continuation token as a Matroska (MKV) tag
    ///             (<code>AWS_KINESISVIDEO_CONTINUATION_TOKEN</code>). If your previous
    ///             <code>GetMedia</code> request terminated, you can use this tag value in your next
    ///             <code>GetMedia</code> request. The API then starts returning chunks starting where the
    ///           last API ended.</p>
    ///             </li>
    ///          </ul>
    public struct StartSelector: Swift.Equatable {
        /// <p>Specifies the fragment number from where you want the <code>GetMedia</code> API to
        ///       start returning the fragments. </p>
        public let afterFragmentNumber: Swift.String?
        /// <p>Continuation token that Kinesis Video Streams returned in the previous
        ///         <code>GetMedia</code> response. The <code>GetMedia</code> API then starts with the chunk
        ///       identified by the continuation token.</p>
        public let continuationToken: Swift.String?
        /// <p>Identifies the fragment on the Kinesis video stream where you want to start getting the
        ///       data from.</p>
        ///          <ul>
        ///             <li>
        ///                <p>NOW - Start with the latest chunk on the stream.</p>
        ///             </li>
        ///             <li>
        ///                <p>EARLIEST - Start with earliest available chunk on the stream.</p>
        ///             </li>
        ///             <li>
        ///                <p>FRAGMENT_NUMBER - Start with the chunk after a specific fragment. You must also
        ///           specify the <code>AfterFragmentNumber</code> parameter.</p>
        ///             </li>
        ///             <li>
        ///                <p>PRODUCER_TIMESTAMP or SERVER_TIMESTAMP - Start with the chunk containing a fragment
        ///           with the specified producer or server timestamp. You specify the timestamp by adding
        ///             <code>StartTimestamp</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p> CONTINUATION_TOKEN - Read using the specified continuation token. </p>
        ///             </li>
        ///          </ul>
        ///          <note>
        ///             <p>If you choose the NOW, EARLIEST, or CONTINUATION_TOKEN as the
        ///           <code>startSelectorType</code>, you don't provide any additional information in the
        ///           <code>startSelector</code>.</p>
        ///          </note>
        public let startSelectorType: KinesisVideoMediaClientTypes.StartSelectorType?
        /// <p>A timestamp value. This value is required if you choose the PRODUCER_TIMESTAMP or the
        ///       SERVER_TIMESTAMP as the <code>startSelectorType</code>. The <code>GetMedia</code> API then
        ///       starts with the chunk containing the fragment that has the specified timestamp.</p>
        public let startTimestamp: ClientRuntime.Date?

        public init (
            afterFragmentNumber: Swift.String? = nil,
            continuationToken: Swift.String? = nil,
            startSelectorType: KinesisVideoMediaClientTypes.StartSelectorType? = nil,
            startTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.afterFragmentNumber = afterFragmentNumber
            self.continuationToken = continuationToken
            self.startSelectorType = startSelectorType
            self.startTimestamp = startTimestamp
        }
    }

}

extension KinesisVideoMediaClientTypes {
    public enum StartSelectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuationToken
        case earliest
        case fragmentNumber
        case now
        case producerTimestamp
        case serverTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [StartSelectorType] {
            return [
                .continuationToken,
                .earliest,
                .fragmentNumber,
                .now,
                .producerTimestamp,
                .serverTimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuationToken: return "CONTINUATION_TOKEN"
            case .earliest: return "EARLIEST"
            case .fragmentNumber: return "FRAGMENT_NUMBER"
            case .now: return "NOW"
            case .producerTimestamp: return "PRODUCER_TIMESTAMP"
            case .serverTimestamp: return "SERVER_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StartSelectorType(rawValue: rawValue) ?? StartSelectorType.sdkUnknown(rawValue)
        }
    }
}
