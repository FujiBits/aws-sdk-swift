// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceDataClientTypes {
    /// Indicates how the given change will be applied to the dataset.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case append
        case modify
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .append,
                .modify,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .modify: return "MODIFY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.ChangesetErrorInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspaceDataClientTypes.ChangesetErrorInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangesetErrorInfo(errorCategory: \(Swift.String(describing: errorCategory)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension FinspaceDataClientTypes {
    /// The structure with error messages.
    public struct ChangesetErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        /// * VALIDATION -The inputs to this request are invalid.
        ///
        /// * SERVICE_QUOTA_EXCEEDED - Service quotas have been exceeded. Please contact AWS support to increase quotas.
        ///
        /// * ACCESS_DENIED - Missing required permission to perform this request.
        ///
        /// * RESOURCE_NOT_FOUND - One or more inputs to this request were not found.
        ///
        /// * THROTTLING - The system temporarily lacks sufficient resources to process the request.
        ///
        /// * INTERNAL_SERVICE_EXCEPTION - An internal service error has occurred.
        ///
        /// * CANCELLED - Cancelled.
        ///
        /// * USER_RECOVERABLE - A user recoverable error has occurred.
        public var errorCategory: FinspaceDataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init (
            errorCategory: FinspaceDataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspaceDataClientTypes.ChangesetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeUntilTimestamp
        case changeType
        case changesetArn
        case changesetId
        case createTime
        case datasetId
        case errorInfo
        case formatParams
        case sourceParams
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeUntilTimestamp != 0 {
            try encodeContainer.encode(activeUntilTimestamp, forKey: .activeUntilTimestamp)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let changesetArn = changesetArn {
            try encodeContainer.encode(changesetArn, forKey: .changesetArn)
        }
        if let changesetId = changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let datasetId = datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatparams0) in formatParams {
                try formatParamsContainer.encode(formatparams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceparams0) in sourceParams {
                try sourceParamsContainer.encode(sourceparams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedByChangesetId = updatedByChangesetId {
            try encodeContainer.encode(updatedByChangesetId, forKey: .updatedByChangesetId)
        }
        if let updatesChangesetId = updatesChangesetId {
            try encodeContainer.encode(updatesChangesetId, forKey: .updatesChangesetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .createTime)
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.IngestionStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangesetErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let activeUntilTimestampDecoded = try containerValues.decode(Swift.Int.self, forKey: .activeUntilTimestamp)
        activeUntilTimestamp = activeUntilTimestampDecoded
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension FinspaceDataClientTypes.ChangesetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangesetSummary(activeUntilTimestamp: \(Swift.String(describing: activeUntilTimestamp)), changeType: \(Swift.String(describing: changeType)), changesetArn: \(Swift.String(describing: changesetArn)), changesetId: \(Swift.String(describing: changesetId)), createTime: \(Swift.String(describing: createTime)), datasetId: \(Swift.String(describing: datasetId)), errorInfo: \(Swift.String(describing: errorInfo)), formatParams: \(Swift.String(describing: formatParams)), sourceParams: \(Swift.String(describing: sourceParams)), status: \(Swift.String(describing: status)), updatedByChangesetId: \(Swift.String(describing: updatedByChangesetId)), updatesChangesetId: \(Swift.String(describing: updatesChangesetId)))"}
}

extension FinspaceDataClientTypes {
    /// A Changeset is unit of data in a Dataset.
    public struct ChangesetSummary: Swift.Equatable {
        /// Time until which the Changeset is active. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeUntilTimestamp: Swift.Int
        /// Type that indicates how a Changeset is applied to a Dataset.
        ///
        /// * REPLACE - Changeset is considered as a replacement to all prior loaded Changesets.
        ///
        /// * APPEND - Changeset is considered as an addition to the end of all prior loaded Changesets.
        ///
        /// * MODIFY - Changeset is considered as a replacement to a specific prior ingested Changeset.
        public var changeType: FinspaceDataClientTypes.ChangeType?
        /// The ARN identifier of the Changeset.
        public var changesetArn: Swift.String?
        /// The unique identifier for a Changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the Changeset was created in FinSpace. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
        public var datasetId: Swift.String?
        /// The structure with error messages.
        public var errorInfo: FinspaceDataClientTypes.ChangesetErrorInfo?
        /// Options that define the structure of the source file(s).
        public var formatParams: [Swift.String:Swift.String]?
        /// Options that define the location of the data being ingested.
        public var sourceParams: [Swift.String:Swift.String]?
        /// Status of the Changeset ingestion.
        ///
        /// * PENDING - Changeset is pending creation.
        ///
        /// * FAILED - Changeset creation has failed.
        ///
        /// * SUCCESS - Changeset creation has succeeded.
        ///
        /// * RUNNING - Changeset creation is running.
        ///
        /// * STOP_REQUESTED - User requested Changeset creation to stop.
        public var status: FinspaceDataClientTypes.IngestionStatus?
        /// The unique identifier of the updated Changeset.
        public var updatedByChangesetId: Swift.String?
        /// The unique identifier of the Changeset that is updated.
        public var updatesChangesetId: Swift.String?

        public init (
            activeUntilTimestamp: Swift.Int = 0,
            changeType: FinspaceDataClientTypes.ChangeType? = nil,
            changesetArn: Swift.String? = nil,
            changesetId: Swift.String? = nil,
            createTime: Swift.Int = 0,
            datasetId: Swift.String? = nil,
            errorInfo: FinspaceDataClientTypes.ChangesetErrorInfo? = nil,
            formatParams: [Swift.String:Swift.String]? = nil,
            sourceParams: [Swift.String:Swift.String]? = nil,
            status: FinspaceDataClientTypes.IngestionStatus? = nil,
            updatedByChangesetId: Swift.String? = nil,
            updatesChangesetId: Swift.String? = nil
        )
        {
            self.activeUntilTimestamp = activeUntilTimestamp
            self.changeType = changeType
            self.changesetArn = changesetArn
            self.changesetId = changesetId
            self.createTime = createTime
            self.datasetId = datasetId
            self.errorInfo = errorInfo
            self.formatParams = formatParams
            self.sourceParams = sourceParams
            self.status = status
            self.updatedByChangesetId = updatedByChangesetId
            self.updatesChangesetId = updatesChangesetId
        }
    }

}

extension FinspaceDataClientTypes {
    /// Data type of a column.
    public enum ColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case binary
        case boolean
        case char
        case date
        case datetime
        case double
        case float
        case integer
        case smallint
        case string
        case tinyint
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataType] {
            return [
                .bigint,
                .binary,
                .boolean,
                .char,
                .date,
                .datetime,
                .double,
                .float,
                .integer,
                .smallint,
                .string,
                .tinyint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .char: return "CHAR"
            case .date: return "DATE"
            case .datetime: return "DATETIME"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .smallint: return "SMALLINT"
            case .string: return "STRING"
            case .tinyint: return "TINYINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnDataType(rawValue: rawValue) ?? ColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.ColumnDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescription
        case columnName
        case dataType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDescription = columnDescription {
            try encodeContainer.encode(columnDescription, forKey: .columnDescription)
        }
        if let columnName = columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ColumnDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnDescription)
        columnDescription = columnDescriptionDecoded
    }
}

extension FinspaceDataClientTypes.ColumnDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ColumnDefinition(columnDescription: \(Swift.String(describing: columnDescription)), columnName: \(Swift.String(describing: columnName)), dataType: \(Swift.String(describing: dataType)))"}
}

extension FinspaceDataClientTypes {
    /// The definition of a column in a tabular Dataset.
    public struct ColumnDefinition: Swift.Equatable {
        /// Description for a column.
        public var columnDescription: Swift.String?
        /// Name for a column.
        public var columnName: Swift.String?
        /// Data type of a column.
        ///
        /// * STRING - A String data type. CHAR - A char data type. INTEGER - An integer data type. TINYINT - A tinyint data type. SMALLINT - A smallint data type. BIGINT - A bigint data type. FLOAT - A float data type. DOUBLE - A double data type. DATE - A date data type. DATETIME - A datetime data type. BOOLEAN - A boolean data type. BINARY - A binary data type.
        public var dataType: FinspaceDataClientTypes.ColumnDataType?

        public init (
            columnDescription: Swift.String? = nil,
            columnName: Swift.String? = nil,
            dataType: FinspaceDataClientTypes.ColumnDataType? = nil
        )
        {
            self.columnDescription = columnDescription
            self.columnName = columnName
            self.dataType = dataType
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request conflicts with an existing resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateChangesetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

extension CreateChangesetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChangesetInput(changeType: \(Swift.String(describing: changeType)), clientToken: \(Swift.String(describing: clientToken)), datasetId: \(Swift.String(describing: datasetId)), formatParams: \(Swift.String(describing: formatParams)), sourceParams: \(Swift.String(describing: sourceParams)))"}
}

extension CreateChangesetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case clientToken
        case formatParams
        case sourceParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatparams0) in formatParams {
                try formatParamsContainer.encode(formatparams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceparams0) in sourceParams {
                try sourceParamsContainer.encode(sourceparams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChangesetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

/// The request for a CreateChangeset operation.
public struct CreateChangesetInput: Swift.Equatable {
    /// Option to indicate how a Changeset will be applied to a Dataset.
    ///
    /// * REPLACE - Changeset will be considered as a replacement to all prior loaded Changesets.
    ///
    /// * APPEND - Changeset will be considered as an addition to the end of all prior loaded Changesets.
    ///
    /// * MODIFY - Changeset is considered as a replacement to a specific prior ingested Changeset.
    /// This member is required.
    public var changeType: FinspaceDataClientTypes.ChangeType?
    /// A token used to ensure idempotency.
    public var clientToken: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset will be created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression). formatType is a required attribute and can have the following values:
    ///
    /// * PARQUET - Parquet source file format.
    ///
    /// * CSV - CSV source file format.
    ///
    /// * JSON - JSON source file format.
    ///
    /// * XML - XML source file format.
    ///
    ///
    /// For example, you could specify the following for formatParams:  "formatParams": { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }
    /// This member is required.
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?

    public init (
        changeType: FinspaceDataClientTypes.ChangeType? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.changeType = changeType
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.sourceParams = sourceParams
    }
}

struct CreateChangesetInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let changeType: FinspaceDataClientTypes.ChangeType?
    public let sourceParams: [Swift.String:Swift.String]?
    public let formatParams: [Swift.String:Swift.String]?
}

extension CreateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case clientToken
        case formatParams
        case sourceParams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
    }
}

extension CreateChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChangesetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChangesetOutputResponse(changesetId: \(Swift.String(describing: changesetId)), datasetId: \(Swift.String(describing: datasetId)))"}
}

extension CreateChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changesetId = output.changesetId
            self.datasetId = output.datasetId
        } else {
            self.changesetId = nil
            self.datasetId = nil
        }
    }
}

/// The response from a CreateChangeset operation.
public struct CreateChangesetOutputResponse: Swift.Equatable {
    /// The unique identifier of the Changeset that is created.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    public var datasetId: Swift.String?

    public init (
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct CreateChangesetOutputResponseBody: Swift.Equatable {
    public let datasetId: Swift.String?
    public let changesetId: Swift.String?
}

extension CreateChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
    }
}

public struct CreateDataViewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataViewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataViewOutputError>
}

extension CreateDataViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataViewInput(asOfTimestamp: \(Swift.String(describing: asOfTimestamp)), autoUpdate: \(Swift.String(describing: autoUpdate)), clientToken: \(Swift.String(describing: clientToken)), datasetId: \(Swift.String(describing: datasetId)), destinationTypeParams: \(Swift.String(describing: destinationTypeParams)), partitionColumns: \(Swift.String(describing: partitionColumns)), sortColumns: \(Swift.String(describing: sortColumns)))"}
}

extension CreateDataViewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case clientToken
        case destinationTypeParams
        case partitionColumns
        case sortColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if asOfTimestamp != 0 {
            try encodeContainer.encode(asOfTimestamp, forKey: .asOfTimestamp)
        }
        if autoUpdate != false {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationTypeParams = destinationTypeParams {
            try encodeContainer.encode(destinationTypeParams, forKey: .destinationTypeParams)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for partitioncolumnlist0 in partitionColumns {
                try partitionColumnsContainer.encode(partitioncolumnlist0)
            }
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for sortcolumnlist0 in sortColumns {
                try sortColumnsContainer.encode(sortcolumnlist0)
            }
        }
    }
}

public struct CreateDataViewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataViewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataViewOutputError>
}

public struct CreateDataViewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataViewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataViewOutputError>
}

public struct CreateDataViewInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataViewInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDataViewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDataViewInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataViewOutputError>
}

public struct CreateDataViewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataViewInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDataViewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDataViewInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataViewOutputError>
}

/// Request for creating a data view.
public struct CreateDataViewInput: Swift.Equatable {
    /// Beginning time to use for the Dataview. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var asOfTimestamp: Swift.Int
    /// Flag to indicate Dataview should be updated automatically.
    public var autoUpdate: Swift.Bool
    /// A token used to ensure idempotency.
    public var clientToken: Swift.String?
    /// The unique Dataset identifier that is used to create a Dataview.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the destination type for the Dataview.
    /// This member is required.
    public var destinationTypeParams: FinspaceDataClientTypes.DataViewDestinationTypeParams?
    /// Ordered set of column names used to partition data.
    public var partitionColumns: [Swift.String]?
    /// Columns to be used for sorting the data.
    public var sortColumns: [Swift.String]?

    public init (
        asOfTimestamp: Swift.Int = 0,
        autoUpdate: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        destinationTypeParams: FinspaceDataClientTypes.DataViewDestinationTypeParams? = nil,
        partitionColumns: [Swift.String]? = nil,
        sortColumns: [Swift.String]? = nil
    )
    {
        self.asOfTimestamp = asOfTimestamp
        self.autoUpdate = autoUpdate
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.destinationTypeParams = destinationTypeParams
        self.partitionColumns = partitionColumns
        self.sortColumns = sortColumns
    }
}

struct CreateDataViewInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let autoUpdate: Swift.Bool
    public let sortColumns: [Swift.String]?
    public let partitionColumns: [Swift.String]?
    public let asOfTimestamp: Swift.Int
    public let destinationTypeParams: FinspaceDataClientTypes.DataViewDestinationTypeParams?
}

extension CreateDataViewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case clientToken
        case destinationTypeParams
        case partitionColumns
        case sortColumns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let autoUpdateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoUpdate)
        autoUpdate = autoUpdateDecoded
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let asOfTimestampDecoded = try containerValues.decode(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let destinationTypeParamsDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeParams)
        destinationTypeParams = destinationTypeParamsDecoded
    }
}

extension CreateDataViewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataViewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataViewOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataViewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataViewOutputResponse(dataViewId: \(Swift.String(describing: dataViewId)), datasetId: \(Swift.String(describing: datasetId)))"}
}

extension CreateDataViewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataViewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataViewId = output.dataViewId
            self.datasetId = output.datasetId
        } else {
            self.dataViewId = nil
            self.datasetId = nil
        }
    }
}

/// Response for creating a data view.
public struct CreateDataViewOutputResponse: Swift.Equatable {
    /// The unique identifier for the created Dataview.
    public var dataViewId: Swift.String?
    /// The unique identifier of the Dataset used for the Dataview.
    public var datasetId: Swift.String?

    public init (
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct CreateDataViewOutputResponseBody: Swift.Equatable {
    public let datasetId: Swift.String?
    public let dataViewId: Swift.String?
}

extension CreateDataViewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataViewId
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetInput(alias: \(Swift.String(describing: alias)), clientToken: \(Swift.String(describing: clientToken)), datasetDescription: \(Swift.String(describing: datasetDescription)), datasetTitle: \(Swift.String(describing: datasetTitle)), kind: \(Swift.String(describing: kind)), ownerInfo: \(Swift.String(describing: ownerInfo)), permissionGroupParams: \(Swift.String(describing: permissionGroupParams)), schemaDefinition: \(Swift.String(describing: schemaDefinition)))"}
}

extension CreateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case ownerInfo
        case permissionGroupParams
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetDescription = datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetTitle = datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let ownerInfo = ownerInfo {
            try encodeContainer.encode(ownerInfo, forKey: .ownerInfo)
        }
        if let permissionGroupParams = permissionGroupParams {
            try encodeContainer.encode(permissionGroupParams, forKey: .permissionGroupParams)
        }
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/datasetsv2"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

/// The request for a CreateDataset operation
public struct CreateDatasetInput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    /// This member is required.
    public var alias: Swift.String?
    /// A token used to ensure idempotency.
    public var clientToken: Swift.String?
    /// Description of a Dataset.
    /// This member is required.
    public var datasetDescription: Swift.String?
    /// Display title for a FinSpace Dataset.
    /// This member is required.
    public var datasetTitle: Swift.String?
    /// The format in which Dataset data is structured.
    ///
    /// * TABULAR - Data is structured in a tabular format.
    ///
    /// * NON_TABULAR - Data is structured in a non-tabular format.
    /// This member is required.
    public var kind: FinspaceDataClientTypes.DatasetKind?
    /// Contact information for a Dataset owner.
    public var ownerInfo: FinspaceDataClientTypes.DatasetOwnerInfo?
    /// Permission group parameters for Dataset permissions.
    /// This member is required.
    public var permissionGroupParams: FinspaceDataClientTypes.PermissionGroupParams?
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspaceDataClientTypes.SchemaUnion?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspaceDataClientTypes.DatasetKind? = nil,
        ownerInfo: FinspaceDataClientTypes.DatasetOwnerInfo? = nil,
        permissionGroupParams: FinspaceDataClientTypes.PermissionGroupParams? = nil,
        schemaDefinition: FinspaceDataClientTypes.SchemaUnion? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.datasetDescription = datasetDescription
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.ownerInfo = ownerInfo
        self.permissionGroupParams = permissionGroupParams
        self.schemaDefinition = schemaDefinition
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let datasetTitle: Swift.String?
    public let kind: FinspaceDataClientTypes.DatasetKind?
    public let datasetDescription: Swift.String?
    public let ownerInfo: FinspaceDataClientTypes.DatasetOwnerInfo?
    public let permissionGroupParams: FinspaceDataClientTypes.PermissionGroupParams?
    public let alias: Swift.String?
    public let schemaDefinition: FinspaceDataClientTypes.SchemaUnion?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case ownerInfo
        case permissionGroupParams
        case schemaDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let ownerInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetOwnerInfo.self, forKey: .ownerInfo)
        ownerInfo = ownerInfoDecoded
        let permissionGroupParamsDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.PermissionGroupParams.self, forKey: .permissionGroupParams)
        permissionGroupParams = permissionGroupParamsDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetOutputResponse(datasetId: \(Swift.String(describing: datasetId)))"}
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from a CreateDataset operation
public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The unique identifier for the created Dataset.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    public let datasetId: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension FinspaceDataClientTypes.Credentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension FinspaceDataClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credentials(accessKeyId: \(Swift.String(describing: accessKeyId)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), sessionToken: \(Swift.String(describing: sessionToken)))"}
}

extension FinspaceDataClientTypes {
    /// Short term API credentials.
    public struct Credentials: Swift.Equatable {
        /// The access key identifier.
        public var accessKeyId: Swift.String?
        /// The access key.
        public var secretAccessKey: Swift.String?
        /// The session token.
        public var sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension FinspaceDataClientTypes.DataViewDestinationTypeParams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType, forKey: .destinationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
    }
}

extension FinspaceDataClientTypes.DataViewDestinationTypeParams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataViewDestinationTypeParams(destinationType: \(Swift.String(describing: destinationType)))"}
}

extension FinspaceDataClientTypes {
    /// Structure for the Dataview destination type parameters.
    public struct DataViewDestinationTypeParams: Swift.Equatable {
        /// Destination type for a Dataview.
        ///
        /// * GLUE_TABLE - Glue table destination type.
        /// This member is required.
        public var destinationType: Swift.String?

        public init (
            destinationType: Swift.String? = nil
        )
        {
            self.destinationType = destinationType
        }
    }

}

extension FinspaceDataClientTypes.DataViewErrorInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspaceDataClientTypes.DataViewErrorInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataViewErrorInfo(errorCategory: \(Swift.String(describing: errorCategory)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension FinspaceDataClientTypes {
    /// The structure with error messages.
    public struct DataViewErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        /// * VALIDATION -The inputs to this request are invalid.
        ///
        /// * SERVICE_QUOTA_EXCEEDED - Service quotas have been exceeded. Please contact AWS support to increase quotas.
        ///
        /// * ACCESS_DENIED - Missing required permission to perform this request.
        ///
        /// * RESOURCE_NOT_FOUND - One or more inputs to this request were not found.
        ///
        /// * THROTTLING - The system temporarily lacks sufficient resources to process the request.
        ///
        /// * INTERNAL_SERVICE_EXCEPTION - An internal service error has occurred.
        ///
        /// * CANCELLED - Cancelled.
        ///
        /// * USER_RECOVERABLE - A user recoverable error has occurred.
        public var errorCategory: FinspaceDataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init (
            errorCategory: FinspaceDataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspaceDataClientTypes {
    /// Status of a DataView
    public enum DataViewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case failedCleanupFailed
        case pending
        case running
        case starting
        case success
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [DataViewStatus] {
            return [
                .cancelled,
                .failed,
                .failedCleanupFailed,
                .pending,
                .running,
                .starting,
                .success,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .failedCleanupFailed: return "FAILED_CLEANUP_FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .success: return "SUCCESS"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataViewStatus(rawValue: rawValue) ?? DataViewStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.DataViewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case createTime
        case dataViewArn
        case dataViewId
        case datasetId
        case destinationTypeProperties
        case errorInfo
        case lastModifiedTime
        case partitionColumns
        case sortColumns
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if asOfTimestamp != 0 {
            try encodeContainer.encode(asOfTimestamp, forKey: .asOfTimestamp)
        }
        if autoUpdate != false {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let dataViewArn = dataViewArn {
            try encodeContainer.encode(dataViewArn, forKey: .dataViewArn)
        }
        if let dataViewId = dataViewId {
            try encodeContainer.encode(dataViewId, forKey: .dataViewId)
        }
        if let datasetId = datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let destinationTypeProperties = destinationTypeProperties {
            try encodeContainer.encode(destinationTypeProperties, forKey: .destinationTypeProperties)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for partitioncolumnlist0 in partitionColumns {
                try partitionColumnsContainer.encode(partitioncolumnlist0)
            }
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for sortcolumnlist0 in sortColumns {
                try sortColumnsContainer.encode(sortcolumnlist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
        let dataViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewArn)
        dataViewArn = dataViewArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let asOfTimestampDecoded = try containerValues.decode(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let destinationTypePropertiesDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeProperties)
        destinationTypeProperties = destinationTypePropertiesDecoded
        let autoUpdateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoUpdate)
        autoUpdate = autoUpdateDecoded
        let createTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension FinspaceDataClientTypes.DataViewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataViewSummary(asOfTimestamp: \(Swift.String(describing: asOfTimestamp)), autoUpdate: \(Swift.String(describing: autoUpdate)), createTime: \(Swift.String(describing: createTime)), dataViewArn: \(Swift.String(describing: dataViewArn)), dataViewId: \(Swift.String(describing: dataViewId)), datasetId: \(Swift.String(describing: datasetId)), destinationTypeProperties: \(Swift.String(describing: destinationTypeProperties)), errorInfo: \(Swift.String(describing: errorInfo)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), partitionColumns: \(Swift.String(describing: partitionColumns)), sortColumns: \(Swift.String(describing: sortColumns)), status: \(Swift.String(describing: status)))"}
}

extension FinspaceDataClientTypes {
    /// Structure for the summary of a Dataview.
    public struct DataViewSummary: Swift.Equatable {
        /// Time range to use for the Dataview. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var asOfTimestamp: Swift.Int
        /// The flag to indicate Dataview should be updated automatically.
        public var autoUpdate: Swift.Bool
        /// The timestamp at which the Dataview was created in FinSpace. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The ARN identifier of the Dataview.
        public var dataViewArn: Swift.String?
        /// The unique identifier for the Dataview.
        public var dataViewId: Swift.String?
        /// Th unique identifier for the Dataview Dataset.
        public var datasetId: Swift.String?
        /// Information about the Dataview destination.
        public var destinationTypeProperties: FinspaceDataClientTypes.DataViewDestinationTypeParams?
        /// The structure with error messages.
        public var errorInfo: FinspaceDataClientTypes.DataViewErrorInfo?
        /// The last time that a Dataview was modified. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTime: Swift.Int
        /// Ordered set of column names used to partition data.
        public var partitionColumns: [Swift.String]?
        /// Columns to be used for sorting the data.
        public var sortColumns: [Swift.String]?
        /// The status of a Dataview creation.
        ///
        /// * RUNNING - Dataview creation is running.
        ///
        /// * STARTING - Dataview creation is starting.
        ///
        /// * FAILED - Dataview creation has failed.
        ///
        /// * CANCELLED - Dataview creation has been cancelled.
        ///
        /// * TIMEOUT - Dataview creation has timed out.
        ///
        /// * SUCCESS - Dataview creation has succeeded.
        ///
        /// * PENDING - Dataview creation is pending.
        ///
        /// * FAILED_CLEANUP_FAILED - Dataview creation failed and resource cleanup failed.
        public var status: FinspaceDataClientTypes.DataViewStatus?

        public init (
            asOfTimestamp: Swift.Int = 0,
            autoUpdate: Swift.Bool = false,
            createTime: Swift.Int = 0,
            dataViewArn: Swift.String? = nil,
            dataViewId: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            destinationTypeProperties: FinspaceDataClientTypes.DataViewDestinationTypeParams? = nil,
            errorInfo: FinspaceDataClientTypes.DataViewErrorInfo? = nil,
            lastModifiedTime: Swift.Int = 0,
            partitionColumns: [Swift.String]? = nil,
            sortColumns: [Swift.String]? = nil,
            status: FinspaceDataClientTypes.DataViewStatus? = nil
        )
        {
            self.asOfTimestamp = asOfTimestamp
            self.autoUpdate = autoUpdate
            self.createTime = createTime
            self.dataViewArn = dataViewArn
            self.dataViewId = dataViewId
            self.datasetId = datasetId
            self.destinationTypeProperties = destinationTypeProperties
            self.errorInfo = errorInfo
            self.lastModifiedTime = lastModifiedTime
            self.partitionColumns = partitionColumns
            self.sortColumns = sortColumns
            self.status = status
        }
    }

}

extension FinspaceDataClientTypes.Dataset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case createTime
        case datasetArn
        case datasetDescription
        case datasetId
        case datasetTitle
        case kind
        case lastModifiedTime
        case ownerInfo
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetDescription = datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetId = datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let datasetTitle = datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let ownerInfo = ownerInfo {
            try encodeContainer.encode(ownerInfo, forKey: .ownerInfo)
        }
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let ownerInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetOwnerInfo.self, forKey: .ownerInfo)
        ownerInfo = ownerInfoDecoded
        let createTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension FinspaceDataClientTypes.Dataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Dataset(alias: \(Swift.String(describing: alias)), createTime: \(Swift.String(describing: createTime)), datasetArn: \(Swift.String(describing: datasetArn)), datasetDescription: \(Swift.String(describing: datasetDescription)), datasetId: \(Swift.String(describing: datasetId)), datasetTitle: \(Swift.String(describing: datasetTitle)), kind: \(Swift.String(describing: kind)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), ownerInfo: \(Swift.String(describing: ownerInfo)), schemaDefinition: \(Swift.String(describing: schemaDefinition)))"}
}

extension FinspaceDataClientTypes {
    /// The structure for a Dataset.
    public struct Dataset: Swift.Equatable {
        /// The unique resource identifier for a Dataset.
        public var alias: Swift.String?
        /// The timestamp at which the Dataset was created in FinSpace. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The ARN identifier of the Dataset.
        public var datasetArn: Swift.String?
        /// Description for a Dataset.
        public var datasetDescription: Swift.String?
        /// An identifier for a Dataset.
        public var datasetId: Swift.String?
        /// Display title for a Dataset.
        public var datasetTitle: Swift.String?
        /// The format in which Dataset data is structured.
        ///
        /// * TABULAR - Data is structured in a tabular format.
        ///
        /// * NON_TABULAR - Data is structured in a non-tabular format.
        public var kind: FinspaceDataClientTypes.DatasetKind?
        /// The last time that the Dataset was modified. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTime: Swift.Int
        /// Contact information for a Dataset owner.
        public var ownerInfo: FinspaceDataClientTypes.DatasetOwnerInfo?
        /// Definition for a schema on a tabular Dataset.
        public var schemaDefinition: FinspaceDataClientTypes.SchemaUnion?

        public init (
            alias: Swift.String? = nil,
            createTime: Swift.Int = 0,
            datasetArn: Swift.String? = nil,
            datasetDescription: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            datasetTitle: Swift.String? = nil,
            kind: FinspaceDataClientTypes.DatasetKind? = nil,
            lastModifiedTime: Swift.Int = 0,
            ownerInfo: FinspaceDataClientTypes.DatasetOwnerInfo? = nil,
            schemaDefinition: FinspaceDataClientTypes.SchemaUnion? = nil
        )
        {
            self.alias = alias
            self.createTime = createTime
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.lastModifiedTime = lastModifiedTime
            self.ownerInfo = ownerInfo
            self.schemaDefinition = schemaDefinition
        }
    }

}

extension FinspaceDataClientTypes {
    /// Dataset Kind
    public enum DatasetKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonTabular
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetKind] {
            return [
                .nonTabular,
                .tabular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonTabular: return "NON_TABULAR"
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetKind(rawValue: rawValue) ?? DatasetKind.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.DatasetOwnerInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case name
        case phoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension FinspaceDataClientTypes.DatasetOwnerInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetOwnerInfo(email: \(Swift.String(describing: email)), name: \(Swift.String(describing: name)), phoneNumber: \(Swift.String(describing: phoneNumber)))"}
}

extension FinspaceDataClientTypes {
    /// A structure for Dataset owner info.
    public struct DatasetOwnerInfo: Swift.Equatable {
        /// Email address for the Dataset owner.
        public var email: Swift.String?
        /// Name of the Dataset owner.
        public var name: Swift.String?
        /// Phone number for the Dataset owner.
        public var phoneNumber: Swift.String?

        public init (
            email: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.email = email
            self.name = name
            self.phoneNumber = phoneNumber
        }
    }

}

extension FinspaceDataClientTypes {
    /// Status of the dataset process returned from scheduler service.
    public enum DatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .failed,
                .pending,
                .running,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetInput(clientToken: \(Swift.String(describing: clientToken)), datasetId: \(Swift.String(describing: datasetId)))"}
}

extension DeleteDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasetsv2/\(datasetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

/// The request for a DeleteDataset operation.
public struct DeleteDatasetInput: Swift.Equatable {
    /// A token used to ensure idempotency.
    public var clientToken: Swift.String?
    /// The unique identifier of the Dataset to be deleted.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetId = datasetId
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetOutputResponse(datasetId: \(Swift.String(describing: datasetId)))"}
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from an DeleteDataset operation
public struct DeleteDatasetOutputResponse: Swift.Equatable {
    /// The unique identifier for the deleted Dataset.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
    public let datasetId: Swift.String?
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension FinspaceDataClientTypes {
    /// Changeset Error Category
    public enum ErrorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case cancelled
        case internalServiceException
        case resourceNotFound
        case serviceQuotaExceeded
        case throttling
        case userRecoverable
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCategory] {
            return [
                .accessDenied,
                .cancelled,
                .internalServiceException,
                .resourceNotFound,
                .serviceQuotaExceeded,
                .throttling,
                .userRecoverable,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .cancelled: return "CANCELLED"
            case .internalServiceException: return "INTERNAL_SERVICE_EXCEPTION"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case .throttling: return "THROTTLING"
            case .userRecoverable: return "USER_RECOVERABLE"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCategory(rawValue: rawValue) ?? ErrorCategory.sdkUnknown(rawValue)
        }
    }
}

extension GetChangesetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChangesetInput(changesetId: \(Swift.String(describing: changesetId)), datasetId: \(Swift.String(describing: datasetId)))"}
}

extension GetChangesetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetChangesetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChangesetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChangesetOutputError>
}

public struct GetChangesetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChangesetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChangesetOutputError>
}

public struct GetChangesetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChangesetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChangesetOutputError>
}

public struct GetChangesetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetChangesetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        guard let changesetId = input.changesetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("changesetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2/\(changesetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetChangesetOutputError>
}

/// Request to describe a changeset.
public struct GetChangesetInput: Swift.Equatable {
    /// The unique identifier of the Changeset for which to get data.
    /// This member is required.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct GetChangesetInputBody: Swift.Equatable {
}

extension GetChangesetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChangesetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetChangesetOutputResponse(activeUntilTimestamp: \(Swift.String(describing: activeUntilTimestamp)), changeType: \(Swift.String(describing: changeType)), changesetArn: \(Swift.String(describing: changesetArn)), changesetId: \(Swift.String(describing: changesetId)), createTime: \(Swift.String(describing: createTime)), datasetId: \(Swift.String(describing: datasetId)), errorInfo: \(Swift.String(describing: errorInfo)), formatParams: \(Swift.String(describing: formatParams)), sourceParams: \(Swift.String(describing: sourceParams)), status: \(Swift.String(describing: status)), updatedByChangesetId: \(Swift.String(describing: updatedByChangesetId)), updatesChangesetId: \(Swift.String(describing: updatesChangesetId)))"}
}

extension GetChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeUntilTimestamp = output.activeUntilTimestamp
            self.changeType = output.changeType
            self.changesetArn = output.changesetArn
            self.changesetId = output.changesetId
            self.createTime = output.createTime
            self.datasetId = output.datasetId
            self.errorInfo = output.errorInfo
            self.formatParams = output.formatParams
            self.sourceParams = output.sourceParams
            self.status = output.status
            self.updatedByChangesetId = output.updatedByChangesetId
            self.updatesChangesetId = output.updatesChangesetId
        } else {
            self.activeUntilTimestamp = 0
            self.changeType = nil
            self.changesetArn = nil
            self.changesetId = nil
            self.createTime = 0
            self.datasetId = nil
            self.errorInfo = nil
            self.formatParams = nil
            self.sourceParams = nil
            self.status = nil
            self.updatedByChangesetId = nil
            self.updatesChangesetId = nil
        }
    }
}

/// The response from a describe changeset operation
public struct GetChangesetOutputResponse: Swift.Equatable {
    /// Time until which the Changeset is active. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeUntilTimestamp: Swift.Int
    /// Type that indicates how a Changeset is applied to a Dataset.
    ///
    /// * REPLACE - Changeset is considered as a replacement to all prior loaded Changesets.
    ///
    /// * APPEND - Changeset is considered as an addition to the end of all prior loaded Changesets.
    ///
    /// * MODIFY - Changeset is considered as a replacement to a specific prior ingested Changeset.
    public var changeType: FinspaceDataClientTypes.ChangeType?
    /// The ARN identifier of the Changeset.
    public var changesetArn: Swift.String?
    /// The unique identifier for a Changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the Changeset was created in FinSpace. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    public var datasetId: Swift.String?
    /// The structure with error messages.
    public var errorInfo: FinspaceDataClientTypes.ChangesetErrorInfo?
    /// Structure of the source file(s).
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested.
    public var sourceParams: [Swift.String:Swift.String]?
    /// The status of Changeset creation operation.
    public var status: FinspaceDataClientTypes.IngestionStatus?
    /// The unique identifier of the updated Changeset.
    public var updatedByChangesetId: Swift.String?
    /// The unique identifier of the Changeset that is being updated.
    public var updatesChangesetId: Swift.String?

    public init (
        activeUntilTimestamp: Swift.Int = 0,
        changeType: FinspaceDataClientTypes.ChangeType? = nil,
        changesetArn: Swift.String? = nil,
        changesetId: Swift.String? = nil,
        createTime: Swift.Int = 0,
        datasetId: Swift.String? = nil,
        errorInfo: FinspaceDataClientTypes.ChangesetErrorInfo? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil,
        status: FinspaceDataClientTypes.IngestionStatus? = nil,
        updatedByChangesetId: Swift.String? = nil,
        updatesChangesetId: Swift.String? = nil
    )
    {
        self.activeUntilTimestamp = activeUntilTimestamp
        self.changeType = changeType
        self.changesetArn = changesetArn
        self.changesetId = changesetId
        self.createTime = createTime
        self.datasetId = datasetId
        self.errorInfo = errorInfo
        self.formatParams = formatParams
        self.sourceParams = sourceParams
        self.status = status
        self.updatedByChangesetId = updatedByChangesetId
        self.updatesChangesetId = updatesChangesetId
    }
}

struct GetChangesetOutputResponseBody: Swift.Equatable {
    public let changesetId: Swift.String?
    public let changesetArn: Swift.String?
    public let datasetId: Swift.String?
    public let changeType: FinspaceDataClientTypes.ChangeType?
    public let sourceParams: [Swift.String:Swift.String]?
    public let formatParams: [Swift.String:Swift.String]?
    public let createTime: Swift.Int
    public let status: FinspaceDataClientTypes.IngestionStatus?
    public let errorInfo: FinspaceDataClientTypes.ChangesetErrorInfo?
    public let activeUntilTimestamp: Swift.Int
    public let updatesChangesetId: Swift.String?
    public let updatedByChangesetId: Swift.String?
}

extension GetChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeUntilTimestamp
        case changeType
        case changesetArn
        case changesetId
        case createTime
        case datasetId
        case errorInfo
        case formatParams
        case sourceParams
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .createTime)
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.IngestionStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangesetErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let activeUntilTimestampDecoded = try containerValues.decode(Swift.Int.self, forKey: .activeUntilTimestamp)
        activeUntilTimestamp = activeUntilTimestampDecoded
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension GetDataViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataViewInput(dataViewId: \(Swift.String(describing: dataViewId)), datasetId: \(Swift.String(describing: datasetId)))"}
}

extension GetDataViewInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDataViewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataViewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataViewOutputError>
}

public struct GetDataViewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataViewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDataViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDataViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataViewOutputError>
}

public struct GetDataViewInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataViewInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDataViewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDataViewInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataViewOutputError>
}

public struct GetDataViewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDataViewInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDataViewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDataViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        guard let dataViewId = input.dataViewId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dataViewId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2/\(dataViewId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDataViewInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDataViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDataViewOutputError>
}

/// Request for retrieving a data view detail. Grouped / accessible within a dataset by its dataset id.
public struct GetDataViewInput: Swift.Equatable {
    /// The unique identifier for the Dataview.
    /// This member is required.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset used in the Dataview.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct GetDataViewInputBody: Swift.Equatable {
}

extension GetDataViewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataViewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataViewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataViewOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataViewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDataViewOutputResponse(asOfTimestamp: \(Swift.String(describing: asOfTimestamp)), autoUpdate: \(Swift.String(describing: autoUpdate)), createTime: \(Swift.String(describing: createTime)), dataViewArn: \(Swift.String(describing: dataViewArn)), dataViewId: \(Swift.String(describing: dataViewId)), datasetId: \(Swift.String(describing: datasetId)), destinationTypeParams: \(Swift.String(describing: destinationTypeParams)), errorInfo: \(Swift.String(describing: errorInfo)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), partitionColumns: \(Swift.String(describing: partitionColumns)), sortColumns: \(Swift.String(describing: sortColumns)), status: \(Swift.String(describing: status)))"}
}

extension GetDataViewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataViewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.asOfTimestamp = output.asOfTimestamp
            self.autoUpdate = output.autoUpdate
            self.createTime = output.createTime
            self.dataViewArn = output.dataViewArn
            self.dataViewId = output.dataViewId
            self.datasetId = output.datasetId
            self.destinationTypeParams = output.destinationTypeParams
            self.errorInfo = output.errorInfo
            self.lastModifiedTime = output.lastModifiedTime
            self.partitionColumns = output.partitionColumns
            self.sortColumns = output.sortColumns
            self.status = output.status
        } else {
            self.asOfTimestamp = 0
            self.autoUpdate = false
            self.createTime = 0
            self.dataViewArn = nil
            self.dataViewId = nil
            self.datasetId = nil
            self.destinationTypeParams = nil
            self.errorInfo = nil
            self.lastModifiedTime = 0
            self.partitionColumns = nil
            self.sortColumns = nil
            self.status = nil
        }
    }
}

/// Response from retrieving a dataview, which includes details on the target database and table name
public struct GetDataViewOutputResponse: Swift.Equatable {
    /// Time range to use for the Dataview. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var asOfTimestamp: Swift.Int
    /// Flag to indicate Dataview should be updated automatically.
    public var autoUpdate: Swift.Bool
    /// The timestamp at which the Dataview was created in FinSpace. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The ARN identifier of the Dataview.
    public var dataViewArn: Swift.String?
    /// The unique identifier for the Dataview.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset used in the Dataview.
    public var datasetId: Swift.String?
    /// Options that define the destination type for the Dataview.
    public var destinationTypeParams: FinspaceDataClientTypes.DataViewDestinationTypeParams?
    /// Information about an error that occurred for the Dataview.
    public var errorInfo: FinspaceDataClientTypes.DataViewErrorInfo?
    /// The last time that a Dataview was modified. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTime: Swift.Int
    /// Ordered set of column names used to partition data.
    public var partitionColumns: [Swift.String]?
    /// Columns to be used for sorting the data.
    public var sortColumns: [Swift.String]?
    /// The status of a Dataview creation.
    ///
    /// * RUNNING - Dataview creation is running.
    ///
    /// * STARTING - Dataview creation is starting.
    ///
    /// * FAILED - Dataview creation has failed.
    ///
    /// * CANCELLED - Dataview creation has been cancelled.
    ///
    /// * TIMEOUT - Dataview creation has timed out.
    ///
    /// * SUCCESS - Dataview creation has succeeded.
    ///
    /// * PENDING - Dataview creation is pending.
    ///
    /// * FAILED_CLEANUP_FAILED - Dataview creation failed and resource cleanup failed.
    public var status: FinspaceDataClientTypes.DataViewStatus?

    public init (
        asOfTimestamp: Swift.Int = 0,
        autoUpdate: Swift.Bool = false,
        createTime: Swift.Int = 0,
        dataViewArn: Swift.String? = nil,
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        destinationTypeParams: FinspaceDataClientTypes.DataViewDestinationTypeParams? = nil,
        errorInfo: FinspaceDataClientTypes.DataViewErrorInfo? = nil,
        lastModifiedTime: Swift.Int = 0,
        partitionColumns: [Swift.String]? = nil,
        sortColumns: [Swift.String]? = nil,
        status: FinspaceDataClientTypes.DataViewStatus? = nil
    )
    {
        self.asOfTimestamp = asOfTimestamp
        self.autoUpdate = autoUpdate
        self.createTime = createTime
        self.dataViewArn = dataViewArn
        self.dataViewId = dataViewId
        self.datasetId = datasetId
        self.destinationTypeParams = destinationTypeParams
        self.errorInfo = errorInfo
        self.lastModifiedTime = lastModifiedTime
        self.partitionColumns = partitionColumns
        self.sortColumns = sortColumns
        self.status = status
    }
}

struct GetDataViewOutputResponseBody: Swift.Equatable {
    public let autoUpdate: Swift.Bool
    public let partitionColumns: [Swift.String]?
    public let datasetId: Swift.String?
    public let asOfTimestamp: Swift.Int
    public let errorInfo: FinspaceDataClientTypes.DataViewErrorInfo?
    public let lastModifiedTime: Swift.Int
    public let createTime: Swift.Int
    public let sortColumns: [Swift.String]?
    public let dataViewId: Swift.String?
    public let dataViewArn: Swift.String?
    public let destinationTypeParams: FinspaceDataClientTypes.DataViewDestinationTypeParams?
    public let status: FinspaceDataClientTypes.DataViewStatus?
}

extension GetDataViewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case createTime
        case dataViewArn
        case dataViewId
        case datasetId
        case destinationTypeParams
        case errorInfo
        case lastModifiedTime
        case partitionColumns
        case sortColumns
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoUpdateDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoUpdate)
        autoUpdate = autoUpdateDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let asOfTimestampDecoded = try containerValues.decode(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let lastModifiedTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let createTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .createTime)
        createTime = createTimeDecoded
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
        let dataViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewArn)
        dataViewArn = dataViewArnDecoded
        let destinationTypeParamsDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeParams)
        destinationTypeParams = destinationTypeParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DataViewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDatasetInput(datasetId: \(Swift.String(describing: datasetId)))"}
}

extension GetDatasetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDatasetOutputError>
}

public struct GetDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDatasetOutputError>
}

public struct GetDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDatasetOutputError>
}

public struct GetDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasetsv2/\(datasetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDatasetOutputError>
}

/// Request for the GetDataset operation.
public struct GetDatasetInput: Swift.Equatable {
    /// The unique identifier for a Dataset.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct GetDatasetInputBody: Swift.Equatable {
}

extension GetDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDatasetOutputResponse(alias: \(Swift.String(describing: alias)), createTime: \(Swift.String(describing: createTime)), datasetArn: \(Swift.String(describing: datasetArn)), datasetDescription: \(Swift.String(describing: datasetDescription)), datasetId: \(Swift.String(describing: datasetId)), datasetTitle: \(Swift.String(describing: datasetTitle)), kind: \(Swift.String(describing: kind)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), schemaDefinition: \(Swift.String(describing: schemaDefinition)), status: \(Swift.String(describing: status)))"}
}

extension GetDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.createTime = output.createTime
            self.datasetArn = output.datasetArn
            self.datasetDescription = output.datasetDescription
            self.datasetId = output.datasetId
            self.datasetTitle = output.datasetTitle
            self.kind = output.kind
            self.lastModifiedTime = output.lastModifiedTime
            self.schemaDefinition = output.schemaDefinition
            self.status = output.status
        } else {
            self.alias = nil
            self.createTime = 0
            self.datasetArn = nil
            self.datasetDescription = nil
            self.datasetId = nil
            self.datasetTitle = nil
            self.kind = nil
            self.lastModifiedTime = 0
            self.schemaDefinition = nil
            self.status = nil
        }
    }
}

/// Response for the GetDataset operation
public struct GetDatasetOutputResponse: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// The timestamp at which the Dataset was created in FinSpace. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The ARN identifier of the Dataset.
    public var datasetArn: Swift.String?
    /// A description of the Dataset.
    public var datasetDescription: Swift.String?
    /// The unique identifier for a Dataset.
    public var datasetId: Swift.String?
    /// Display title for a Dataset.
    public var datasetTitle: Swift.String?
    /// The format in which Dataset data is structured.
    ///
    /// * TABULAR - Data is structured in a tabular format.
    ///
    /// * NON_TABULAR - Data is structured in a non-tabular format.
    public var kind: FinspaceDataClientTypes.DatasetKind?
    /// The last time that the Dataset was modified. The value is determined as Epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTime: Swift.Int
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspaceDataClientTypes.SchemaUnion?
    /// Status of the Dataset creation.
    ///
    /// * PENDING - Dataset is pending creation.
    ///
    /// * FAILED - Dataset creation has failed.
    ///
    /// * SUCCESS - Dataset creation has succeeded.
    ///
    /// * RUNNING - Dataset creation is running.
    public var status: FinspaceDataClientTypes.DatasetStatus?

    public init (
        alias: Swift.String? = nil,
        createTime: Swift.Int = 0,
        datasetArn: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspaceDataClientTypes.DatasetKind? = nil,
        lastModifiedTime: Swift.Int = 0,
        schemaDefinition: FinspaceDataClientTypes.SchemaUnion? = nil,
        status: FinspaceDataClientTypes.DatasetStatus? = nil
    )
    {
        self.alias = alias
        self.createTime = createTime
        self.datasetArn = datasetArn
        self.datasetDescription = datasetDescription
        self.datasetId = datasetId
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.lastModifiedTime = lastModifiedTime
        self.schemaDefinition = schemaDefinition
        self.status = status
    }
}

struct GetDatasetOutputResponseBody: Swift.Equatable {
    public let datasetId: Swift.String?
    public let datasetArn: Swift.String?
    public let datasetTitle: Swift.String?
    public let kind: FinspaceDataClientTypes.DatasetKind?
    public let datasetDescription: Swift.String?
    public let createTime: Swift.Int
    public let lastModifiedTime: Swift.Int
    public let schemaDefinition: FinspaceDataClientTypes.SchemaUnion?
    public let alias: Swift.String?
    public let status: FinspaceDataClientTypes.DatasetStatus?
}

extension GetDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case createTime
        case datasetArn
        case datasetDescription
        case datasetId
        case datasetTitle
        case kind
        case lastModifiedTime
        case schemaDefinition
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let createTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decode(Swift.Int.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetProgrammaticAccessCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProgrammaticAccessCredentialsInput(durationInMinutes: \(Swift.String(describing: durationInMinutes)), environmentId: \(Swift.String(describing: environmentId)))"}
}

extension GetProgrammaticAccessCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetProgrammaticAccessCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let environmentId = input.operationInput.environmentId {
            let environmentIdQueryItem = ClientRuntime.URLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            input.builder.withQueryItem(environmentIdQueryItem)
        }
        if input.operationInput.durationInMinutes != 0 {
            let durationInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "durationInMinutes".urlPercentEncoding(), value: Swift.String(input.operationInput.durationInMinutes).urlPercentEncoding())
            input.builder.withQueryItem(durationInMinutesQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetProgrammaticAccessCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProgrammaticAccessCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetProgrammaticAccessCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/credentials/programmatic"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProgrammaticAccessCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

/// Request for GetProgrammaticAccessCredentials operation
public struct GetProgrammaticAccessCredentialsInput: Swift.Equatable {
    /// The time duration in which the credentials remain valid.
    public var durationInMinutes: Swift.Int
    /// The FinSpace environment identifier.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        durationInMinutes: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.environmentId = environmentId
    }
}

struct GetProgrammaticAccessCredentialsInputBody: Swift.Equatable {
}

extension GetProgrammaticAccessCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProgrammaticAccessCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProgrammaticAccessCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProgrammaticAccessCredentialsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProgrammaticAccessCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProgrammaticAccessCredentialsOutputResponse(credentials: \(Swift.String(describing: credentials)), durationInMinutes: \(Swift.String(describing: durationInMinutes)))"}
}

extension GetProgrammaticAccessCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProgrammaticAccessCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.durationInMinutes = output.durationInMinutes
        } else {
            self.credentials = nil
            self.durationInMinutes = 0
        }
    }
}

/// Response for GetProgrammaticAccessCredentials operation
public struct GetProgrammaticAccessCredentialsOutputResponse: Swift.Equatable {
    /// Returns the programmatic credentials.
    public var credentials: FinspaceDataClientTypes.Credentials?
    /// Returns the duration in which the credentials will remain valid.
    public var durationInMinutes: Swift.Int

    public init (
        credentials: FinspaceDataClientTypes.Credentials? = nil,
        durationInMinutes: Swift.Int = 0
    )
    {
        self.credentials = credentials
        self.durationInMinutes = durationInMinutes
    }
}

struct GetProgrammaticAccessCredentialsOutputResponseBody: Swift.Equatable {
    public let credentials: FinspaceDataClientTypes.Credentials?
    public let durationInMinutes: Swift.Int
}

extension GetProgrammaticAccessCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case durationInMinutes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let durationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
    }
}

public struct GetWorkingLocationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

extension GetWorkingLocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkingLocationInput(locationType: \(Swift.String(describing: locationType)))"}
}

extension GetWorkingLocationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationType = locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

public struct GetWorkingLocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetWorkingLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWorkingLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetWorkingLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/workingLocationV1"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWorkingLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInput: Swift.Equatable {
    /// Specify the type of the working location.
    ///
    /// * SAGEMAKER - Use the Amazon S3 location as a temporary location to store data content when working with FinSpace Notebooks that run on SageMaker studio.
    ///
    /// * INGESTION - Use the Amazon S3 location as a staging location to copy your data content and then use the location with the Changeset creation operation.
    public var locationType: FinspaceDataClientTypes.LocationType?

    public init (
        locationType: FinspaceDataClientTypes.LocationType? = nil
    )
    {
        self.locationType = locationType
    }
}

struct GetWorkingLocationInputBody: Swift.Equatable {
    public let locationType: FinspaceDataClientTypes.LocationType?
}

extension GetWorkingLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
    }
}

extension GetWorkingLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkingLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkingLocationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkingLocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkingLocationOutputResponse(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Path: \(Swift.String(describing: s3Path)), s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension GetWorkingLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkingLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.s3Bucket = output.s3Bucket
            self.s3Path = output.s3Path
            self.s3Uri = output.s3Uri
        } else {
            self.s3Bucket = nil
            self.s3Path = nil
            self.s3Uri = nil
        }
    }
}

public struct GetWorkingLocationOutputResponse: Swift.Equatable {
    /// Returns the Amazon S3 bucket name for the working location.
    public var s3Bucket: Swift.String?
    /// Returns the Amazon S3 Path for the working location.
    public var s3Path: Swift.String?
    /// Returns the Amazon S3 URI for the working location.
    public var s3Uri: Swift.String?

    public init (
        s3Bucket: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Uri: Swift.String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Path = s3Path
        self.s3Uri = s3Uri
    }
}

struct GetWorkingLocationOutputResponseBody: Swift.Equatable {
    public let s3Uri: Swift.String?
    public let s3Path: Swift.String?
    public let s3Bucket: Swift.String?
}

extension GetWorkingLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Path
        case s3Uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension FinspaceDataClientTypes {
    /// Status of the ingestion process returned from scheduler service.
    public enum IngestionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case stopRequested
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionStatus] {
            return [
                .failed,
                .pending,
                .running,
                .stopRequested,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopRequested: return "STOP_REQUESTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionStatus(rawValue: rawValue) ?? IngestionStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit has exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangesetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChangesetsInput(datasetId: \(Swift.String(describing: datasetId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChangesetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListChangesetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChangesetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChangesetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChangesetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChangesetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChangesetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChangesetsOutputError>
}

public struct ListChangesetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChangesetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListChangesetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChangesetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListChangesetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListChangesetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChangesetsOutputError>
}

public struct ListChangesetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChangesetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListChangesetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChangesetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChangesetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChangesetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChangesetsOutputError>
}

public struct ListChangesetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListChangesetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListChangesetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListChangesetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListChangesetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListChangesetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListChangesetsOutputError>
}

/// Request to ListChangesetsRequest. It exposes minimal query filters.
public struct ListChangesetsInput: Swift.Equatable {
    /// The unique identifier for the FinSpace Dataset to which the Changeset belongs.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int
    /// A token indicating where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        datasetId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChangesetsInputBody: Swift.Equatable {
}

extension ListChangesetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChangesetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChangesetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChangesetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangesetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChangesetsOutputResponse(changesets: \(Swift.String(describing: changesets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListChangesetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListChangesetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changesets = output.changesets
            self.nextToken = output.nextToken
        } else {
            self.changesets = nil
            self.nextToken = nil
        }
    }
}

/// Response to ListChangesetsResponse. This returns a list of dataset changesets that match the query criteria.
public struct ListChangesetsOutputResponse: Swift.Equatable {
    /// List of Changesets found.
    public var changesets: [FinspaceDataClientTypes.ChangesetSummary]?
    /// A token indicating where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        changesets: [FinspaceDataClientTypes.ChangesetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changesets = changesets
        self.nextToken = nextToken
    }
}

struct ListChangesetsOutputResponseBody: Swift.Equatable {
    public let changesets: [FinspaceDataClientTypes.ChangesetSummary]?
    public let nextToken: Swift.String?
}

extension ListChangesetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetsContainer = try containerValues.decodeIfPresent([FinspaceDataClientTypes.ChangesetSummary?].self, forKey: .changesets)
        var changesetsDecoded0:[FinspaceDataClientTypes.ChangesetSummary]? = nil
        if let changesetsContainer = changesetsContainer {
            changesetsDecoded0 = [FinspaceDataClientTypes.ChangesetSummary]()
            for structure0 in changesetsContainer {
                if let structure0 = structure0 {
                    changesetsDecoded0?.append(structure0)
                }
            }
        }
        changesets = changesetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataViewsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataViewsInput(datasetId: \(Swift.String(describing: datasetId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataViewsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDataViewsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataViewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataViewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataViewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataViewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataViewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataViewsOutputError>
}

public struct ListDataViewsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataViewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDataViewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataViewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDataViewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataViewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataViewsOutputError>
}

public struct ListDataViewsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataViewsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDataViewsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataViewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataViewsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataViewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataViewsOutputError>
}

public struct ListDataViewsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDataViewsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDataViewsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDataViewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDataViewsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDataViewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDataViewsOutputError>
}

/// Request for a list data views.
public struct ListDataViewsInput: Swift.Equatable {
    /// The unique identifier of the Dataset for which to retrieve Dataviews.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int
    /// A token indicating where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        datasetId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataViewsInputBody: Swift.Equatable {
}

extension ListDataViewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataViewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataViewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataViewsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataViewsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDataViewsOutputResponse(dataViews: \(Swift.String(describing: dataViews)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDataViewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataViewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataViews = output.dataViews
            self.nextToken = output.nextToken
        } else {
            self.dataViews = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataViewsOutputResponse: Swift.Equatable {
    /// A list of Dataviews.
    public var dataViews: [FinspaceDataClientTypes.DataViewSummary]?
    /// A token indicating where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        dataViews: [FinspaceDataClientTypes.DataViewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataViews = dataViews
        self.nextToken = nextToken
    }
}

struct ListDataViewsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let dataViews: [FinspaceDataClientTypes.DataViewSummary]?
}

extension ListDataViewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataViews
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataViewsContainer = try containerValues.decodeIfPresent([FinspaceDataClientTypes.DataViewSummary?].self, forKey: .dataViews)
        var dataViewsDecoded0:[FinspaceDataClientTypes.DataViewSummary]? = nil
        if let dataViewsContainer = dataViewsContainer {
            dataViewsDecoded0 = [FinspaceDataClientTypes.DataViewSummary]()
            for structure0 in dataViewsContainer {
                if let structure0 = structure0 {
                    dataViewsDecoded0?.append(structure0)
                }
            }
        }
        dataViews = dataViewsDecoded0
    }
}

extension ListDatasetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDatasetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDatasetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDatasetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/datasetsv2"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

/// Request for the ListDatasets operation.
public struct ListDatasetsInput: Swift.Equatable {
    /// The maximum number of results per page.
    public var maxResults: Swift.Int
    /// A token indicating where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsOutputResponse(datasets: \(Swift.String(describing: datasets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

/// Response for the ListDatasets operation
public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// List of Datasets.
    public var datasets: [FinspaceDataClientTypes.Dataset]?
    /// A token indicating where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        datasets: [FinspaceDataClientTypes.Dataset]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    public let datasets: [FinspaceDataClientTypes.Dataset]?
    public let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([FinspaceDataClientTypes.Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[FinspaceDataClientTypes.Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [FinspaceDataClientTypes.Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension FinspaceDataClientTypes {
    public enum LocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ingestion
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationType] {
            return [
                .ingestion,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ingestion: return "INGESTION"
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.PermissionGroupParams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetPermissions
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetPermissions = datasetPermissions {
            var datasetPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetPermissions)
            for resourcepermissionslist0 in datasetPermissions {
                try datasetPermissionsContainer.encode(resourcepermissionslist0)
            }
        }
        if let permissionGroupId = permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let datasetPermissionsContainer = try containerValues.decodeIfPresent([FinspaceDataClientTypes.ResourcePermission?].self, forKey: .datasetPermissions)
        var datasetPermissionsDecoded0:[FinspaceDataClientTypes.ResourcePermission]? = nil
        if let datasetPermissionsContainer = datasetPermissionsContainer {
            datasetPermissionsDecoded0 = [FinspaceDataClientTypes.ResourcePermission]()
            for structure0 in datasetPermissionsContainer {
                if let structure0 = structure0 {
                    datasetPermissionsDecoded0?.append(structure0)
                }
            }
        }
        datasetPermissions = datasetPermissionsDecoded0
    }
}

extension FinspaceDataClientTypes.PermissionGroupParams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PermissionGroupParams(datasetPermissions: \(Swift.String(describing: datasetPermissions)), permissionGroupId: \(Swift.String(describing: permissionGroupId)))"}
}

extension FinspaceDataClientTypes {
    /// Permission group parameters for Dataset permissions.
    public struct PermissionGroupParams: Swift.Equatable {
        /// List of resource permissions.
        public var datasetPermissions: [FinspaceDataClientTypes.ResourcePermission]?
        /// The unique identifier of the PermissionGroup.
        public var permissionGroupId: Swift.String?

        public init (
            datasetPermissions: [FinspaceDataClientTypes.ResourcePermission]? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.datasetPermissions = datasetPermissions
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceDataClientTypes.ResourcePermission: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permission = permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension FinspaceDataClientTypes.ResourcePermission: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePermission(permission: \(Swift.String(describing: permission)))"}
}

extension FinspaceDataClientTypes {
    /// Resource permission for a Dataset.
    public struct ResourcePermission: Swift.Equatable {
        /// Permission for a resource.
        public var permission: Swift.String?

        public init (
            permission: Swift.String? = nil
        )
        {
            self.permission = permission
        }
    }

}

extension FinspaceDataClientTypes.SchemaDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
        case primaryKeyColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnlist0 in columns {
                try columnsContainer.encode(columnlist0)
            }
        }
        if let primaryKeyColumns = primaryKeyColumns {
            var primaryKeyColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .primaryKeyColumns)
            for columnnamelist0 in primaryKeyColumns {
                try primaryKeyColumnsContainer.encode(columnnamelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([FinspaceDataClientTypes.ColumnDefinition?].self, forKey: .columns)
        var columnsDecoded0:[FinspaceDataClientTypes.ColumnDefinition]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [FinspaceDataClientTypes.ColumnDefinition]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let primaryKeyColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .primaryKeyColumns)
        var primaryKeyColumnsDecoded0:[Swift.String]? = nil
        if let primaryKeyColumnsContainer = primaryKeyColumnsContainer {
            primaryKeyColumnsDecoded0 = [Swift.String]()
            for string0 in primaryKeyColumnsContainer {
                if let string0 = string0 {
                    primaryKeyColumnsDecoded0?.append(string0)
                }
            }
        }
        primaryKeyColumns = primaryKeyColumnsDecoded0
    }
}

extension FinspaceDataClientTypes.SchemaDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaDefinition(columns: \(Swift.String(describing: columns)), primaryKeyColumns: \(Swift.String(describing: primaryKeyColumns)))"}
}

extension FinspaceDataClientTypes {
    /// Definition for a schema on a tabular Dataset.
    public struct SchemaDefinition: Swift.Equatable {
        /// List of column definitions.
        public var columns: [FinspaceDataClientTypes.ColumnDefinition]?
        /// List of column names used for primary key.
        public var primaryKeyColumns: [Swift.String]?

        public init (
            columns: [FinspaceDataClientTypes.ColumnDefinition]? = nil,
            primaryKeyColumns: [Swift.String]? = nil
        )
        {
            self.columns = columns
            self.primaryKeyColumns = primaryKeyColumns
        }
    }

}

extension FinspaceDataClientTypes.SchemaUnion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tabularSchemaConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tabularSchemaConfig = tabularSchemaConfig {
            try encodeContainer.encode(tabularSchemaConfig, forKey: .tabularSchemaConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tabularSchemaConfigDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SchemaDefinition.self, forKey: .tabularSchemaConfig)
        tabularSchemaConfig = tabularSchemaConfigDecoded
    }
}

extension FinspaceDataClientTypes.SchemaUnion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SchemaUnion(tabularSchemaConfig: \(Swift.String(describing: tabularSchemaConfig)))"}
}

extension FinspaceDataClientTypes {
    /// A union of schema types.
    public struct SchemaUnion: Swift.Equatable {
        /// The configuration for a schema on a tabular Dataset.
        public var tabularSchemaConfig: FinspaceDataClientTypes.SchemaDefinition?

        public init (
            tabularSchemaConfig: FinspaceDataClientTypes.SchemaDefinition? = nil
        )
        {
            self.tabularSchemaConfig = tabularSchemaConfig
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException()"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

public struct UpdateChangesetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChangesetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChangesetOutputError>
}

extension UpdateChangesetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChangesetInput(changesetId: \(Swift.String(describing: changesetId)), clientToken: \(Swift.String(describing: clientToken)), datasetId: \(Swift.String(describing: datasetId)), formatParams: \(Swift.String(describing: formatParams)), sourceParams: \(Swift.String(describing: sourceParams)))"}
}

extension UpdateChangesetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case formatParams
        case sourceParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatparams0) in formatParams {
                try formatParamsContainer.encode(formatparams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceparams0) in sourceParams {
                try sourceParamsContainer.encode(sourceparams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateChangesetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChangesetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChangesetOutputError>
}

public struct UpdateChangesetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChangesetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChangesetOutputError>
}

public struct UpdateChangesetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChangesetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChangesetOutputError>
}

public struct UpdateChangesetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateChangesetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        guard let changesetId = input.changesetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("changesetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2/\(changesetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateChangesetOutputError>
}

/// Request to update an existing changeset.
public struct UpdateChangesetInput: Swift.Equatable {
    /// The unique identifier for the Changeset to update.
    /// This member is required.
    public var changesetId: Swift.String?
    /// A token used to ensure idempotency.
    public var clientToken: Swift.String?
    /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s).
    /// This member is required.
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?

    public init (
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.sourceParams = sourceParams
    }
}

struct UpdateChangesetInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let sourceParams: [Swift.String:Swift.String]?
    public let formatParams: [Swift.String:Swift.String]?
}

extension UpdateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case formatParams
        case sourceParams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
    }
}

extension UpdateChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChangesetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChangesetOutputResponse(changesetId: \(Swift.String(describing: changesetId)), datasetId: \(Swift.String(describing: datasetId)))"}
}

extension UpdateChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changesetId = output.changesetId
            self.datasetId = output.datasetId
        } else {
            self.changesetId = nil
            self.datasetId = nil
        }
    }
}

/// The response from a update changeset operation.
public struct UpdateChangesetOutputResponse: Swift.Equatable {
    /// The unique identifier for the Changeset to update.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
    public var datasetId: Swift.String?

    public init (
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct UpdateChangesetOutputResponseBody: Swift.Equatable {
    public let changesetId: Swift.String?
    public let datasetId: Swift.String?
}

extension UpdateChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

public struct UpdateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

extension UpdateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetInput(alias: \(Swift.String(describing: alias)), clientToken: \(Swift.String(describing: clientToken)), datasetDescription: \(Swift.String(describing: datasetDescription)), datasetId: \(Swift.String(describing: datasetId)), datasetTitle: \(Swift.String(describing: datasetTitle)), kind: \(Swift.String(describing: kind)), schemaDefinition: \(Swift.String(describing: schemaDefinition)))"}
}

extension UpdateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetDescription = datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetTitle = datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let schemaDefinition = schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

public struct UpdateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

public struct UpdateDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDatasetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/datasetsv2/\(datasetId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDatasetOutputError>
}

/// The request for an UpdateDataset operation
public struct UpdateDatasetInput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    /// This member is required.
    public var alias: Swift.String?
    /// A token used to ensure idempotency.
    public var clientToken: Swift.String?
    /// A description for the Dataset.
    public var datasetDescription: Swift.String?
    /// The unique identifier for the Dataset to update.
    /// This member is required.
    public var datasetId: Swift.String?
    /// A display title for the Dataset.
    /// This member is required.
    public var datasetTitle: Swift.String?
    /// The format in which the Dataset data is structured.
    ///
    /// * TABULAR - Data is structured in a tabular format.
    ///
    /// * NON_TABULAR - Data is structured in a non-tabular format.
    /// This member is required.
    public var kind: FinspaceDataClientTypes.DatasetKind?
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspaceDataClientTypes.SchemaUnion?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspaceDataClientTypes.DatasetKind? = nil,
        schemaDefinition: FinspaceDataClientTypes.SchemaUnion? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.datasetDescription = datasetDescription
        self.datasetId = datasetId
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.schemaDefinition = schemaDefinition
    }
}

struct UpdateDatasetInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let datasetTitle: Swift.String?
    public let kind: FinspaceDataClientTypes.DatasetKind?
    public let datasetDescription: Swift.String?
    public let alias: Swift.String?
    public let schemaDefinition: FinspaceDataClientTypes.SchemaUnion?
}

extension UpdateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case schemaDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension UpdateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDatasetOutputResponse(datasetId: \(Swift.String(describing: datasetId)))"}
}

extension UpdateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from an UpdateDataset operation
public struct UpdateDatasetOutputResponse: Swift.Equatable {
    /// The unique identifier for updated Dataset.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct UpdateDatasetOutputResponseBody: Swift.Equatable {
    public let datasetId: Swift.String?
}

extension UpdateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
