// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceDataClientTypes {
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case append
        case modify
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .append,
                .modify,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .modify: return "MODIFY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.ChangesetInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case changesetArn
        case changesetLabels
        case createTimestamp
        case datasetId
        case errorInfo
        case formatParams
        case formatType
        case id
        case sourceParams
        case sourceType
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let changesetArn = changesetArn {
            try encodeContainer.encode(changesetArn, forKey: .changesetArn)
        }
        if let changesetLabels = changesetLabels {
            var changesetLabelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .changesetLabels)
            for (dictKey0, stringmap0) in changesetLabels {
                try changesetLabelsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createTimestamp = createTimestamp {
            try encodeContainer.encode(createTimestamp.timeIntervalSince1970, forKey: .createTimestamp)
        }
        if let datasetId = datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let errorInfo = errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, stringmap0) in formatParams {
                try formatParamsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formatType = formatType {
            try encodeContainer.encode(formatType.rawValue, forKey: .formatType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, stringmap0) in sourceParams {
                try sourceParamsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedByChangesetId = updatedByChangesetId {
            try encodeContainer.encode(updatedByChangesetId, forKey: .updatedByChangesetId)
        }
        if let updatesChangesetId = updatesChangesetId {
            try encodeContainer.encode(updatesChangesetId, forKey: .updatesChangesetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.FormatType.self, forKey: .formatType)
        formatType = formatTypeDecoded
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createTimestamp)
        createTimestamp = createTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangesetStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let changesetLabelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .changesetLabels)
        var changesetLabelsDecoded0: [Swift.String:Swift.String]? = nil
        if let changesetLabelsContainer = changesetLabelsContainer {
            changesetLabelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in changesetLabelsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    changesetLabelsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        changesetLabels = changesetLabelsDecoded0
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension FinspaceDataClientTypes.ChangesetInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangesetInfo(changeType: \(Swift.String(describing: changeType)), changesetArn: \(Swift.String(describing: changesetArn)), changesetLabels: \(Swift.String(describing: changesetLabels)), createTimestamp: \(Swift.String(describing: createTimestamp)), datasetId: \(Swift.String(describing: datasetId)), errorInfo: \(Swift.String(describing: errorInfo)), formatParams: \(Swift.String(describing: formatParams)), formatType: \(Swift.String(describing: formatType)), id: \(Swift.String(describing: id)), sourceParams: \(Swift.String(describing: sourceParams)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedByChangesetId: \(Swift.String(describing: updatedByChangesetId)), updatesChangesetId: \(Swift.String(describing: updatesChangesetId)))"}
}

extension FinspaceDataClientTypes {
    /// A changeset is unit of data in a dataset.
    public struct ChangesetInfo: Swift.Equatable {
        /// Change type indicates how a changeset is applied to a dataset.
        ///
        ///
        ///
        ///                   REPLACE - Changeset is considered as a replacement to all prior loaded
        ///           changesets.
        ///
        ///
        ///
        ///                   APPEND - Changeset is considered as an addition to the end of all prior
        ///           loaded changesets.
        ///
        ///
        ///
        ///                   MODIFY - Changeset is considered as a replacement to a specific prior
        ///           ingested changeset.
        ///
        ///
        public var changeType: FinspaceDataClientTypes.ChangeType?
        /// The ARN identifier of the changeset.
        public var changesetArn: Swift.String?
        /// Tags associated with the changeset.
        public var changesetLabels: [Swift.String:Swift.String]?
        /// The timestamp at which the changeset was created in FinSpace.
        public var createTimestamp: ClientRuntime.Date?
        /// The unique identifier for the FinSpace dataset in which the changeset is created.
        public var datasetId: Swift.String?
        /// The structure with error messages.
        public var errorInfo: FinspaceDataClientTypes.ErrorInfo?
        /// Structure of the source file(s).
        public var formatParams: [Swift.String:Swift.String]?
        /// Format type of the input files loaded into the changeset.
        public var formatType: FinspaceDataClientTypes.FormatType?
        /// Unique identifier for a changeset.
        public var id: Swift.String?
        /// Source path from which the files to create the changeset are sourced.
        public var sourceParams: [Swift.String:Swift.String]?
        /// Type of the data source from which the files to create the changeset are sourced.
        ///
        ///
        ///
        ///                   S3 - Amazon S3.
        ///
        ///
        public var sourceType: FinspaceDataClientTypes.SourceType?
        /// The status of changeset creation operation.
        public var status: FinspaceDataClientTypes.ChangesetStatus?
        /// Unique identifier of the changeset that is updated a changeset.
        public var updatedByChangesetId: Swift.String?
        /// Unique identifier of the changeset that is updated.
        public var updatesChangesetId: Swift.String?

        public init (
            changeType: FinspaceDataClientTypes.ChangeType? = nil,
            changesetArn: Swift.String? = nil,
            changesetLabels: [Swift.String:Swift.String]? = nil,
            createTimestamp: ClientRuntime.Date? = nil,
            datasetId: Swift.String? = nil,
            errorInfo: FinspaceDataClientTypes.ErrorInfo? = nil,
            formatParams: [Swift.String:Swift.String]? = nil,
            formatType: FinspaceDataClientTypes.FormatType? = nil,
            id: Swift.String? = nil,
            sourceParams: [Swift.String:Swift.String]? = nil,
            sourceType: FinspaceDataClientTypes.SourceType? = nil,
            status: FinspaceDataClientTypes.ChangesetStatus? = nil,
            updatedByChangesetId: Swift.String? = nil,
            updatesChangesetId: Swift.String? = nil
        )
        {
            self.changeType = changeType
            self.changesetArn = changesetArn
            self.changesetLabels = changesetLabels
            self.createTimestamp = createTimestamp
            self.datasetId = datasetId
            self.errorInfo = errorInfo
            self.formatParams = formatParams
            self.formatType = formatType
            self.id = id
            self.sourceParams = sourceParams
            self.sourceType = sourceType
            self.status = status
            self.updatedByChangesetId = updatedByChangesetId
            self.updatesChangesetId = updatesChangesetId
        }
    }

}

extension FinspaceDataClientTypes {
    public enum ChangesetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case stopRequested
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangesetStatus] {
            return [
                .failed,
                .pending,
                .running,
                .stopRequested,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopRequested: return "STOP_REQUESTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangesetStatus(rawValue: rawValue) ?? ChangesetStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateChangesetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

extension CreateChangesetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChangesetInput(changeType: \(Swift.String(describing: changeType)), datasetId: \(Swift.String(describing: datasetId)), formatParams: \(Swift.String(describing: formatParams)), formatType: \(Swift.String(describing: formatType)), sourceParams: \(Swift.String(describing: sourceParams)), sourceType: \(Swift.String(describing: sourceType)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateChangesetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case formatParams
        case formatType
        case sourceParams
        case sourceType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, stringmap0) in formatParams {
                try formatParamsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formatType = formatType {
            try encodeContainer.encode(formatType.rawValue, forKey: .formatType)
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, stringmap0) in sourceParams {
                try sourceParamsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, stringmap0) in tags {
                try tagsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateChangesetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateChangesetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateChangesetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateChangesetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateChangesetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateChangesetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let datasetId = input.datasetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("datasetId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/datasets/\(datasetId.urlPercentEncoding())/changesets"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateChangesetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateChangesetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateChangesetOutputError>
}

public struct CreateChangesetInput: Swift.Equatable {
    /// Option to indicate how a changeset will be applied to a dataset.
    ///
    ///
    ///
    ///                   REPLACE - Changeset will be considered as a replacement to all prior
    ///           loaded changesets.
    ///
    ///
    ///
    ///                   APPEND - Changeset will be considered as an addition to the end of all
    ///           prior loaded changesets.
    ///
    ///
    /// This member is required.
    public var changeType: FinspaceDataClientTypes.ChangeType?
    /// The unique identifier for the FinSpace dataset in which the changeset will be
    ///       created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s).
    public var formatParams: [Swift.String:Swift.String]?
    /// Format type of the input files being loaded into the changeset.
    public var formatType: FinspaceDataClientTypes.FormatType?
    /// Source path from which the files to create the changeset will be sourced.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?
    /// Type of the data source from which the files to create the changeset will be
    ///       sourced.
    ///
    ///
    ///
    ///                   S3 - Amazon S3.
    ///
    ///
    /// This member is required.
    public var sourceType: FinspaceDataClientTypes.SourceType?
    /// Metadata tags to apply to this changeset.
    public var tags: [Swift.String:Swift.String]?

    public init (
        changeType: FinspaceDataClientTypes.ChangeType? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        formatType: FinspaceDataClientTypes.FormatType? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil,
        sourceType: FinspaceDataClientTypes.SourceType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.changeType = changeType
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.formatType = formatType
        self.sourceParams = sourceParams
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateChangesetInputBody: Swift.Equatable {
    public let changeType: FinspaceDataClientTypes.ChangeType?
    public let sourceType: FinspaceDataClientTypes.SourceType?
    public let sourceParams: [Swift.String:Swift.String]?
    public let formatType: FinspaceDataClientTypes.FormatType?
    public let formatParams: [Swift.String:Swift.String]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case formatParams
        case formatType
        case sourceParams
        case sourceType
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.FormatType.self, forKey: .formatType)
        formatType = formatTypeDecoded
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in tagsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    tagsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChangesetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChangesetOutputResponse(changeset: \(Swift.String(describing: changeset)))"}
}

extension CreateChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeset = output.changeset
        } else {
            self.changeset = nil
        }
    }
}

public struct CreateChangesetOutputResponse: Swift.Equatable {
    /// Returns the changeset details.
    public var changeset: FinspaceDataClientTypes.ChangesetInfo?

    public init (
        changeset: FinspaceDataClientTypes.ChangesetInfo? = nil
    )
    {
        self.changeset = changeset
    }
}

struct CreateChangesetOutputResponseBody: Swift.Equatable {
    public let changeset: FinspaceDataClientTypes.ChangesetInfo?
}

extension CreateChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeset
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ChangesetInfo.self, forKey: .changeset)
        changeset = changesetDecoded
    }
}

extension FinspaceDataClientTypes.Credentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension FinspaceDataClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credentials(accessKeyId: \(Swift.String(describing: accessKeyId)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), sessionToken: \(Swift.String(describing: sessionToken)))"}
}

extension FinspaceDataClientTypes {
    /// Set short term API credentials.
    public struct Credentials: Swift.Equatable {
        /// The access key identifier.
        public var accessKeyId: Swift.String?
        /// The access key.
        public var secretAccessKey: Swift.String?
        /// The session token.
        public var sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension FinspaceDataClientTypes {
    public enum ErrorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case cancelled
        case internalServiceException
        case resourceNotFound
        case serviceQuotaExceeded
        case throttling
        case userRecoverable
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCategory] {
            return [
                .accessDenied,
                .cancelled,
                .internalServiceException,
                .resourceNotFound,
                .serviceQuotaExceeded,
                .throttling,
                .userRecoverable,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "Missing_required_permission_to_perform_this_request"
            case .cancelled: return "Cancelled"
            case .internalServiceException: return "An_internal_error_has_occurred"
            case .resourceNotFound: return "One_or_more_inputs_to_this_request_were_not_found"
            case .serviceQuotaExceeded: return "Service_limits_have_been_exceeded"
            case .throttling: return "The_system_temporarily_lacks_sufficient_resources_to_process_the_request"
            case .userRecoverable: return "A_user_recoverable_error_has_occurred"
            case .validation: return "The_inputs_to_this_request_are_invalid"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCategory(rawValue: rawValue) ?? ErrorCategory.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceDataClientTypes.ErrorInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspaceDataClientTypes.ErrorInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorInfo(errorCategory: \(Swift.String(describing: errorCategory)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension FinspaceDataClientTypes {
    /// Error message.
    public struct ErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        ///
        ///
        ///                   VALIDATION -The inputs to this request are invalid.
        ///
        ///
        ///
        ///                   SERVICE_QUOTA_EXCEEDED - Service quotas have been exceeded. Please
        ///           contact AWS support to increase quotas.
        ///
        ///
        ///
        ///                   ACCESS_DENIED - Missing required permission to perform this
        ///           request.
        ///
        ///
        ///
        ///                   RESOURCE_NOT_FOUND - One or more inputs to this request were not
        ///           found.
        ///
        ///
        ///
        ///                   THROTTLING - The system temporarily lacks sufficient resources to process
        ///           the request.
        ///
        ///
        ///
        ///                   INTERNAL_SERVICE_EXCEPTION - An internal service error has
        ///           occurred.
        ///
        ///
        ///
        ///                   CANCELLED - A user recoverable error has occurred.
        ///
        ///
        public var errorCategory: FinspaceDataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init (
            errorCategory: FinspaceDataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspaceDataClientTypes {
    public enum FormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case parquet
        case xml
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatType] {
            return [
                .csv,
                .json,
                .parquet,
                .xml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case .xml: return "XML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormatType(rawValue: rawValue) ?? FormatType.sdkUnknown(rawValue)
        }
    }
}

extension GetProgrammaticAccessCredentialsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProgrammaticAccessCredentialsInput(durationInMinutes: \(Swift.String(describing: durationInMinutes)), environmentId: \(Swift.String(describing: environmentId)))"}
}

extension GetProgrammaticAccessCredentialsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetProgrammaticAccessCredentialsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let environmentId = input.operationInput.environmentId {
            let environmentIdQueryItem = ClientRuntime.URLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            input.builder.withQueryItem(environmentIdQueryItem)
        }
        if input.operationInput.durationInMinutes != 0 {
            let durationInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "durationInMinutes".urlPercentEncoding(), value: Swift.String(input.operationInput.durationInMinutes).urlPercentEncoding())
            input.builder.withQueryItem(durationInMinutesQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProgrammaticAccessCredentialsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProgrammaticAccessCredentialsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetProgrammaticAccessCredentialsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/credentials/programmatic"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProgrammaticAccessCredentialsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProgrammaticAccessCredentialsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProgrammaticAccessCredentialsOutputError>
}

public struct GetProgrammaticAccessCredentialsInput: Swift.Equatable {
    /// The time duration in which the credentials remain valid.
    public var durationInMinutes: Swift.Int
    /// The habanero environment identifier.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        durationInMinutes: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.environmentId = environmentId
    }
}

struct GetProgrammaticAccessCredentialsInputBody: Swift.Equatable {
}

extension GetProgrammaticAccessCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProgrammaticAccessCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProgrammaticAccessCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProgrammaticAccessCredentialsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProgrammaticAccessCredentialsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProgrammaticAccessCredentialsOutputResponse(credentials: \(Swift.String(describing: credentials)), durationInMinutes: \(Swift.String(describing: durationInMinutes)))"}
}

extension GetProgrammaticAccessCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProgrammaticAccessCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.durationInMinutes = output.durationInMinutes
        } else {
            self.credentials = nil
            self.durationInMinutes = 0
        }
    }
}

public struct GetProgrammaticAccessCredentialsOutputResponse: Swift.Equatable {
    /// Returns the programmatic credentials.
    public var credentials: FinspaceDataClientTypes.Credentials?
    /// Returns the duration in which the credentials will remain valid.
    public var durationInMinutes: Swift.Int

    public init (
        credentials: FinspaceDataClientTypes.Credentials? = nil,
        durationInMinutes: Swift.Int = 0
    )
    {
        self.credentials = credentials
        self.durationInMinutes = durationInMinutes
    }
}

struct GetProgrammaticAccessCredentialsOutputResponseBody: Swift.Equatable {
    public let credentials: FinspaceDataClientTypes.Credentials?
    public let durationInMinutes: Swift.Int
}

extension GetProgrammaticAccessCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case durationInMinutes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let durationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
    }
}

public struct GetWorkingLocationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

extension GetWorkingLocationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkingLocationInput(locationType: \(Swift.String(describing: locationType)))"}
}

extension GetWorkingLocationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationType = locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

public struct GetWorkingLocationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetWorkingLocationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetWorkingLocationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetWorkingLocationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetWorkingLocationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/workingLocationV1"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetWorkingLocationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetWorkingLocationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetWorkingLocationOutputError>
}

public struct GetWorkingLocationInput: Swift.Equatable {
    /// Specify the type of the working location.
    ///
    ///
    ///
    ///                   SAGEMAKER - Use the Amazon S3 location as a temporary location to store data content when
    ///           working with FinSpace Notebooks that run on SageMaker studio.
    ///
    ///
    ///
    ///                   INGESTION - Use the Amazon S3 location as a staging location to copy your
    ///           data content and then use the location with the changeset creation operation.
    ///
    ///
    public var locationType: FinspaceDataClientTypes.LocationType?

    public init (
        locationType: FinspaceDataClientTypes.LocationType? = nil
    )
    {
        self.locationType = locationType
    }
}

struct GetWorkingLocationInputBody: Swift.Equatable {
    public let locationType: FinspaceDataClientTypes.LocationType?
}

extension GetWorkingLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(FinspaceDataClientTypes.LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
    }
}

extension GetWorkingLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkingLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkingLocationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkingLocationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkingLocationOutputResponse(s3Bucket: \(Swift.String(describing: s3Bucket)), s3Path: \(Swift.String(describing: s3Path)), s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension GetWorkingLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkingLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.s3Bucket = output.s3Bucket
            self.s3Path = output.s3Path
            self.s3Uri = output.s3Uri
        } else {
            self.s3Bucket = nil
            self.s3Path = nil
            self.s3Uri = nil
        }
    }
}

public struct GetWorkingLocationOutputResponse: Swift.Equatable {
    /// Returns the Amazon S3 bucket name for the working location.
    public var s3Bucket: Swift.String?
    /// Returns the Amazon S3 Path for the working location.
    public var s3Path: Swift.String?
    /// Returns the Amazon S3 URI for the working location.
    public var s3Uri: Swift.String?

    public init (
        s3Bucket: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Uri: Swift.String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Path = s3Path
        self.s3Uri = s3Uri
    }
}

struct GetWorkingLocationOutputResponseBody: Swift.Equatable {
    public let s3Uri: Swift.String?
    public let s3Path: Swift.String?
    public let s3Bucket: Swift.String?
}

extension GetWorkingLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Path
        case s3Uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or
///       failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceDataClientTypes {
    public enum LocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ingestion
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationType] {
            return [
                .ingestion,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ingestion: return "INGESTION"
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceDataClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException()"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
