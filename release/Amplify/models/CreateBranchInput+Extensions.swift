// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct CreateBranchInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

public struct CreateBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

public struct CreateBranchInputBodyMiddleware: Middleware {
    public let id: String = "CreateBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

extension CreateBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendEnvironmentArn
        case basicAuthCredentials
        case branchName
        case buildSpec
        case description
        case displayName
        case enableAutoBuild
        case enableBasicAuth
        case enableNotification
        case enablePerformanceMode
        case enablePullRequestPreview
        case environmentVariables
        case framework
        case pullRequestEnvironmentName
        case stage
        case tags
        case ttl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentArn = backendEnvironmentArn {
            try encodeContainer.encode(backendEnvironmentArn, forKey: .backendEnvironmentArn)
        }
        if let basicAuthCredentials = basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let buildSpec = buildSpec {
            try encodeContainer.encode(buildSpec, forKey: .buildSpec)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let enableAutoBuild = enableAutoBuild {
            try encodeContainer.encode(enableAutoBuild, forKey: .enableAutoBuild)
        }
        if let enableBasicAuth = enableBasicAuth {
            try encodeContainer.encode(enableBasicAuth, forKey: .enableBasicAuth)
        }
        if let enableNotification = enableNotification {
            try encodeContainer.encode(enableNotification, forKey: .enableNotification)
        }
        if let enablePerformanceMode = enablePerformanceMode {
            try encodeContainer.encode(enablePerformanceMode, forKey: .enablePerformanceMode)
        }
        if let enablePullRequestPreview = enablePullRequestPreview {
            try encodeContainer.encode(enablePullRequestPreview, forKey: .enablePullRequestPreview)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariables0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let framework = framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let pullRequestEnvironmentName = pullRequestEnvironmentName {
            try encodeContainer.encode(pullRequestEnvironmentName, forKey: .pullRequestEnvironmentName)
        }
        if let stage = stage {
            try encodeContainer.encode(stage.rawValue, forKey: .stage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ttl = ttl {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }
}
