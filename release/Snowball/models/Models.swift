// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SnowballClientTypes.Address: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case city = "City"
        case company = "Company"
        case country = "Country"
        case isRestricted = "IsRestricted"
        case landmark = "Landmark"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case postalCode = "PostalCode"
        case prefectureOrDistrict = "PrefectureOrDistrict"
        case stateOrProvince = "StateOrProvince"
        case street1 = "Street1"
        case street2 = "Street2"
        case street3 = "Street3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if isRestricted != false {
            try encodeContainer.encode(isRestricted, forKey: .isRestricted)
        }
        if let landmark = landmark {
            try encodeContainer.encode(landmark, forKey: .landmark)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let prefectureOrDistrict = prefectureOrDistrict {
            try encodeContainer.encode(prefectureOrDistrict, forKey: .prefectureOrDistrict)
        }
        if let stateOrProvince = stateOrProvince {
            try encodeContainer.encode(stateOrProvince, forKey: .stateOrProvince)
        }
        if let street1 = street1 {
            try encodeContainer.encode(street1, forKey: .street1)
        }
        if let street2 = street2 {
            try encodeContainer.encode(street2, forKey: .street2)
        }
        if let street3 = street3 {
            try encodeContainer.encode(street3, forKey: .street3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let street1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street1)
        street1 = street1Decoded
        let street2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street2)
        street2 = street2Decoded
        let street3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street3)
        street3 = street3Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateOrProvinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrProvince)
        stateOrProvince = stateOrProvinceDecoded
        let prefectureOrDistrictDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefectureOrDistrict)
        prefectureOrDistrict = prefectureOrDistrictDecoded
        let landmarkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landmark)
        landmark = landmarkDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let isRestrictedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isRestricted)
        isRestricted = isRestrictedDecoded
    }
}

extension SnowballClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(addressId: \(Swift.String(describing: addressId)), city: \(Swift.String(describing: city)), company: \(Swift.String(describing: company)), country: \(Swift.String(describing: country)), isRestricted: \(Swift.String(describing: isRestricted)), landmark: \(Swift.String(describing: landmark)), name: \(Swift.String(describing: name)), phoneNumber: \(Swift.String(describing: phoneNumber)), postalCode: \(Swift.String(describing: postalCode)), prefectureOrDistrict: \(Swift.String(describing: prefectureOrDistrict)), stateOrProvince: \(Swift.String(describing: stateOrProvince)), street1: \(Swift.String(describing: street1)), street2: \(Swift.String(describing: street2)), street3: \(Swift.String(describing: street3)))"}
}

extension SnowballClientTypes {
    /// <p>The address that you want the Snow device(s) associated with a specific job to
    ///       be shipped to. Addresses are validated at the time of creation. The address you provide must
    ///       be located within the serviceable area of your region. Although no individual elements of the
    ///         <code>Address</code> are required, if the address is invalid or unsupported, then an
    ///       exception is thrown.</p>
    public struct Address: Swift.Equatable {
        /// <p>The unique ID for an address.</p>
        public let addressId: Swift.String?
        /// <p>The city in an address that a Snow device is to be delivered to.</p>
        public let city: Swift.String?
        /// <p>The name of the company to receive a Snow device at an address.</p>
        public let company: Swift.String?
        /// <p>The country in an address that a Snow device is to be delivered to.</p>
        public let country: Swift.String?
        /// <p>If the address you are creating is a primary address, then set this option to
        ///       true. This field is not supported in most regions.</p>
        public let isRestricted: Swift.Bool
        /// <p>This field is no longer used and the value is ignored.</p>
        public let landmark: Swift.String?
        /// <p>The name of a person to receive a Snow device at an address.</p>
        public let name: Swift.String?
        /// <p>The phone number associated with an address that a Snow device is to be delivered
        ///       to.</p>
        public let phoneNumber: Swift.String?
        /// <p>The postal code in an address that a Snow device is to be delivered to.</p>
        public let postalCode: Swift.String?
        /// <p>This field is no longer used and the value is ignored.</p>
        public let prefectureOrDistrict: Swift.String?
        /// <p>The state or province in an address that a Snow device is to be delivered to.</p>
        public let stateOrProvince: Swift.String?
        /// <p>The first line in a street address that a Snow device is to be delivered
        ///       to.</p>
        public let street1: Swift.String?
        /// <p>The second line in a street address that a Snow device is to be delivered
        ///       to.</p>
        public let street2: Swift.String?
        /// <p>The third line in a street address that a Snow device is to be delivered
        ///       to.</p>
        public let street3: Swift.String?

        public init (
            addressId: Swift.String? = nil,
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            isRestricted: Swift.Bool = false,
            landmark: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            prefectureOrDistrict: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil
        )
        {
            self.addressId = addressId
            self.city = city
            self.company = company
            self.country = country
            self.isRestricted = isRestricted
            self.landmark = landmark
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.prefectureOrDistrict = prefectureOrDistrict
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
        }
    }

}

public struct CancelClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelClusterOutputError>
}

extension CancelClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelClusterInput(clusterId: \(Swift.String(describing: clusterId)))"}
}

extension CancelClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

public struct CancelClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelClusterOutputError>
}

public struct CancelClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelClusterOutputError>
}

public struct CancelClusterInput: Swift.Equatable {
    /// <p>The 39-character ID for the cluster that you want to cancel, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: Swift.String?

    public init (
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CancelClusterInputBody: Swift.Equatable {
    public let clusterId: Swift.String?
}

extension CancelClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension CancelClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelClusterOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelClusterOutputResponse()"}
}

extension CancelClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelClusterOutputResponseBody: Swift.Equatable {
}

extension CancelClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CancelJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

extension CancelJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension CancelJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct CancelJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInput: Swift.Equatable {
    /// <p>The 39-character job ID for the job that you want to cancel, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension CancelJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobOutputResponse()"}
}

extension CancelJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelJobOutputResponseBody: Swift.Equatable {
}

extension CancelJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ClusterLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ClusterLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Job creation failed. Currently, clusters support five nodes. If you have less than five
///       nodes for your cluster and you have more nodes to create for this cluster, try again and
///       create jobs until your cluster has exactly five notes.</p>
public struct ClusterLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClusterLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.ClusterListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SnowballClientTypes.ClusterListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterListEntry(clusterId: \(Swift.String(describing: clusterId)), clusterState: \(Swift.String(describing: clusterState)), creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)))"}
}

extension SnowballClientTypes {
    /// <p>Contains a cluster's state, a cluster's ID, and other important information.</p>
    public struct ClusterListEntry: Swift.Equatable {
        /// <p>The 39-character ID for the cluster that you want to list, for example
        ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        public let clusterId: Swift.String?
        /// <p>The current state of this cluster. For information about the state of a specific node,
        ///       see <a>JobListEntry$JobState</a>.</p>
        public let clusterState: SnowballClientTypes.ClusterState?
        /// <p>The creation date for this cluster.</p>
        public let creationDate: ClientRuntime.Date?
        /// <p>Defines an optional description of the cluster, for example <code>Environmental Data
        ///         Cluster-01</code>.</p>
        public let description: Swift.String?

        public init (
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil
        )
        {
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
        }
    }

}

extension SnowballClientTypes.ClusterMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
    }
}

extension SnowballClientTypes.ClusterMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClusterMetadata(addressId: \(Swift.String(describing: addressId)), clusterId: \(Swift.String(describing: clusterId)), clusterState: \(Swift.String(describing: clusterState)), creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)), forwardingAddressId: \(Swift.String(describing: forwardingAddressId)), jobType: \(Swift.String(describing: jobType)), kmsKeyARN: \(Swift.String(describing: kmsKeyARN)), notification: \(Swift.String(describing: notification)), resources: \(Swift.String(describing: resources)), roleARN: \(Swift.String(describing: roleARN)), shippingOption: \(Swift.String(describing: shippingOption)), snowballType: \(Swift.String(describing: snowballType)), taxDocuments: \(Swift.String(describing: taxDocuments)))"}
}

extension SnowballClientTypes {
    /// <p>Contains metadata about a specific cluster.</p>
    public struct ClusterMetadata: Swift.Equatable {
        /// <p>The automatically generated ID for a specific address.</p>
        public let addressId: Swift.String?
        /// <p>The automatically generated ID for a cluster.</p>
        public let clusterId: Swift.String?
        /// <p>The current status of the cluster.</p>
        public let clusterState: SnowballClientTypes.ClusterState?
        /// <p>The creation date for this cluster.</p>
        public let creationDate: ClientRuntime.Date?
        /// <p>The optional description of the cluster.</p>
        public let description: Swift.String?
        /// <p>The ID of the address that you want a cluster shipped to, after it will be
        ///       shipped to its primary address. This field is not supported in most regions.</p>
        public let forwardingAddressId: Swift.String?
        /// <p>The type of job for this cluster. Currently, the only job type supported for clusters
        ///       is <code>LOCAL_USE</code>.</p>
        public let jobType: SnowballClientTypes.JobType?
        /// <p>The <code>KmsKeyARN</code> Amazon Resource Name (ARN) associated with this cluster.
        ///       This ARN was created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS Key
        ///       Management Service (AWS KMS).</p>
        public let kmsKeyARN: Swift.String?
        /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings for this
        ///       cluster.</p>
        public let notification: SnowballClientTypes.Notification?
        /// <p>The arrays of <a>JobResource</a> objects that can include updated <a>S3Resource</a> objects or <a>LambdaResource</a> objects.</p>
        public let resources: SnowballClientTypes.JobResource?
        /// <p>The role ARN associated with this cluster. This ARN was created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>
        ///       API action in AWS Identity and Access Management (IAM).</p>
        public let roleARN: Swift.String?
        /// <p>The shipping speed for each node in this cluster. This speed doesn't dictate how soon
        ///       you'll get each device, rather it represents how quickly each device moves to
        ///       its destination while in transit. Regional shipping speeds are as follows:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>In Australia, you have access to express shipping. Typically, devices shipped
        ///           express are delivered in about a day.</p>
        ///             </li>
        ///             <li>
        ///                <p>In the European Union (EU), you have access to express shipping. Typically,
        ///           Snow devices shipped express are delivered in about a day. In addition, most countries
        ///           in the EU have access to standard shipping, which typically takes less than a week, one
        ///           way.</p>
        ///             </li>
        ///             <li>
        ///                <p>In India, Snow devices are delivered in one to seven days.</p>
        ///             </li>
        ///             <li>
        ///                <p>In the US, you have access to one-day shipping and two-day shipping.</p>
        ///             </li>
        ///          </ul>
        public let shippingOption: SnowballClientTypes.ShippingOption?
        /// <p>The type of AWS Snow device to use for this cluster.
        ///       </p>
        ///          <note>
        ///             <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
        ///          </note>
        public let snowballType: SnowballClientTypes.SnowballType?
        /// <p>The tax documents required in your AWS Region.</p>
        public let taxDocuments: SnowballClientTypes.TaxDocuments?

        public init (
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forwardingAddressId: Swift.String? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.notification = notification
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }

}

extension SnowballClientTypes {
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingQuorum
        case cancelled
        case complete
        case inUse
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .awaitingQuorum,
                .cancelled,
                .complete,
                .inUse,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingQuorum: return "AwaitingQuorum"
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inUse: return "InUse"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.CompatibleImage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId = "AmiId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SnowballClientTypes.CompatibleImage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompatibleImage(amiId: \(Swift.String(describing: amiId)), name: \(Swift.String(describing: name)))"}
}

extension SnowballClientTypes {
    /// <p>A JSON-formatted object that describes a compatible Amazon Machine Image (AMI),
    ///       including the ID and name for a Snow device AMI. This AMI is compatible with the device's
    ///       physical hardware requirements, and it should be able to be run in an SBE1 instance on the
    ///       device.</p>
    public struct CompatibleImage: Swift.Equatable {
        /// <p>The unique identifier for an individual Snow device AMI.</p>
        public let amiId: Swift.String?
        /// <p>The optional name of a compatible image.</p>
        public let name: Swift.String?

        public init (
            amiId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.name = name
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(conflictResource: \(Swift.String(describing: conflictResource)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictResource = output.conflictResource
            self.message = output.message
        } else {
            self.conflictResource = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You get this exception when you call <code>CreateReturnShippingLabel</code> more than once when other requests are not completed.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var conflictResource: Swift.String?
    public var message: Swift.String?

    public init (
        conflictResource: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.conflictResource = conflictResource
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let conflictResource: Swift.String?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResource = "ConflictResource"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conflictResource)
        conflictResource = conflictResourceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAddressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAddressOutputError>
}

extension CreateAddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAddressInput(address: \(Swift.String(describing: address)))"}
}

extension CreateAddressInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
    }
}

public struct CreateAddressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAddressOutputError>
}

public struct CreateAddressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAddressOutputError>
}

public struct CreateAddressInput: Swift.Equatable {
    /// <p>The address that you want the Snow device shipped to.</p>
    public let address: SnowballClientTypes.Address?

    public init (
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

struct CreateAddressInputBody: Swift.Equatable {
    public let address: SnowballClientTypes.Address?
}

extension CreateAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension CreateAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAddressException" : self = .invalidAddressException(try InvalidAddressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAddressException" : self = .unsupportedAddressException(try UnsupportedAddressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAddressOutputError: Swift.Error, Swift.Equatable {
    case invalidAddressException(InvalidAddressException)
    case unsupportedAddressException(UnsupportedAddressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAddressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAddressOutputResponse(addressId: \(Swift.String(describing: addressId)))"}
}

extension CreateAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressId = output.addressId
        } else {
            self.addressId = nil
        }
    }
}

public struct CreateAddressOutputResponse: Swift.Equatable {
    /// <p>The automatically generated ID for a specific address. You'll use this ID when you
    ///       create a job to specify which address you want the Snow device for that job shipped to.</p>
    public let addressId: Swift.String?

    public init (
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct CreateAddressOutputResponseBody: Swift.Equatable {
    public let addressId: Swift.String?
}

extension CreateAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterInput(addressId: \(Swift.String(describing: addressId)), description: \(Swift.String(describing: description)), forwardingAddressId: \(Swift.String(describing: forwardingAddressId)), jobType: \(Swift.String(describing: jobType)), kmsKeyARN: \(Swift.String(describing: kmsKeyARN)), notification: \(Swift.String(describing: notification)), resources: \(Swift.String(describing: resources)), roleARN: \(Swift.String(describing: roleARN)), shippingOption: \(Swift.String(describing: shippingOption)), snowballType: \(Swift.String(describing: snowballType)), taxDocuments: \(Swift.String(describing: taxDocuments)))"}
}

extension CreateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Swift.Equatable {
    /// <p>The ID for the address that you want the cluster shipped to.</p>
    public let addressId: Swift.String?
    /// <p>An optional description of this specific cluster, for example <code>Environmental Data
    ///         Cluster-01</code>.</p>
    public let description: Swift.String?
    /// <p>The forwarding address ID for a cluster. This field is not supported in most
    ///       regions.</p>
    public let forwardingAddressId: Swift.String?
    /// <p>The type of job for this cluster. Currently, the only job type supported for clusters
    ///       is <code>LOCAL_USE</code>.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let jobType: SnowballClientTypes.JobType?
    /// <p>The <code>KmsKeyARN</code> value that you want to associate with this cluster.
    ///         <code>KmsKeyARN</code> values are created by using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS Key
    ///       Management Service (AWS KMS). </p>
    public let kmsKeyARN: Swift.String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings for this
    ///       cluster.</p>
    public let notification: SnowballClientTypes.Notification?
    /// <p>The resources associated with the cluster job. These resources include Amazon S3
    ///       buckets and optional AWS Lambda functions written in the Python language. </p>
    public let resources: SnowballClientTypes.JobResource?
    /// <p>The <code>RoleARN</code> that you want to associate with this cluster.
    ///         <code>RoleArn</code> values are created by using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
    ///       Identity and Access Management (IAM).</p>
    public let roleARN: Swift.String?
    /// <p>The shipping speed for each node in this cluster. This speed doesn't dictate how soon
    ///       you'll get each Snowball Edge device, rather it represents how quickly each device moves to
    ///       its destination while in transit. Regional shipping speeds are as follows:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries in the
    ///           EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow device are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the United States of America (US), you have access to one-day shipping and
    ///           two-day shipping.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries
    ///           in the EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow device are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the US, you have access to one-day shipping and two-day shipping.</p>
    ///             </li>
    ///          </ul>
    public let shippingOption: SnowballClientTypes.ShippingOption?
    /// <p>The type of AWS Snow Family device to use for this cluster.
    ///     </p>
    ///          <note>
    ///             <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
    ///          </note>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballType: SnowballClientTypes.SnowballType?
    /// <p>The tax documents required in your AWS Region.</p>
    public let taxDocuments: SnowballClientTypes.TaxDocuments?

    public init (
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    public let jobType: SnowballClientTypes.JobType?
    public let resources: SnowballClientTypes.JobResource?
    public let description: Swift.String?
    public let addressId: Swift.String?
    public let kmsKeyARN: Swift.String?
    public let roleARN: Swift.String?
    public let snowballType: SnowballClientTypes.SnowballType?
    public let shippingOption: SnowballClientTypes.ShippingOption?
    public let notification: SnowballClientTypes.Notification?
    public let forwardingAddressId: Swift.String?
    public let taxDocuments: SnowballClientTypes.TaxDocuments?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateClusterOutputResponse(clusterId: \(Swift.String(describing: clusterId)))"}
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterId = output.clusterId
        } else {
            self.clusterId = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// <p>The automatically generated ID for a cluster.</p>
    public let clusterId: Swift.String?

    public init (
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    public let clusterId: Swift.String?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

public struct CreateJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

extension CreateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobInput(addressId: \(Swift.String(describing: addressId)), clusterId: \(Swift.String(describing: clusterId)), description: \(Swift.String(describing: description)), deviceConfiguration: \(Swift.String(describing: deviceConfiguration)), forwardingAddressId: \(Swift.String(describing: forwardingAddressId)), jobType: \(Swift.String(describing: jobType)), kmsKeyARN: \(Swift.String(describing: kmsKeyARN)), longTermPricingId: \(Swift.String(describing: longTermPricingId)), notification: \(Swift.String(describing: notification)), resources: \(Swift.String(describing: resources)), roleARN: \(Swift.String(describing: roleARN)), shippingOption: \(Swift.String(describing: shippingOption)), snowballCapacityPreference: \(Swift.String(describing: snowballCapacityPreference)), snowballType: \(Swift.String(describing: snowballType)), taxDocuments: \(Swift.String(describing: taxDocuments)))"}
}

extension CreateJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

public struct CreateJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

public struct CreateJobInput: Swift.Equatable {
    /// <p>The ID for the address that you want the Snow device shipped to.</p>
    public let addressId: Swift.String?
    /// <p>The ID of a cluster. If you're creating a job for a node in a cluster, you need to
    ///       provide only this <code>clusterId</code> value. The other job attributes are inherited from
    ///       the cluster.</p>
    public let clusterId: Swift.String?
    /// <p>Defines an optional description of this specific job, for example <code>Important
    ///         Photos 2016-08-11</code>.</p>
    public let description: Swift.String?
    /// <p>Defines the device configuration for an AWS Snowcone job.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    /// <p>The forwarding address ID for a job. This field is not supported in most
    ///       regions.</p>
    public let forwardingAddressId: Swift.String?
    /// <p>Defines the type of job that you're creating.
    ///       </p>
    public let jobType: SnowballClientTypes.JobType?
    /// <p>The <code>KmsKeyARN</code> that you want to associate with this job.
    ///         <code>KmsKeyARN</code>s are created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> AWS Key Management
    ///       Service (KMS) API action.</p>
    public let kmsKeyARN: Swift.String?
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: Swift.String?
    /// <p>Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for
    ///       this job.</p>
    public let notification: SnowballClientTypes.Notification?
    /// <p>Defines the Amazon S3 buckets associated with this job.</p>
    ///
    ///          <p>With <code>IMPORT</code> jobs, you specify the bucket or buckets that your transferred
    ///       data will be imported into.</p>
    ///
    ///          <p>With <code>EXPORT</code> jobs, you specify the bucket or buckets that your transferred
    ///       data will be exported from. Optionally, you can also specify a <code>KeyRange</code> value. If
    ///       you choose to export a range, you define the length of the range by providing either an
    ///       inclusive <code>BeginMarker</code> value, an inclusive <code>EndMarker</code> value, or both.
    ///       Ranges are UTF-8 binary sorted.</p>
    public let resources: SnowballClientTypes.JobResource?
    /// <p>The <code>RoleARN</code> that you want to associate with this job.
    ///       <code>RoleArn</code>s are created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> AWS Identity and
    ///       Access Management (IAM) API action.</p>
    public let roleARN: Swift.String?
    /// <p>The shipping speed for this job. This speed doesn't dictate how soon you'll get the
    ///       Snow device, rather it represents how quickly the Snow device moves to its destination while in
    ///       transit. Regional shipping speeds are as follows:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries in the
    ///           EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow devices are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the US, you have access to one-day shipping and two-day shipping.</p>
    ///             </li>
    ///          </ul>
    public let shippingOption: SnowballClientTypes.ShippingOption?
    /// <p>If your job is being created in one of the US regions, you have the option of
    ///       specifying what size Snow device you'd like for this job. In all other regions, Snowballs come
    ///       with 80 TB in storage capacity.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    /// <p>The type of AWS Snow Family device to use for this job.
    ///       </p>
    ///          <note>
    ///             <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
    ///          </note>
    ///          <p>The type of AWS Snow device to use for this job. Currently, the only supported
    ///       device type for cluster jobs is <code>EDGE</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html">Snowball Edge Device
    ///       Options</a> in the Snowball Edge Developer Guide.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballType: SnowballClientTypes.SnowballType?
    /// <p>The tax documents required in your AWS Region.</p>
    public let taxDocuments: SnowballClientTypes.TaxDocuments?

    public init (
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        longTermPricingId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.deviceConfiguration = deviceConfiguration
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingId = longTermPricingId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateJobInputBody: Swift.Equatable {
    public let jobType: SnowballClientTypes.JobType?
    public let resources: SnowballClientTypes.JobResource?
    public let description: Swift.String?
    public let addressId: Swift.String?
    public let kmsKeyARN: Swift.String?
    public let roleARN: Swift.String?
    public let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    public let shippingOption: SnowballClientTypes.ShippingOption?
    public let notification: SnowballClientTypes.Notification?
    public let clusterId: Swift.String?
    public let snowballType: SnowballClientTypes.SnowballType?
    public let forwardingAddressId: Swift.String?
    public let taxDocuments: SnowballClientTypes.TaxDocuments?
    public let deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    public let longTermPricingId: Swift.String?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

extension CreateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterLimitExceededException" : self = .clusterLimitExceededException(try ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Swift.Error, Swift.Equatable {
    case clusterLimitExceededException(ClusterLimitExceededException)
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension CreateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutputResponse: Swift.Equatable {
    /// <p>The automatically generated ID for a job, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension CreateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct CreateLongTermPricingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLongTermPricingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLongTermPricingOutputError>
}

extension CreateLongTermPricingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLongTermPricingInput(isLongTermPricingAutoRenew: \(Swift.String(describing: isLongTermPricingAutoRenew)), longTermPricingType: \(Swift.String(describing: longTermPricingType)), snowballType: \(Swift.String(describing: snowballType)))"}
}

extension CreateLongTermPricingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingType = longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }
}

public struct CreateLongTermPricingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLongTermPricingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLongTermPricingOutputError>
}

public struct CreateLongTermPricingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLongTermPricingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLongTermPricingOutputError>
}

public struct CreateLongTermPricingInput: Swift.Equatable {
    /// <p>Specifies whether the current long term pricing type for the device should be renewed.</p>
    public let isLongTermPricingAutoRenew: Swift.Bool?
    /// <p>The type of long term pricing option you want for the device - one year or three year long term pricing.</p>
    public let longTermPricingType: SnowballClientTypes.LongTermPricingType?
    /// <p>The type of AWS Snow Family device to use for the long term pricing job.</p>
    public let snowballType: SnowballClientTypes.SnowballType?

    public init (
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingType = longTermPricingType
        self.snowballType = snowballType
    }
}

struct CreateLongTermPricingInputBody: Swift.Equatable {
    public let longTermPricingType: SnowballClientTypes.LongTermPricingType?
    public let isLongTermPricingAutoRenew: Swift.Bool?
    public let snowballType: SnowballClientTypes.SnowballType?
}

extension CreateLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
    }
}

extension CreateLongTermPricingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLongTermPricingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLongTermPricingOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLongTermPricingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLongTermPricingOutputResponse(longTermPricingId: \(Swift.String(describing: longTermPricingId)))"}
}

extension CreateLongTermPricingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLongTermPricingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingId = output.longTermPricingId
        } else {
            self.longTermPricingId = nil
        }
    }
}

public struct CreateLongTermPricingOutputResponse: Swift.Equatable {
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: Swift.String?

    public init (
        longTermPricingId: Swift.String? = nil
    )
    {
        self.longTermPricingId = longTermPricingId
    }
}

struct CreateLongTermPricingOutputResponseBody: Swift.Equatable {
    public let longTermPricingId: Swift.String?
}

extension CreateLongTermPricingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case longTermPricingId = "LongTermPricingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

public struct CreateReturnShippingLabelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReturnShippingLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReturnShippingLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReturnShippingLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReturnShippingLabelOutputError>
}

extension CreateReturnShippingLabelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReturnShippingLabelInput(jobId: \(Swift.String(describing: jobId)), shippingOption: \(Swift.String(describing: shippingOption)))"}
}

extension CreateReturnShippingLabelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

public struct CreateReturnShippingLabelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReturnShippingLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReturnShippingLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReturnShippingLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReturnShippingLabelOutputError>
}

public struct CreateReturnShippingLabelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReturnShippingLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReturnShippingLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReturnShippingLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReturnShippingLabelOutputError>
}

public struct CreateReturnShippingLabelInput: Swift.Equatable {
    /// <p>The ID for a job that you want to create the return shipping label for. For example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?
    /// <p>The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to AWS.
    ///       This speed represents how quickly it moves to its
    ///       destination while in transit. Regional shipping speeds are as follows:</p>
    public let shippingOption: SnowballClientTypes.ShippingOption?

    public init (
        jobId: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.jobId = jobId
        self.shippingOption = shippingOption
    }
}

struct CreateReturnShippingLabelInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let shippingOption: SnowballClientTypes.ShippingOption?
}

extension CreateReturnShippingLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
    }
}

extension CreateReturnShippingLabelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReturnShippingLabelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReturnShippingLabelAlreadyExistsException" : self = .returnShippingLabelAlreadyExistsException(try ReturnShippingLabelAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReturnShippingLabelOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case returnShippingLabelAlreadyExistsException(ReturnShippingLabelAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReturnShippingLabelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReturnShippingLabelOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension CreateReturnShippingLabelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReturnShippingLabelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CreateReturnShippingLabelOutputResponse: Swift.Equatable {
    /// <p>The status information of the task on a Snow device that is being returned to AWS.</p>
    public let status: SnowballClientTypes.ShippingLabelStatus?

    public init (
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateReturnShippingLabelOutputResponseBody: Swift.Equatable {
    public let status: SnowballClientTypes.ShippingLabelStatus?
}

extension CreateReturnShippingLabelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SnowballClientTypes.DataTransfer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesTransferred = "BytesTransferred"
        case objectsTransferred = "ObjectsTransferred"
        case totalBytes = "TotalBytes"
        case totalObjects = "TotalObjects"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytesTransferred != 0 {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if objectsTransferred != 0 {
            try encodeContainer.encode(objectsTransferred, forKey: .objectsTransferred)
        }
        if totalBytes != 0 {
            try encodeContainer.encode(totalBytes, forKey: .totalBytes)
        }
        if totalObjects != 0 {
            try encodeContainer.encode(totalObjects, forKey: .totalObjects)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesTransferredDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let objectsTransferredDecoded = try containerValues.decode(Swift.Int.self, forKey: .objectsTransferred)
        objectsTransferred = objectsTransferredDecoded
        let totalBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalBytes)
        totalBytes = totalBytesDecoded
        let totalObjectsDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalObjects)
        totalObjects = totalObjectsDecoded
    }
}

extension SnowballClientTypes.DataTransfer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataTransfer(bytesTransferred: \(Swift.String(describing: bytesTransferred)), objectsTransferred: \(Swift.String(describing: objectsTransferred)), totalBytes: \(Swift.String(describing: totalBytes)), totalObjects: \(Swift.String(describing: totalObjects)))"}
}

extension SnowballClientTypes {
    /// <p>Defines the real-time status of a Snow device's data transfer while the device is at AWS.
    ///       This data is only available while a job has a <code>JobState</code> value of
    ///         <code>InProgress</code>, for both import and export jobs.</p>
    public struct DataTransfer: Swift.Equatable {
        /// <p>The number of bytes transferred between a Snow device and Amazon S3.</p>
        public let bytesTransferred: Swift.Int
        /// <p>The number of objects transferred between a Snow device and Amazon S3.</p>
        public let objectsTransferred: Swift.Int
        /// <p>The total bytes of data for a transfer between a Snow device and Amazon S3. This value is
        ///       set to 0 (zero) until all the keys that will be transferred have been listed.</p>
        public let totalBytes: Swift.Int
        /// <p>The total number of objects for a transfer between a Snow device and Amazon S3. This value
        ///       is set to 0 (zero) until all the keys that will be transferred have been listed.</p>
        public let totalObjects: Swift.Int

        public init (
            bytesTransferred: Swift.Int = 0,
            objectsTransferred: Swift.Int = 0,
            totalBytes: Swift.Int = 0,
            totalObjects: Swift.Int = 0
        )
        {
            self.bytesTransferred = bytesTransferred
            self.objectsTransferred = objectsTransferred
            self.totalBytes = totalBytes
            self.totalObjects = totalObjects
        }
    }

}

public struct DescribeAddressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAddressOutputError>
}

extension DescribeAddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAddressInput(addressId: \(Swift.String(describing: addressId)))"}
}

extension DescribeAddressInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
    }
}

public struct DescribeAddressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAddressOutputError>
}

public struct DescribeAddressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAddressOutputError>
}

public struct DescribeAddressInput: Swift.Equatable {
    /// <p>The automatically generated ID for a specific address.</p>
    public let addressId: Swift.String?

    public init (
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct DescribeAddressInputBody: Swift.Equatable {
    public let addressId: Swift.String?
}

extension DescribeAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

extension DescribeAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAddressOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAddressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAddressOutputResponse(address: \(Swift.String(describing: address)))"}
}

extension DescribeAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
        } else {
            self.address = nil
        }
    }
}

public struct DescribeAddressOutputResponse: Swift.Equatable {
    /// <p>The address that you want the Snow device(s) associated with a specific job to
    ///       be shipped to.</p>
    public let address: SnowballClientTypes.Address?

    public init (
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

struct DescribeAddressOutputResponseBody: Swift.Equatable {
    public let address: SnowballClientTypes.Address?
}

extension DescribeAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

public struct DescribeAddressesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAddressesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAddressesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAddressesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAddressesOutputError>
}

extension DescribeAddressesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAddressesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAddressesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAddressesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAddressesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAddressesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAddressesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAddressesOutputError>
}

public struct DescribeAddressesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAddressesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAddressesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAddressesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAddressesOutputError>
}

public struct DescribeAddressesInput: Swift.Equatable {
    /// <p>The number of <code>ADDRESS</code> objects to return.</p>
    public let maxResults: Swift.Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>ADDRESS</code> objects, you have the option of specifying a value for
    ///         <code>NextToken</code> as the starting point for your list of returned addresses.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAddressesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeAddressesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAddressesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAddressesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAddressesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAddressesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAddressesOutputResponse(addresses: \(Swift.String(describing: addresses)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeAddressesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAddressesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.nextToken = output.nextToken
        } else {
            self.addresses = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAddressesOutputResponse: Swift.Equatable {
    /// <p>The Snow device shipping addresses that were created for this account.</p>
    public let addresses: [SnowballClientTypes.Address]?
    /// <p>HTTP requests are stateless. If you use the automatically generated
    ///         <code>NextToken</code> value in your next <code>DescribeAddresses</code> call, your list of
    ///       returned addresses will start from this point in the array.</p>
    public let nextToken: Swift.String?

    public init (
        addresses: [SnowballClientTypes.Address]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

struct DescribeAddressesOutputResponseBody: Swift.Equatable {
    public let addresses: [SnowballClientTypes.Address]?
    public let nextToken: Swift.String?
}

extension DescribeAddressesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[SnowballClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [SnowballClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

extension DescribeClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterInput(clusterId: \(Swift.String(describing: clusterId)))"}
}

extension DescribeClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

public struct DescribeClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInput: Swift.Equatable {
    /// <p>The automatically generated ID for a cluster.</p>
    public let clusterId: Swift.String?

    public init (
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct DescribeClusterInputBody: Swift.Equatable {
    public let clusterId: Swift.String?
}

extension DescribeClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension DescribeClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeClusterOutputResponse(clusterMetadata: \(Swift.String(describing: clusterMetadata)))"}
}

extension DescribeClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterMetadata = output.clusterMetadata
        } else {
            self.clusterMetadata = nil
        }
    }
}

public struct DescribeClusterOutputResponse: Swift.Equatable {
    /// <p>Information about a specific cluster, including shipping information, cluster status,
    ///       and other important metadata.</p>
    public let clusterMetadata: SnowballClientTypes.ClusterMetadata?

    public init (
        clusterMetadata: SnowballClientTypes.ClusterMetadata? = nil
    )
    {
        self.clusterMetadata = clusterMetadata
    }
}

struct DescribeClusterOutputResponseBody: Swift.Equatable {
    public let clusterMetadata: SnowballClientTypes.ClusterMetadata?
}

extension DescribeClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterMetadata = "ClusterMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterMetadataDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterMetadata.self, forKey: .clusterMetadata)
        clusterMetadata = clusterMetadataDecoded
    }
}

public struct DescribeJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobOutputError>
}

extension DescribeJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeJobInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeJobOutputError>
}

public struct DescribeJobInput: Swift.Equatable {
    /// <p>The automatically generated ID for a job, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeJobOutputResponse(jobMetadata: \(Swift.String(describing: jobMetadata)), subJobMetadata: \(Swift.String(describing: subJobMetadata)))"}
}

extension DescribeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobMetadata = output.jobMetadata
            self.subJobMetadata = output.subJobMetadata
        } else {
            self.jobMetadata = nil
            self.subJobMetadata = nil
        }
    }
}

public struct DescribeJobOutputResponse: Swift.Equatable {
    /// <p>Information about a specific job, including shipping information, job status, and other
    ///       important metadata.</p>
    public let jobMetadata: SnowballClientTypes.JobMetadata?
    /// <p>Information about a specific job part (in the case of an export job), including
    ///       shipping information, job status, and other important metadata.</p>
    public let subJobMetadata: [SnowballClientTypes.JobMetadata]?

    public init (
        jobMetadata: SnowballClientTypes.JobMetadata? = nil,
        subJobMetadata: [SnowballClientTypes.JobMetadata]? = nil
    )
    {
        self.jobMetadata = jobMetadata
        self.subJobMetadata = subJobMetadata
    }
}

struct DescribeJobOutputResponseBody: Swift.Equatable {
    public let jobMetadata: SnowballClientTypes.JobMetadata?
    public let subJobMetadata: [SnowballClientTypes.JobMetadata]?
}

extension DescribeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobMetadata = "JobMetadata"
        case subJobMetadata = "SubJobMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobMetadataDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobMetadata.self, forKey: .jobMetadata)
        jobMetadata = jobMetadataDecoded
        let subJobMetadataContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobMetadata?].self, forKey: .subJobMetadata)
        var subJobMetadataDecoded0:[SnowballClientTypes.JobMetadata]? = nil
        if let subJobMetadataContainer = subJobMetadataContainer {
            subJobMetadataDecoded0 = [SnowballClientTypes.JobMetadata]()
            for structure0 in subJobMetadataContainer {
                if let structure0 = structure0 {
                    subJobMetadataDecoded0?.append(structure0)
                }
            }
        }
        subJobMetadata = subJobMetadataDecoded0
    }
}

public struct DescribeReturnShippingLabelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReturnShippingLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReturnShippingLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReturnShippingLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReturnShippingLabelOutputError>
}

extension DescribeReturnShippingLabelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReturnShippingLabelInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeReturnShippingLabelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeReturnShippingLabelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReturnShippingLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReturnShippingLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReturnShippingLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReturnShippingLabelOutputError>
}

public struct DescribeReturnShippingLabelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReturnShippingLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReturnShippingLabelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReturnShippingLabelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReturnShippingLabelOutputError>
}

public struct DescribeReturnShippingLabelInput: Swift.Equatable {
    /// <p>The automatically generated ID for a job, for example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeReturnShippingLabelInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension DescribeReturnShippingLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeReturnShippingLabelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReturnShippingLabelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReturnShippingLabelOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReturnShippingLabelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReturnShippingLabelOutputResponse(expirationDate: \(Swift.String(describing: expirationDate)), status: \(Swift.String(describing: status)))"}
}

extension DescribeReturnShippingLabelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReturnShippingLabelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expirationDate = output.expirationDate
            self.status = output.status
        } else {
            self.expirationDate = nil
            self.status = nil
        }
    }
}

public struct DescribeReturnShippingLabelOutputResponse: Swift.Equatable {
    /// <p>The expiration date of the current return shipping label.</p>
    public let expirationDate: ClientRuntime.Date?
    /// <p>The status information of the task on a Snow device that is being returned to AWS.</p>
    public let status: SnowballClientTypes.ShippingLabelStatus?

    public init (
        expirationDate: ClientRuntime.Date? = nil,
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.expirationDate = expirationDate
        self.status = status
    }
}

struct DescribeReturnShippingLabelOutputResponseBody: Swift.Equatable {
    public let status: SnowballClientTypes.ShippingLabelStatus?
    public let expirationDate: ClientRuntime.Date?
}

extension DescribeReturnShippingLabelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationDate = "ExpirationDate"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
    }
}

extension SnowballClientTypes.DeviceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snowconeDeviceConfiguration = "SnowconeDeviceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snowconeDeviceConfiguration = snowconeDeviceConfiguration {
            try encodeContainer.encode(snowconeDeviceConfiguration, forKey: .snowconeDeviceConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowconeDeviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowconeDeviceConfiguration.self, forKey: .snowconeDeviceConfiguration)
        snowconeDeviceConfiguration = snowconeDeviceConfigurationDecoded
    }
}

extension SnowballClientTypes.DeviceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceConfiguration(snowconeDeviceConfiguration: \(Swift.String(describing: snowconeDeviceConfiguration)))"}
}

extension SnowballClientTypes {
    /// <p>The container for <code>SnowconeDeviceConfiguration</code>. </p>
    public struct DeviceConfiguration: Swift.Equatable {
        /// <p>Returns information about the device configuration for an AWS Snowcone job.</p>
        public let snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration?

        public init (
            snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration? = nil
        )
        {
            self.snowconeDeviceConfiguration = snowconeDeviceConfiguration
        }
    }

}

extension SnowballClientTypes.Ec2AmiResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId = "AmiId"
        case snowballAmiId = "SnowballAmiId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let snowballAmiId = snowballAmiId {
            try encodeContainer.encode(snowballAmiId, forKey: .snowballAmiId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let snowballAmiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snowballAmiId)
        snowballAmiId = snowballAmiIdDecoded
    }
}

extension SnowballClientTypes.Ec2AmiResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ec2AmiResource(amiId: \(Swift.String(describing: amiId)), snowballAmiId: \(Swift.String(describing: snowballAmiId)))"}
}

extension SnowballClientTypes {
    /// <p>A JSON-formatted object that contains the IDs for an Amazon Machine Image (AMI),
    ///       including the Amazon EC2 AMI ID and the Snow device AMI ID. Each AMI has these two IDs to
    ///       simplify identifying the AMI in both the AWS Cloud and on the device.</p>
    public struct Ec2AmiResource: Swift.Equatable {
        /// <p>The ID of the AMI in Amazon EC2.</p>
        public let amiId: Swift.String?
        /// <p>The ID of the AMI on the Snow device.</p>
        public let snowballAmiId: Swift.String?

        public init (
            amiId: Swift.String? = nil,
            snowballAmiId: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.snowballAmiId = snowballAmiId
        }
    }

}

extension Ec2RequestFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ec2RequestFailedException(message: \(Swift.String(describing: message)))"}
}

extension Ec2RequestFailedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: Ec2RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your IAM user lacks the necessary Amazon EC2 permissions to perform the attempted
///       action.</p>
public struct Ec2RequestFailedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct Ec2RequestFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension Ec2RequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.EventTriggerDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventResourceARN = "EventResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventResourceARN = eventResourceARN {
            try encodeContainer.encode(eventResourceARN, forKey: .eventResourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventResourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventResourceARN)
        eventResourceARN = eventResourceARNDecoded
    }
}

extension SnowballClientTypes.EventTriggerDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventTriggerDefinition(eventResourceARN: \(Swift.String(describing: eventResourceARN)))"}
}

extension SnowballClientTypes {
    /// <p>The container for the <a>EventTriggerDefinition$EventResourceARN</a>.</p>
    public struct EventTriggerDefinition: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an AWS Lambda
        ///       function's event trigger associated with this job.</p>
        public let eventResourceARN: Swift.String?

        public init (
            eventResourceARN: Swift.String? = nil
        )
        {
            self.eventResourceARN = eventResourceARN
        }
    }

}

public struct GetJobManifestInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobManifestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobManifestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobManifestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobManifestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobManifestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobManifestOutputError>
}

extension GetJobManifestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobManifestInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension GetJobManifestInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetJobManifestInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobManifestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobManifestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobManifestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobManifestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobManifestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobManifestOutputError>
}

public struct GetJobManifestInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobManifestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobManifestInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobManifestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobManifestInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobManifestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobManifestOutputError>
}

public struct GetJobManifestInput: Swift.Equatable {
    /// <p>The ID for a job that you want to get the manifest file for, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobManifestInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension GetJobManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobManifestOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobManifestOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobManifestOutputResponse(manifestURI: \(Swift.String(describing: manifestURI)))"}
}

extension GetJobManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.manifestURI = output.manifestURI
        } else {
            self.manifestURI = nil
        }
    }
}

public struct GetJobManifestOutputResponse: Swift.Equatable {
    /// <p>The Amazon S3 presigned URL for the manifest file associated with the specified
    ///         <code>JobId</code> value.</p>
    public let manifestURI: Swift.String?

    public init (
        manifestURI: Swift.String? = nil
    )
    {
        self.manifestURI = manifestURI
    }
}

struct GetJobManifestOutputResponseBody: Swift.Equatable {
    public let manifestURI: Swift.String?
}

extension GetJobManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestURI = "ManifestURI"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestURI)
        manifestURI = manifestURIDecoded
    }
}

public struct GetJobUnlockCodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobUnlockCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobUnlockCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobUnlockCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobUnlockCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobUnlockCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobUnlockCodeOutputError>
}

extension GetJobUnlockCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobUnlockCodeInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension GetJobUnlockCodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetJobUnlockCodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobUnlockCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobUnlockCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobUnlockCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobUnlockCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobUnlockCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobUnlockCodeOutputError>
}

public struct GetJobUnlockCodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobUnlockCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobUnlockCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobUnlockCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobUnlockCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobUnlockCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobUnlockCodeOutputError>
}

public struct GetJobUnlockCodeInput: Swift.Equatable {
    /// <p>The ID for the job that you want to get the <code>UnlockCode</code> value for, for
    ///       example <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobUnlockCodeInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension GetJobUnlockCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobUnlockCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobUnlockCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobUnlockCodeOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobUnlockCodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobUnlockCodeOutputResponse(unlockCode: \(Swift.String(describing: unlockCode)))"}
}

extension GetJobUnlockCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobUnlockCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unlockCode = output.unlockCode
        } else {
            self.unlockCode = nil
        }
    }
}

public struct GetJobUnlockCodeOutputResponse: Swift.Equatable {
    /// <p>The <code>UnlockCode</code> value for the specified job. The <code>UnlockCode</code>
    ///       value can be accessed for up to 360 days after the job has been created.</p>
    public let unlockCode: Swift.String?

    public init (
        unlockCode: Swift.String? = nil
    )
    {
        self.unlockCode = unlockCode
    }
}

struct GetJobUnlockCodeOutputResponseBody: Swift.Equatable {
    public let unlockCode: Swift.String?
}

extension GetJobUnlockCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockCode = "UnlockCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unlockCode)
        unlockCode = unlockCodeDecoded
    }
}

extension GetSnowballUsageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSnowballUsageInput()"}
}

extension GetSnowballUsageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSnowballUsageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSnowballUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSnowballUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSnowballUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSnowballUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSnowballUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSnowballUsageOutputError>
}

public struct GetSnowballUsageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSnowballUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSnowballUsageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSnowballUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSnowballUsageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSnowballUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSnowballUsageOutputError>
}

public struct GetSnowballUsageInput: Swift.Equatable {

    public init() {}
}

struct GetSnowballUsageInputBody: Swift.Equatable {
}

extension GetSnowballUsageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSnowballUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnowballUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSnowballUsageOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnowballUsageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSnowballUsageOutputResponse(snowballLimit: \(Swift.String(describing: snowballLimit)), snowballsInUse: \(Swift.String(describing: snowballsInUse)))"}
}

extension GetSnowballUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSnowballUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snowballLimit = output.snowballLimit
            self.snowballsInUse = output.snowballsInUse
        } else {
            self.snowballLimit = nil
            self.snowballsInUse = nil
        }
    }
}

public struct GetSnowballUsageOutputResponse: Swift.Equatable {
    /// <p>The service limit for number of Snow devices this account can have at once. The default
    ///       service limit is 1 (one).</p>
    public let snowballLimit: Swift.Int?
    /// <p>The number of Snow devices that this account is currently using.</p>
    public let snowballsInUse: Swift.Int?

    public init (
        snowballLimit: Swift.Int? = nil,
        snowballsInUse: Swift.Int? = nil
    )
    {
        self.snowballLimit = snowballLimit
        self.snowballsInUse = snowballsInUse
    }
}

struct GetSnowballUsageOutputResponseBody: Swift.Equatable {
    public let snowballLimit: Swift.Int?
    public let snowballsInUse: Swift.Int?
}

extension GetSnowballUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snowballLimit = "SnowballLimit"
        case snowballsInUse = "SnowballsInUse"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowballLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snowballLimit)
        snowballLimit = snowballLimitDecoded
        let snowballsInUseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snowballsInUse)
        snowballsInUse = snowballsInUseDecoded
    }
}

public struct GetSoftwareUpdatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSoftwareUpdatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSoftwareUpdatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSoftwareUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSoftwareUpdatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSoftwareUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSoftwareUpdatesOutputError>
}

extension GetSoftwareUpdatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSoftwareUpdatesInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension GetSoftwareUpdatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetSoftwareUpdatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSoftwareUpdatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSoftwareUpdatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSoftwareUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSoftwareUpdatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSoftwareUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSoftwareUpdatesOutputError>
}

public struct GetSoftwareUpdatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSoftwareUpdatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSoftwareUpdatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSoftwareUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSoftwareUpdatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSoftwareUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSoftwareUpdatesOutputError>
}

public struct GetSoftwareUpdatesInput: Swift.Equatable {
    /// <p>The ID for a job that you want to get the software update file for, for example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetSoftwareUpdatesInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension GetSoftwareUpdatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetSoftwareUpdatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSoftwareUpdatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSoftwareUpdatesOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSoftwareUpdatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSoftwareUpdatesOutputResponse(updatesURI: \(Swift.String(describing: updatesURI)))"}
}

extension GetSoftwareUpdatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSoftwareUpdatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updatesURI = output.updatesURI
        } else {
            self.updatesURI = nil
        }
    }
}

public struct GetSoftwareUpdatesOutputResponse: Swift.Equatable {
    /// <p>The Amazon S3 presigned URL for the update file associated with the specified
    ///       <code>JobId</code> value. The software update will be available for 2 days after this request is made.
    ///       To access an update after the 2 days have passed, you'll have to make another call to <code>GetSoftwareUpdates</code>.</p>
    public let updatesURI: Swift.String?

    public init (
        updatesURI: Swift.String? = nil
    )
    {
        self.updatesURI = updatesURI
    }
}

struct GetSoftwareUpdatesOutputResponseBody: Swift.Equatable {
    public let updatesURI: Swift.String?
}

extension GetSoftwareUpdatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatesURI = "UpdatesURI"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesURI)
        updatesURI = updatesURIDecoded
    }
}

extension SnowballClientTypes.INDTaxDocuments: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gSTIN = "GSTIN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gSTIN = gSTIN {
            try encodeContainer.encode(gSTIN, forKey: .gSTIN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gSTINDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gSTIN)
        gSTIN = gSTINDecoded
    }
}

extension SnowballClientTypes.INDTaxDocuments: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "INDTaxDocuments(gSTIN: \(Swift.String(describing: gSTIN)))"}
}

extension SnowballClientTypes {
    /// <p>The tax documents required in AWS Regions in India.</p>
    public struct INDTaxDocuments: Swift.Equatable {
        /// <p>The Goods and Services Tax (GST) documents required in AWS Regions in India.</p>
        public let gSTIN: Swift.String?

        public init (
            gSTIN: Swift.String? = nil
        )
        {
            self.gSTIN = gSTIN
        }
    }

}

extension InvalidAddressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAddressException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAddressException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The address provided was invalid. Check the address with your region's carrier, and try
///       again.</p>
public struct InvalidAddressException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAddressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAddressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputCombinationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputCombinationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInputCombinationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Job or cluster creation failed. One or more inputs were invalid. Confirm that the
///       <a>CreateClusterRequest$SnowballType</a> value supports your <a>CreateJobRequest$JobType</a>, and try again.</p>
public struct InvalidInputCombinationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputCombinationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidJobStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidJobStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action can't be performed because the job's current state doesn't allow that action
///       to be performed.</p>
public struct InvalidJobStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidJobStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>NextToken</code> string was altered unexpectedly, and the operation has
///       stopped. Run the operation without changing the <code>NextToken</code> string, and try
///       again.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceException(message: \(Swift.String(describing: message)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension InvalidResourceException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource can't be found. Check the information you provided in your last
///       request, and try again.</p>
public struct InvalidResourceException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// <p>The provided resource value is invalid.</p>
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct InvalidResourceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceType: Swift.String?
}

extension InvalidResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SnowballClientTypes.JobListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case isMaster = "IsMaster"
        case jobId = "JobId"
        case jobState = "JobState"
        case jobType = "JobType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isMaster != false {
            try encodeContainer.encode(isMaster, forKey: .isMaster)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobState = jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let isMasterDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isMaster)
        isMaster = isMasterDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SnowballClientTypes.JobListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobListEntry(creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)), isMaster: \(Swift.String(describing: isMaster)), jobId: \(Swift.String(describing: jobId)), jobState: \(Swift.String(describing: jobState)), jobType: \(Swift.String(describing: jobType)), snowballType: \(Swift.String(describing: snowballType)))"}
}

extension SnowballClientTypes {
    /// <p>Each <code>JobListEntry</code> object contains a job's state, a job's ID, and a value
    ///       that indicates whether the job is a job part, in the case of an export job.</p>
    public struct JobListEntry: Swift.Equatable {
        /// <p>The creation date for this job.</p>
        public let creationDate: ClientRuntime.Date?
        /// <p>The optional description of this specific job, for example <code>Important Photos
        ///         2016-08-11</code>.</p>
        public let description: Swift.String?
        /// <p>A value that indicates that this job is a main job. A main job represents a
        ///       successful request to create an export job. Main jobs aren't associated with any Snowballs.
        ///       Instead, each main job will have at least one job part, and each job part is associated with
        ///       a Snowball. It might take some time before the job parts associated with a particular main
        ///       job are listed, because they are created after the main job is created.</p>
        public let isMaster: Swift.Bool
        /// <p>The automatically generated ID for a job, for example
        ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        public let jobId: Swift.String?
        /// <p>The current state of this job.</p>
        public let jobState: SnowballClientTypes.JobState?
        /// <p>The type of job.</p>
        public let jobType: SnowballClientTypes.JobType?
        /// <p>The type of device used with this job.</p>
        public let snowballType: SnowballClientTypes.SnowballType?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            isMaster: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.isMaster = isMaster
            self.jobId = jobId
            self.jobState = jobState
            self.jobType = jobType
            self.snowballType = snowballType
        }
    }

}

extension SnowballClientTypes.JobLogs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobCompletionReportURI = "JobCompletionReportURI"
        case jobFailureLogURI = "JobFailureLogURI"
        case jobSuccessLogURI = "JobSuccessLogURI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobCompletionReportURI = jobCompletionReportURI {
            try encodeContainer.encode(jobCompletionReportURI, forKey: .jobCompletionReportURI)
        }
        if let jobFailureLogURI = jobFailureLogURI {
            try encodeContainer.encode(jobFailureLogURI, forKey: .jobFailureLogURI)
        }
        if let jobSuccessLogURI = jobSuccessLogURI {
            try encodeContainer.encode(jobSuccessLogURI, forKey: .jobSuccessLogURI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobCompletionReportURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobCompletionReportURI)
        jobCompletionReportURI = jobCompletionReportURIDecoded
        let jobSuccessLogURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobSuccessLogURI)
        jobSuccessLogURI = jobSuccessLogURIDecoded
        let jobFailureLogURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobFailureLogURI)
        jobFailureLogURI = jobFailureLogURIDecoded
    }
}

extension SnowballClientTypes.JobLogs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobLogs(jobCompletionReportURI: \(Swift.String(describing: jobCompletionReportURI)), jobFailureLogURI: \(Swift.String(describing: jobFailureLogURI)), jobSuccessLogURI: \(Swift.String(describing: jobSuccessLogURI)))"}
}

extension SnowballClientTypes {
    /// <p>Contains job logs. Whenever a Snow device is used to import data into or export data out of
    ///       Amazon S3, you'll have the option of downloading a PDF job report. Job logs are returned as a
    ///       part of the response syntax of the <code>DescribeJob</code> action in the
    ///         <code>JobMetadata</code> data type. The job logs can be accessed for up to 60 minutes after
    ///       this request has been made. To access any of the job logs after 60 minutes have passed, you'll
    ///       have to make another call to the <code>DescribeJob</code> action.</p>
    ///
    ///          <p>For import jobs, the PDF job report becomes available at the end of the import process.
    ///       For export jobs, your job report typically becomes available while the Snow device for your job
    ///       part is being delivered to you.</p>
    ///
    ///          <p>The job report provides you insight into the state of your Amazon S3 data transfer. The
    ///       report includes details about your job or job part for your records.</p>
    ///
    ///          <p>For deeper visibility into the status of your transferred objects, you can look at the
    ///       two associated logs: a success log and a failure log. The logs are saved in comma-separated
    ///       value (CSV) format, and the name of each log includes the ID of the job or job part that the
    ///       log describes.</p>
    public struct JobLogs: Swift.Equatable {
        /// <p>A link to an Amazon S3 presigned URL where the job completion report is
        ///       located.</p>
        public let jobCompletionReportURI: Swift.String?
        /// <p>A link to an Amazon S3 presigned URL where the job failure log is located.</p>
        public let jobFailureLogURI: Swift.String?
        /// <p>A link to an Amazon S3 presigned URL where the job success log is located.</p>
        public let jobSuccessLogURI: Swift.String?

        public init (
            jobCompletionReportURI: Swift.String? = nil,
            jobFailureLogURI: Swift.String? = nil,
            jobSuccessLogURI: Swift.String? = nil
        )
        {
            self.jobCompletionReportURI = jobCompletionReportURI
            self.jobFailureLogURI = jobFailureLogURI
            self.jobSuccessLogURI = jobSuccessLogURI
        }
    }

}

extension SnowballClientTypes.JobMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case creationDate = "CreationDate"
        case dataTransferProgress = "DataTransferProgress"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case jobLogInfo = "JobLogInfo"
        case jobState = "JobState"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingDetails = "ShippingDetails"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let dataTransferProgress = dataTransferProgress {
            try encodeContainer.encode(dataTransferProgress, forKey: .dataTransferProgress)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobLogInfo = jobLogInfo {
            try encodeContainer.encode(jobLogInfo, forKey: .jobLogInfo)
        }
        if let jobState = jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingDetails = shippingDetails {
            try encodeContainer.encode(shippingDetails, forKey: .shippingDetails)
        }
        if let snowballCapacityPreference = snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingDetailsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingDetails.self, forKey: .shippingDetails)
        shippingDetails = shippingDetailsDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DataTransfer.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let jobLogInfoDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobLogs.self, forKey: .jobLogInfo)
        jobLogInfo = jobLogInfoDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

extension SnowballClientTypes.JobMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobMetadata(addressId: \(Swift.String(describing: addressId)), clusterId: \(Swift.String(describing: clusterId)), creationDate: \(Swift.String(describing: creationDate)), dataTransferProgress: \(Swift.String(describing: dataTransferProgress)), description: \(Swift.String(describing: description)), deviceConfiguration: \(Swift.String(describing: deviceConfiguration)), forwardingAddressId: \(Swift.String(describing: forwardingAddressId)), jobId: \(Swift.String(describing: jobId)), jobLogInfo: \(Swift.String(describing: jobLogInfo)), jobState: \(Swift.String(describing: jobState)), jobType: \(Swift.String(describing: jobType)), kmsKeyARN: \(Swift.String(describing: kmsKeyARN)), longTermPricingId: \(Swift.String(describing: longTermPricingId)), notification: \(Swift.String(describing: notification)), resources: \(Swift.String(describing: resources)), roleARN: \(Swift.String(describing: roleARN)), shippingDetails: \(Swift.String(describing: shippingDetails)), snowballCapacityPreference: \(Swift.String(describing: snowballCapacityPreference)), snowballType: \(Swift.String(describing: snowballType)), taxDocuments: \(Swift.String(describing: taxDocuments)))"}
}

extension SnowballClientTypes {
    /// <p>Contains information about a specific job including shipping information, job status,
    ///       and other important metadata. This information is returned as a part of the response syntax of
    ///       the <code>DescribeJob</code> action.</p>
    public struct JobMetadata: Swift.Equatable {
        /// <p>The ID for the address that you want the Snow device shipped to.</p>
        public let addressId: Swift.String?
        /// <p>The 39-character ID for the cluster, for example
        ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        public let clusterId: Swift.String?
        /// <p>The creation date for this job.</p>
        public let creationDate: ClientRuntime.Date?
        /// <p>A value that defines the real-time status of a Snow device's data transfer while the
        ///       device is at AWS. This data is only available while a job has a <code>JobState</code> value of
        ///         <code>InProgress</code>, for both import and export jobs.</p>
        public let dataTransferProgress: SnowballClientTypes.DataTransfer?
        /// <p>The description of the job, provided at job creation.</p>
        public let description: Swift.String?
        /// <p>The container for <code>SnowconeDeviceConfiguration</code>. </p>
        public let deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
        /// <p>The ID of the address that you want a job shipped to, after it will be
        ///       shipped to its primary address. This field is not supported in most regions.</p>
        public let forwardingAddressId: Swift.String?
        /// <p>The automatically generated ID for a job, for example
        ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
        public let jobId: Swift.String?
        /// <p>Links to Amazon S3 presigned URLs for the job report and logs. For import jobs, the PDF
        ///       job report becomes available at the end of the import process. For export jobs, your job
        ///       report typically becomes available while the Snow device for your job part is being delivered to
        ///       you.</p>
        public let jobLogInfo: SnowballClientTypes.JobLogs?
        /// <p>The current status of the jobs.</p>
        public let jobState: SnowballClientTypes.JobState?
        /// <p>The type of job.</p>
        public let jobType: SnowballClientTypes.JobType?
        /// <p>The Amazon Resource Name (ARN) for the AWS Key Management Service (AWS KMS) key
        ///       associated with this job. This ARN was created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS
        ///       KMS.</p>
        public let kmsKeyARN: Swift.String?
        /// <p>The ID of the long term pricing type for the device.</p>
        public let longTermPricingId: Swift.String?
        /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings associated
        ///       with a specific job. The <code>Notification</code> object is returned as a part of the
        ///       response syntax of the <code>DescribeJob</code> action in the <code>JobMetadata</code> data
        ///       type.</p>
        public let notification: SnowballClientTypes.Notification?
        /// <p>An array of <code>S3Resource</code> objects. Each <code>S3Resource</code> object
        ///       represents an Amazon S3 bucket that your transferred data will be exported from or imported
        ///       into.</p>
        public let resources: SnowballClientTypes.JobResource?
        /// <p>The role ARN associated with this job. This ARN was created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>
        ///       API action in AWS Identity and Access Management (IAM).</p>
        public let roleARN: Swift.String?
        /// <p>A job's shipping information, including inbound and outbound tracking numbers and
        ///       shipping speed options.</p>
        public let shippingDetails: SnowballClientTypes.ShippingDetails?
        /// <p>The Snow device capacity preference for this job, specified at job creation. In US
        ///       regions, you can choose between 50 TB and 80 TB Snowballs. All other regions use 80 TB
        ///       capacity Snowballs.</p>
        ///
        ///          <p>For more information, see
        ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
        ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
        ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
        ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
        public let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
        /// <p>The type of device used with this job.</p>
        public let snowballType: SnowballClientTypes.SnowballType?
        /// <p>The metadata associated with the tax documents required in your AWS Region.</p>
        public let taxDocuments: SnowballClientTypes.TaxDocuments?

        public init (
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            dataTransferProgress: SnowballClientTypes.DataTransfer? = nil,
            description: Swift.String? = nil,
            deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
            forwardingAddressId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobLogInfo: SnowballClientTypes.JobLogs? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            longTermPricingId: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingDetails: SnowballClientTypes.ShippingDetails? = nil,
            snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.creationDate = creationDate
            self.dataTransferProgress = dataTransferProgress
            self.description = description
            self.deviceConfiguration = deviceConfiguration
            self.forwardingAddressId = forwardingAddressId
            self.jobId = jobId
            self.jobLogInfo = jobLogInfo
            self.jobState = jobState
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingId = longTermPricingId
            self.notification = notification
            self.resources = resources
            self.roleARN = roleARN
            self.shippingDetails = shippingDetails
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }

}

extension SnowballClientTypes.JobResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2AmiResources = "Ec2AmiResources"
        case lambdaResources = "LambdaResources"
        case s3Resources = "S3Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2AmiResources = ec2AmiResources {
            var ec2AmiResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2AmiResources)
            for ec2amiresourcelist0 in ec2AmiResources {
                try ec2AmiResourcesContainer.encode(ec2amiresourcelist0)
            }
        }
        if let lambdaResources = lambdaResources {
            var lambdaResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaResources)
            for lambdaresourcelist0 in lambdaResources {
                try lambdaResourcesContainer.encode(lambdaresourcelist0)
            }
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resourcelist0 in s3Resources {
                try s3ResourcesContainer.encode(s3resourcelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.S3Resource?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[SnowballClientTypes.S3Resource]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [SnowballClientTypes.S3Resource]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let lambdaResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.LambdaResource?].self, forKey: .lambdaResources)
        var lambdaResourcesDecoded0:[SnowballClientTypes.LambdaResource]? = nil
        if let lambdaResourcesContainer = lambdaResourcesContainer {
            lambdaResourcesDecoded0 = [SnowballClientTypes.LambdaResource]()
            for structure0 in lambdaResourcesContainer {
                if let structure0 = structure0 {
                    lambdaResourcesDecoded0?.append(structure0)
                }
            }
        }
        lambdaResources = lambdaResourcesDecoded0
        let ec2AmiResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Ec2AmiResource?].self, forKey: .ec2AmiResources)
        var ec2AmiResourcesDecoded0:[SnowballClientTypes.Ec2AmiResource]? = nil
        if let ec2AmiResourcesContainer = ec2AmiResourcesContainer {
            ec2AmiResourcesDecoded0 = [SnowballClientTypes.Ec2AmiResource]()
            for structure0 in ec2AmiResourcesContainer {
                if let structure0 = structure0 {
                    ec2AmiResourcesDecoded0?.append(structure0)
                }
            }
        }
        ec2AmiResources = ec2AmiResourcesDecoded0
    }
}

extension SnowballClientTypes.JobResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobResource(ec2AmiResources: \(Swift.String(describing: ec2AmiResources)), lambdaResources: \(Swift.String(describing: lambdaResources)), s3Resources: \(Swift.String(describing: s3Resources)))"}
}

extension SnowballClientTypes {
    /// <p>Contains an array of AWS resource objects. Each object represents an Amazon S3 bucket,
    ///       an AWS Lambda function, or an Amazon Machine Image (AMI) based on Amazon EC2 that is
    ///       associated with a particular job.</p>
    public struct JobResource: Swift.Equatable {
        /// <p>The Amazon Machine Images (AMIs) associated with this job.</p>
        public let ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]?
        /// <p>The Python-language Lambda functions for this job.</p>
        public let lambdaResources: [SnowballClientTypes.LambdaResource]?
        /// <p>An array of <code>S3Resource</code> objects.</p>
        public let s3Resources: [SnowballClientTypes.S3Resource]?

        public init (
            ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]? = nil,
            lambdaResources: [SnowballClientTypes.LambdaResource]? = nil,
            s3Resources: [SnowballClientTypes.S3Resource]? = nil
        )
        {
            self.ec2AmiResources = ec2AmiResources
            self.lambdaResources = lambdaResources
            self.s3Resources = s3Resources
        }
    }

}

extension SnowballClientTypes {
    public enum JobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case complete
        case inProgress
        case inTransitToAws
        case inTransitToCustomer
        case listing
        case new
        case pending
        case preparingAppliance
        case preparingShipment
        case withAws
        case withAwsSortingFacility
        case withCustomer
        case sdkUnknown(Swift.String)

        public static var allCases: [JobState] {
            return [
                .cancelled,
                .complete,
                .inProgress,
                .inTransitToAws,
                .inTransitToCustomer,
                .listing,
                .new,
                .pending,
                .preparingAppliance,
                .preparingShipment,
                .withAws,
                .withAwsSortingFacility,
                .withCustomer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case .inTransitToAws: return "InTransitToAWS"
            case .inTransitToCustomer: return "InTransitToCustomer"
            case .listing: return "Listing"
            case .new: return "New"
            case .pending: return "Pending"
            case .preparingAppliance: return "PreparingAppliance"
            case .preparingShipment: return "PreparingShipment"
            case .withAws: return "WithAWS"
            case .withAwsSortingFacility: return "WithAWSSortingFacility"
            case .withCustomer: return "WithCustomer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobState(rawValue: rawValue) ?? JobState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .export,
                .import,
                .localUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension KMSRequestFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSRequestFailedException(message: \(Swift.String(describing: message)))"}
}

extension KMSRequestFailedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSRequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided AWS Key Management Service key lacks the permissions to perform the
///       specified <a>CreateJob</a> or <a>UpdateJob</a> action.</p>
public struct KMSRequestFailedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSRequestFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension KMSRequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.KeyRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginMarker = "BeginMarker"
        case endMarker = "EndMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginMarker = beginMarker {
            try encodeContainer.encode(beginMarker, forKey: .beginMarker)
        }
        if let endMarker = endMarker {
            try encodeContainer.encode(endMarker, forKey: .endMarker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beginMarker)
        beginMarker = beginMarkerDecoded
        let endMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endMarker)
        endMarker = endMarkerDecoded
    }
}

extension SnowballClientTypes.KeyRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KeyRange(beginMarker: \(Swift.String(describing: beginMarker)), endMarker: \(Swift.String(describing: endMarker)))"}
}

extension SnowballClientTypes {
    /// <p>Contains a key range. For export jobs, a <code>S3Resource</code> object can have an
    ///       optional <code>KeyRange</code> value. The length of the range is defined at job creation, and
    ///       has either an inclusive <code>BeginMarker</code>, an inclusive <code>EndMarker</code>, or
    ///       both. Ranges are UTF-8 binary sorted.</p>
    public struct KeyRange: Swift.Equatable {
        /// <p>The key that starts an optional key range for an export job. Ranges are inclusive and
        ///       UTF-8 binary sorted.</p>
        public let beginMarker: Swift.String?
        /// <p>The key that ends an optional key range for an export job. Ranges are inclusive and
        ///       UTF-8 binary sorted.</p>
        public let endMarker: Swift.String?

        public init (
            beginMarker: Swift.String? = nil,
            endMarker: Swift.String? = nil
        )
        {
            self.beginMarker = beginMarker
            self.endMarker = endMarker
        }
    }

}

extension SnowballClientTypes.LambdaResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTriggers = "EventTriggers"
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTriggers = eventTriggers {
            var eventTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTriggers)
            for eventtriggerdefinitionlist0 in eventTriggers {
                try eventTriggersContainer.encode(eventtriggerdefinitionlist0)
            }
        }
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let eventTriggersContainer = try containerValues.decodeIfPresent([SnowballClientTypes.EventTriggerDefinition?].self, forKey: .eventTriggers)
        var eventTriggersDecoded0:[SnowballClientTypes.EventTriggerDefinition]? = nil
        if let eventTriggersContainer = eventTriggersContainer {
            eventTriggersDecoded0 = [SnowballClientTypes.EventTriggerDefinition]()
            for structure0 in eventTriggersContainer {
                if let structure0 = structure0 {
                    eventTriggersDecoded0?.append(structure0)
                }
            }
        }
        eventTriggers = eventTriggersDecoded0
    }
}

extension SnowballClientTypes.LambdaResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaResource(eventTriggers: \(Swift.String(describing: eventTriggers)), lambdaArn: \(Swift.String(describing: lambdaArn)))"}
}

extension SnowballClientTypes {
    /// <p>Identifies </p>
    public struct LambdaResource: Swift.Equatable {
        /// <p>The array of ARNs for <a>S3Resource</a> objects to trigger the <a>LambdaResource</a> objects associated with this job.</p>
        public let eventTriggers: [SnowballClientTypes.EventTriggerDefinition]?
        /// <p>An Amazon Resource Name (ARN) that represents an AWS Lambda function to be triggered by
        ///       PUT object actions on the associated local Amazon S3 resource.</p>
        public let lambdaArn: Swift.String?

        public init (
            eventTriggers: [SnowballClientTypes.EventTriggerDefinition]? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.eventTriggers = eventTriggers
            self.lambdaArn = lambdaArn
        }
    }

}

public struct ListClusterJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClusterJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClusterJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterJobsOutputError>
}

extension ListClusterJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClusterJobsInput(clusterId: \(Swift.String(describing: clusterId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClusterJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListClusterJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClusterJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClusterJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterJobsOutputError>
}

public struct ListClusterJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClusterJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClusterJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClusterJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClusterJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClusterJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClusterJobsOutputError>
}

public struct ListClusterJobsInput: Swift.Equatable {
    /// <p>The 39-character ID for the cluster that you want to list, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: Swift.String?
    /// <p>The number of <code>JobListEntry</code> objects to return.</p>
    public let maxResults: Swift.Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
    ///       as the starting point for your returned list.</p>
    public let nextToken: Swift.String?

    public init (
        clusterId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterJobsInputBody: Swift.Equatable {
    public let clusterId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListClusterJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClusterJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClusterJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClusterJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClusterJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClusterJobsOutputResponse(jobListEntries: \(Swift.String(describing: jobListEntries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClusterJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClusterJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterJobsOutputResponse: Swift.Equatable {
    /// <p>Each <code>JobListEntry</code> object contains a job's state, a job's ID, and a value
    ///       that indicates whether the job is a job part, in the case of export jobs. </p>
    public let jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// <p>HTTP requests are stateless. If you use the automatically generated
    ///         <code>NextToken</code> value in your next <code>ListClusterJobsResult</code> call, your list
    ///       of returned jobs will start from this point in the array.</p>
    public let nextToken: Swift.String?

    public init (
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListClusterJobsOutputResponseBody: Swift.Equatable {
    public let jobListEntries: [SnowballClientTypes.JobListEntry]?
    public let nextToken: Swift.String?
}

extension ListClusterJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListClustersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

extension ListClustersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClustersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClustersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListClustersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

public struct ListClustersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListClustersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListClustersOutputError>
}

public struct ListClustersInput: Swift.Equatable {
    /// <p>The number of <code>ClusterListEntry</code> objects to return.</p>
    public let maxResults: Swift.Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>ClusterListEntry</code> objects, you have the option of specifying
    ///         <code>NextToken</code> as the starting point for your returned list.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClustersOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClustersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListClustersOutputResponse(clusterListEntries: \(Swift.String(describing: clusterListEntries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterListEntries = output.clusterListEntries
            self.nextToken = output.nextToken
        } else {
            self.clusterListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutputResponse: Swift.Equatable {
    /// <p>Each <code>ClusterListEntry</code> object contains a cluster's state, a cluster's ID,
    ///       and other important status information.</p>
    public let clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    /// <p>HTTP requests are stateless. If you use the automatically generated
    ///         <code>NextToken</code> value in your next <code>ClusterListEntry</code> call, your list of
    ///       returned clusters will start from this point in the array.</p>
    public let nextToken: Swift.String?

    public init (
        clusterListEntries: [SnowballClientTypes.ClusterListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterListEntries = clusterListEntries
        self.nextToken = nextToken
    }
}

struct ListClustersOutputResponseBody: Swift.Equatable {
    public let clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    public let nextToken: Swift.String?
}

extension ListClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterListEntries = "ClusterListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.ClusterListEntry?].self, forKey: .clusterListEntries)
        var clusterListEntriesDecoded0:[SnowballClientTypes.ClusterListEntry]? = nil
        if let clusterListEntriesContainer = clusterListEntriesContainer {
            clusterListEntriesDecoded0 = [SnowballClientTypes.ClusterListEntry]()
            for structure0 in clusterListEntriesContainer {
                if let structure0 = structure0 {
                    clusterListEntriesDecoded0?.append(structure0)
                }
            }
        }
        clusterListEntries = clusterListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCompatibleImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCompatibleImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCompatibleImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCompatibleImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCompatibleImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCompatibleImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCompatibleImagesOutputError>
}

extension ListCompatibleImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCompatibleImagesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCompatibleImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCompatibleImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCompatibleImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCompatibleImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCompatibleImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCompatibleImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCompatibleImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCompatibleImagesOutputError>
}

public struct ListCompatibleImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCompatibleImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCompatibleImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCompatibleImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCompatibleImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCompatibleImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCompatibleImagesOutputError>
}

public struct ListCompatibleImagesInput: Swift.Equatable {
    /// <p>The maximum number of results for the list of compatible images. Currently, a Snowball
    ///       Edge device can store 10 AMIs.</p>
    public let maxResults: Swift.Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///       compatible images, you can specify a value for <code>NextToken</code> as the starting point
    ///       for your list of returned images.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListCompatibleImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCompatibleImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCompatibleImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCompatibleImagesOutputError: Swift.Error, Swift.Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCompatibleImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCompatibleImagesOutputResponse(compatibleImages: \(Swift.String(describing: compatibleImages)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCompatibleImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCompatibleImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleImages = output.compatibleImages
            self.nextToken = output.nextToken
        } else {
            self.compatibleImages = nil
            self.nextToken = nil
        }
    }
}

public struct ListCompatibleImagesOutputResponse: Swift.Equatable {
    /// <p>A JSON-formatted object that describes a compatible AMI, including the ID and name for
    ///       a Snow device AMI.</p>
    public let compatibleImages: [SnowballClientTypes.CompatibleImage]?
    /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
    ///       returned images.</p>
    public let nextToken: Swift.String?

    public init (
        compatibleImages: [SnowballClientTypes.CompatibleImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compatibleImages = compatibleImages
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesOutputResponseBody: Swift.Equatable {
    public let compatibleImages: [SnowballClientTypes.CompatibleImage]?
    public let nextToken: Swift.String?
}

extension ListCompatibleImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleImages = "CompatibleImages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleImagesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.CompatibleImage?].self, forKey: .compatibleImages)
        var compatibleImagesDecoded0:[SnowballClientTypes.CompatibleImage]? = nil
        if let compatibleImagesContainer = compatibleImagesContainer {
            compatibleImagesDecoded0 = [SnowballClientTypes.CompatibleImage]()
            for structure0 in compatibleImagesContainer {
                if let structure0 = structure0 {
                    compatibleImagesDecoded0?.append(structure0)
                }
            }
        }
        compatibleImages = compatibleImagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

extension ListJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Swift.Equatable {
    /// <p>The number of <code>JobListEntry</code> objects to return.</p>
    public let maxResults: Swift.Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
    ///       as the starting point for your returned list.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsOutputResponse(jobListEntries: \(Swift.String(describing: jobListEntries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Swift.Equatable {
    /// <p>Each <code>JobListEntry</code> object contains a job's state, a job's ID, and a value
    ///       that indicates whether the job is a job part, in the case of export jobs. </p>
    public let jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// <p>HTTP requests are stateless. If you use this automatically generated
    ///         <code>NextToken</code> value in your next <code>ListJobs</code> call, your returned
    ///         <code>JobListEntry</code> objects will start from this point in the array.</p>
    public let nextToken: Swift.String?

    public init (
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    public let jobListEntries: [SnowballClientTypes.JobListEntry]?
    public let nextToken: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLongTermPricingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLongTermPricingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLongTermPricingOutputError>
}

extension ListLongTermPricingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLongTermPricingInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLongTermPricingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLongTermPricingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLongTermPricingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLongTermPricingOutputError>
}

public struct ListLongTermPricingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLongTermPricingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLongTermPricingOutputError>
}

public struct ListLongTermPricingInput: Swift.Equatable {
    /// <p>The maximum number of <code>ListLongTermPricing</code> objects to return.</p>
    public let maxResults: Swift.Int?
    /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
    ///       <code>ListLongTermPricing</code> to return.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLongTermPricingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLongTermPricingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLongTermPricingOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLongTermPricingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLongTermPricingOutputResponse(longTermPricingEntries: \(Swift.String(describing: longTermPricingEntries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLongTermPricingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLongTermPricingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingEntries = output.longTermPricingEntries
            self.nextToken = output.nextToken
        } else {
            self.longTermPricingEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLongTermPricingOutputResponse: Swift.Equatable {
    /// <p>Each <code>LongTermPricingEntry</code> object contains a status, ID, and other information
    ///       about the <code>LongTermPricing</code> type. </p>
    public let longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
    ///       returned <code>ListLongTermPricing</code> list.</p>
    public let nextToken: Swift.String?

    public init (
        longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.longTermPricingEntries = longTermPricingEntries
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingOutputResponseBody: Swift.Equatable {
    public let longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    public let nextToken: Swift.String?
}

extension ListLongTermPricingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case longTermPricingEntries = "LongTermPricingEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.LongTermPricingListEntry?].self, forKey: .longTermPricingEntries)
        var longTermPricingEntriesDecoded0:[SnowballClientTypes.LongTermPricingListEntry]? = nil
        if let longTermPricingEntriesContainer = longTermPricingEntriesContainer {
            longTermPricingEntriesDecoded0 = [SnowballClientTypes.LongTermPricingListEntry]()
            for structure0 in longTermPricingEntriesContainer {
                if let structure0 = structure0 {
                    longTermPricingEntriesDecoded0?.append(structure0)
                }
            }
        }
        longTermPricingEntries = longTermPricingEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SnowballClientTypes.LongTermPricingListEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentActiveJob = "CurrentActiveJob"
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case jobIds = "JobIds"
        case longTermPricingEndDate = "LongTermPricingEndDate"
        case longTermPricingId = "LongTermPricingId"
        case longTermPricingStartDate = "LongTermPricingStartDate"
        case longTermPricingStatus = "LongTermPricingStatus"
        case longTermPricingType = "LongTermPricingType"
        case replacementJob = "ReplacementJob"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentActiveJob = currentActiveJob {
            try encodeContainer.encode(currentActiveJob, forKey: .currentActiveJob)
        }
        if let isLongTermPricingAutoRenew = isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let jobIds = jobIds {
            var jobIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIds)
            for longtermpricingassociatedjobidlist0 in jobIds {
                try jobIdsContainer.encode(longtermpricingassociatedjobidlist0)
            }
        }
        if let longTermPricingEndDate = longTermPricingEndDate {
            try encodeContainer.encode(longTermPricingEndDate.timeIntervalSince1970, forKey: .longTermPricingEndDate)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let longTermPricingStartDate = longTermPricingStartDate {
            try encodeContainer.encode(longTermPricingStartDate.timeIntervalSince1970, forKey: .longTermPricingStartDate)
        }
        if let longTermPricingStatus = longTermPricingStatus {
            try encodeContainer.encode(longTermPricingStatus, forKey: .longTermPricingStatus)
        }
        if let longTermPricingType = longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let replacementJob = replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let longTermPricingEndDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .longTermPricingEndDate)
        longTermPricingEndDate = longTermPricingEndDateDecoded
        let longTermPricingStartDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .longTermPricingStartDate)
        longTermPricingStartDate = longTermPricingStartDateDecoded
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let currentActiveJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentActiveJob)
        currentActiveJob = currentActiveJobDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let longTermPricingStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingStatus)
        longTermPricingStatus = longTermPricingStatusDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let jobIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIds)
        var jobIdsDecoded0:[Swift.String]? = nil
        if let jobIdsContainer = jobIdsContainer {
            jobIdsDecoded0 = [Swift.String]()
            for string0 in jobIdsContainer {
                if let string0 = string0 {
                    jobIdsDecoded0?.append(string0)
                }
            }
        }
        jobIds = jobIdsDecoded0
    }
}

extension SnowballClientTypes.LongTermPricingListEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LongTermPricingListEntry(currentActiveJob: \(Swift.String(describing: currentActiveJob)), isLongTermPricingAutoRenew: \(Swift.String(describing: isLongTermPricingAutoRenew)), jobIds: \(Swift.String(describing: jobIds)), longTermPricingEndDate: \(Swift.String(describing: longTermPricingEndDate)), longTermPricingId: \(Swift.String(describing: longTermPricingId)), longTermPricingStartDate: \(Swift.String(describing: longTermPricingStartDate)), longTermPricingStatus: \(Swift.String(describing: longTermPricingStatus)), longTermPricingType: \(Swift.String(describing: longTermPricingType)), replacementJob: \(Swift.String(describing: replacementJob)), snowballType: \(Swift.String(describing: snowballType)))"}
}

extension SnowballClientTypes {
    /// <p>Each <code>LongTermPricingListEntry</code> object contains information about a long term pricing type.</p>
    public struct LongTermPricingListEntry: Swift.Equatable {
        /// <p>The current active jobs on the device the long term pricing type.</p>
        public let currentActiveJob: Swift.String?
        /// <p>If set to <code>true</code>, specifies that the current long term pricing type for the
        ///       device should be automatically renewed before the long term pricing contract expires.</p>
        public let isLongTermPricingAutoRenew: Swift.Bool?
        /// <p>The IDs of the jobs that are associated with a long term pricing type.</p>
        public let jobIds: [Swift.String]?
        /// <p>The end date the long term pricing contract.</p>
        public let longTermPricingEndDate: ClientRuntime.Date?
        /// <p>The ID of the long term pricing type for the device.</p>
        public let longTermPricingId: Swift.String?
        /// <p>The start date of the long term pricing contract.</p>
        public let longTermPricingStartDate: ClientRuntime.Date?
        /// <p>The status of the long term pricing type.</p>
        public let longTermPricingStatus: Swift.String?
        /// <p>The type of long term pricing that was selected for the device.</p>
        public let longTermPricingType: SnowballClientTypes.LongTermPricingType?
        /// <p>A new device that replaces a device that is ordered with long term pricing.</p>
        public let replacementJob: Swift.String?
        /// <p>The type of AWS Snow Family device associated with this long term pricing job.</p>
        public let snowballType: SnowballClientTypes.SnowballType?

        public init (
            currentActiveJob: Swift.String? = nil,
            isLongTermPricingAutoRenew: Swift.Bool? = nil,
            jobIds: [Swift.String]? = nil,
            longTermPricingEndDate: ClientRuntime.Date? = nil,
            longTermPricingId: Swift.String? = nil,
            longTermPricingStartDate: ClientRuntime.Date? = nil,
            longTermPricingStatus: Swift.String? = nil,
            longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
            replacementJob: Swift.String? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.currentActiveJob = currentActiveJob
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.jobIds = jobIds
            self.longTermPricingEndDate = longTermPricingEndDate
            self.longTermPricingId = longTermPricingId
            self.longTermPricingStartDate = longTermPricingStartDate
            self.longTermPricingStatus = longTermPricingStatus
            self.longTermPricingType = longTermPricingType
            self.replacementJob = replacementJob
            self.snowballType = snowballType
        }
    }

}

extension SnowballClientTypes {
    public enum LongTermPricingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneYear
        case threeYear
        case sdkUnknown(Swift.String)

        public static var allCases: [LongTermPricingType] {
            return [
                .oneYear,
                .threeYear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "OneYear"
            case .threeYear: return "ThreeYear"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LongTermPricingType(rawValue: rawValue) ?? LongTermPricingType.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.Notification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatesToNotify = "JobStatesToNotify"
        case notifyAll = "NotifyAll"
        case snsTopicARN = "SnsTopicARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatesToNotify = jobStatesToNotify {
            var jobStatesToNotifyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobStatesToNotify)
            for jobstatelist0 in jobStatesToNotify {
                try jobStatesToNotifyContainer.encode(jobstatelist0.rawValue)
            }
        }
        if notifyAll != false {
            try encodeContainer.encode(notifyAll, forKey: .notifyAll)
        }
        if let snsTopicARN = snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let jobStatesToNotifyContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobState?].self, forKey: .jobStatesToNotify)
        var jobStatesToNotifyDecoded0:[SnowballClientTypes.JobState]? = nil
        if let jobStatesToNotifyContainer = jobStatesToNotifyContainer {
            jobStatesToNotifyDecoded0 = [SnowballClientTypes.JobState]()
            for string0 in jobStatesToNotifyContainer {
                if let string0 = string0 {
                    jobStatesToNotifyDecoded0?.append(string0)
                }
            }
        }
        jobStatesToNotify = jobStatesToNotifyDecoded0
        let notifyAllDecoded = try containerValues.decode(Swift.Bool.self, forKey: .notifyAll)
        notifyAll = notifyAllDecoded
    }
}

extension SnowballClientTypes.Notification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Notification(jobStatesToNotify: \(Swift.String(describing: jobStatesToNotify)), notifyAll: \(Swift.String(describing: notifyAll)), snsTopicARN: \(Swift.String(describing: snsTopicARN)))"}
}

extension SnowballClientTypes {
    /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings associated
    ///       with a specific job. The <code>Notification</code> object is returned as a part of the
    ///       response syntax of the <code>DescribeJob</code> action in the <code>JobMetadata</code> data
    ///       type.</p>
    ///
    ///          <p>When the notification settings are defined during job creation, you can choose to
    ///       notify based on a specific set of job states using the <code>JobStatesToNotify</code> array of
    ///       strings, or you can specify that you want to have Amazon SNS notifications sent out for all
    ///       job states with <code>NotifyAll</code> set to true.</p>
    public struct Notification: Swift.Equatable {
        /// <p>The list of job states that will trigger a notification for this job.</p>
        public let jobStatesToNotify: [SnowballClientTypes.JobState]?
        /// <p>Any change in job state will trigger a notification for this job.</p>
        public let notifyAll: Swift.Bool
        /// <p>The new SNS <code>TopicArn</code> that you want to associate with this job. You can
        ///       create Amazon Resource Names (ARNs) for topics by using the <a href="https://docs.aws.amazon.com/sns/latest/api/API_CreateTopic.html">CreateTopic</a> Amazon SNS API
        ///       action.</p>
        ///
        ///          <p>You can subscribe email addresses to an Amazon SNS topic through the AWS Management
        ///       Console, or by using the <a href="https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html">Subscribe</a> AWS Simple Notification Service (SNS) API action.</p>
        public let snsTopicARN: Swift.String?

        public init (
            jobStatesToNotify: [SnowballClientTypes.JobState]? = nil,
            notifyAll: Swift.Bool = false,
            snsTopicARN: Swift.String? = nil
        )
        {
            self.jobStatesToNotify = jobStatesToNotify
            self.notifyAll = notifyAll
            self.snsTopicARN = snsTopicARN
        }
    }

}

extension ReturnShippingLabelAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReturnShippingLabelAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ReturnShippingLabelAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReturnShippingLabelAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You get this exception if you call <code>CreateReturnShippingLabel</code> and a valid return
///       shipping label already exists. In this case, use
///         <code>DescribeReturnShippingLabel</code> to get the url.</p>
public struct ReturnShippingLabelAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReturnShippingLabelAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReturnShippingLabelAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.S3Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn = "BucketArn"
        case keyRange = "KeyRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyRange = keyRange {
            try encodeContainer.encode(keyRange, forKey: .keyRange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyRangeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.KeyRange.self, forKey: .keyRange)
        keyRange = keyRangeDecoded
    }
}

extension SnowballClientTypes.S3Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Resource(bucketArn: \(Swift.String(describing: bucketArn)), keyRange: \(Swift.String(describing: keyRange)))"}
}

extension SnowballClientTypes {
    /// <p>Each <code>S3Resource</code> object represents an Amazon S3 bucket that your
    ///       transferred data will be exported from or imported into. For export jobs, this object can have
    ///       an optional <code>KeyRange</code> value. The length of the range is defined at job creation,
    ///       and has either an inclusive <code>BeginMarker</code>, an inclusive <code>EndMarker</code>, or
    ///       both. Ranges are UTF-8 binary sorted.</p>
    public struct S3Resource: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of an Amazon S3 bucket.</p>
        public let bucketArn: Swift.String?
        /// <p>For export jobs, you can provide an optional <code>KeyRange</code> within a specific
        ///       Amazon S3 bucket. The length of the range is defined at job creation, and has either an
        ///       inclusive <code>BeginMarker</code>, an inclusive <code>EndMarker</code>, or both. Ranges are
        ///       UTF-8 binary sorted.</p>
        public let keyRange: SnowballClientTypes.KeyRange?

        public init (
            bucketArn: Swift.String? = nil,
            keyRange: SnowballClientTypes.KeyRange? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyRange = keyRange
        }
    }

}

extension SnowballClientTypes.Shipment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case trackingNumber = "TrackingNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingNumber = trackingNumber {
            try encodeContainer.encode(trackingNumber, forKey: .trackingNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let trackingNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNumber)
        trackingNumber = trackingNumberDecoded
    }
}

extension SnowballClientTypes.Shipment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Shipment(status: \(Swift.String(describing: status)), trackingNumber: \(Swift.String(describing: trackingNumber)))"}
}

extension SnowballClientTypes {
    /// <p>The <code>Status</code> and <code>TrackingNumber</code> information for an inbound or
    ///       outbound shipment.</p>
    public struct Shipment: Swift.Equatable {
        /// <p>Status information for a shipment.</p>
        public let status: Swift.String?
        /// <p>The tracking number for this job. Using this tracking number with your region's
        ///       carrier's website, you can track a Snow device as the carrier transports it.</p>
        ///          <p>For India, the carrier is Amazon Logistics. For all other regions, UPS is the
        ///       carrier.</p>
        public let trackingNumber: Swift.String?

        public init (
            status: Swift.String? = nil,
            trackingNumber: Swift.String? = nil
        )
        {
            self.status = status
            self.trackingNumber = trackingNumber
        }
    }

}

extension SnowballClientTypes {
    public enum ShipmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case received
        case returned
        case sdkUnknown(Swift.String)

        public static var allCases: [ShipmentState] {
            return [
                .received,
                .returned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .returned: return "RETURNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShipmentState(rawValue: rawValue) ?? ShipmentState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.ShippingDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundShipment = "InboundShipment"
        case outboundShipment = "OutboundShipment"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundShipment = inboundShipment {
            try encodeContainer.encode(inboundShipment, forKey: .inboundShipment)
        }
        if let outboundShipment = outboundShipment {
            try encodeContainer.encode(outboundShipment, forKey: .outboundShipment)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let inboundShipmentDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Shipment.self, forKey: .inboundShipment)
        inboundShipment = inboundShipmentDecoded
        let outboundShipmentDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Shipment.self, forKey: .outboundShipment)
        outboundShipment = outboundShipmentDecoded
    }
}

extension SnowballClientTypes.ShippingDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShippingDetails(inboundShipment: \(Swift.String(describing: inboundShipment)), outboundShipment: \(Swift.String(describing: outboundShipment)), shippingOption: \(Swift.String(describing: shippingOption)))"}
}

extension SnowballClientTypes {
    /// <p>A job's shipping information, including inbound and outbound tracking numbers and
    ///       shipping speed options.</p>
    public struct ShippingDetails: Swift.Equatable {
        /// <p>The <code>Status</code> and <code>TrackingNumber</code> values for a Snow device being
        ///       returned to AWS for a particular job.</p>
        public let inboundShipment: SnowballClientTypes.Shipment?
        /// <p>The <code>Status</code> and <code>TrackingNumber</code> values for a Snow device being
        ///       delivered to the address that you specified for a particular job.</p>
        public let outboundShipment: SnowballClientTypes.Shipment?
        /// <p>The shipping speed for a particular job. This speed doesn't dictate how soon you'll get
        ///       the Snow device from the job's creation date. This speed represents how quickly it moves to its
        ///       destination while in transit. Regional shipping speeds are as follows:</p>
        ///
        ///          <ul>
        ///             <li>
        ///                <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
        ///           express are delivered in about a day.</p>
        ///             </li>
        ///             <li>
        ///                <p>In the European Union (EU), you have access to express shipping. Typically,
        ///           Snow devices shipped express are delivered in about a day. In addition, most countries in the
        ///           EU have access to standard shipping, which typically takes less than a week, one
        ///           way.</p>
        ///             </li>
        ///             <li>
        ///                <p>In India, Snow device are delivered in one to seven days.</p>
        ///             </li>
        ///             <li>
        ///                <p>In the United States of America (US), you have access to one-day shipping and
        ///           two-day shipping.</p>
        ///             </li>
        ///          </ul>
        public let shippingOption: SnowballClientTypes.ShippingOption?

        public init (
            inboundShipment: SnowballClientTypes.Shipment? = nil,
            outboundShipment: SnowballClientTypes.Shipment? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil
        )
        {
            self.inboundShipment = inboundShipment
            self.outboundShipment = outboundShipment
            self.shippingOption = shippingOption
        }
    }

}

extension SnowballClientTypes {
    public enum ShippingLabelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingLabelStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .succeeded: return "Succeeded"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShippingLabelStatus(rawValue: rawValue) ?? ShippingLabelStatus.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum ShippingOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case express
        case nextDay
        case secondDay
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingOption] {
            return [
                .express,
                .nextDay,
                .secondDay,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .express: return "EXPRESS"
            case .nextDay: return "NEXT_DAY"
            case .secondDay: return "SECOND_DAY"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShippingOption(rawValue: rawValue) ?? ShippingOption.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum SnowballCapacity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noPreference
        case t100
        case t14
        case t42
        case t50
        case t8
        case t80
        case t98
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballCapacity] {
            return [
                .noPreference,
                .t100,
                .t14,
                .t42,
                .t50,
                .t8,
                .t80,
                .t98,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "NoPreference"
            case .t100: return "T100"
            case .t14: return "T14"
            case .t42: return "T42"
            case .t50: return "T50"
            case .t8: return "T8"
            case .t80: return "T80"
            case .t98: return "T98"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnowballCapacity(rawValue: rawValue) ?? SnowballCapacity.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum SnowballType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case edgeC
        case edgeCg
        case edgeS
        case snc1Hdd
        case snc1Ssd
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballType] {
            return [
                .edge,
                .edgeC,
                .edgeCg,
                .edgeS,
                .snc1Hdd,
                .snc1Ssd,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .edgeC: return "EDGE_C"
            case .edgeCg: return "EDGE_CG"
            case .edgeS: return "EDGE_S"
            case .snc1Hdd: return "SNC1_HDD"
            case .snc1Ssd: return "SNC1_SSD"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnowballType(rawValue: rawValue) ?? SnowballType.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.SnowconeDeviceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessConnection = "WirelessConnection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessConnection = wirelessConnection {
            try encodeContainer.encode(wirelessConnection, forKey: .wirelessConnection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessConnectionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.WirelessConnection.self, forKey: .wirelessConnection)
        wirelessConnection = wirelessConnectionDecoded
    }
}

extension SnowballClientTypes.SnowconeDeviceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowconeDeviceConfiguration(wirelessConnection: \(Swift.String(describing: wirelessConnection)))"}
}

extension SnowballClientTypes {
    /// <p>Specifies the device configuration for an AWS Snowcone job. </p>
    public struct SnowconeDeviceConfiguration: Swift.Equatable {
        /// <p>Configures the wireless connection for the AWS Snowcone device.</p>
        public let wirelessConnection: SnowballClientTypes.WirelessConnection?

        public init (
            wirelessConnection: SnowballClientTypes.WirelessConnection? = nil
        )
        {
            self.wirelessConnection = wirelessConnection
        }
    }

}

extension SnowballClientTypes.TaxDocuments: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iND = "IND"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iND = iND {
            try encodeContainer.encode(iND, forKey: .iND)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iNDDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.INDTaxDocuments.self, forKey: .iND)
        iND = iNDDecoded
    }
}

extension SnowballClientTypes.TaxDocuments: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaxDocuments(iND: \(Swift.String(describing: iND)))"}
}

extension SnowballClientTypes {
    /// <p>The tax documents required in your AWS Region.</p>
    public struct TaxDocuments: Swift.Equatable {
        /// <p>The tax documents required in AWS Regions in India.</p>
        public let iND: SnowballClientTypes.INDTaxDocuments?

        public init (
            iND: SnowballClientTypes.INDTaxDocuments? = nil
        )
        {
            self.iND = iND
        }
    }

}

extension UnsupportedAddressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedAddressException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedAddressException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The address is either outside the serviceable area for your region, or an error
///       occurred. Check the address with your region's carrier and try again. If the issue persists,
///       contact AWS Support.</p>
public struct UnsupportedAddressException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedAddressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedAddressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateClusterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

extension UpdateClusterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterInput(addressId: \(Swift.String(describing: addressId)), clusterId: \(Swift.String(describing: clusterId)), description: \(Swift.String(describing: description)), forwardingAddressId: \(Swift.String(describing: forwardingAddressId)), notification: \(Swift.String(describing: notification)), resources: \(Swift.String(describing: resources)), roleARN: \(Swift.String(describing: roleARN)), shippingOption: \(Swift.String(describing: shippingOption)))"}
}

extension UpdateClusterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

public struct UpdateClusterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInput: Swift.Equatable {
    /// <p>The ID of the updated <a>Address</a> object.</p>
    public let addressId: Swift.String?
    /// <p>The cluster ID of the cluster that you want to update, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: Swift.String?
    /// <p>The updated description of this cluster.</p>
    public let description: Swift.String?
    /// <p>The updated ID for the forwarding address for a cluster. This field is not
    ///       supported in most regions.</p>
    public let forwardingAddressId: Swift.String?
    /// <p>The new or updated <a>Notification</a> object.</p>
    public let notification: SnowballClientTypes.Notification?
    /// <p>The updated arrays of <a>JobResource</a> objects that can include updated
    ///         <a>S3Resource</a> objects or <a>LambdaResource</a> objects.</p>
    public let resources: SnowballClientTypes.JobResource?
    /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this cluster.
    ///       To create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
    ///       Identity and Access Management (IAM).</p>
    public let roleARN: Swift.String?
    /// <p>The updated shipping option value of this cluster's <a>ShippingDetails</a>
    ///       object.</p>
    public let shippingOption: SnowballClientTypes.ShippingOption?

    public init (
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    public let clusterId: Swift.String?
    public let roleARN: Swift.String?
    public let description: Swift.String?
    public let resources: SnowballClientTypes.JobResource?
    public let addressId: Swift.String?
    public let shippingOption: SnowballClientTypes.ShippingOption?
    public let notification: SnowballClientTypes.Notification?
    public let forwardingAddressId: Swift.String?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterOutputError: Swift.Error, Swift.Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateClusterOutputResponse()"}
}

extension UpdateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateClusterOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateClusterOutputResponseBody: Swift.Equatable {
}

extension UpdateClusterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateJobOutputError>
}

extension UpdateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateJobInput(addressId: \(Swift.String(describing: addressId)), description: \(Swift.String(describing: description)), forwardingAddressId: \(Swift.String(describing: forwardingAddressId)), jobId: \(Swift.String(describing: jobId)), notification: \(Swift.String(describing: notification)), resources: \(Swift.String(describing: resources)), roleARN: \(Swift.String(describing: roleARN)), shippingOption: \(Swift.String(describing: shippingOption)), snowballCapacityPreference: \(Swift.String(describing: snowballCapacityPreference)))"}
}

extension UpdateJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
    }
}

public struct UpdateJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateJobOutputError>
}

public struct UpdateJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateJobOutputError>
}

public struct UpdateJobInput: Swift.Equatable {
    /// <p>The ID of the updated <a>Address</a> object.</p>
    public let addressId: Swift.String?
    /// <p>The updated description of this job's <a>JobMetadata</a> object.</p>
    public let description: Swift.String?
    /// <p>The updated ID for the forwarding address for a job. This field is not
    ///       supported in most regions.</p>
    public let forwardingAddressId: Swift.String?
    /// <p>The job ID of the job that you want to update, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?
    /// <p>The new or updated <a>Notification</a> object.</p>
    public let notification: SnowballClientTypes.Notification?
    /// <p>The updated <code>JobResource</code> object, or the updated <a>JobResource</a> object. </p>
    public let resources: SnowballClientTypes.JobResource?
    /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this job. To
    ///       create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>AWS Identity and Access
    ///       Management (IAM) API action.</p>
    public let roleARN: Swift.String?
    /// <p>The updated shipping option value of this job's <a>ShippingDetails</a>
    ///       object.</p>
    public let shippingOption: SnowballClientTypes.ShippingOption?
    /// <p>The updated <code>SnowballCapacityPreference</code> of this job's <a>JobMetadata</a> object. The 50 TB Snowballs are only available in the US
    ///       regions.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?

    public init (
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobId = jobId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
    }
}

struct UpdateJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let roleARN: Swift.String?
    public let notification: SnowballClientTypes.Notification?
    public let resources: SnowballClientTypes.JobResource?
    public let addressId: Swift.String?
    public let shippingOption: SnowballClientTypes.ShippingOption?
    public let description: Swift.String?
    public let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    public let forwardingAddressId: Swift.String?
}

extension UpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterLimitExceededException" : self = .clusterLimitExceededException(try ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobOutputError: Swift.Error, Swift.Equatable {
    case clusterLimitExceededException(ClusterLimitExceededException)
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateJobOutputResponse()"}
}

extension UpdateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateJobOutputResponseBody: Swift.Equatable {
}

extension UpdateJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateJobShipmentStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateJobShipmentStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateJobShipmentStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateJobShipmentStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateJobShipmentStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateJobShipmentStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateJobShipmentStateOutputError>
}

extension UpdateJobShipmentStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateJobShipmentStateInput(jobId: \(Swift.String(describing: jobId)), shipmentState: \(Swift.String(describing: shipmentState)))"}
}

extension UpdateJobShipmentStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shipmentState = shipmentState {
            try encodeContainer.encode(shipmentState.rawValue, forKey: .shipmentState)
        }
    }
}

public struct UpdateJobShipmentStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateJobShipmentStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateJobShipmentStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateJobShipmentStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateJobShipmentStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateJobShipmentStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateJobShipmentStateOutputError>
}

public struct UpdateJobShipmentStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateJobShipmentStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateJobShipmentStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateJobShipmentStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateJobShipmentStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateJobShipmentStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateJobShipmentStateOutputError>
}

public struct UpdateJobShipmentStateInput: Swift.Equatable {
    /// <p>The job ID of the job whose shipment date you want to update, for example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: Swift.String?
    /// <p>The state of a device when it is being shipped. </p>
    ///          <p>Set to <code>RECEIVED</code> when the device arrives at your location.</p>
    ///          <p>Set to <code>RETURNED</code> when you have returned the device to AWS.</p>
    public let shipmentState: SnowballClientTypes.ShipmentState?

    public init (
        jobId: Swift.String? = nil,
        shipmentState: SnowballClientTypes.ShipmentState? = nil
    )
    {
        self.jobId = jobId
        self.shipmentState = shipmentState
    }
}

struct UpdateJobShipmentStateInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let shipmentState: SnowballClientTypes.ShipmentState?
}

extension UpdateJobShipmentStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shipmentStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShipmentState.self, forKey: .shipmentState)
        shipmentState = shipmentStateDecoded
    }
}

extension UpdateJobShipmentStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobShipmentStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobShipmentStateOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobShipmentStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateJobShipmentStateOutputResponse()"}
}

extension UpdateJobShipmentStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobShipmentStateOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateJobShipmentStateOutputResponseBody: Swift.Equatable {
}

extension UpdateJobShipmentStateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLongTermPricingInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLongTermPricingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLongTermPricingOutputError>
}

extension UpdateLongTermPricingInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLongTermPricingInput(isLongTermPricingAutoRenew: \(Swift.String(describing: isLongTermPricingAutoRenew)), longTermPricingId: \(Swift.String(describing: longTermPricingId)), replacementJob: \(Swift.String(describing: replacementJob)))"}
}

extension UpdateLongTermPricingInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let replacementJob = replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
    }
}

public struct UpdateLongTermPricingInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLongTermPricingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLongTermPricingOutputError>
}

public struct UpdateLongTermPricingInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLongTermPricingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLongTermPricingInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLongTermPricingInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLongTermPricingOutputError>
}

public struct UpdateLongTermPricingInput: Swift.Equatable {
    /// <p>If set to <code>true</code>, specifies that the current long term pricing type for the
    ///       device should be automatically renewed before the long term pricing contract expires.</p>
    public let isLongTermPricingAutoRenew: Swift.Bool?
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: Swift.String?
    /// <p>Specifies that a device that is ordered with long term pricing should be replaced with a new device.</p>
    public let replacementJob: Swift.String?

    public init (
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingId: Swift.String? = nil,
        replacementJob: Swift.String? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingId = longTermPricingId
        self.replacementJob = replacementJob
    }
}

struct UpdateLongTermPricingInputBody: Swift.Equatable {
    public let longTermPricingId: Swift.String?
    public let replacementJob: Swift.String?
    public let isLongTermPricingAutoRenew: Swift.Bool?
}

extension UpdateLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
    }
}

extension UpdateLongTermPricingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLongTermPricingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLongTermPricingOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLongTermPricingOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLongTermPricingOutputResponse()"}
}

extension UpdateLongTermPricingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLongTermPricingOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateLongTermPricingOutputResponseBody: Swift.Equatable {
}

extension UpdateLongTermPricingOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SnowballClientTypes.WirelessConnection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isWifiEnabled = "IsWifiEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isWifiEnabled != false {
            try encodeContainer.encode(isWifiEnabled, forKey: .isWifiEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isWifiEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isWifiEnabled)
        isWifiEnabled = isWifiEnabledDecoded
    }
}

extension SnowballClientTypes.WirelessConnection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WirelessConnection(isWifiEnabled: \(Swift.String(describing: isWifiEnabled)))"}
}

extension SnowballClientTypes {
    /// <p>Configures the wireless connection on an AWS Snowcone device.</p>
    public struct WirelessConnection: Swift.Equatable {
        /// <p>Enables the Wi-Fi adapter on an AWS Snowcone device.</p>
        public let isWifiEnabled: Swift.Bool

        public init (
            isWifiEnabled: Swift.Bool = false
        )
        {
            self.isWifiEnabled = isWifiEnabled
        }
    }

}
