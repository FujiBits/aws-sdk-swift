// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessForbidden: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessForbidden(message: \(Swift.String(describing: message)))"}
}

extension AccessForbidden: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessForbiddenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have permission to perform an action.</p>
public struct AccessForbidden: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessForbiddenBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessForbiddenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecordInput(eventTime: \(Swift.String(describing: eventTime)), featureGroupName: \(Swift.String(describing: featureGroupName)), recordIdentifierValueAsString: \(Swift.String(describing: recordIdentifierValueAsString)))"}
}

extension DeleteRecordInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recordIdentifierValueAsString = input.operationInput.recordIdentifierValueAsString {
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            input.builder.withQueryItem(recordIdentifierValueAsStringQueryItem)
        }
        if let eventTime = input.operationInput.eventTime {
            let eventTimeQueryItem = ClientRuntime.URLQueryItem(name: "EventTime".urlPercentEncoding(), value: Swift.String(eventTime).urlPercentEncoding())
            input.builder.withQueryItem(eventTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecordOutputError>
}

public struct DeleteRecordInput: Swift.Equatable {
    /// <p>Timestamp indicating when the deletion event occurred. <code>EventTime</code> can be
    ///          used to query data at a certain point in time.</p>
    public let eventTime: Swift.String?
    /// <p>The name of the feature group to delete the record from. </p>
    public let featureGroupName: Swift.String?
    /// <p>The value for the <code>RecordIdentifier</code> that uniquely identifies the record, in
    ///          string format. </p>
    public let recordIdentifierValueAsString: Swift.String?

    public init (
        eventTime: Swift.String? = nil,
        featureGroupName: Swift.String? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.eventTime = eventTime
        self.featureGroupName = featureGroupName
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct DeleteRecordInputBody: Swift.Equatable {
}

extension DeleteRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecordOutputResponse()"}
}

extension DeleteRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRecordOutputResponseBody: Swift.Equatable {
}

extension DeleteRecordOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case valueAsString = "ValueAsString"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let valueAsString = valueAsString {
            try encodeContainer.encode(valueAsString, forKey: .valueAsString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let valueAsStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueAsString)
        valueAsString = valueAsStringDecoded
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FeatureValue(featureName: \(Swift.String(describing: featureName)), valueAsString: \(Swift.String(describing: valueAsString)))"}
}

extension SageMakerFeatureStoreRuntimeClientTypes {
    /// <p>The value associated with a feature.</p>
    public struct FeatureValue: Swift.Equatable {
        /// <p>The name of a feature that a feature value corresponds to.</p>
        public let featureName: Swift.String?
        /// <p>The value associated with a feature, in string format. Note that features types can be
        ///          String, Integral, or Fractional. This value represents all three types as a string.</p>
        public let valueAsString: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            valueAsString: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.valueAsString = valueAsString
        }
    }

}

extension GetRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordInput(featureGroupName: \(Swift.String(describing: featureGroupName)), featureNames: \(Swift.String(describing: featureNames)), recordIdentifierValueAsString: \(Swift.String(describing: recordIdentifierValueAsString)))"}
}

extension GetRecordInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordOutputError>
}

public struct GetRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recordIdentifierValueAsString = input.operationInput.recordIdentifierValueAsString {
            let recordIdentifierValueAsStringQueryItem = ClientRuntime.URLQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
            input.builder.withQueryItem(recordIdentifierValueAsStringQueryItem)
        }
        if let featureNames = input.operationInput.featureNames {
            featureNames.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "FeatureName".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecordOutputError>
}

public struct GetRecordInput: Swift.Equatable {
    /// <p>The name of the feature group in which you want to put the records.</p>
    public let featureGroupName: Swift.String?
    /// <p>List of names of Features to be retrieved. If not specified, the latest value for all
    ///          the Features are returned.</p>
    public let featureNames: [Swift.String]?
    /// <p>The value that corresponds to <code>RecordIdentifier</code> type and uniquely identifies
    ///          the record in the <code>FeatureGroup</code>. </p>
    public let recordIdentifierValueAsString: Swift.String?

    public init (
        featureGroupName: Swift.String? = nil,
        featureNames: [Swift.String]? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.featureNames = featureNames
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

struct GetRecordInputBody: Swift.Equatable {
}

extension GetRecordInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case resourceNotFound(ResourceNotFound)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecordOutputResponse(record: \(Swift.String(describing: record)))"}
}

extension GetRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.record = output.record
        } else {
            self.record = nil
        }
    }
}

public struct GetRecordOutputResponse: Swift.Equatable {
    /// <p>The record you requested. A list of <code>FeatureValues</code>.</p>
    public let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init (
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.record = record
    }
}

struct GetRecordOutputResponseBody: Swift.Equatable {
    public let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
}

extension GetRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension InternalFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailure(message: \(Swift.String(describing: message)))"}
}

extension InternalFailure: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred. Try your request again. If the problem
///       persists, contact AWS customer support.</p>
public struct InternalFailure: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRecordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

extension PutRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordInput(featureGroupName: \(Swift.String(describing: featureGroupName)), record: \(Swift.String(describing: record)))"}
}

extension PutRecordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let record = record {
            var recordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .record)
            for record0 in record {
                try recordContainer.encode(record0)
            }
        }
    }
}

public struct PutRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

public struct PutRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecordOutputError>
}

public struct PutRecordInput: Swift.Equatable {
    /// <p>The name of the feature group that you want to insert the record into.</p>
    public let featureGroupName: Swift.String?
    /// <p>List of FeatureValues to be inserted. This will be a full over-write. If you only want
    ///          to update few of the feature values, do the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Use <code>GetRecord</code> to retrieve the latest record.</p>
    ///             </li>
    ///             <li>
    ///                <p>Update the record returned from <code>GetRecord</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>Use <code>PutRecord</code> to update feature values.</p>
    ///             </li>
    ///          </ul>
    public let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init (
        featureGroupName: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.record = record
    }
}

struct PutRecordInputBody: Swift.Equatable {
    public let record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
}

extension PutRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case record = "Record"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordContainer = try containerValues.decodeIfPresent([SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?].self, forKey: .record)
        var recordDecoded0:[SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
        if let recordContainer = recordContainer {
            recordDecoded0 = [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]()
            for structure0 in recordContainer {
                if let structure0 = structure0 {
                    recordDecoded0?.append(structure0)
                }
            }
        }
        record = recordDecoded0
    }
}

extension PutRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessForbidden" : self = .accessForbidden(try AccessForbidden(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailure" : self = .internalFailure(try InternalFailure(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailable" : self = .serviceUnavailable(try ServiceUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationError" : self = .validationError(try ValidationError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecordOutputError: Swift.Error, Swift.Equatable {
    case accessForbidden(AccessForbidden)
    case internalFailure(InternalFailure)
    case serviceUnavailable(ServiceUnavailable)
    case validationError(ValidationError)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecordOutputResponse()"}
}

extension PutRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRecordOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutRecordOutputResponseBody: Swift.Equatable {
}

extension PutRecordOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFound(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that is required to perform an action was not found.</p>
public struct ResourceNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailable(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailable: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is currently unavailable.</p>
public struct ServiceUnavailable: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationError(message: \(Swift.String(describing: message)))"}
}

extension ValidationError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an error validating your request.</p>
public struct ValidationError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
