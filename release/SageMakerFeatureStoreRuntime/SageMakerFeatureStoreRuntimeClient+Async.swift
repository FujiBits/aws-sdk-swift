// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension SageMakerFeatureStoreRuntimeClient {
    /// <p>Deletes a <code>Record</code> from a <code>FeatureGroup</code>. A new record will show
    ///          up in the <code>OfflineStore</code> when the <code>DeleteRecord</code> API is called. This
    ///          record will have a value of <code>True</code> in the <code>is_deleted</code> column.</p>
    func deleteRecord(input: DeleteRecordInput) async throws -> DeleteRecordOutputResponse
    {
        typealias deleteRecordContinuation = CheckedContinuation<DeleteRecordOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRecordContinuation) in
            deleteRecord(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Use for <code>OnlineStore</code> serving from a <code>FeatureStore</code>. Only the
    ///          latest records stored in the <code>OnlineStore</code> can be retrieved. If no Record with
    ///             <code>RecordIdentifierValue</code> is found, then an empty result is returned. </p>
    func getRecord(input: GetRecordInput) async throws -> GetRecordOutputResponse
    {
        typealias getRecordContinuation = CheckedContinuation<GetRecordOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRecordContinuation) in
            getRecord(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Used for data ingestion into the <code>FeatureStore</code>. The <code>PutRecord</code>
    ///          API writes to both the <code>OnlineStore</code> and <code>OfflineStore</code>. If the
    ///          record is the latest record for the <code>recordIdentifier</code>, the record is written to
    ///          both the <code>OnlineStore</code> and <code>OfflineStore</code>. If the record is a
    ///          historic record, it is written only to the <code>OfflineStore</code>.</p>
    func putRecord(input: PutRecordInput) async throws -> PutRecordOutputResponse
    {
        typealias putRecordContinuation = CheckedContinuation<PutRecordOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRecordContinuation) in
            putRecord(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
