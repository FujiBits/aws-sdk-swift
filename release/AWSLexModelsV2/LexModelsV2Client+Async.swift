// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension LexModelsV2Client {
    /// Builds a bot, its intents, and its slot types into a specific
    ///          locale. A bot can be built into multiple locales. At runtime the locale
    ///          is used to choose a specific build of the bot.
    func buildBotLocale(input: BuildBotLocaleInput) async throws -> BuildBotLocaleOutputResponse
    {
        typealias buildBotLocaleContinuation = CheckedContinuation<BuildBotLocaleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: buildBotLocaleContinuation) in
            buildBotLocale(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an Amazon Lex conversational bot.
    func createBot(input: CreateBotInput) async throws -> CreateBotOutputResponse
    {
        typealias createBotContinuation = CheckedContinuation<CreateBotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBotContinuation) in
            createBot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an alias for the specified version of a bot. Use an alias to
    ///          enable you to change the version of a bot without updating applications
    ///          that use the bot.
    ///          For example, you can create an alias called "PROD" that your
    ///          applications use to call the Amazon Lex bot.
    func createBotAlias(input: CreateBotAliasInput) async throws -> CreateBotAliasOutputResponse
    {
        typealias createBotAliasContinuation = CheckedContinuation<CreateBotAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBotAliasContinuation) in
            createBotAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a locale in the bot. The locale contains the intents and
    ///          slot types that the bot uses in conversations with users in the
    ///          specified language and locale. You must add a locale to a bot before
    ///          you can add intents and slot types to the bot.
    func createBotLocale(input: CreateBotLocaleInput) async throws -> CreateBotLocaleOutputResponse
    {
        typealias createBotLocaleContinuation = CheckedContinuation<CreateBotLocaleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBotLocaleContinuation) in
            createBotLocale(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new version of the bot based on the DRAFT
    ///          version. If the DRAFT version of this resource hasn't
    ///          changed since you created the last version, Amazon Lex doesn't create a new
    ///          version, it returns the last created version.
    ///          When you create the first version of a bot, Amazon Lex sets the version
    ///          to 1. Subsequent versions increment by 1.
    func createBotVersion(input: CreateBotVersionInput) async throws -> CreateBotVersionOutputResponse
    {
        typealias createBotVersionContinuation = CheckedContinuation<CreateBotVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBotVersionContinuation) in
            createBotVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a zip archive containing the contents of a bot or a bot
    ///          locale. The archive contains a directory structure that contains JSON
    ///          files that define the bot.
    ///          You can create an archive that contains the complete definition of a
    ///          bot, or you can specify that the archive contain only the definition of
    ///          a single bot locale.
    ///          For more information about exporting bots, and about the structure
    ///          of the export archive, see <a href="https://docs.aws.amazon.com/lexv2/latest/dg/importing-exporting.html"> Importing and
    ///             exporting bots
    ///
    func createExport(input: CreateExportInput) async throws -> CreateExportOutputResponse
    {
        typealias createExportContinuation = CheckedContinuation<CreateExportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createExportContinuation) in
            createExport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an intent.
    ///          To define the interaction between the user and your bot, you define
    ///          one or more intents. For example, for a pizza ordering bot you would
    ///          create an OrderPizza intent.
    ///          When you create an intent, you must provide a name. You can
    ///          optionally provide the following:
    ///
    ///
    ///                Sample utterances. For example, "I want to order a pizza" and
    ///                "Can I order a pizza." You can't provide utterances for built-in
    ///                intents.
    ///
    ///
    ///                Information to be gathered. You specify slots for the
    ///                information that you bot requests from the user. You can specify
    ///                standard slot types, such as date and time, or custom slot types
    ///                for your application.
    ///
    ///
    ///                How the intent is fulfilled. You can provide a Lambda function
    ///                or configure the intent to return the intent information to your
    ///                client application. If you use a Lambda function, Amazon Lex invokes
    ///                the function when all of the intent information is
    ///                available.
    ///
    ///
    ///                A confirmation prompt to send to the user to confirm an
    ///                intent. For example, "Shall I order your pizza?"
    ///
    ///
    ///                A conclusion statement to send to the user after the intent is
    ///                fulfilled. For example, "I ordered your pizza."
    ///
    ///
    ///                A follow-up prompt that asks the user for additional activity.
    ///                For example, "Do you want a drink with your pizza?"
    ///
    ///
    func createIntent(input: CreateIntentInput) async throws -> CreateIntentOutputResponse
    {
        typealias createIntentContinuation = CheckedContinuation<CreateIntentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createIntentContinuation) in
            createIntent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new resource policy with the specified policy
    ///          statements.
    func createResourcePolicy(input: CreateResourcePolicyInput) async throws -> CreateResourcePolicyOutputResponse
    {
        typealias createResourcePolicyContinuation = CheckedContinuation<CreateResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResourcePolicyContinuation) in
            createResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds a new resource policy statement to a bot or bot alias. If a
    ///          resource policy exists, the statement is added to the current resource
    ///          policy. If a policy doesn't exist, a new policy is created.
    ///          You can't create a resource policy statement that allows
    ///          cross-account access.
    func createResourcePolicyStatement(input: CreateResourcePolicyStatementInput) async throws -> CreateResourcePolicyStatementOutputResponse
    {
        typealias createResourcePolicyStatementContinuation = CheckedContinuation<CreateResourcePolicyStatementOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createResourcePolicyStatementContinuation) in
            createResourcePolicyStatement(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a slot in an intent. A slot is a variable needed to fulfill
    ///          an intent. For example, an OrderPizza intent might need
    ///          slots for size, crust, and number of pizzas. For each slot, you define
    ///          one or more utterances that Amazon Lex uses to elicit a response from the
    ///          user.
    func createSlot(input: CreateSlotInput) async throws -> CreateSlotOutputResponse
    {
        typealias createSlotContinuation = CheckedContinuation<CreateSlotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSlotContinuation) in
            createSlot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a custom slot type
    ///           To create a custom slot type, specify a name for the slot type and
    ///          a set of enumeration values, the values that a slot of this type can
    ///          assume.
    func createSlotType(input: CreateSlotTypeInput) async throws -> CreateSlotTypeOutputResponse
    {
        typealias createSlotTypeContinuation = CheckedContinuation<CreateSlotTypeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSlotTypeContinuation) in
            createSlotType(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a pre-signed S3 write URL that you use to upload the zip
    ///          archive when importing a bot or a bot locale.
    func createUploadUrl(input: CreateUploadUrlInput) async throws -> CreateUploadUrlOutputResponse
    {
        typealias createUploadUrlContinuation = CheckedContinuation<CreateUploadUrlOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createUploadUrlContinuation) in
            createUploadUrl(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes all versions of a bot, including the Draft
    ///          version. To delete a specific version, use the
    ///             DeleteBotVersion operation.
    ///          When you delete a bot, all of the resources contained in the bot are
    ///          also deleted. Deleting a bot removes all locales, intents, slot, and
    ///          slot types defined for the bot.
    ///          If a bot has an alias, the DeleteBot operation returns
    ///          a ResourceInUseException exception. If you want to delete
    ///          the bot and the alias, set the skipResourceInUseCheck
    ///          parameter to true.
    func deleteBot(input: DeleteBotInput) async throws -> DeleteBotOutputResponse
    {
        typealias deleteBotContinuation = CheckedContinuation<DeleteBotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBotContinuation) in
            deleteBot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified bot alias.
    func deleteBotAlias(input: DeleteBotAliasInput) async throws -> DeleteBotAliasOutputResponse
    {
        typealias deleteBotAliasContinuation = CheckedContinuation<DeleteBotAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBotAliasContinuation) in
            deleteBotAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a locale from a bot.
    ///          When you delete a locale, all intents, slots, and slot types defined
    ///          for the locale are also deleted.
    func deleteBotLocale(input: DeleteBotLocaleInput) async throws -> DeleteBotLocaleOutputResponse
    {
        typealias deleteBotLocaleContinuation = CheckedContinuation<DeleteBotLocaleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBotLocaleContinuation) in
            deleteBotLocale(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a specific version of a bot. To delete all version of a bot,
    ///          use the DeleteBot operation.
    func deleteBotVersion(input: DeleteBotVersionInput) async throws -> DeleteBotVersionOutputResponse
    {
        typealias deleteBotVersionContinuation = CheckedContinuation<DeleteBotVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteBotVersionContinuation) in
            deleteBotVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a previous export and the associated files stored in an S3
    ///          bucket.
    func deleteExport(input: DeleteExportInput) async throws -> DeleteExportOutputResponse
    {
        typealias deleteExportContinuation = CheckedContinuation<DeleteExportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteExportContinuation) in
            deleteExport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a previous import and the associated file stored in an S3
    ///          bucket.
    func deleteImport(input: DeleteImportInput) async throws -> DeleteImportOutputResponse
    {
        typealias deleteImportContinuation = CheckedContinuation<DeleteImportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteImportContinuation) in
            deleteImport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes the specified intent.
    ///          Deleting an intent also deletes the slots associated with the
    ///          intent.
    func deleteIntent(input: DeleteIntentInput) async throws -> DeleteIntentOutputResponse
    {
        typealias deleteIntentContinuation = CheckedContinuation<DeleteIntentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteIntentContinuation) in
            deleteIntent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes an existing policy from a bot or bot alias. If the resource
    ///          doesn't have a policy attached, Amazon Lex returns an exception.
    func deleteResourcePolicy(input: DeleteResourcePolicyInput) async throws -> DeleteResourcePolicyOutputResponse
    {
        typealias deleteResourcePolicyContinuation = CheckedContinuation<DeleteResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourcePolicyContinuation) in
            deleteResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a policy statement from a resource policy. If you delete the
    ///          last statement from a policy, the policy is deleted. If you specify a
    ///          statement ID that doesn't exist in the policy, or if the bot or bot
    ///          alias doesn't have a policy attached, Amazon Lex returns an
    ///          exception.
    func deleteResourcePolicyStatement(input: DeleteResourcePolicyStatementInput) async throws -> DeleteResourcePolicyStatementOutputResponse
    {
        typealias deleteResourcePolicyStatementContinuation = CheckedContinuation<DeleteResourcePolicyStatementOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourcePolicyStatementContinuation) in
            deleteResourcePolicyStatement(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified slot from an intent.
    func deleteSlot(input: DeleteSlotInput) async throws -> DeleteSlotOutputResponse
    {
        typealias deleteSlotContinuation = CheckedContinuation<DeleteSlotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSlotContinuation) in
            deleteSlot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a slot type from a bot locale.
    ///          If a slot is using the slot type, Amazon Lex throws a
    ///             ResourceInUseException exception. To avoid the
    ///          exception, set the skipResourceInUseCheck parameter to
    ///             true.
    func deleteSlotType(input: DeleteSlotTypeInput) async throws -> DeleteSlotTypeOutputResponse
    {
        typealias deleteSlotTypeContinuation = CheckedContinuation<DeleteSlotTypeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSlotTypeContinuation) in
            deleteSlotType(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Provides metadata information about a bot.
    func describeBot(input: DescribeBotInput) async throws -> DescribeBotOutputResponse
    {
        typealias describeBotContinuation = CheckedContinuation<DescribeBotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBotContinuation) in
            describeBot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get information about a specific bot alias.
    func describeBotAlias(input: DescribeBotAliasInput) async throws -> DescribeBotAliasOutputResponse
    {
        typealias describeBotAliasContinuation = CheckedContinuation<DescribeBotAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBotAliasContinuation) in
            describeBotAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the settings that a bot has for a specific locale.
    func describeBotLocale(input: DescribeBotLocaleInput) async throws -> DescribeBotLocaleOutputResponse
    {
        typealias describeBotLocaleContinuation = CheckedContinuation<DescribeBotLocaleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBotLocaleContinuation) in
            describeBotLocale(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Provides metadata about a version of a bot.
    func describeBotVersion(input: DescribeBotVersionInput) async throws -> DescribeBotVersionOutputResponse
    {
        typealias describeBotVersionContinuation = CheckedContinuation<DescribeBotVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBotVersionContinuation) in
            describeBotVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a specific export.
    func describeExport(input: DescribeExportInput) async throws -> DescribeExportOutputResponse
    {
        typealias describeExportContinuation = CheckedContinuation<DescribeExportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeExportContinuation) in
            describeExport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about a specific import.
    func describeImport(input: DescribeImportInput) async throws -> DescribeImportOutputResponse
    {
        typealias describeImportContinuation = CheckedContinuation<DescribeImportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeImportContinuation) in
            describeImport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns metadata about an intent.
    func describeIntent(input: DescribeIntentInput) async throws -> DescribeIntentOutputResponse
    {
        typealias describeIntentContinuation = CheckedContinuation<DescribeIntentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeIntentContinuation) in
            describeIntent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the resource policy and policy revision for a bot or bot
    ///          alias.
    func describeResourcePolicy(input: DescribeResourcePolicyInput) async throws -> DescribeResourcePolicyOutputResponse
    {
        typealias describeResourcePolicyContinuation = CheckedContinuation<DescribeResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeResourcePolicyContinuation) in
            describeResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets metadata information about a slot.
    func describeSlot(input: DescribeSlotInput) async throws -> DescribeSlotOutputResponse
    {
        typealias describeSlotContinuation = CheckedContinuation<DescribeSlotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSlotContinuation) in
            describeSlot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets metadata information about a slot type.
    func describeSlotType(input: DescribeSlotTypeInput) async throws -> DescribeSlotTypeOutputResponse
    {
        typealias describeSlotTypeContinuation = CheckedContinuation<DescribeSlotTypeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSlotTypeContinuation) in
            describeSlotType(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of aliases for the specified bot.
    func listBotAliases(input: ListBotAliasesInput) async throws -> ListBotAliasesOutputResponse
    {
        typealias listBotAliasesContinuation = CheckedContinuation<ListBotAliasesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBotAliasesContinuation) in
            listBotAliases(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of locales for the specified bot.
    func listBotLocales(input: ListBotLocalesInput) async throws -> ListBotLocalesOutputResponse
    {
        typealias listBotLocalesContinuation = CheckedContinuation<ListBotLocalesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBotLocalesContinuation) in
            listBotLocales(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets information about all of the versions of a bot.
    ///          The ListBotVersions operation returns a summary of each
    ///          version of a bot. For example, if a bot has three numbered versions,
    ///          the ListBotVersions operation returns for summaries, one
    ///          for each numbered version and one for the DRAFT
    ///          version.
    ///          The ListBotVersions operation always returns at least
    ///          one version, the DRAFT version.
    func listBotVersions(input: ListBotVersionsInput) async throws -> ListBotVersionsOutputResponse
    {
        typealias listBotVersionsContinuation = CheckedContinuation<ListBotVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBotVersionsContinuation) in
            listBotVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of available bots.
    func listBots(input: ListBotsInput) async throws -> ListBotsOutputResponse
    {
        typealias listBotsContinuation = CheckedContinuation<ListBotsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBotsContinuation) in
            listBots(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of built-in intents provided by Amazon Lex that you can use
    ///          in your bot.
    ///          To use a built-in intent as a the base for your own intent, include
    ///          the built-in intent signature in the parentIntentSignature
    ///          parameter when you call the CreateIntent operation. For
    ///          more information, see CreateIntent.
    func listBuiltInIntents(input: ListBuiltInIntentsInput) async throws -> ListBuiltInIntentsOutputResponse
    {
        typealias listBuiltInIntentsContinuation = CheckedContinuation<ListBuiltInIntentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBuiltInIntentsContinuation) in
            listBuiltInIntents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of built-in slot types that meet the specified
    ///          criteria.
    func listBuiltInSlotTypes(input: ListBuiltInSlotTypesInput) async throws -> ListBuiltInSlotTypesOutputResponse
    {
        typealias listBuiltInSlotTypesContinuation = CheckedContinuation<ListBuiltInSlotTypesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBuiltInSlotTypesContinuation) in
            listBuiltInSlotTypes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the exports for a bot or bot locale. Exports are kept in the
    ///          list for 7 days.
    func listExports(input: ListExportsInput) async throws -> ListExportsOutputResponse
    {
        typealias listExportsContinuation = CheckedContinuation<ListExportsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listExportsContinuation) in
            listExports(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the imports for a bot or bot locale. Imports are kept in the
    ///          list for 7 days.
    func listImports(input: ListImportsInput) async throws -> ListImportsOutputResponse
    {
        typealias listImportsContinuation = CheckedContinuation<ListImportsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImportsContinuation) in
            listImports(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get a list of intents that meet the specified criteria.
    func listIntents(input: ListIntentsInput) async throws -> ListIntentsOutputResponse
    {
        typealias listIntentsContinuation = CheckedContinuation<ListIntentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listIntentsContinuation) in
            listIntents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of slot types that match the specified criteria.
    func listSlotTypes(input: ListSlotTypesInput) async throws -> ListSlotTypesOutputResponse
    {
        typealias listSlotTypesContinuation = CheckedContinuation<ListSlotTypesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSlotTypesContinuation) in
            listSlotTypes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of slots that match the specified criteria.
    func listSlots(input: ListSlotsInput) async throws -> ListSlotsOutputResponse
    {
        typealias listSlotsContinuation = CheckedContinuation<ListSlotsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSlotsContinuation) in
            listSlots(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of tags associated with a resource. Only bots, bot
    ///          aliases, and bot channels can have tags associated with them.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts importing a bot or bot locale from a zip archive that you
    ///          uploaded to an S3 bucket.
    func startImport(input: StartImportInput) async throws -> StartImportOutputResponse
    {
        typealias startImportContinuation = CheckedContinuation<StartImportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startImportContinuation) in
            startImport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds the specified tags to the specified resource. If a tag key
    ///          already exists, the existing value is replaced with the new
    ///          value.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes tags from a bot, bot alias, or bot channel.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the configuration of an existing bot.
    func updateBot(input: UpdateBotInput) async throws -> UpdateBotOutputResponse
    {
        typealias updateBotContinuation = CheckedContinuation<UpdateBotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateBotContinuation) in
            updateBot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the configuration of an existing bot alias.
    func updateBotAlias(input: UpdateBotAliasInput) async throws -> UpdateBotAliasOutputResponse
    {
        typealias updateBotAliasContinuation = CheckedContinuation<UpdateBotAliasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateBotAliasContinuation) in
            updateBotAlias(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the settings that a bot has for a specific locale.
    func updateBotLocale(input: UpdateBotLocaleInput) async throws -> UpdateBotLocaleOutputResponse
    {
        typealias updateBotLocaleContinuation = CheckedContinuation<UpdateBotLocaleOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateBotLocaleContinuation) in
            updateBotLocale(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the password used to protect an export zip archive.
    ///          The password is not required. If you don't supply a password, Amazon Lex
    ///          generates a zip file that is not protected by a password. This is the
    ///          archive that is available at the pre-signed S3 URL provided by the
    ///              operation.
    func updateExport(input: UpdateExportInput) async throws -> UpdateExportOutputResponse
    {
        typealias updateExportContinuation = CheckedContinuation<UpdateExportOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateExportContinuation) in
            updateExport(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the settings for an intent.
    func updateIntent(input: UpdateIntentInput) async throws -> UpdateIntentOutputResponse
    {
        typealias updateIntentContinuation = CheckedContinuation<UpdateIntentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateIntentContinuation) in
            updateIntent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Replaces the existing resource policy for a bot or bot alias with a
    ///          new one. If the policy doesn't exist, Amazon Lex returns an
    ///          exception.
    func updateResourcePolicy(input: UpdateResourcePolicyInput) async throws -> UpdateResourcePolicyOutputResponse
    {
        typealias updateResourcePolicyContinuation = CheckedContinuation<UpdateResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateResourcePolicyContinuation) in
            updateResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the settings for a slot.
    func updateSlot(input: UpdateSlotInput) async throws -> UpdateSlotOutputResponse
    {
        typealias updateSlotContinuation = CheckedContinuation<UpdateSlotOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSlotContinuation) in
            updateSlot(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates the configuration of an existing slot type.
    func updateSlotType(input: UpdateSlotTypeInput) async throws -> UpdateSlotTypeOutputResponse
    {
        typealias updateSlotTypeContinuation = CheckedContinuation<UpdateSlotTypeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateSlotTypeContinuation) in
            updateSlotType(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
